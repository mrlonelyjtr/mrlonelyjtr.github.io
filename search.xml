<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[Leetcode] Problem 675 - Cut Off Trees for Golf Event]]></title>
    <url>%2F2020%2F10%2F08%2FLeetcode-Problem-675-Cut-Off-Trees-for-Golf-Event%2F</url>
    <content type="text"><![CDATA[You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map: 0 represents the obstacle can’t be reached. 1 represents the ground can be walked through. The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree’s height. In one step you can walk in any of the four directions top, bottom, left and right also when standing in a point which is a tree you can decide whether or not to cut off the tree. You are asked to cut off all the trees in this forest in the order of tree’s height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can’t cut off all the trees, output -1 in that situation. You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off. ExampleNo.1Input: 12345[ [1,2,3], [0,0,4], [7,6,5]] Output: 6 No.2Input: 12345[ [1,2,3], [0,0,0], [7,6,5]] Output: -1 No.3Input: 12345[ [2,3,4], [0,0,5], [8,7,6]] Output: 6 Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking. Constraints 1 &lt;= forest.length &lt;= 50 1 &lt;= forest[i].length &lt;= 50 0 &lt;= forest[i][j] &lt;= 10^9 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public int cutOffTree(List&lt;List&lt;Integer&gt;&gt; forest) &#123; int m = forest.size(); int n = forest.get(0).size(); List&lt;int[]&gt; trees = new ArrayList&lt;&gt;(); int startX = 0; int startY = 0; int steps = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; int height = forest.get(i).get(j); if (height &gt; 1) trees.add(new int[] &#123;i, j, height&#125;); &#125; &#125; Collections.sort(trees, (a, b) -&gt; a[2] - b[2]); for (int[] tree : trees) &#123; int endX = tree[0]; int endY = tree[1]; int step = bfs(forest, startX, startY, endX, endY); if (step == -1) return -1; forest.get(endX).set(endY, 1); steps += step; startX = endX; startY = endY; &#125; return steps;&#125;private int bfs(List&lt;List&lt;Integer&gt;&gt; forest, int startX, int startY, int endX, int endY) &#123; int m = forest.size(); int n = forest.get(0).size(); int[][] dirs = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; int step = 0; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); boolean[][] visit = new boolean[m][n]; queue.offer(new int[] &#123;startX, startY&#125;); visit[startX][startY] = true; while (!queue.isEmpty()) &#123; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; int[] node = queue.poll(); if (node[0] == endX &amp;&amp; node[1] == endY) return step; for (int[] dir : dirs) &#123; int x = node[0] + dir[0]; int y = node[1] + dir[1]; if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n || visit[x][y] || forest.get(x).get(y) == 0) continue; visit[x][y] = true; queue.offer(new int[] &#123;x, y&#125;); &#125; &#125; step++; &#125; return -1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 1377 - Frog Position After T Seconds]]></title>
    <url>%2F2020%2F10%2F08%2FLeetcode-Problem-1377-Frog-Position-After-T-Seconds%2F</url>
    <content type="text"><![CDATA[Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from the vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices it jumps randomly to one of them with the same probability, otherwise, when the frog can not jump to any unvisited vertex it jumps forever on the same vertex. The edges of the undirected tree are given in the array edges, where edges[i] = [fromi, toi] means that exists an edge connecting directly the vertices fromi and toi. Return the probability that after t seconds the frog is on the vertex target. ExampleNo.1 Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4 Output: 0.16666666666666666 Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. No.2 Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7 Output: 0.3333333333333333 Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. No.3Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 20, target = 6 Output: 0.16666666666666666 Constraints 1 &lt;= n &lt;= 100 edges.length == n-1 edges[i].length == 2 1 &lt;= edges[i][0], edges[i][1] &lt;= n 1 &lt;= t &lt;= 50 1 &lt;= target &lt;= n Answers within 10^-5 of the actual value will be accepted as correct. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public double frogPosition(int n, int[][] edges, int t, int target) &#123; List&lt;Integer&gt;[] graph = new ArrayList[n + 1]; double[] prob = new double[n + 1]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); boolean[] visit = new boolean[n + 1]; queue.offer(1); visit[1] = true; prob[1] = 1.0; for (int i = 0; i &lt;= n; i++) graph[i] = new ArrayList&lt;&gt;(); for (int[] edge : edges) &#123; graph[edge[0]].add(edge[1]); graph[edge[1]].add(edge[0]); &#125; while (!queue.isEmpty() &amp;&amp; t &gt; 0) &#123; int size = queue.size(); t--; for (int i = 0; i &lt; size; i++) &#123; int node = queue.poll(); int children = 0; for (int neighbor : graph[node]) &#123; if (!visit[neighbor]) children++; &#125; for (int neighbor : graph[node]) &#123; if (!visit[neighbor]) &#123; visit[neighbor] = true; queue.offer(neighbor); prob[neighbor] = prob[node] / children; &#125; &#125; if (children &gt; 0) prob[node] = 0.0; if (node == target) break; &#125; &#125; return prob[target];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 964 - Least Operators to Express Number]]></title>
    <url>%2F2020%2F10%2F07%2FLeetcode-Problem-964-Least-Operators-to-Express-Number%2F</url>
    <content type="text"><![CDATA[Given a single positive integer x, we will write an expression of the form x (op1) x (op2) x (op3) x … where each operator op1, op2, etc. is either addition, subtraction, multiplication, or division (+, -, *, or /). For example, with x = 3, we might write 3 * 3 / 3 + 3 - 3 which is a value of 3. When writing such an expression, we adhere to the following conventions: The division operator (/) returns rational numbers. There are no parentheses placed anywhere. We use the usual order of operations: multiplication and division happens before addition and subtraction. It’s not allowed to use the unary negation operator (-). For example, “x - x” is a valid expression as it only uses subtraction, but “-x + x” is not because it uses negation. We would like to write an expression with the least number of operators such that the expression equals the given target. Return the least number of operators used. ExampleNo.1Input: x = 3, target = 19 Output: 5 Explanation: 3 * 3 + 3 * 3 + 3 / 3. The expression contains 5 operations. No.2Input: x = 5, target = 501 Output: 8 Explanation: 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5. The expression contains 8 operations. No.3Input: x = 100, target = 100000000 Output: 3 Explanation: 100 * 100 * 100 * 100. The expression contains 3 operations. Note 2 &lt;= x &lt;= 100 1 &lt;= target &lt;= 2 * 10^8 Code12345678910111213141516171819202122232425262728293031// f(x, t) = min(f(x, t - x^k) + k, f(x, x^(k+1) - t) + k + 1), x^(k+1) - t &lt; t, k = logx(t)// t = 0, f(x, t) = 0;// t &lt; x, f(x, t) = min(2 * t - 1, 2 * (x - t)) // x/x + x/x + x/x + ... , x - x/x - x/x - ...// t = x^k, f(x, t) = k - 1 // x * x * x * ...private Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();public int leastOpsExpressTarget(int x, int target) &#123; if (target == 0) return 0; if (target &lt; x) return Math.min(2 * target - 1, 2 * (x - target)); if (map.containsKey(target)) return map.get(target); int k = (int) (Math.log(target) / Math.log(x)); int pow1 = (int) Math.pow(x, k); if (target == pow1) return k - 1; int result = leastOpsExpressTarget(x, target - pow1) + k; int pow2 = (int) Math.pow(x, k + 1); if (pow2 - target &lt; target) result = Math.min(result, leastOpsExpressTarget(x, pow2 - target) + k + 1); map.put(target, result); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 952 - Largest Component Size by Common Factor]]></title>
    <url>%2F2020%2F10%2F07%2FLeetcode-Problem-952-Largest-Component-Size-by-Common-Factor%2F</url>
    <content type="text"><![CDATA[Given a non-empty array of unique positive integers A, consider the following graph: There are A.length nodes, labelled A[0] to A[A.length - 1]; There is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1. Return the size of the largest connected component in the graph. ExampleNo.1Input: [4,6,15,35] Output: 4 No.2Input: [20,50,9,63] Output: 2 No.3Input: [2,3,6,7,4,12,21,39] Output: 8 Note 1 &lt;= A.length &lt;= 20000 1 &lt;= A[i] &lt;= 100000 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class UnionFind &#123; private int[] id; private int[] size; public UnionFind(int n) &#123; this.id = new int[n + 1]; this.size = new int[n + 1]; for (int i = 1; i &lt;= n; i++) &#123; id[i] = i; size[i] = 1; &#125; &#125; public boolean union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return false; if (size[pRoot] &lt; size[qRoot]) &#123; id[pRoot] = qRoot; size[qRoot] += size[pRoot]; &#125; else &#123; id[qRoot] = pRoot; size[pRoot] += size[qRoot]; &#125; return true; &#125; public int find(int p) &#123; while (p != id[p]) p = id[p]; return p; &#125;&#125;public int largestComponentSize(int[] A) &#123; int result = 0; Arrays.sort(A); int maxNum = A[A.length - 1]; UnionFind uf = new UnionFind(maxNum); for (int a : A) &#123; double sqrt = Math.sqrt(a); for (int i = 2; i &lt;= sqrt; i++) &#123; if (a % i == 0) &#123; uf.union(a, i); uf.union(a, a / i); &#125; &#125; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int a : A) &#123; int root = uf.find(a); map.putIfAbsent(root, 0); map.put(root, map.get(root) + 1); result = Math.max(map.get(root), result); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 943 - Find the Shortest Superstring]]></title>
    <url>%2F2020%2F10%2F07%2FLeetcode-Problem-943-Find-the-Shortest-Superstring%2F</url>
    <content type="text"><![CDATA[Given an array A of strings, find any smallest string that contains each string in A as a substring. We may assume that no string in A is substring of another string in A. ExampleNo.1Input: [“alex”,”loves”,”leetcode”] Output: “alexlovesleetcode” Explanation: All permutations of “alex”,”loves”,”leetcode” would also be accepted. No.2Input: [“catg”,”ctaagt”,”gcta”,”ttca”,”atgcatc”] Output: “gctaagttcatgcatc” Note 1 &lt;= A.length &lt;= 12 1 &lt;= A[i].length &lt;= 20 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// cost[i][j]: the cost of appending A[j] after A[i]// dp[s][i] = min&#123;d[s - 2^i][j] + cost[j][i]&#125;: min cost to visit nodes of s and ends with i// dp[2^i][i] = A[i].length// min = min&#123;dp[2^n - 1][*]&#125;public String shortestSuperstring(String[] A) &#123; StringBuilder sb = new StringBuilder(); int n = A.length; int[][] cost = new int[n][n]; int[][] dp = new int[1 &lt;&lt; n][n]; int[][] parent = new int[1 &lt;&lt; n][n]; int min = Integer.MAX_VALUE; int node = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; cost[i][j] = getCost(A[i], A[j]); cost[j][i] = getCost(A[j], A[i]); &#125; &#125; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) &#123; Arrays.fill(dp[i], Integer.MAX_VALUE / 2); Arrays.fill(parent[i], -1); &#125; for (int i = 0; i &lt; n; i++) dp[1 &lt;&lt; i][i] = A[i].length(); for (int s = 0; s &lt; (1 &lt;&lt; n); s++) &#123; for (int i = 0; i &lt; n; i++) &#123; if ((s &amp; (1 &lt;&lt; i)) == 0) continue; int preState = s &amp; ~ (1 &lt;&lt; i); for (int j = 0; j &lt; n; j++) &#123; if (dp[preState][j] + cost[j][i] &lt; dp[s][i]) &#123; dp[s][i] = dp[preState][j] + cost[j][i]; parent[s][i] = j; &#125; &#125; if (s == (1 &lt;&lt; n) - 1 &amp;&amp; dp[s][i] &lt; min) &#123; min = dp[s][i]; node = i; &#125; &#125; &#125; int curState = (1 &lt;&lt; n) - 1; while (curState != 0) &#123; int preNode = parent[curState][node]; if (preNode &gt;= 0) sb.insert(0, A[node].substring(A[node].length() - cost[preNode][node])); else sb.insert(0, A[node]); curState &amp;= ~ (1 &lt;&lt; node); node = preNode; &#125; return sb.toString();&#125;private int getCost(String a, String b) &#123; int cost = b.length(); int len = Math.min(a.length(), b.length()); for (int i = 1; i &lt;= len; i++) &#123; if (b.startsWith(a.substring(a.length() - i))) cost = b.length() - i; &#125; return cost;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 399 - Evaluate Division]]></title>
    <url>%2F2020%2F10%2F06%2FLeetcode-Problem-399-Evaluate-Division%2F</url>
    <content type="text"><![CDATA[You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable. You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?. Return the answers to all queries. If a single answer cannot be determined, return -1.0. NoteThe input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction. ExampleNo.1Input: equations = [[“a”,”b”],[“b”,”c”]], values = [2.0,3.0], queries = [[“a”,”c”],[“b”,”a”],[“a”,”e”],[“a”,”a”],[“x”,”x”]] Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000] Explanation:Given: a / b = 2.0, b / c = 3.0queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?return: [6.0, 0.5, -1.0, 1.0, -1.0] No.2Input: equations = [[“a”,”b”],[“b”,”c”],[“bc”,”cd”]], values = [1.5,2.5,5.0], queries = [[“a”,”c”],[“c”,”b”],[“bc”,”cd”],[“cd”,”bc”]] Output: [3.75000,0.40000,5.00000,0.20000] No.3Input: equations = [[“a”,”b”]], values = [0.5], queries = [[“a”,”b”],[“b”,”a”],[“a”,”c”],[“x”,”y”]] Output: [0.50000,2.00000,-1.00000,-1.00000] Constraints 1 &lt;= equations.length &lt;= 20 equations[i].length == 2 1 &lt;= Ai.length, Bi.length &lt;= 5 values.length == equations.length 0.0 &lt; values[i] &lt;= 20.0 1 &lt;= queries.length &lt;= 20 queries[i].length == 2 1 &lt;= Cj.length, Dj.length &lt;= 5 Ai, Bi, Cj, Dj consist of lower case English letters and digits. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private Map&lt;String, List&lt;Object&gt;&gt; parent = new HashMap&lt;&gt;();public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123; double[] result = new double[queries.size()]; for (int i = 0; i &lt; equations.size(); i++) &#123; String a = equations.get(i).get(0); String b = equations.get(i).get(1); double value = values[i]; if (!parent.containsKey(a) &amp;&amp; !parent.containsKey(b)) &#123; parent.put(a, Arrays.asList(b, value)); parent.put(b, Arrays.asList(b, 1.0)); &#125; else if (!parent.containsKey(a)) &#123; parent.put(a, Arrays.asList(b, value)); &#125; else if (!parent.containsKey(b)) &#123; parent.put(b, Arrays.asList(a, 1.0 / value)); &#125; else &#123; List&lt;Object&gt; parentA = findParent(a); // a/pa List&lt;Object&gt; parentB = findParent(b); // b/pb // pa/pb = a/b * (b/pb) / (a/pa) parent.put((String) parentA.get(0), Arrays.asList(parentB.get(0), value * (double) parentB.get(1) / (double) parentA.get(1))); &#125; &#125; for (int i = 0; i &lt; queries.size(); i++) &#123; String a = queries.get(i).get(0); String b = queries.get(i).get(1); if (!parent.containsKey(a) || !parent.containsKey(b)) &#123; result[i] = -1.0; continue; &#125; List&lt;Object&gt; parentA = findParent(a); // a/c List&lt;Object&gt; parentB = findParent(b); // b/c if (!parentA.get(0).equals(parentB.get(0))) result[i] = -1.0; else // a/b = (a/c) / (b/c) result[i] = (double) parentA.get(1) / (double) parentB.get(1); &#125; return result;&#125;private List&lt;Object&gt; findParent(String node) &#123; double value = 1.0; while (!node.equals(parent.get(node).get(0))) &#123; value *= (double) parent.get(node).get(1); node = String.valueOf(parent.get(node).get(0)); &#125; return Arrays.asList(node, value);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 959 - Regions Cut By Slashes]]></title>
    <url>%2F2020%2F10%2F06%2FLeetcode-Problem-959-Regions-Cut-By-Slashes%2F</url>
    <content type="text"><![CDATA[In a N x N grid composed of 1 x 1 squares, each 1 x 1 square consists of a /, \, or blank space. These characters divide the square into contiguous regions. (Note that backslash characters are escaped, so a \ is represented as “\\“.) Return the number of regions. ExampleNo.1Input: 1234[ " /", "/ "] Output: 2 Explanation: The 2x2 grid is as follows: No.2Input: 1234[ " /", " "] Output: 1 Explanation: The 2x2 grid is as follows: No.3Input: 1234[ "\\/", "/\\"] Output: 4 Explanation: (Recall that because \ characters are escaped, “\\/“ refers to \/, and “/\\“ refers to /\.)The 2x2 grid is as follows: No.4Input: 1234[ "/\\", "\\/"] Output: 5 Explanation: (Recall that because \ characters are escaped, “/\\“ refers to /\, and “\\/“ refers to \/.)The 2x2 grid is as follows: No.5Input: 1234[ "//", "/ "] Output: 3 Explanation: The 2x2 grid is as follows: Note 1 &lt;= grid.length == grid[0].length &lt;= 30 grid[i][j] is either ‘/‘, ‘\‘, or ‘ ‘. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class UnionFind &#123; private int[] id; private int[] size; private int count; public UnionFind(int n) &#123; this.id = new int[n]; this.size = new int[n]; count = n; for (int i = 0; i &lt; n; i++) &#123; id[i] = i; size[i] = 1; &#125; &#125; public int count() &#123; return count; &#125; public boolean union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return false; if (size[pRoot] &lt; size[qRoot]) &#123; id[pRoot] = qRoot; size[qRoot] += size[pRoot]; &#125; else &#123; id[qRoot] = pRoot; size[pRoot] += size[qRoot]; &#125; count--; return true; &#125; public int find(int p) &#123; while (p != id[p]) p = id[p]; return p; &#125;&#125;public int regionsBySlashes(String[] grid) &#123; int n = grid.length; UnionFind uf = new UnionFind(4 * n * n); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; int idx = 4 * (i * n + j); if (grid[i].charAt(j) == '/') &#123; uf.union(idx, idx + 3); uf.union(idx + 1, idx + 2); &#125; else if (grid[i].charAt(j) == '\\') &#123; uf.union(idx, idx + 1); uf.union(idx + 2, idx + 3); &#125; else &#123; uf.union(idx, idx + 1); uf.union(idx + 1, idx + 2); uf.union(idx + 2, idx + 3); &#125; if (i &lt; n - 1) uf.union(idx + 2, idx + 4 * n); if (j &lt; n - 1) uf.union(idx + 1, idx + 4 + 3); &#125; &#125; return uf.count();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 1579 - Remove Max Number of Edges to Keep Graph Fully Traversable]]></title>
    <url>%2F2020%2F10%2F06%2FLeetcode-Problem-1579-Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable%2F</url>
    <content type="text"><![CDATA[Alice and Bob have an undirected graph of n nodes and 3 types of edges: Type 1: Can be traversed by Alice only. Type 2: Can be traversed by Bob only. Type 3: Can by traversed by both Alice and Bob. Given an array edges where edges[i] = [typei, ui, vi] represents a bidirectional edge of type typei between nodes ui and vi, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes. Return the maximum number of edges you can remove, or return -1 if it’s impossible for the graph to be fully traversed by Alice and Bob. ExampleNo.1 Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]] Output: 2 Explanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2. No.2 Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]] Output: 0 Explanation: Notice that removing any edge will not make the graph fully traversable by Alice and Bob. No.3 Input: n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]] Output: -1 Explanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it’s impossible to make the graph fully traversable. Constraints 1 &lt;= n &lt;= 10^5 1 &lt;= edges.length &lt;= min(10^5, 3 * n * (n-1) / 2) edges[i].length == 3 1 &lt;= edges[i][0] &lt;= 3 1 &lt;= edges[i][1] &lt; edges[i][2] &lt;= n All tuples (typei, ui, vi) are distinct. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class UnionFind &#123; private int[] id; private int[] size; private int count; public UnionFind(int n) &#123; this.id = new int[n + 1]; this.size = new int[n + 1]; count = n; for (int i = 1; i &lt;= n; i++) &#123; id[i] = i; size[i] = 1; &#125; &#125; public int count() &#123; return count; &#125; public boolean union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return false; if (size[pRoot] &lt; size[qRoot]) &#123; id[pRoot] = qRoot; size[qRoot] += size[pRoot]; &#125; else &#123; id[qRoot] = pRoot; size[pRoot] += size[qRoot]; &#125; count--; return true; &#125; public int find(int p) &#123; while (p != id[p]) p = id[p]; return p; &#125;&#125;public int maxNumEdgesToRemove(int n, int[][] edges) &#123; int result = 0; UnionFind a = new UnionFind(n); UnionFind b = new UnionFind(n); for (int[] edge : edges) &#123; if (edge[0] != 3) continue; if (a.union(edge[1], edge[2])) b.union(edge[1], edge[2]); else result++; &#125; for (int[] edge : edges) &#123; if (edge[0] == 1) &#123; if (!a.union(edge[1], edge[2])) result++; &#125; else if (edge[0] == 2) &#123; if (!b.union(edge[1], edge[2])) result++; &#125; &#125; return a.count == 1 &amp;&amp; b.count == 1 ? result : -1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 1489 - Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree]]></title>
    <url>%2F2020%2F10%2F05%2FLeetcode-Problem-1489-Find-Critical-and-Pseudo-Critical-Edges-in-Minimum-Spanning-Tree%2F</url>
    <content type="text"><![CDATA[Given a weighted undirected connected graph with n vertices numbered from 0 to n-1, and an array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between nodes fromi and toi. A minimum spanning tree (MST) is a subset of the edges of the graph that connects all vertices without cycles and with the minimum possible total edge weight. Find all the critical and pseudo-critical edges in the minimum spanning tree (MST) of the given graph. An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. A pseudo-critical edge, on the other hand, is that which can appear in some MSTs but not all. Note that you can return the indices of the edges in any order. ExampleNo.1 Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]] Output: [[0,1],[2,3,4,5]] Explanation: The figure above describes the graph.The following figure shows all the possible MSTs: Notice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output.The edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output. No.2 Input: n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]] Output: [[],[0,1,2,3]] Explanation: We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical. Constraints 2 &lt;= n &lt;= 100 1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2) edges[i].length == 3 0 &lt;= fromi &lt; toi &lt; n 1 &lt;= weighti &lt;= 1000 All pairs (fromi, toi) are distinct. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class UnionFind &#123; private int[] id; private int[] size; private int count; public UnionFind(int n) &#123; this.id = new int[n]; this.size = new int[n]; count = n; for (int i = 0; i &lt; n; i++) &#123; id[i] = i; size[i] = 1; &#125; &#125; public int count() &#123; return count; &#125; public boolean union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return false; if (size[pRoot] &lt; size[qRoot]) &#123; id[pRoot] = qRoot; size[qRoot] += size[pRoot]; &#125; else &#123; id[qRoot] = pRoot; size[pRoot] += size[qRoot]; &#125; count--; return true; &#125; public int find(int p) &#123; while (p != id[p]) p = id[p]; return p; &#125;&#125;public List&lt;List&lt;Integer&gt;&gt; findCriticalAndPseudoCriticalEdges(int n, int[][] edges) &#123; List&lt;Integer&gt; critical = new ArrayList&lt;&gt;(); List&lt;Integer&gt; pseudo = new ArrayList&lt;&gt;(); Map&lt;int[], Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; edges.length; i++) map.put(edges[i], i); Arrays.sort(edges, (a, b) -&gt; Integer.compare(a[2], b[2])); int minCost = buildMST(n, edges, null, null); for (int i = 0; i &lt; edges.length; i++) &#123; int[] edge = edges[i]; if (buildMST(n, edges, edge, null) &gt; minCost) critical.add(map.get(edge)); else if (buildMST(n, edges, null, edge) == minCost) pseudo.add(map.get(edge)); &#125; return Arrays.asList(critical, pseudo);&#125;private int buildMST(int n, int[][] edges, int[] exclude, int[] include) &#123; UnionFind uf = new UnionFind(n); int cost = 0; if (include != null) &#123; uf.union(include[0], include[1]); cost += include[2]; &#125; for (int[] edge : edges) &#123; if (edge == exclude) continue; if (uf.union(edge[0], edge[1])) cost += edge[2]; &#125; return uf.count == 1 ? cost : Integer.MAX_VALUE;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Lintcode] Problem 854 - Closest Leaf in a Binary Tree]]></title>
    <url>%2F2020%2F09%2F24%2FLintcode-Problem-854-Closest-Leaf-in-a-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree where every node has a unique value, and a target key k. Find the value of the nearest leaf node to target k in the tree. If there are multiple cases, you should follow these priorities: The leaf node is in the left subtree of the node with k; The leaf node is in the right subtree of the node with k; The leaf node is not in the subtree of the node with k. Note root represents a binary tree with at least 1 node and at most 1000 nodes. Every node has a unique node.val in range [1, 1000]. There exists a node in the given binary tree for which node.val == k. ExampleNo.1Input: {1, 3, 2}, k = 1 Output: 3 Explanation: 123 1 / \3 2 No.2Input: {1}, k = 1 Output: 1 Code123456789101112public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123;&#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private TreeNode start;private Map&lt;TreeNode, TreeNode&gt; connection = new HashMap&lt;&gt;();public int findClosestLeaf(TreeNode root, int k) &#123; Set&lt;TreeNode&gt; visit = new HashSet&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); dfs(null, root, k); queue.offer(start); visit.add(start); while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); if (node.left == null &amp;&amp; node.right == null) return node.val; if (node.left != null &amp;&amp; !visit.contains(node.left)) &#123; queue.offer(node.left); visit.add(node.left); &#125; if (node.right != null &amp;&amp; !visit.contains(node.right)) &#123; queue.offer(node.right); visit.add(node.right); &#125; if (connection.containsKey(node) &amp;&amp; !visit.contains(connection.get(node))) &#123; queue.offer(connection.get(node)); visit.add(connection.get(node)); &#125; &#125; return 0;&#125;private void dfs(TreeNode parent, TreeNode node, int k) &#123; if (node == null) return; if (node.val == k) start = node; if (parent != null) &#123; connection.put(node, parent); &#125; dfs(node, node.left, k); dfs(node, node.right, k);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 1145 - Binary Tree Coloring Game]]></title>
    <url>%2F2020%2F09%2F23%2FLeetcode-Problem-1145-Binary-Tree-Coloring-Game%2F</url>
    <content type="text"><![CDATA[Two players play a turn based game on a binary tree. We are given the root of this binary tree, and the number of nodes n in the tree. n is odd, and each node has a distinct value from 1 to n. Initially, the first player names a value x with 1 &lt;= x &lt;= n, and the second player names a value y with 1 &lt;= y &lt;= n and y != x. The first player colors the node with value x red, and the second player colors the node with value y blue. Then, the players take turns starting with the first player. In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an uncolored neighbor of the chosen node (either the left child, right child, or parent of the chosen node.) If (and only if) a player cannot choose such a node in this way, they must pass their turn. If both players pass their turn, the game ends, and the winner is the player that colored more nodes. You are the second player. If it is possible to choose such a y to ensure you win the game, return true. If it is not possible, return false. Example Input: root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3 Output: true Explanation: The second player can choose the node with value 2. Constraints root is the root of a binary tree with n nodes and distinct node values from 1 to n. n is odd. 1 &lt;= x &lt;= n &lt;= 100 Code123456789101112public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123;&#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125; 1234567891011121314151617181920212223private int sizeL = 0;private int sizeR = 0;public boolean btreeGameWinningMove(TreeNode root, int n, int x) &#123; traverse(root, x); int sizeP = n - sizeL - sizeR - 1; return Math.max(Math.max(sizeL, sizeR), sizeP) &gt; n / 2;&#125;private int traverse(TreeNode root, int x) &#123; if (root == null) return 0; int left = traverse(root.left, x); int right = traverse(root.right, x); if (root.val == x) &#123; sizeL = left; sizeR = right; &#125; return left + right + 1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 1319 - Number of Operations to Make Network Connected]]></title>
    <url>%2F2020%2F09%2F21%2FLeetcode-Problem-1319-Number-of-Operations-to-Make-Network-Connected%2F</url>
    <content type="text"><![CDATA[There are n computers numbered from 0 to n-1 connected by ethernet cables connections forming a network where connections[i] = [a, b] represents a connection between computers a and b. Any computer can reach any other computer directly or indirectly through the network. Given an initial computer network connections. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected. Return the minimum number of times you need to do this in order to make all the computers connected. If it’s not possible, return -1. ExampleNo.1 Input: n = 4, connections = [[0,1],[0,2],[1,2]] Output: 1 Explanation: Remove cable between computer 1 and 2 and place between computers 1 and 3. No.2 Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]] Output: 2 No.3Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2]] Output: -1 Explanation: There are not enough cables. No.4Input: n = 5, connections = [[0,1],[0,2],[3,4],[2,3]] Output: 0 Constraints 1 &lt;= n &lt;= 10^5 1 &lt;= connections.length &lt;= min(n*(n-1)/2, 10^5) connections[i].length == 2 0 &lt;= connections[i][0], connections[i][1] &lt; n connections[i][0] != connections[i][1] There are no repeated connections. No two computers are connected by more than one cable. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class UnionFind &#123; private int[] id; private int[] size; private int count; public UnionFind(int n) &#123; this.id = new int[n]; this.size = new int[n]; count = n; for (int i = 0; i &lt; n; i++) &#123; id[i] = i; size[i] = 1; &#125; &#125; public int count() &#123; return count; &#125; public boolean union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return false; if (size[pRoot] &lt; size[qRoot]) &#123; id[pRoot] = qRoot; size[qRoot] += size[pRoot]; &#125; else &#123; id[qRoot] = pRoot; size[pRoot] += size[qRoot]; &#125; count--; return true; &#125; public int find(int p) &#123; while (p != id[p]) p = id[p]; return p; &#125;&#125;public int makeConnected(int n, int[][] connections) &#123; if (connections.length &lt; n - 1) return -1; UnionFind uf = new UnionFind(n); for (int[] connection : connections) uf.union(connection[0], connection[1]); return uf.count() - 1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 1202 - Smallest String With Swaps]]></title>
    <url>%2F2020%2F09%2F21%2FLeetcode-Problem-1202-Smallest-String-With-Swaps%2F</url>
    <content type="text"><![CDATA[You are given a string s, and an array of pairs of indices in the string pairs where pairs[i] = [a, b] indicates 2 indices(0-indexed) of the string. You can swap the characters at any pair of indices in the given pairs any number of times. Return the lexicographically smallest string that s can be changed to after using the swaps. ExampleNo.1Input: s = “dcab”, pairs = [[0,3],[1,2]] Output: “bacd” Explaination:Swap s[0] and s[3], s = “bcad”Swap s[1] and s[2], s = “bacd” No.2Input: s = “dcab”, pairs = [[0,3],[1,2],[0,2]] Output: “abcd” Explaination:Swap s[0] and s[3], s = “bcad”Swap s[0] and s[2], s = “acbd”Swap s[1] and s[2], s = “abcd” No.3Input: s = “cba”, pairs = [[0,1],[1,2]] Output: “abc” Explaination:Swap s[0] and s[1], s = “bca”Swap s[1] and s[2], s = “bac”Swap s[0] and s[1], s = “abc” Constraints 1 &lt;= s.length &lt;= 10^5 0 &lt;= pairs.length &lt;= 10^5 0 &lt;= pairs[i][0], pairs[i][1] &lt; s.length s only contains lower case English letters. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class UnionFind &#123; private int[] id; private int[] size; public UnionFind(int n) &#123; this.id = new int[n]; this.size = new int[n]; for (int i = 0; i &lt; n; i++) &#123; id[i] = i; size[i] = 1; &#125; &#125; public boolean union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return false; if (size[pRoot] &lt; size[qRoot]) &#123; id[pRoot] = qRoot; size[qRoot] += size[pRoot]; &#125; else &#123; id[qRoot] = pRoot; size[pRoot] += size[qRoot]; &#125; return true; &#125; public int find(int p) &#123; while (p != id[p]) p = id[p]; return p; &#125;&#125;public String smallestStringWithSwaps(String s, List&lt;List&lt;Integer&gt;&gt; pairs) &#123; char[] result = s.toCharArray(); UnionFind uf = new UnionFind(s.length()); Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (List&lt;Integer&gt; pair : pairs) uf.union(pair.get(0), pair.get(1)); for (int i = 0; i &lt; s.length(); i++) &#123; int root = uf.find(i); map.putIfAbsent(root, new ArrayList&lt;&gt;()); map.get(root).add(i); &#125; for (Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; entry : map.entrySet()) &#123; List&lt;Integer&gt; index = entry.getValue(); List&lt;Character&gt; chars = new ArrayList&lt;&gt;(); for (int idx : index) chars.add(result[idx]); Collections.sort(chars); for (int i = 0; i &lt; index.size(); i++) result[index.get(i)] = chars.get(i); &#125; return String.valueOf(result);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 1334 - Find the City With the Smallest Number of Neighbors at a Threshold Distance]]></title>
    <url>%2F2020%2F09%2F17%2FLeetcode-Problem-1334-Find-the-City-With-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance%2F</url>
    <content type="text"><![CDATA[There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold. Return the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, If there are multiple such cities, return the city with the greatest number. Notice that the distance of a path connecting cities i and j is equal to the sum of the edges’ weights along that path. ExampleNo.1 Input: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4 Output: 3 Explanation: The figure above describes the graph.The neighboring cities at a distanceThreshold = 4 for each city are:City 0 -&gt; [City 1, City 2]City 1 -&gt; [City 0, City 2, City 3]City 2 -&gt; [City 0, City 1, City 3]City 3 -&gt; [City 1, City 2]Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number. No.2 Input: n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2 Output: 0 Explanation: The figure above describes the graph.The neighboring cities at a distanceThreshold = 2 for each city are:City 0 -&gt; [City 1]City 1 -&gt; [City 0, City 4]City 2 -&gt; [City 3, City 4]City 3 -&gt; [City 2, City 4]City 4 -&gt; [City 1, City 2, City 3]The city 0 has 1 neighboring city at a distanceThreshold = 2. Constraints 2 &lt;= n &lt;= 100 1 &lt;= edges.length &lt;= n * (n - 1) / 2 edges[i].length == 3 0 &lt;= fromi &lt; toi &lt; n 1 &lt;= weighti, distanceThreshold &lt;= 10^4 All pairs (fromi, toi) are distinct. Code123456789101112131415161718192021222324252627282930313233343536public int findTheCity(int n, int[][] edges, int distanceThreshold) &#123; int result = -1; int[][] distance = new int[n][n]; int min = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) Arrays.fill(distance[i], Integer.MAX_VALUE / 2); for (int[] edge : edges) &#123; distance[edge[0]][edge[1]] = edge[2]; distance[edge[1]][edge[0]] = edge[2]; &#125; for (int k = 0; k &lt; n; k++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) distance[i][j] = Math.min(distance[i][j], distance[i][k] + distance[k][j]); &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; int count = 0; for (int j = 0; j &lt; n; j++) &#123; if (i != j &amp;&amp; distance[i][j] &lt;= distanceThreshold) count++; &#125; if (count &lt;= min) &#123; min = count; result = i; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 1129 - Shortest Path with Alternating Colors]]></title>
    <url>%2F2020%2F09%2F17%2FLeetcode-Problem-1129-Shortest-Path-with-Alternating-Colors%2F</url>
    <content type="text"><![CDATA[Consider a directed graph, with nodes labelled 0, 1, …, n-1. In this graph, each edge is either red or blue, and there could be self-edges or parallel edges. Each [i, j] in red_edges denotes a red directed edge from node i to node j. Similarly, each [i, j] in blue_edges denotes a blue directed edge from node i to node j. Return an array answer of length n, where each answer[X] is the length of the shortest path from node 0 to node X such that the edge colors alternate along the path (or -1 if such a path doesn’t exist). ExampleNo.1Input: n = 3, red_edges = [[0,1],[1,2]], blue_edges = [] Output: [0,1,-1] No.2Input: n = 3, red_edges = [[0,1]], blue_edges = [[2,1]] Output: [0,1,-1] No.3Input: n = 3, red_edges = [[1,0]], blue_edges = [[2,1]] Output: [0,-1,-1] No.4Input: n = 3, red_edges = [[0,1]], blue_edges = [[1,2]] Output: [0,1,2] No.5Input: n = 3, red_edges = [[0,1],[0,2]], blue_edges = [[1,0]] Output: [0,1,1] Note 1 &lt;= n &lt;= 100 red_edges.length &lt;= 400 blue_edges.length &lt;= 400 red_edges[i].length == blue_edges[i].length == 2 0 &lt;= red_edges[i][j], blue_edges[i][j] &lt; n Code123456789101112131415161718192021222324252627282930313233343536373839404142434445public int[] shortestAlternatingPaths(int n, int[][] red_edges, int[][] blue_edges) &#123; int[] result = new int[n]; List&lt;Integer&gt;[][] graph = new ArrayList[2][n]; boolean[][] visit = new boolean[2][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); // 0 = red, 1 = blue queue.offer(new int[] &#123;0, 0&#125;); queue.offer(new int[] &#123;0, 1&#125;); visit[0][0] = true; visit[1][0] = true; int path = 0; Arrays.fill(result, -1); for (int i = 0; i &lt; n; i++) &#123; graph[0][i] = new ArrayList&lt;&gt;(); graph[1][i] = new ArrayList&lt;&gt;(); &#125; for (int[] red : red_edges) graph[0][red[0]].add(red[1]); for (int[] blue : blue_edges) graph[1][blue[0]].add(blue[1]); while (!queue.isEmpty()) &#123; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; int[] node = queue.poll(); int idx = node[0]; int color = node[1]; result[idx] = result[idx] &lt; 0 ? path : Math.min(path, result[idx]); for (int neighbor : graph[1 - color][node[0]]) &#123; if (!visit[1 - color][neighbor]) &#123; visit[1 - color][neighbor] = true; queue.offer(new int[] &#123;neighbor, 1 - color&#125;); &#125; &#125; &#125; path++; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 886 - Possible Bipartition]]></title>
    <url>%2F2020%2F09%2F16%2FLeetcode-Problem-886-Possible-Bipartition%2F</url>
    <content type="text"><![CDATA[Given a set of N people (numbered 1, 2, …, N), we would like to split everyone into two groups of any size. Each person may dislike some other people, and they should not go into the same group. Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group. Return true if and only if it is possible to split everyone into two groups in this way. ExampleNo.1Input: N = 4, dislikes = [[1,2],[1,3],[2,4]] Output: true Explanation: group1 [1,4], group2 [2,3] No.2Input: N = 3, dislikes = [[1,2],[1,3],[2,3]] Output: false No.3Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]] Output: false Constraints 1 &lt;= N &lt;= 2000 0 &lt;= dislikes.length &lt;= 10000 dislikes[i].length == 2 1 &lt;= dislikes[i][j] &lt;= N dislikes[i][0] &lt; dislikes[i][1] There does not exist i != j for which dislikes[i] == dislikes[j]. Code123456789101112131415161718192021222324252627282930313233343536private int[] color;private List&lt;Integer&gt;[] graph;public boolean possibleBipartition(int N, int[][] dislikes) &#123; color = new int[N + 1]; graph = new ArrayList[N + 1]; for (int i = 1; i &lt;= N; i++) graph[i] = new ArrayList&lt;Integer&gt;(); for (int[] dislike : dislikes) &#123; graph[dislike[0]].add(dislike[1]); graph[dislike[1]].add(dislike[0]); &#125; for (int i = 1; i &lt;= N; i++) &#123; if (color[i] == 0 &amp;&amp; !dfs(i, 1)) return false; &#125; return true;&#125;private boolean dfs(int node, int currentColor) &#123; color[node] = currentColor; for (int neighbor : graph[node]) &#123; if (color[neighbor] == currentColor) return false; if (color[neighbor] == 0 &amp;&amp; !dfs(neighbor, -currentColor)) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 882 - Reachable Nodes In Subdivided Graph]]></title>
    <url>%2F2020%2F09%2F15%2FLeetcode-Problem-882-Reachable-Nodes-In-Subdivided-Graph%2F</url>
    <content type="text"><![CDATA[Starting with an undirected graph (the “original graph”) with nodes from 0 to N-1, subdivisions are made to some of the edges. The graph is given as follows: edges[k] is a list of integer pairs (i, j, n) such that (i, j) is an edge of the original graph, and n is the total number of new nodes on that edge. Then, the edge (i, j) is deleted from the original graph, n new nodes (x_1, x_2, …, x_n) are added to the original graph, and n+1 new edges (i, x_1), (x_1, x_2), (x_2, x_3), …, (x_{n-1}, x_n), (x_n, j) are added to the original graph. Now, you start at node 0 from the original graph, and in each move, you travel along one edge. Return how many nodes you can reach in at most M moves. ExampleNo.1Input: edges = [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3 Output: 13 Explanation:The nodes that are reachable in the final graph after M = 6 moves are indicated below. No.2Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4 Output: 23 Note 0 &lt;= edges.length &lt;= 10000 0 &lt;= edges[i][0] &lt; edges[i][1] &lt; N There does not exist any i != j for which edges[i][0] == edges[j][0] and edges[i][1] == edges[j][1]. The original graph has no parallel edges. 0 &lt;= edges[i][2] &lt;= 10000 0 &lt;= M &lt;= 10^9 1 &lt;= N &lt;= 3000 A reachable node is a node that can be travelled to using at most M moves starting from node 0. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Node&#123; private int idx; private int val; public Node(int idx, int val) &#123; this.idx = idx; this.val = val; &#125;&#125;public int reachableNodes(int[][] edges, int M, int N) &#123; List&lt;Node&gt;[] graph = new ArrayList[N]; Map&lt;Integer, Integer&gt; visit = new HashMap&lt;&gt;(); PriorityQueue&lt;Node&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; (b.val - a.val)); pq.offer(new Node(0, M)); for (int i = 0; i &lt; N; i++) graph[i] = new ArrayList&lt;Node&gt;(); for (int[] edge : edges) &#123; graph[edge[0]].add(new Node(edge[1], edge[2] + 1)); graph[edge[1]].add(new Node(edge[0], edge[2] + 1)); &#125; while (!pq.isEmpty()) &#123; Node node = pq.poll(); if (!visit.containsKey(node.idx)) &#123; visit.put(node.idx, node.val); for (Node neighbor : graph[node.idx]) &#123; int val = node.val - neighbor.val; if (visit.containsKey(neighbor.idx) || val &lt; 0) continue; pq.offer(new Node(neighbor.idx, val)); &#125; &#125; &#125; int result = visit.size(); for (int[] edge : edges) &#123; int a = visit.containsKey(edge[0]) ? visit.get(edge[0]) : 0; int b = visit.containsKey(edge[1]) ? visit.get(edge[1]) : 0; result += Math.min(edge[2], a + b); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 827 - Making A Large Island]]></title>
    <url>%2F2020%2F09%2F14%2FLeetcode-Problem-827-Making-A-Large-Island%2F</url>
    <content type="text"><![CDATA[In a 2D grid of 0s and 1s, we change at most one 0 to a 1. After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s). ExampleNo.1Input: [[1, 0], [0, 1]] Output: 3 Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3. No.2Input: [[1, 1], [1, 0]] Output: 4 Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4. No.3Input: [[1, 1], [1, 1]] Output: 4 Explanation: Can’t change any 0 to 1, only one island with area = 4. Note 1 &lt;= grid.length = grid[0].length &lt;= 50. 0 &lt;= grid[i][j] &lt;= 1. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private int m;private int n;private int[][] dirs = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;public int largestIsland(int[][] grid) &#123; int result = 0; int index = 2; m = grid.length; n = grid[0].length; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 1) &#123; int area = getArea(grid, i, j, index); map.put(index, area); result = Math.max(area, result); index++; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 0) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int area = 1; for (int[] dir : dirs) &#123; int idx = getIndex(grid, i + dir[0], j + dir[1]); if (idx != 0 &amp;&amp; !set.contains(idx)) area += map.get(idx); set.add(idx); &#125; result = Math.max(area, result); &#125; &#125; &#125; return result;&#125;private int getArea(int[][] grid, int x, int y, int index) &#123; if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n || grid[x][y] != 1) return 0; grid[x][y] = index; int area = 1; for (int[] dir : dirs) area += getArea(grid, x + dir[0], y + dir[1], index); return area;&#125;private int getIndex(int[][] grid, int x, int y) &#123; if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n) return 0; return grid[x][y];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 817 - Linked List Components]]></title>
    <url>%2F2020%2F09%2F13%2FLeetcode-Problem-817-Linked-List-Components%2F</url>
    <content type="text"><![CDATA[We are given head, the head node of a linked list containing unique integer values. We are also given the list G, a subset of the values in the linked list. Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list. ExampleNo.1Input:head: 0-&gt;1-&gt;2-&gt;3G = [0, 1, 3] Output: 2 Explanation:0 and 1 are connected, so [0, 1] and [3] are the two connected components. No.2Input:head: 0-&gt;1-&gt;2-&gt;3-&gt;4G = [0, 3, 1, 4] Output: 2 Explanation:0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components. Note If N is the length of the linked list given by head, 1 &lt;= N &lt;= 10000. The value of each node in the linked list will be in the range [0, N - 1]. 1 &lt;= G.length &lt;= 10000. G is a subset of all values in the linked list. Code12345678910public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; 12345678910111213141516public int numComponents(ListNode head, int[] G) &#123; int result = 0; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int g : G) set.add(g); while (head != null) &#123; if (set.contains(head.val) &amp;&amp; (head.next == null || !set.contains(head.next.val))) result++; head = head.next; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 802 - Find Eventual Safe States]]></title>
    <url>%2F2020%2F09%2F13%2FLeetcode-Problem-802-Find-Eventual-Safe-States%2F</url>
    <content type="text"><![CDATA[In a directed graph, we start at some node and every turn, walk along a directed edge of the graph. If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop. Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node. More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps. Which nodes are eventually safe? Return them as an array in sorted order. The directed graph has N nodes with labels 0, 1, …, N-1, where N is the length of graph. The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph. ExampleInput: graph = [[1,2],[2,3],[5],[0],[5],[],[]] Output: [2,4,5,6]Here is a diagram of the above graph. Note graph will have length at most 10000. The number of edges in the graph will not exceed 32000. Each graph[i] will be a sorted list of different integers, chosen within the range [0, graph.length - 1]. Code1234567891011121314151617181920212223242526272829303132333435363738public List&lt;Integer&gt; eventualSafeNodes(int[][] graph) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int[] state = new int[graph.length]; // 0 = unvisit, 1 = visited, 2 = safe, 3 = unsafe for (int i = 0; i &lt; graph.length; i++) &#123; dfs(graph, i, state); if (state[i] == 2) &#123; result.add(i); &#125; &#125; return result;&#125;private void dfs(int[][] graph, int node, int[] state) &#123; if (state[node] == 1) &#123; state[node] = 3; return; &#125; if (state[node] != 0) &#123; return; &#125; state[node] = 1; for (int neighbor : graph[node]) &#123; dfs(graph, neighbor, state); if (state[neighbor] == 3) &#123; state[node] = 3; return; &#125; &#125; state[node] = 2;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 1424 - Diagonal Traverse II]]></title>
    <url>%2F2020%2F09%2F07%2FLeetcode-Problem-1424-Diagonal-Traverse-II%2F</url>
    <content type="text"><![CDATA[Given a list of lists of integers, nums, return all elements of nums in diagonal order as shown in the below images. ExampleNo.1 Input: nums = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,4,2,7,5,3,8,6,9] No.2 Input: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]] Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16] No.3Input: nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]] Output: [1,4,2,5,3,8,6,9,7,10,11] No.4Input: nums = [[1,2,3,4,5,6]] Output: [1,2,3,4,5,6] Constraints 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i].length &lt;= 10^5 1 &lt;= nums[i][j] &lt;= 10^9 There at most 10^5 elements in nums. Code12345678910111213141516171819202122232425262728public int[] findDiagonalOrder(List&lt;List&lt;Integer&gt;&gt; nums) &#123; Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); int count = 0; int idx = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; List&lt;Integer&gt; num = nums.get(i); for (int j = 0; j &lt; num.size(); j++) &#123; map.putIfAbsent(i + j, new ArrayList&lt;&gt;()); map.get(i + j).add(num.get(j)); count++; &#125; &#125; int[] result = new int[count]; for (int i = 0; i &lt; map.size(); i++) &#123; List&lt;Integer&gt; num = map.get(i); for (int j = num.size() - 1; j &gt;= 0; j--) &#123; result[idx] = num.get(j); idx++; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 498 - Diagonal Traverse]]></title>
    <url>%2F2020%2F09%2F07%2FLeetcode-Problem-498-Diagonal-Traverse%2F</url>
    <content type="text"><![CDATA[Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image. ExampleInput:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]] Output: [1,2,4,7,5,3,6,8,9] Explanation: NoteThe total number of elements of the given matrix will not exceed 10,000. Code1234567891011121314151617181920212223242526272829303132333435363738394041public int[] findDiagonalOrder(int[][] matrix) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return new int[0]; int m = matrix.length; int n = matrix[0].length; int[] result = new int[m * n]; int row = 0; int col = 0; int dir = 1; for (int i = 0; i &lt; m * n; i++) &#123; result[i] = matrix[row][col]; row -= dir; col += dir; if (row &gt;= m) &#123; row = m - 1; col += 2; dir = -dir; &#125; if (col &gt;= n) &#123; col = n - 1; row += 2; dir = -dir; &#125; if (row &lt; 0) &#123; row = 0; dir = -dir; &#125; if (col &lt; 0) &#123; col = 0; dir = -dir; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 963 - Minimum Area Rectangle II]]></title>
    <url>%2F2020%2F08%2F03%2FLeetcode-Problem-963-Minimum-Area-Rectangle-II%2F</url>
    <content type="text"><![CDATA[Given a set of points in the xy-plane, determine the minimum area of any rectangle formed from these points, with sides not necessarily parallel to the x and y axes. If there isn’t any rectangle, return 0. ExampleNo.1 Input: [[1,2],[2,1],[1,0],[0,1]] Output: 2.00000 Explanation: The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2. No.2 Input: [[0,1],[2,1],[1,1],[1,0],[2,0]] Output: 1.00000 Explanation: The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1. No.3 Input: [[0,3],[1,2],[3,1],[1,3],[2,1]] Output: 0 Explanation: There is no possible rectangle to form from these points. No.4 Input: [[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]] Output: 2.00000 Explanation: The minimum area rectangle occurs at [2,1],[2,3],[3,3],[3,1], with an area of 2. Note 1 &lt;= points.length &lt;= 50 0 &lt;= points[i][0] &lt;= 40000 0 &lt;= points[i][1] &lt;= 40000 All points are distinct. Answers within 10^-5 of the actual value will be accepted as correct. Code123456789101112131415161718192021222324252627282930313233343536373839public double minAreaFreeRect(int[][] points) &#123; double result = Double.MAX_VALUE; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int[] point : points) &#123; set.add(point[0] &lt;&lt; 16 | point[1]); &#125; int size = set.size(); for (int i = 0; i &lt; size; i++) &#123; for (int j = 0; j &lt; size; j++) &#123; if (i == j) continue; for (int k = 0; k &lt; size; k++) &#123; if (k == i || k == j) continue; int[] p0 = points[i]; int[] p1 = points[j]; int[] p2 = points[k]; int dot = (p1[0] - p0[0]) * (p2[0] - p0[0]) + (p1[1] - p0[1]) * (p2[1] - p0[1]); if (dot != 0) continue; int x3 = p1[0] + p2[0] - p0[0]; int y3 = p1[1] + p2[1] - p0[1]; if (!set.contains(x3 &lt;&lt; 16 | y3)) continue; double a = Math.pow(p1[0] - p0[0], 2) + Math.pow(p1[1] - p0[1], 2); double b = Math.pow(p2[0] - p0[0], 2) + Math.pow(p2[1] - p0[1], 2); result = Math.min(a * b, result); &#125; &#125; &#125; return result == Double.MAX_VALUE ? 0 : Math.sqrt(result);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode] Problem 939 - Minimum Area Rectangle]]></title>
    <url>%2F2020%2F08%2F02%2FLeetcode-Problem-939-Minimum-Area-Rectangle%2F</url>
    <content type="text"><![CDATA[Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes. If there isn’t any rectangle, return 0. ExampleNo.1Input: [[1,1],[1,3],[3,1],[3,3],[2,2]] Output: 4 No.2Input: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]] Output: 2 Note 1 &lt;= points.length &lt;= 500 0 &lt;= points[i][0] &lt;= 40000 0 &lt;= points[i][1] &lt;= 40000 All points are distinct. Code1234567891011121314151617181920212223242526272829public int minAreaRect(int[][] points) &#123; int result = Integer.MAX_VALUE; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int[] point : points) &#123; set.add(point[0] &lt;&lt; 16 | point[1]); &#125; int size = set.size(); for (int i = 0; i &lt; size; i++) &#123; for (int j = i + 1; j &lt; size; j++) &#123; int x0 = points[i][0]; int y0 = points[i][1]; int x1 = points[j][0]; int y1 = points[j][1]; if (x0 == x1 || y0 == y1) continue; if (!set.contains(x0 &lt;&lt; 16 | y1) || !set.contains(x1 &lt;&lt; 16 | y0)) continue; int area = Math.abs(x0 - x1) * Math.abs(y0 - y1); result = Math.min(area, result); &#125; &#125; return result == Integer.MAX_VALUE ? 0 : result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字签名]]></title>
    <url>%2F2020%2F04%2F26%2F%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%2F</url>
    <content type="text"><![CDATA[通过散列函数可以确保数据内容的完整性，但这还远远不够。此外，还需要确保数据来源的可认证（鉴别）性和数据发送行为的不可否认性。数字签名针对以数字形式存储的消息进行处理，产生一种带有操作者身份信息的编码。执行数字签名的实体称为签名者，签名过程中所使用的算法称为签名算法（Signature Algorithm），签名操作中生成的编码称为签名者对该消息的数字签名。发送者通过网络将消息连同其数字签名一起发送给接收者。接收者在得到该消息及其数字签名后，可以通过一个算法来验证签名的真伪以及识别相应的签名者。这一过程称为验证过程，其过程中使用的算法称为验证算法（Verification Algorithm），执行验证的实体称为验证者。数字签名离不开非对称密码体制，签名算法受私钥控制，且由签名者保密；验证算法受公钥控制，且对外公开。]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列函数]]></title>
    <url>%2F2020%2F04%2F26%2F%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[散列函数，又称哈希函数、信息摘要函数、单向函数或杂凑函数。散列函数的主要作用不是完成数据加密与解密的工作，它是用来验证数据完整性的重要技术。通过散列函数，可以为数据创建“数字指纹”（散列值）。散列值通常是一个短的随机字母和数字组成的字符串。 在上述认证流程中，信息收发双方在通信前已经商定了具体的散列算法，并且该算法是公开的。如果消息在传递过程中被篡改，则该消息不能与已获得的数字指纹相匹配。]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非对称密码体制]]></title>
    <url>%2F2020%2F04%2F25%2F%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%2F</url>
    <content type="text"><![CDATA[非对称密码体制的加密密钥和解密密钥不相同，分为两个密钥，一个公开，一个保密。公开的密钥称为公钥，保密的密钥称为私钥。非对称密码体制使得发送者和接收者之间以无密钥传输的方法进行保密通信成为了可能，弥补了对称密码体制的缺陷。 在非对称密码体制中，公钥和私钥均可用于加密与解密操作，但它与对称密码体制有极大的不同。公钥与私钥分属通信双方，一份消息的加密与解密需要公钥与私钥共同参与。公钥加密需要私钥解密，反之，私钥加密需要公钥解密。]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对称密码体制]]></title>
    <url>%2F2020%2F04%2F24%2F%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%2F</url>
    <content type="text"><![CDATA[对称密码体制要求加密与解密使用同一个共享密钥，解密是加密的逆运算，由于通信双方共享同一个密钥，这就要求通信双方必须在通信前商定该密钥，并妥善保存该密钥。该密钥称为秘密密钥。秘密密钥的存在使得对称密码体制开放性变差。 对称密码体制分为两种：一种是对明文的单个位（或字节）进行加密和解密，称为流密码，又称为序列密码；另一种是把明文信息划分成不同的组（或块）结构，分别对每个组（或块）进行加密和解密，称为分组密码。]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【RabbitMQ实战】虚拟主机]]></title>
    <url>%2F2020%2F03%2F21%2F%E3%80%90RabbitMQ%E5%AE%9E%E6%88%98%E3%80%91%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[每一个RabbitMQ服务器都能创建虚拟消息服务器，称之为虚拟主机（vhost）。]]></content>
      <categories>
        <category>Message Queue</category>
      </categories>
      <tags>
        <tag>Message Queue</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【RabbitMQ实战】AMQP元素——交换器、队列和绑定]]></title>
    <url>%2F2020%2F03%2F11%2F%E3%80%90RabbitMQ%E5%AE%9E%E6%88%98%E3%80%91AMQP%E5%85%83%E7%B4%A0%E2%80%94%E2%80%94%E4%BA%A4%E6%8D%A2%E5%99%A8%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[AMQP消息路由必须有三部分：交换器、队列和绑定。生产者把消息发布到交换器上；消息最终到达队列，并被消费者接收；绑定决定了消息如何从路由器路由到特定的队列。 从底部开始构造：队列消费者通过以下两种方式从特定的队列中接受消息：（1）通过AMQP的basic.consume命令订阅。这样做会将信道置为接收模式，直到取消对队列的订阅为止。订阅了消息后，消费者在消费（或者拒绝）最近接收的那条消息后，就能从队列中（可用的）自动接收下一条消息。如果消费者处理队列消息，并且/或者需要在消息一到达队列时就自动接收的话，应该使用basic.consume。（2）某些时候，只想从队列获得单条消息而不是持续订阅。向队列请求单条消息是通过AMQP的basic.get命令实现的。这样做可以让消费者接收队列中的下一条消息。如果要获得更多消息的话，需要再次发送basic.get命令。不应该将basic.get放在一个循环里来代替basic.consume。因为这样做会影响Rabbit的性能。大致上讲，basic.get命令会订阅消息，获得单条消息，然后取消订阅。消费者理应始终使用basic.consume来实现高吞吐量。 如果至少有一个消费者订阅了队列的话，消息会立即发送给这些订阅的消费者。但是如果消息到达了无人订阅的队列呢？在这种情况下，消息会在队列中等待。一旦有消费者订阅到该队列，那么队列上的消息就会发送给消费者。 当Rabbit队列拥有多个消费者时，队列收到的消息将以循环（round-robin）的方式发送给消费者。每条消息只会发送给一个订阅的消费者。 消费者接收到的每一条消息都必须进行确认。消费者必须通过AMQP的basic.ack命令显示地向RabbitMQ发送一个确认，或者在订阅到队列的时候就将auto_ack参数设置为true。当设置了auto_ack时，一旦消费者接收消息，RabbitMQ会自动视其确认了消息。需要记住的是，消费者对消息的确认和告诉生产者消息已经被接收了这两件事毫不相关。因此，消费者通过确认命令告诉RabbitMQ它已经正确地接收了消息，同时RabbitMQ才能安全地把消息从队列中删除。 如果消费者收到一条消息，然后确认之前从Rabbit断开连接（或者从队列上取消订阅），RabbitMQ会认为这条消息没有分发，然后重新分发给下一个订阅的消费者。如果应用程序崩溃了，这样做可以确保消息会被发送给另一个消费者进行处理。 另一方面，如果应用程序有bug而忘记确认消息的话，Rabbit将不会给该消费者发送更多消息了。这是因为在上一条消息被确认之前，Rabbit会认为这个消费者并没有准备好接收下一条消息。如果处理消息内容非常耗时，则应用程序可以延迟确认该消息，直到消息处理完成。这样可以防止Rabbit持续不断的消息涌向应用程序而导致过载。 在收到消息后，如果想要明确拒绝而不是确认收到该消息的话，该如何呢？只要消息尚未确认，则有以下两个选择：（1） 把消费者从RabbitMQ服务器断开连接。这会导致RabbitMQ自动重新把消息入队并发送给另一个消费者。这样做的好处是所有的RabbitMQ版本都支持。缺点是，这样连接/断开连接的方式会额外增加RabbitMQ的负担（如果消费者在处理每条消息时都遇到错误的话，会导致潜在的重大负荷）。（2）如果正使用RabbitMQ 2.0.0或者更新的版本，那就使用AMQP的basic.reject命令。顾名思义：basic.reject允许消费者拒绝RabbitMQ发送的消息。如果把reject命令的requeue参数设置成true的话，RabbitMQ会将消息重新发送给下一个订阅的消费者。如果设置成false的话，RabbitMQ立即会把消息从队列中移除，而不会把它发送给新的消费者。也可以通过对消息确认的方式来简单地忽略该消息（这种忽略消息的方式的优势在于所有版本的RabbitMQ都支持）。如果检测到一条格式错误的消息而任何一个消费者都无法处理的时候，这样做就十分有用。 在将来的RabbitMQ版本中会支持一个特殊的“死信”（dead letter）队列，用来存放那些被拒绝而不重入队列的消息。死信队列让通过检测拒绝/未送达的消息来发现问题。如果应用程序想自动从死信队列功能中获益的话，需要使用reject命令并将requeue参数设置成false。 消费者和生产者都能使用AMQP的queue.declare命令来创建队列。但是如果消费者在同一条信道上订阅了另一个队列的话，就无法再声明队列了。必须首先取消订阅，将信道置为“传输”模式。当创建队列时，常常想要指定队列名称。消费者订阅队列时需要队列名称，并在创建绑定时也需要指定队列名称。如果不指定队列名称的话，Rabbit会分配一个随机名称并在queue.declare命令的响应中返回。以下是队列设置中另一些有用的参数： exclusive——如果设置为true的话，队列将变成私有的，此时只有你的应用程序才能够消费队列消息。当想要限制一个队列只有一个消费者的时候很有帮助。 auto-delete——当最后一个消费者取消订阅的时候，队列就会自动移除。如果需要临时队列只为一个消费者服务的话，请结合使用auto-delete和exclusive。当消费者断开连接时，队列就被移除了。 如果尝试声明一个已经存在的队列会发生什么呢？只要声明参数完全匹配现存的队列的话，Rabbit就什么都不做，并成功返回，就好像这个队列已经创建成功一样（如果参数不匹配的话，队列声明尝试会失败）。如果只是想检测队列是否存在，则可以设置queue.declare的passive选项为true。在该设置下，如果队列存在，那么queue.declare命令会成功返回；如果队列不存在的话，queue.declare命令不会创建队列而会返回一个错误。 联合起来：交换器和绑定服务器会根据路由键将消息从交换器路由到队列，但它是如何处理投递到多个队列的情况的呢？协议中定义的不同类型交换器发挥了作用。一共有四种类型：direct、fanout、topic、和headers。每一种类型实现了不同的路由算法。 headers交换器允许匹配AMQP消息的header而非路由键。除此之外，headers交换器和direct交换器完全一致，但性能会差很多。因此它并不太实用，而且几乎再也用不到了。 direct交换器非常简单：如果路由键匹配的话，消息就被投递到对应的队列。 服务器必须实现direct类型交换器，包含一个空白字符串名称的默认交换器。当声明一个队列时，它会自动绑定到默认交换器，并以队列名称作为路由键。这意味着可以使用如下代码发送消息到之前声明的队列去。前提是已经获得了信道实例： 1$channel-&gt;basic_publish($msg, '', 'queue_name'); 第一个参数是想要发送的消息内容；第二个参数是一个空的字符串，指定了默认交换器；而第三个参数就是路由键了。当默认的direct交换器无法满足应用程序的需求时，可以声明自己的交换器。只需发送exchange.declare命令并设置合适的参数就行了。 fanout交换器会将收到的消息广播到绑定的队列上。消息通信模式很简单：当发送一条消息到fanout交换器时，它会把消息投递给所有附加在此交换器上的队列。这允许对单条消息做不同方式的反应。 topic交换器允许实现有趣的消息通信场景，它使得来自不同源头的消息能够到达同一个队列。 1234$channel-&gt;basic_publish($msg, 'logs-exchange', 'error.msg-inbox');$channel-&gt;queue_bind('msg-inbox-logs', 'logs-exchange', '*.msg-inbox');$channel-&gt;queue_bind('all-logs', 'logs-exchange', '#'); 单个”.”把路由键分为了几部分，”*”匹配特定位置的任意文本，”#”匹配所有规则。]]></content>
      <categories>
        <category>Message Queue</category>
      </categories>
      <tags>
        <tag>Message Queue</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【RabbitMQ实战】消息通信概念——消费者、生产者和代理]]></title>
    <url>%2F2020%2F02%2F23%2F%E3%80%90RabbitMQ%E5%AE%9E%E6%88%98%E3%80%91%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5%E2%80%94%E2%80%94%E6%B6%88%E8%B4%B9%E8%80%85%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[生产者（producer）创建消息，然后发布（发送）到代理服务器（RabbitMQ）。 消息包含两部分内容：有效载荷（payload）和标签（label）。有效载荷就是想要传输的数据。它可以是任何内容。标签描述了有效载荷，并且RabbitMQ用它来决定谁将获得消息的拷贝。举例来说，不同于TCP协议的是，当明确指定发送方和接收方时，AMQP只会用标签表述这条消息（一个交换器的名称和可选的主题标记），然后把消息交由Rabbit。Rabbit会根据标签把消息发送给感兴趣的接收方。这种通信方式是一种“发后即忘”（fire-and-forget）的单向方式。 消费者连接到代理服务器上，并订阅到队列（queue）上。每当消息到达特定的消息队列时，RabbitMQ会将其发送给其中一个订阅的/监听的消费者。当消费者接收到消息时，它只得到消息的一部分：有效载荷。在消息路由过程中，消息的标签并没有随有效载荷一同传递。RabbitMQ甚至不会告诉是谁生产/发送了消息。如果需要明确知道是谁生产的AMQP消息的话，就要看生产者是否把发送方信息放入有效载荷中。 整个过程其实很简单：生产者创建消息，消费者接收这些消息。应用程序可以作为生产者，向其他应用程序发送消息。或者作为一个消费者，接收消息。也可以在两者之间进行切换。不过在此之前，它必须先建立一条信道（channel）。 必须首先连接到Rabbit，才能消费或者发布消息。在应用程序和Rabbit代理服务器之间创建一条TCP连接。一旦TCP连接打开（通过了认证），应用程序就可以创建一条AMQP信道。信道是建立在“真实的”TCP连接内的虚拟连接。AMQP命令都是通过信道发送出去的。每条信道都会被指派一个唯一ID（AMQP库会记住ID的）。不论是发布消息、订阅队列或是接收消息，这些动作都是通过信道完成的。 为什么需要信道呢？为什么不直接通过TCP连接发送AMQP命令呢？主要原因在于对操作系统来说建立和销毁TCP会话是非常昂贵的开销。假设应用程序从队列消费消息，并根据服务需求合理调度线程。假设只进行TCP连接，那么每个线程都需要自行连接到Rabbit。也就是说高峰期有每秒成百上千条连接。这不仅造成TCP连接的巨大浪费，而且操作系统每秒也就只能建立这点数量的连接。因此，可能很快就碰到性能瓶颈了。如果为所有线程只使用一条TCP连接以满足性能方面的要求，但又能确保每个线程的私密性，就像拥有独立连接一样的话，那不就非常完美吗？这就是要引入信道概念的原因。线程启动后，会在现成的连接上创建一条信道，也就获得了连接到Rabbit上的私密通信路径，而不会给操作系统的TCP栈造成额外负担。]]></content>
      <categories>
        <category>Message Queue</category>
      </categories>
      <tags>
        <tag>Message Queue</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 994 - Rotting Oranges]]></title>
    <url>%2F2019%2F10%2F07%2FLeetCode-Problem-994-Rotting-Oranges%2F</url>
    <content type="text"><![CDATA[In a given grid, each cell can have one of three values: the value 0 representing an empty cell; the value 1 representing a fresh orange; the value 2 representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1 instead. ExampleNo.1 Input: [[2,1,1],[1,1,0],[0,1,1]] Output: 4 No.2Input: [[2,1,1],[0,1,1],[1,0,1]] Output: -1 Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally. No.3Input: [[0,2]] Output: 0 Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0. Note 1 &lt;= grid.length &lt;= 10 1 &lt;= grid[0].length &lt;= 10 grid[i][j] is only 0, 1, or 2. Code12345678910111213141516171819202122232425262728293031323334353637383940public int orangesRotting(int[][] grid) &#123; int result = 0; int m = grid.length; int n = grid[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int[][] dirs = new int[][] &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; int count = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 2) queue.offer(new int[] &#123;i, j&#125;); else if (grid[i][j] == 1) count++; &#125; &#125; while (!queue.isEmpty() &amp;&amp; count &gt; 0) &#123; int size = queue.size(); result++; for (int i = 0; i &lt; size; i++) &#123; int[] pos = queue.poll(); for (int[] dir : dirs) &#123; int x = pos[0] + dir[0]; int y = pos[1] + dir[1]; if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n || grid[x][y] != 1) continue; queue.offer(new int[] &#123;x, y&#125;); grid[x][y] = 2; count--; &#125; &#125; &#125; return count == 0 ? result : -1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 860 - Lemonade Change]]></title>
    <url>%2F2019%2F10%2F07%2FLeetCode-Problem-860-Lemonade-Change%2F</url>
    <content type="text"><![CDATA[At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer, so that the net transaction is that the customer pays $5. Note that you don’t have any change in hand at first. Return true if and only if you can provide every customer with correct change. ExampleNo.1Input: [5,5,5,10,20] Output: true Explanation:From the first 3 customers, we collect three $5 bills in order.From the fourth customer, we collect a $10 bill and give back a $5.From the fifth customer, we give a $10 bill and a $5 bill.Since all customers got correct change, we output true. No.2Input: [5,5,10] Output: true No.3Input: [10,10] Output: false No.4Input: [5,5,10,10,20] Output: false Explanation:From the first two customers in order, we collect two $5 bills.For the next two customers in order, we collect a $10 bill and give back a $5 bill.For the last customer, we can’t give change of $15 back because we only have two $10 bills.Since not every customer received correct change, the answer is false. Note 0 &lt;= bills.length &lt;= 10000 bills[i] will be either 5, 10, or 20. Code123456789101112131415161718192021222324public boolean lemonadeChange(int[] bills) &#123; int five = 0; int ten = 0; for (int bill : bills) &#123; if (bill == 5) five++; else if (bill == 10) &#123; ten++; five--; &#125; else if (ten &gt; 0) &#123; ten--; five--; &#125; else five -= 3; if (five &lt; 0) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 824 - Goat Latin]]></title>
    <url>%2F2019%2F10%2F07%2FLeetCode-Problem-824-Goat-Latin%2F</url>
    <content type="text"><![CDATA[A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to “Goat Latin” (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows: If a word begins with a vowel (a, e, i, o, or u), append “ma” to the end of the word. For example, the word ‘apple’ becomes ‘applema’. If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add “ma”. For example, the word “goat” becomes “oatgma”. Add one letter ‘a’ to the end of each word per its word index in the sentence, starting with 1. For example, the first word gets “a” added to the end, the second word gets “aa” added to the end and so on. Return the final sentence representing the conversion from S to Goat Latin. ExampleNo.1Input: “I speak Goat Latin” Output: “Imaa peaksmaaa oatGmaaaa atinLmaaaaa” No.2Input: “The quick brown fox jumped over the lazy dog” Output: “heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa” Notes S contains only uppercase, lowercase and spaces. Exactly one space between each word. 1 &lt;= S.length &lt;= 150. Code123456789101112131415161718192021222324252627public String toGoatLatin(String S) &#123; StringBuffer sb = new StringBuffer(); Set&lt;Character&gt; vowel = new HashSet&lt;&gt;(); int idx = 1; for (char ch : "aeiouAEIOU".toCharArray()) vowel.add(ch); for (String str : S.split(" ")) &#123; sb.append(" "); char ch = str.charAt(0); if (vowel.contains(ch)) sb.append(str); else sb.append(str.substring(1)).append(ch); sb.append("ma"); for (int i = 0; i &lt; idx; i++) sb.append("a"); idx++; &#125; return sb.substring(1).toString();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 892 - Surface Area of 3D Shapes]]></title>
    <url>%2F2019%2F10%2F07%2FLeetCode-Problem-892-Surface-Area-of-3D-Shapes%2F</url>
    <content type="text"><![CDATA[On a N * N grid, we place some 1 * 1 * 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Return the total surface area of the resulting shapes. ExampleNo.1Input: [[2]] Output: 10 No.2Input: [[1,2],[3,4]] Output: 34 No.3Input: [[1,0],[0,2]] Output: 16 No.4Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 32 No.5Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 46 Note 1 &lt;= N &lt;= 50 0 &lt;= grid[i][j] &lt;= 50 Code1234567891011121314151617181920public int surfaceArea(int[][] grid) &#123; int result = 0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid.length; j++) &#123; if (grid[i][j] == 0) continue; result += 4 * grid[i][j] + 2; if (j &gt; 0 &amp;&amp; grid[i][j - 1] &gt; 0) result -= Math.min(grid[i][j], grid[i][j - 1]) * 2; if (i &gt; 0 &amp;&amp; grid[i - 1][j] &gt; 0) result -= Math.min(grid[i][j], grid[i - 1][j]) * 2; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 976 - Largest Perimeter Triangle]]></title>
    <url>%2F2019%2F10%2F07%2FLeetCode-Problem-976-Largest-Perimeter-Triangle%2F</url>
    <content type="text"><![CDATA[Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths. If it is impossible to form any triangle of non-zero area, return 0. ExampleNo.1Input: [2,1,2] Output: 5 No.2Input: [1,2,1] Output: 0 No.3Input: [3,2,3,4] Output: 10 No.4Input: [3,6,2,3] Output: 8 Note 3 &lt;= A.length &lt;= 10000 1 &lt;= A[i] &lt;= 10^6 Code12345678910public int largestPerimeter(int[] A) &#123; Arrays.sort(A); for (int i = A.length - 1; i &gt;= 2; i--) &#123; if (A[i - 2] + A[i - 1] &gt; A[i]) return A[i - 2] + A[i - 1] + A[i]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 812 - Largest Triangle Area]]></title>
    <url>%2F2019%2F10%2F06%2FLeetCode-Problem-812-Largest-Triangle-Area%2F</url>
    <content type="text"><![CDATA[You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points. ExampleInput: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] Output: 2 Explanation:The five points are show in the figure below. The red triangle is the largest. Notes 3 &lt;= points.length &lt;= 50. No points will be duplicated. -50 &lt;= points[i][j] &lt;= 50. Answers within 10^-6 of the true value will be accepted as correct. Code123456789101112131415161718public double largestTriangleArea(int[][] points) &#123; double max = 0; for (int i = 0; i &lt; points.length; i++) &#123; for (int j = i + 1; j &lt; points.length; j++) &#123; for (int k = j + 1; k &lt; points.length; k++) max = Math.max(max, getArea(points[i], points[j], points[k])); &#125; &#125; return max;&#125;private double getArea(int[] p1, int[] p2, int[] p3) &#123; return Math.abs(p1[0] * p2[1] - p1[1] * p2[0] + p2[0] * p3[1] - p2[1] * p3[0] + p3[0] * p1[1] - p3[1] * p1[0]) / 2.0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 1127 - Add Bold Tag in String]]></title>
    <url>%2F2019%2F10%2F05%2FLintCode-Problem-1127-Add-Bold-Tag-in-String%2F</url>
    <content type="text"><![CDATA[Given a string s and a list of strings dict, you need to add a closed pair of bold tag and to wrap the substrings in s that exist in dict. If two such substrings overlap, you need to wrap them together by only one pair of closed bold tag. Also, if two substrings wrapped by bold tags are consecutive, you need to combine them. NoteThe given dict won’t contain duplicates, and its length won’t exceed 100.All the strings in input have length in range [1, 1000]. ExampleNo.1Input:s = “abcxyz123”dict = [“abc”,”123”] Output:“&lt;b&gt;abc&lt;/b&gt;xyz&lt;b&gt;123&lt;/b&gt;“ No.2Input:s = “aaabbcc”dict = [“aaa”,”aab”,”bc”] Output:“&lt;b&gt;aaabbc&lt;/b&gt;c” Code123456789101112131415161718192021222324252627282930313233public String addBoldTag(String s, String[] dict) &#123; StringBuilder sb = new StringBuilder(); int n = s.length(); int[] array = new int[n + 1]; int sum = 0; int preSum = 0; for (String word : dict) &#123; int idx = 0; while ((idx = s.indexOf(word, idx)) &gt;= 0) &#123; array[idx]++; array[idx + word.length()]--; idx++; &#125; &#125; for (int i = 0; i &lt;= n; i++) &#123; sum += array[i]; if (sum &gt; 0 &amp;&amp; preSum == 0) sb.append("&lt;b&gt;"); else if (sum == 0 &amp;&amp; preSum &gt; 0) sb.append("&lt;/b&gt;"); if (i &lt; n) sb.append(s.charAt(i)); preSum = sum; &#125; return sb.toString();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 812 - Bold Words in String]]></title>
    <url>%2F2019%2F10%2F05%2FLintCode-Problem-812-Bold-Words-in-String%2F</url>
    <content type="text"><![CDATA[Given a set of keywords words and a string S, make all appearances of all keywords in S bold. Any letters between &lt;b&gt; and &lt;/b&gt; tags become bold.The returned string should use the least number of tags possible, and of course the tags should form a valid combination. Note words has length in range [0, 50]. words[i] has length in range [1, 10]. S has length in range [0, 500]. All characters in words[i] and S are lowercase letters. ExampleNo.1Input:[“ab”, “bc”]“aabcd” Output:“a&lt;b&gt;abc&lt;/b&gt;d” Explanation:Note that returning “a&lt;b&gt;a&lt;b&gt;b&lt;/b&gt;c&lt;/b&gt;d” would use more tags, so it is incorrect. No.2Input:[“bcccaeb”,”b”,”eedcbda”,”aeebebebd”,”ccd”,”eabbbdcde”,”deaaea”,”aea”,”accebbb”,”d”]“ceaaabbbedabbecbcced” Output:“ceaaa&lt;b&gt;bbb&lt;/b&gt;e&lt;b&gt;d&lt;/b&gt;a&lt;b&gt;bb&lt;/b&gt;ec&lt;b&gt;b&lt;/b&gt;cce&lt;b&gt;d&lt;/b&gt;“ Code123456789101112131415161718192021222324252627282930313233public String boldWords(String[] words, String S) &#123; StringBuilder sb = new StringBuilder(); int n = S.length(); int[] array = new int[n + 1]; int sum = 0; int preSum = 0; for (String word : words) &#123; int idx = 0; while ((idx = S.indexOf(word, idx)) &gt;= 0) &#123; array[idx]++; array[idx + word.length()]--; idx++; &#125; &#125; for (int i = 0; i &lt;= n; i++) &#123; sum += array[i]; if (sum &gt; 0 &amp;&amp; preSum == 0) sb.append("&lt;b&gt;"); else if (sum == 0 &amp;&amp; preSum &gt; 0) sb.append("&lt;/b&gt;"); if (i &lt; n) sb.append(S.charAt(i)); preSum = sum; &#125; return sb.toString();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 754 - Reach a Number]]></title>
    <url>%2F2019%2F10%2F04%2FLeetCode-Problem-754-Reach-a-Number%2F</url>
    <content type="text"><![CDATA[You are standing at position 0 on an infinite number line. There is a goal at position target. On each move, you can either go left or right. During the n-th move (starting from 1), you take n steps. Return the minimum number of steps required to reach the destination. ExampleNo.1Input: target = 3 Output: 2 Explanation:On the first move we step from 0 to 1.On the second step we step from 1 to 3. No.2Input: target = 2 Output: 3 Explanation:On the first move we step from 0 to 1.On the second move we step from 1 to -1.On the third move we step from -1 to 2. Note target will be a non-zero integer in the range [-10^9, 10^9]. Code 123456789101112131415public int reachNumber(int target) &#123; target = Math.abs(target); int sum = 0; int k = 0; while (sum &lt; target) &#123; k++; sum += k; &#125; if ((sum - target) % 2 == 0) return k; else return k + 1 + (k % 2);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 762 - Prime Number of Set Bits in Binary Representation]]></title>
    <url>%2F2019%2F10%2F04%2FLeetCode-Problem-762-Prime-Number-of-Set-Bits-in-Binary-Representation%2F</url>
    <content type="text"><![CDATA[Given two integers L and R, find the count of numbers in the range [L, R] (inclusive) having a prime number of set bits in their binary representation. (Recall that the number of set bits an integer has is the number of 1s present when written in binary. For example, 21 written in binary is 10101 which has 3 set bits. Also, 1 is not a prime.) ExampleNo.1Input: L = 6, R = 10 Output: 4 Explanation:6 -&gt; 110 (2 set bits, 2 is prime)7 -&gt; 111 (3 set bits, 3 is prime)9 -&gt; 1001 (2 set bits , 2 is prime)10-&gt;1010 (2 set bits , 2 is prime) No.2Input: L = 10, R = 15 Output: 5 Explanation:10 -&gt; 1010 (2 set bits, 2 is prime)11 -&gt; 1011 (3 set bits, 3 is prime)12 -&gt; 1100 (2 set bits, 2 is prime)13 -&gt; 1101 (3 set bits, 3 is prime)14 -&gt; 1110 (3 set bits, 3 is prime)15 -&gt; 1111 (4 set bits, 4 is not prime) Note L, R will be integers L &lt;= R in the range [1, 10^6]. R - L will be at most 10000. Code1234567891011121314151617public int countPrimeSetBits(int L, int R) &#123; int result = 0; for (int i = L; i &lt;= R; i++) &#123; int count = Integer.bitCount(i); if (isPrime(count)) result++; &#125; return result;&#125;private boolean isPrime(int n) &#123; int prime = 665772; // 2, 3, 5, 7, 11, 13, 17, 19 return (prime &amp; (1 &lt;&lt; n)) != 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 747 - Largest Number At Least Twice of Others]]></title>
    <url>%2F2019%2F10%2F04%2FLeetCode-Problem-747-Largest-Number-At-Least-Twice-of-Others%2F</url>
    <content type="text"><![CDATA[In a given integer array nums, there is always exactly one largest element. Find whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, otherwise return -1. ExampleNo.1Input: nums = [3, 6, 1, 0] Output: 1 Explanation: 6 is the largest integer, and for every other number in the array x,6 is more than twice as big as x. The index of value 6 is 1, so we return 1. No.2Input: nums = [1, 2, 3, 4] Output: -1 Explanation: 4 isn’t at least as big as twice the value of 3, so we return -1. Note nums will have a length in the range [1, 50]. Every nums[i] will be an integer in the range [0, 99]. Code1234567891011121314151617public int dominantIndex(int[] nums) &#123; int result = 0; int max1 = Integer.MIN_VALUE; int max2 = Integer.MIN_VALUE; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt;= max1) &#123; max2 = max1; max1 = nums[i]; result = i; &#125; else if (nums[i] &gt; max2) max2 = nums[i]; &#125; return max1 &gt;= 2 * max2 ? result : -1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 746 - Min Cost Climbing Stairs]]></title>
    <url>%2F2019%2F10%2F04%2FLeetCode-Problem-746-Min-Cost-Climbing-Stairs%2F</url>
    <content type="text"><![CDATA[On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. ExampleNo.1Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top. No.2Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3]. Note cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999]. Code1234567891011121314// dp[i] = min&#123;dp[i - 2], dp[i - 1]&#125; + cost[i]public int minCostClimbingStairs(int[] cost) &#123; int result = Integer.MAX_VALUE; int a = 0; int b = 0; for (int i = 0; i &lt; cost.length; i++) &#123; result = Math.min(a, b) + cost[i]; a = b; b = result; &#125; return Math.min(a, b);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 724 - Find Pivot Index]]></title>
    <url>%2F2019%2F10%2F03%2FLeetCode-Problem-724-Find-Pivot-Index%2F</url>
    <content type="text"><![CDATA[Given an array of integers nums, write a method that returns the “pivot” index of this array. We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index. ExampleNo.1Input:nums = [1, 7, 3, 6, 5, 6] Output: 3 Explanation:The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.Also, 3 is the first index where this occurs. No.2Input:nums = [1, 2, 3] Output: -1 Explanation:There is no index that satisfies the conditions in the problem statement. Note The length of nums will be in the range [0, 10000]. Each element nums[i] will be an integer in the range [-1000, 1000]. Code12345678910111213141516public int pivotIndex(int[] nums) &#123; int sum = 0; int currentSum = 0; for (int num : nums) sum += num; for (int i = 0; i &lt; nums.length; i++) &#123; if (sum - nums[i] == 2 * currentSum) return i; currentSum += nums[i]; &#125; return -1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The English We Speak 5]]></title>
    <url>%2F2019%2F10%2F03%2FThe-English-We-Speak-5%2F</url>
    <content type="text"><![CDATA[A leopard can’t change its spotshe won’t change. He will always be the same person and his bad habits are here to stay. ExamplesI told Karen she had to study more if she wants to pass her exams but a leopard can’t change its spots – she won’t do it. Freddie promised he wouldn’t get into trouble at school but I don’t believe him – a leopard can’t change its spots. Full of the joys of springsomeone is happy. ExamplesEmily’s full of the joys of spring today – her boyfriend has just asked her to marry him! Raj seems full of the joys of spring today – he must have some good news about his exam results. I’m full of the joys of spring today – I’ve just won £1,000 in the lottery – now, what shall I spend it on? You’ve sold it to me‘you’ve convinced me’. ExamplesA: I lost five pounds after just a week on this new diet. It’s definitely worth a try.B: You’ve sold it to me. I need to get in shape for my school reunion. A: Your phone looks amazing.B: It’s brilliant, does everything, fab photos and great apps. AND it only cost me 10 pounds.A: 10 pounds. You’ve sold it to me. Where can I get one today? Crash courseWhen you are on a crash course, you learn about something in a very short period of time. ExamplesPeter applied to train as a teacher, but he had to complete a compulsory crash course in maths first. Alison did a crash course in French before her trip to Paris. I booked Nathan on a video editing crash course, so we’ve got at least one person who can operate the camera. Julie took a crash course in cooking to prepare for her wedding. A recipe for disastera combination of things that will, at some point, go wrong and cause harm, damage or humiliation – in other words it will end in trouble. ExamplesMy doctor says drinking too much, not exercising enough, and having a stressful job are a recipe for disaster. He says I might die young! I’m not looking forward to the party. Having my wife and ex-girlfriend in the same room will be a recipe for disaster! Watch out on the road tonight – all that rain followed by freezing temperatures is a recipe for disaster. Going forward‘in the future’.used at business meetings when a person wants someone to change the way they do something in the future. ExamplesA: Did you get the files I emailed over?B: Yes I did, but going forward can you send hard copies in the post? We need them for our records. Boss: I’ve noticed you chatting on your mobile quite a lot during the working day. Going forward, can you keep the private conversations to your lunch breaks? A: Going forward we will only have an online version of our newspaper. The days of print are dead. To turn something upside downmake the place really messy because you’re trying to search thoroughly for something. ExamplesI turned my house upside down and I still couldn’t find my car keys. I don’t care if you have to turn the place upside down. You’ve got to find my wedding ring. Burn a hole in your pocketWhenever he has money he has to spend it.‘it’s burnt a hole in your pocket’: something unexpected costs a lot of money ExamplesA: Why have you never got any money?B: Well, I have a bad habit of spending my money as soon as I get it. Money burns a hole in my pocket. A: I find saving money so difficult. I like to buy the latest gadgets.B: The trouble with you is that money burns a hole in your pocket. A: My daughter is getting married next year.B: Oh that’s fantastic news.A: Yes, it is. But I think the cost of the wedding will burn a hole in my pocket. Pain in the necksomething or someone is annoying, actually very annoying for a long time. ExamplesSam is so disruptive in the class, he’s a pain in the neck to deal with. Completing this tax form is a real pain in the neck, there are so many boxes to fill in. The telesales people are a real pain in the neck, they keep ringing me. To fall at the first hurdleto fail near the beginning of something. ExamplesPlans to construct a new motorway will fall at the first hurdle if they can’t buy the farmland to build it on. His dream of marrying Julie fell at the first hurdle when he discovered she was already married. One good turn deserves anotherdo someone a favour and they should return the favour. ExamplesA: Do you mind doing the washing up? I did do all the cooking and one good turn does deserve another!B: Oh, OK then. Please can you help me with my homework, I did yours last week and you know what they say: one good turn deserves another! He helped me fix my car, so I was happy to let him borrow it if he needed to – one good turn deserves another. You’re pulling my leg!to fool or trick them but in a fun way. ExamplesA: So I got to the restaurant and sat down at my table and guess who was sitting on the next table – George Clooney!B: You’re pulling my leg! I was pulling his leg when I said I was going to marry Jenny but he believed me and bought me a present! Oh stop pulling my leg – you can’t have won the lottery, you didn’t even buy a ticket! Clean up your actto improve your behaviour or your performance. ExamplesI used to drink a lot of alcohol but when I got ill, I decided to clean up my act and now I only drink cola! He turned up late for work every day looking a real mess, so they told him to clean up his act or face losing his job. Until you’re blue in the facetelling someone something is a waste of time because nothing will happen or change. ExamplesI’ve told him to get here on time until I’m blue in the face but still he continues to arrive late. He told her not to break the speed limit on the motorway until he was blue in the face but she still did it and guess what? She got a speeding ticket! It’s on the cardssomething is likely to happen. ExamplesWage rises are on the cards in the UK. There are now signs that things are getting better for ordinary British workers. My son might be ready to settle down. He’s had lots of girlfriends but now he’s going steady with a colleague and a wedding might be on the cards. Drama queenhe or she becomes very angry or upset over tiny small things. ExamplesA: Oh, it’s raining and my new hairdo is ruined! All those hours in the hairdresser for nothing!B: Don’t be such a drama queen. Here, take my umbrella. I’m not dining out with Peter anymore. If the dish is not cooked exactly the way he likes he makes a big fuss. He’s such a drama queen! White-collar worker / blue-collar workerA blue-collar worker is an expression to describe someone who does manual work. Someone who works in a factory, for example, who wears a uniform.People who worked in offices, doing administration or managerial tasks - clerks for example - were referred to as white-collar workers. ExamplesWhen the company went bankrupt many white-collar workers found themselves looking for blue-collar jobs. Some popular folk songs reflect the aspirations and struggles of blue-collar workers. The university of lifethey are wise but not necessarily educated – they’ve learnt everything just from experiencing life. ExamplesI set up the business without any qualifications – everything I learnt was from the university of life. The university of life taught me to be polite to everyone you meet; you never know when you might see them again. 19!!!!]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 524 - Longest Word in Dictionary through Deleting]]></title>
    <url>%2F2019%2F10%2F03%2FLeetCode-Problem-524-Longest-Word-in-Dictionary-through-Deleting%2F</url>
    <content type="text"><![CDATA[Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string. ExampleNo.1Input:s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”] Output:“apple” No.2Input:s = “abpcplea”, d = [“a”,”b”,”c”] Output:“a” Note All the strings in the input will only contain lower-case letters. The size of the dictionary won’t exceed 1,000. The length of all the strings in the input won’t exceed 1,000. Code12345678910111213141516171819202122232425262728public String findLongestWord(String s, List&lt;String&gt; d) &#123; String result = ""; char[] array = s.toCharArray(); for (String word : d) &#123; if (word.length() &lt; result.length() || (word.length() == result.length() &amp;&amp; word.compareTo(result) &gt; 0)) continue; if (isValid(array, word.toCharArray())) result = word; &#125; return result;&#125;private boolean isValid(char[] s, char[] w) &#123; int i = 0; int j = 0; while (i &lt; s.length &amp;&amp; j &lt; w.length) &#123; if (s[i] == w[j]) j++; i++; &#125; return j == w.length;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 720 - Longest Word in Dictionary]]></title>
    <url>%2F2019%2F10%2F03%2FLeetCode-Problem-720-Longest-Word-in-Dictionary%2F</url>
    <content type="text"><![CDATA[Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words. If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string. ExampleNo.1Input:words = [“w”,”wo”,”wor”,”worl”, “world”] Output: “world” Explanation:The word “world” can be built one character at a time by “w”, “wo”, “wor”, and “worl”. No.2Input:words = [“a”, “banana”, “app”, “appl”, “ap”, “apply”, “apple”] Output: “apple” Explanation:Both “apply” and “apple” can be built from other words in the dictionary. However, “apple” is lexicographically smaller than “apply”. Note All the strings in the input will only contain lowercase letters. The length of words will be in the range [1, 1000]. The length of words[i] will be in the range [1, 30]. Code123456789101112131415161718192021222324252627282930public String longestWord(String[] words) &#123; String result = ""; Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (String word : words) set.add(word); for (String word : words) &#123; if (word.length() &lt; result.length() || (word.length() == result.length() &amp;&amp; word.compareTo(result) &gt; 0)) continue; StringBuilder sb = new StringBuilder(); boolean valid = true; for (int i = 0; i &lt; word.length() - 1; i++) &#123; sb.append(word.charAt(i)); if (!set.contains(sb.toString())) &#123; valid = false; break; &#125; &#125; if (valid) result = word; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 748 - Shortest Completing Word]]></title>
    <url>%2F2019%2F10%2F02%2FLeetCode-Problem-748-Shortest-Completing-Word%2F</url>
    <content type="text"><![CDATA[Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate. Such a word is said to complete the given string licensePlate Here, for letters we ignore case. For example, “P” on the licensePlate still matches “p” on the word. It is guaranteed an answer exists. If there are multiple answers, return the one that occurs first in the array. The license plate might have the same letter occurring multiple times. For example, given a licensePlate of “PP”, the word “pair” does not complete the licensePlate, but the word “supper” does. ExampleNo.1Input: licensePlate = “1s3 PSt”, words = [“step”, “steps”, “stripe”, “stepple”] Output: “steps” Explanation: The smallest length word that contains the letters “S”, “P”, “S”, and “T”.Note that the answer is not “step”, because the letter “s” must occur in the word twice.Also note that we ignored case for the purposes of comparing whether a letter exists in the word. No.2Input: licensePlate = “1s3 456”, words = [“looks”, “pest”, “stew”, “show”] Output: “pest” Explanation: There are 3 smallest length words that contains the letters “s”.We return the one that occurred first. Note licensePlate will be a string with length in range [1, 7]. licensePlate will contain digits, spaces, or letters (uppercase or lowercase). words will have a length in the range [10, 1000]. Every words[i] will consist of lowercase letters, and have length in range [1, 15]. Code1234567891011121314151617181920212223242526272829303132public String shortestCompletingWord(String licensePlate, String[] words) &#123; String result = null; int[] array = new int[26]; int count = 0; for (char ch : licensePlate.toCharArray()) &#123; if (Character.isLetter(ch)) &#123; array[Character.toLowerCase(ch) - 'a']++; count++; &#125; &#125; for (String word : words) &#123; if (result == null || word.length() &lt; result.length()) &#123; if (isCompleting(array.clone(), count, word)) result = word; &#125; &#125; return result;&#125;private boolean isCompleting(int[] array, int count, String word) &#123; for (char ch : word.toCharArray()) &#123; if (array[ch - 'a'] &gt; 0) &#123; array[ch - 'a']--; count--; &#125; &#125; return count == 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 796 - Rotate String]]></title>
    <url>%2F2019%2F09%2F29%2FLeetCode-Problem-796-Rotate-String%2F</url>
    <content type="text"><![CDATA[We are given two strings, A and B. A shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = ‘abcde’, then it will be ‘bcdea’ after one shift on A. Return True if and only if A can become B after some number of shifts on A. ExampleNo.1Input: A = ‘abcde’, B = ‘cdeab’ Output: true No.2Input: A = ‘abcde’, B = ‘abced’ Output: false Note A and B will have length at most 100. Code123456public boolean rotateString(String A, String B) &#123; if (A.length() != B.length()) return false; return (A + A).indexOf(B) &gt;= 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 788 - Rotated Digits]]></title>
    <url>%2F2019%2F09%2F29%2FLeetCode-Problem-788-Rotated-Digits%2F</url>
    <content type="text"><![CDATA[X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X. Each digit must be rotated - we cannot choose to leave it alone. A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid. Now given a positive number N, how many numbers X from 1 to N are good? ExampleInput: 10 Output: 4 Explanation:There are four good numbers in the range [1, 10] : 2, 5, 6, 9.Note that 1 and 10 are not good numbers, since they remain unchanged after rotating. Note N will be in range [1, 10000]. Code123456789101112131415161718192021222324252627282930private int INVALID = (1 &lt;&lt; 3) | (1 &lt;&lt; 4) | (1 &lt;&lt; 7);private int VALID = (1 &lt;&lt; 2) | (1 &lt;&lt; 5) | (1 &lt;&lt; 6) | (1 &lt;&lt; 9);public int rotatedDigits(int N) &#123; int result = 0; for (int i = 1; i &lt;= N; i++) &#123; if (isValid(i)) result++; &#125; return result;&#125;private boolean isValid(int n) &#123; boolean result = false; while (n &gt; 0) &#123; int bit = 1 &lt;&lt; (n % 10); if ((bit &amp; INVALID) != 0) return false; else if ((bit &amp; VALID) != 0) result = true; n /= 10; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 697 - Degree of an Array]]></title>
    <url>%2F2019%2F09%2F29%2FLeetCode-Problem-697-Degree-of-an-Array%2F</url>
    <content type="text"><![CDATA[Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums. ExampleNo.1Input: [1, 2, 2, 3, 1] Output: 2 Explanation:The input array has a degree of 2 because both elements 1 and 2 appear twice.Of the subarrays that have the same degree:[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]The shortest length is 2. So return 2. No.2Input: [1,2,2,3,1,4,2] Output: 6 Note nums.length will be between 1 and 50,000. nums[i] will be an integer between 0 and 49,999. Code1234567891011121314151617181920public int findShortestSubArray(int[] nums) &#123; int result = Integer.MAX_VALUE; int degree = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); Map&lt;Integer, Integer&gt; index = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], map.getOrDefault(nums[i], 0) + 1); index.putIfAbsent(nums[i], i); int d = map.get(nums[i]); if (d &gt; degree) &#123; degree = d; result = i - index.get(nums[i]) + 1; &#125; else if (d == degree) result = Math.min(result, i - index.get(nums[i]) + 1); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 693 - Binary Number with Alternating Bits]]></title>
    <url>%2F2019%2F09%2F29%2FLeetCode-Problem-693-Binary-Number-with-Alternating-Bits%2F</url>
    <content type="text"><![CDATA[Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. ExampleNo.1Input: 5 Output: True Explanation:The binary representation of 5 is: 101 No.2Input: 7 Output: False Explanation:The binary representation of 7 is: 111. No.3Input: 11 Output: False Explanation:The binary representation of 11 is: 1011. No.4Input: 10 Output: True Explanation:The binary representation of 10 is: 1010. Code123456789101112public boolean hasAlternatingBits(int n) &#123; int bit = n &amp; 1; while ((n &gt;&gt;= 1) &gt; 0) &#123; if ((n &amp; 1) == bit) return false; bit = n &amp; 1; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 665 - Non-decreasing Array]]></title>
    <url>%2F2019%2F09%2F29%2FLeetCode-Problem-665-Non-decreasing-Array%2F</url>
    <content type="text"><![CDATA[Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element. We define an array is non-decreasing if array[i] &lt;= array[i + 1] holds for every i (1 &lt;= i &lt; n). ExampleNo.1Input: [4,2,3] Output: True Explanation: You could modify the first 4 to 1 to get a non-decreasing array. No.2Input: [4,2,1] Output: False Explanation: You can’t get a non-decreasing array by modify at most one element. NoteThe n belongs to [1, 10,000]. Code1234567891011121314151617public boolean checkPossibility(int[] nums) &#123; int count = 1; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &lt; nums[i - 1]) &#123; if (i &gt;= 2 &amp;&amp; nums[i] &lt; nums[i - 2]) nums[i] = nums[i - 1]; else nums[i - 1] = nums[i]; if (--count &lt; 0) return false; &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 859 - Max Stack]]></title>
    <url>%2F2019%2F09%2F28%2FLintCode-Problem-859-Max-Stack%2F</url>
    <content type="text"><![CDATA[Design a max stack that supports push, pop, top, peekMax and popMax. push(x) – Push element x onto stack. pop() – Remove the element on top of the stack and return it. top() – Get the element on the top. peekMax() – Retrieve the maximum element in the stack. popMax() – Retrieve the maximum element in the stack, and remove it. If you find more than one maximum elements, only remove the top-most one. Note -1e7 &lt;= x &lt;= 1e7 Number of operations won’t exceed 10000. The last four operations won’t be called when stack is empty. ExampleInput:push(5)push(1)push(5)top()popMax()top()peekMax()pop()top() Output:551515 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MaxStack &#123; private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; max; public MaxStack() &#123; stack = new Stack&lt;&gt;(); max = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; stack.push(x); if (max.isEmpty() || max.peek() &lt;= x) max.push(x); &#125; public int pop() &#123; int x = stack.pop(); if (max.peek() == x) max.pop(); return x; &#125; public int top() &#123; return stack.peek(); &#125; public int peekMax() &#123; return max.peek(); &#125; public int popMax() &#123; int x = max.pop(); Stack&lt;Integer&gt; temp = new Stack&lt;&gt;(); while (stack.peek() != x) temp.push(stack.pop()); stack.pop(); while (!temp.isEmpty()) stack.push(temp.pop()); return x; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 686 - Repeated String Match]]></title>
    <url>%2F2019%2F09%2F27%2FLeetCode-Problem-686-Repeated-String-Match%2F</url>
    <content type="text"><![CDATA[Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1. For example, with A = “abcd” and B = “cdabcdab”. Return 3, because by repeating A three times (“abcdabcdabcd”), B is a substring of it; and B is not a substring of A repeated two times (“abcdabcd”). NoteThe length of A and B will be between 1 and 10000. Code1234567891011121314public int repeatedStringMatch(String A, String B) &#123; int count = 0; StringBuilder sb = new StringBuilder(); while (sb.length() &lt; B.length()) &#123; sb.append(A); count++; &#125; if (sb.indexOf(B) &gt;= 0) return count; return sb.append(A).indexOf(B) &gt;= 0 ? count + 1 : -1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 661 - Image Smoother]]></title>
    <url>%2F2019%2F09%2F27%2FLeetCode-Problem-661-Image-Smoother%2F</url>
    <content type="text"><![CDATA[Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then use as many as you can. ExampleInput: 123[[1,1,1], [1,0,1], [1,1,1]] Output: 123[[0, 0, 0], [0, 0, 0], [0, 0, 0]] Explanation:For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0For the point (1,1): floor(8/9) = floor(0.88888889) = 0 Note The value in the given matrix is in the range of [0, 255]. The length and width of the given matrix are in the range of [1, 150]. Code123456789101112131415161718192021222324252627282930313233private int[][] dirs = &#123;&#123;-1, -1&#125;, &#123;0, -1&#125;, &#123;1, -1&#125;, &#123;-1, 0&#125;, &#123;0, 0&#125;, &#123;1, 0&#125;, &#123;-1, 1&#125;, &#123;0, 1&#125;, &#123;1, 1&#125;&#125;;public int[][] imageSmoother(int[][] M) &#123; int m = M.length; int n = M[0].length; int[][] result = new int[m][n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) result[i][j] = smooth(M, m, n, i, j); &#125; return result;&#125;private int smooth(int[][] M, int m, int n, int i, int j) &#123; int count = 0; int sum = 0; for (int[] dir : dirs) &#123; int x = i + dir[0]; int y = j + dir[1]; if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n) continue; count++; sum += M[x][y]; &#125; return sum / count;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 645 - Set Mismatch]]></title>
    <url>%2F2019%2F09%2F27%2FLeetCode-Problem-645-Set-Mismatch%2F</url>
    <content type="text"><![CDATA[The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number. Given an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array. ExampleInput: nums = [1,2,2,4] Output: [2,3] Note The given array size will in the range [2, 10000]. The given array’s numbers won’t have any order. Code123456789101112131415161718192021public int[] findErrorNums(int[] nums) &#123; int[] result = new int[2]; for (int i = 0; i &lt; nums.length; i++) &#123; int idx = Math.abs(nums[i]) - 1; if (nums[idx] &lt; 0) result[0] = idx + 1; else nums[idx] *= -1; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt; 0) &#123; result[1] = i + 1; break; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 671 - Second Minimum Node In a Binary Tree]]></title>
    <url>%2F2019%2F09%2F23%2FLeetCode-Problem-671-Second-Minimum-Node-In-a-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds. Given such a binary tree, you need to output the second minimum value in the set made of all the nodes’ value in the whole tree. If no such second minimum value exists, output -1 instead. ExampleNo.1Input: 12345 2 / \2 5 / \ 5 7 Output: 5 Explanation: The smallest value is 2, the second smallest value is 5. No.2Input: 123 2 / \2 2 Output: -1 Explanation: The smallest value is 2, but there isn’t any second smallest value. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021public int findSecondMinimumValue(TreeNode root) &#123; return dfs(root, root.val);&#125;private int dfs(TreeNode root, int s) &#123; if (root == null) return -1; if (root.val &gt; s) return root.val; int left = dfs(root.left, s); int right = dfs(root.right, s); if (left == -1) return right; else if (right == -1) return left; else return Math.min(left, right);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 637 - Average of Levels in Binary Tree]]></title>
    <url>%2F2019%2F09%2F23%2FLeetCode-Problem-637-Average-of-Levels-in-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array. ExampleInput: 12345 3 / \9 20 / \ 15 7 Output: [3, 14.5, 11] Explanation:The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11]. Note The range of node’s value is in the range of 32-bit signed integer. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516171819202122232425262728public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123; List&lt;Double&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; int size = queue.size(); long sum = 0; for (int i = 0; i &lt; size; i++) &#123; TreeNode node = queue.poll(); sum += node.val; if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); &#125; result.add(sum * 1.0 / size); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 633 - Sum of Square Numbers]]></title>
    <url>%2F2019%2F09%2F23%2FLeetCode-Problem-633-Sum-of-Square-Numbers%2F</url>
    <content type="text"><![CDATA[Given a non-negative integer c, your task is to decide whether there’re two integers a and b such that a^2 + b^2 = c. ExampleNo.1Input: 5 Output: True Explanation: 1 * 1 + 2 * 2 = 5 No.2Input: 3 Output: False Code1234567891011121314151617public boolean judgeSquareSum(int c) &#123; int a = 0; int b = (int) Math.sqrt(c); while (a &lt;= b) &#123; int sum = a * a + b * b; if (sum &lt; c) a++; else if (sum &gt; c) b--; else return true; &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 628 - Maximum Product of Three Numbers]]></title>
    <url>%2F2019%2F09%2F23%2FLeetCode-Problem-628-Maximum-Product-of-Three-Numbers%2F</url>
    <content type="text"><![CDATA[Given an integer array, find three numbers whose product is maximum and output the maximum product. ExampleNo.1Input: [1,2,3] Output: 6 No.2Input: [1,2,3,4] Output: 24 Note The length of the given array will be in range [3,10^4] and all elements are in the range [-1000, 1000]. Multiplication of any three numbers in the input won’t exceed the range of 32-bit signed integer. Code123456789101112131415161718192021222324252627282930public int maximumProduct(int[] nums) &#123; int max1 = Integer.MIN_VALUE; int max2 = Integer.MIN_VALUE; int max3 = Integer.MIN_VALUE; int min1 = Integer.MAX_VALUE; int min2 = Integer.MAX_VALUE; for (int num : nums) &#123; if (num &gt; max1) &#123; max3 = max2; max2 = max1; max1 = num; &#125; else if (num &gt; max2) &#123; max3 = max2; max2 = num; &#125; else if (num &gt; max3) max3 = num; if (num &lt; min1) &#123; min2 = min1; min1 = num; &#125; else if (num &lt; min2) min2 = num; &#125; return Math.max(min1 * min2 * max1, max1 * max2 * max3);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 698 - Maximum Distance in Arrays]]></title>
    <url>%2F2019%2F09%2F23%2FLintCode-Problem-698-Maximum-Distance-in-Arrays%2F</url>
    <content type="text"><![CDATA[Given m arrays, and each array is sorted in ascending order. Now you can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the difference between two integers a and b to be their absolute difference |a-b|. Your task is to find the maximum difference. Note Each given array will have at least 1 number. There will be at least two non-empty arrays. The total number of the integers in all the m arrays will be in the range of [2, 10000]. The integers in the m arrays will be in the range of [-10000, 10000]. ExampleNo.1Input: [[1,2,3], [4,5], [1,2,3]] Output: 4 Explanation:One way to reach the maximum difference 4 is to pick 1 in the first or third array and pick 5 in the second array. No.2Input: [[1,2,3,4,5,6,7,8,9],[0,10]] Output: 9 Code12345678910111213141516public int maxDiff(int[][] arrs) &#123; int result = 0; int min = arrs[0][0]; int max = arrs[0][arrs[0].length - 1]; for (int i = 1; i &lt; arrs.length; i++) &#123; int start = arrs[i][0]; int end = arrs[i][arrs[i].length - 1]; result = Math.max(result, Math.max(Math.abs(start - max), Math.abs(end - min))); min = Math.min(min, start); max = Math.max(max, end); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 880 - Construct Binary Tree from String]]></title>
    <url>%2F2019%2F09%2F23%2FLintCode-Problem-880-Construct-Binary-Tree-from-String%2F</url>
    <content type="text"><![CDATA[You need to construct a binary tree from a string consisting of parenthesis and integers. The whole input represents a binary tree. It contains an integer followed by zero, one or two pairs of parenthesis. The integer represents the root’s value and a pair of parenthesis contains a child binary tree with the same structure. You always start to construct the left child node of the parent first if it exists. Note There will only be ‘(‘, ‘)’, ‘-‘ and ‘0’ ~ ‘9’ in the input string. An empty tree is represented by “” instead of “()”. ExampleNo.1Input: “-4(2(3)(1))(6(5))” Output: {-4,2,6,3,1,5} Explanation:The output is look like this: 12345 -4 / \ 2 6 / \ / 3 1 5 No.2Input: “1(-1)” Output: {1,-1} Explanation:The output is look like this: 123 1 /-1 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617181920212223242526272829public TreeNode str2tree(String s) &#123; if (s.length() &lt;= 0) return null; int idx = s.indexOf("("); if (idx == -1) return new TreeNode(Integer.valueOf(s)); int val = Integer.parseInt(s.substring(0, idx)); TreeNode root = new TreeNode(val); int count = 0; int openIdx = idx; for (int i = idx; i &lt; s.length(); i++) &#123; if (s.charAt(i) == '(') count++; else if (s.charAt(i) == ')') count--; if (count == 0 &amp;&amp; openIdx == idx) &#123; root.left = str2tree(s.substring(idx + 1, i)); openIdx = i + 1; &#125; else if (count == 0) root.right = str2tree(s.substring(openIdx + 1, i)); &#125; return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 606 - Construct String from Binary Tree]]></title>
    <url>%2F2019%2F09%2F22%2FLeetCode-Problem-606-Construct-String-from-Binary-Tree%2F</url>
    <content type="text"><![CDATA[You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair “()”. And you need to omit all the empty parenthesis pairs that don’t affect the one-to-one mapping relationship between the string and the original binary tree. ExampleNo.1Input: Binary tree: [1,2,3,4] 12345 1 / \ 2 3 / 4 Output: “1(2(4))(3)” Explanation: Originallay it needs to be “1(2(4)())(3()())”,but you need to omit all the unnecessary empty parenthesis pairs.And it will be “1(2(4))(3)”. No.2Input: Binary tree: [1,2,3,null,4] 12345 1 / \2 3 \ 4 Output: “1(2()(4))(3)” Explanation: Almost the same as the first example,except we can’t omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617181920212223242526public String tree2str(TreeNode t) &#123; StringBuilder sb = new StringBuilder(); helper(t, sb); return sb.toString();&#125;private void helper(TreeNode t, StringBuilder sb) &#123; if (t == null) return; if (t.left == null &amp;&amp; t.right == null) &#123; sb.append(t.val); return; &#125; sb.append(t.val); sb.append("("); helper(t.left, sb); sb.append(")"); if (t.right != null) &#123; sb.append("("); helper(t.right, sb); sb.append(")"); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 605 - Can Place Flowers]]></title>
    <url>%2F2019%2F09%2F22%2FLeetCode-Problem-605-Can-Place-Flowers%2F</url>
    <content type="text"><![CDATA[Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die. Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule. ExampleNo.1Input: flowerbed = [1,0,0,0,1], n = 1 Output: True No.2Input: flowerbed = [1,0,0,0,1], n = 2 Output: False Note The input array won’t violate no-adjacent-flowers rule. The input array size is in the range of [1, 20000]. n is a non-negative integer which won’t exceed the input array size. Code12345678910111213141516171819public boolean canPlaceFlowers(int[] flowerbed, int n) &#123; for (int i = 0; i &lt; flowerbed.length; i++) &#123; if (flowerbed[i] == 1) continue; if (n == 0) return true; int prev = i == 0 ? 0 : flowerbed[i - 1]; int next = i == flowerbed.length - 1 ? 0 : flowerbed[i + 1]; if (prev + next == 0) &#123; n--; flowerbed[i] = 1; &#125; &#125; return n == 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The English We Speak 4]]></title>
    <url>%2F2019%2F09%2F22%2FThe-English-We-Speak-4%2F</url>
    <content type="text"><![CDATA[Across the pondIn Britain, when we say ‘across the pond’ or ‘the other side of the pond’ we might be referring to the Atlantic Ocean and the United States. Because there’s so much contact between the two continents, we compare the ocean to a pond. ExamplesThe latest Woody Allen movie was very popular on both sides of the pond. It was praised by critics and popular among cinemagoers. Many American actors are starring in plays in London’s West End. But this is Shakespeare’s territory and I think the best theatre is still on our side of the pond! Thingya word which we sometimes use when I can’t remember or don’t know the name of an object.it can be used, informally, when you can’t remember the name of a particular person too. ExamplesYou want a recipe for stew? Ask… thingy. She was talking about a lovely one the other day. Sorry, I’m late for the meeting. Could you just pass me the thingy for my report… I mean… the stapler? Eye candysomeone who is attractive, but not very interesting.things which look good but are not very useful. ExamplesI was going out with this gorgeous footballer but it didn’t last. He was just eye candy. This illustrated cookbook looks good but you can never find the ingredients for the recipes. These pictures are just eye candy! Bumper-to-bumperWhen there is a lot of traffic on the road and it’s moving very slowly or not at all, the front of one car is almost touching the back of another one, so it’s bumper-to-bumper. ExamplesTraffic on the northbound A12 near Greenwich Junction is bumper-to-bumper. Best to avoid the area if you can. The approach to the Dartford Tunnel southbound entrance is bumper-to-bumper. Expect severe delays. Sweet toothsomeone craves sweet food all the time, such as sweets, desserts and chocolates. ExamplesJohn always has a bag of sweets open on his desk. He’s got such a sweet tooth. I wish I didn’t have a sweet tooth, because I had four rotten teeth pulled out and eight filled when I was only twenty. Part of the furnituresomeone or something that’s been in the same place for a very long time. ExamplesJohn has been the school caretaker for nearly twenty years. He’s become part of the furniture. We come here so often, it’s almost as if we are part of the furniture. She’s had a seat in parliament for over 50 years – she’s part of the furniture in the House of Commons. Down the pansomething disastrous has happened. ExamplesJason had great dreams of becoming a football player, but they went down the pan when he broke his leg. I’m afraid all that careful preparation we did for Jemma’s surprise birthday party went down the pan when her brother told her about it. He was ready to move into his new home, but everything went down the pan when the fire destroyed the house last night. Fancy someonefind them physically attractive. ExamplesLook at the figure-hugging clothes you’re wearing, Betty. Is there someone you fancy at the party? He’s a lovely guy. We’re really good friends. Actually, I fancy him a little… That’ll put hairs on your chest!it’s good for you, it’ll make you a strong man or a woman!Traditionally, we say ‘that’ll put hairs on your chest’ to someone when they are about to have a very strong alcoholic drink or a very satisfying hearty meal. It is used in a humorous way. ExamplesHave another drink! It’ll put hairs on your chest. Why don’t you try the spicy fish dish? That’ll put hairs on your chest. I was told eating dates everyday would put hairs on my chest. Have some more green vegetables – they’ll put hairs on your chest. I’m gameyou are willing to try something; you are interested in doing something fun or unusual. ExamplesSo many people in England are fans of football; they all love the game. Sam is brilliant at board games. A: I’m going to have a fancy dress party next Saturday. Would you like to come?B: Hey thanks! Yes, I’d love to. I’m game for a laugh. A: Hey Brian, I’m organising a football match between the managers and the workers, do you want to play?B: Sure, count me in. I’m game. Pottythey are crazy or going crazy. to be potty about something: be really keen on something. ExamplesMy boss wants me to work on New Year’s day for no extra money. He must be potty. She’s potty to sell off her car so cheaply. A bitter pill to swallowit’s a situation that is unpleasant and difficult to accept. ExamplesWhen John found out about his wife’s affair with his best friend, it was a bitter pill to swallow. It was a bitter pill to swallow knowing that my older sister finished the race quicker than me. My friend has booked the same flights as me for half the price – it’s a bitter pill to swallow! Cheap and cheerfulthe product doesn’t cost much but it serves its purpose. cheap and nasty: the quality is bad. ExamplesShe enjoys shopping for cheap and cheerful presents. He made a lot of money from designing cheap and cheerful toys for children. Everything in this shop is cheap and nasty. Don’t buy anything. My boyfriend is very stingy. The hotel where we stayed was cheap and nasty. I wouldn’t recommend it. In good nick‘it’s in good condition’, especially if it’s something that’s very old but still looks new. ExamplesI picked up a set of silver plates from an antique shop and they were in pretty good nick. My grandpa loves his 1960s motorbike and has worked very hard to kept it in good nick. There’s method to my madnessyou are doing something that looks strange but you have a plan and really, you are doing something very sensible. ExamplesI’m driving to my friend’s house today but I’m going to take the long route, avoiding the motorway. There’s method to my madness, I think the motorway will be very busy and the longer route will be quicker. A: What are you doing putting all the books on the floor?B: There’s method to my madness. I’m taking a photo of the books I’m putting away. The photos will help me locate the books more easily.A: Oh, that’s clever. Hot potatodifficult or tricky situations, or even people. ExamplesThe shortage of housing supply is fast becoming a hot potato for the council. The pay rise issue is a hot potato for management; I don’t know how they are going to sort this one out between the staff, the union and the shareholders. To make a monkey out of meto make me look foolish or to humiliate me. ExamplesMary made a monkey out me by telling to me to ask her best friend out on a date – she said no! My boyfriend’s always making a monkey out of himself by getting drunk at parties. Sid made a monkey out of Paul by telling him to wear a suit to the party – everyone else was wearing jeans! To lie through your teethto tell someone something that’s completely untrue. ExamplesWhen she said she was nearly 30 years old, I knew she was lying through her teeth! They promised we’d get free drinks every day at our hotel but they were lying through their teeth. He lied through his teeth when he said he bought her an expensive engagement ring – it was just a cheap one from the catalogue. Test the waterto test the idea, try it out and see if it works. ExamplesA: Have you started on your new book?B: Yes, I’ve written three chapters and I’ve sent it to the publishers to test the water. A: Oh, what perfume are you wearing? It’s lovely.B: Oh thanks. It’s just a sample a company sent me. They’re testing the water to see if people like it. A: How is your Shakespeare project going?B: It’s early days; we’re still testing the water.A: Well, good luck with it.B: Thanks. Six of one, half a dozen of the otherthere is very little difference between two choices.two people are equally responsible for something. ExamplesA: I don’t know whether to give my mum flowers or chocolates for Mother’s Day.B: It’s six of one, half a dozen of the other. A: Do you think we should take the third ring road instead of the second ring road?B: Oh, I don’t know, it’s six of one, half a dozen of the other. A: They keep blaming each other - whose fault was it really?B: Oh, it was six of one, half a dozen of the other.]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 598 - Range Addition II]]></title>
    <url>%2F2019%2F09%2F22%2FLeetCode-Problem-598-Range-Addition-II%2F</url>
    <content type="text"><![CDATA[Given an m * n matrix M initialized with all 0’s and several update operations. Operations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 &lt;= i &lt; a and 0 &lt;= j &lt; b. You need to count and return the number of maximum integers in the matrix after performing all the operations. ExampleInput:m = 3, n = 3operations = [[2,2],[3,3]] Output: 4 Explanation:Initially, M = 123[[0, 0, 0], [0, 0, 0], [0, 0, 0]] After performing [2,2], M = 123[[1, 1, 0], [1, 1, 0], [0, 0, 0]] After performing [3,3], M = 123[[2, 2, 1], [2, 2, 1], [1, 1, 1]] So the maximum integer in M is 2, and there are four of it in M. So return 4. Note The range of m and n is [1,40000]. The range of a is [1,m], and the range of b is [1,n]. The range of operations size won’t exceed 10,000. Code12345678public int maxCount(int m, int n, int[][] ops) &#123; for (int[] op : ops) &#123; m = Math.min(m, op[0]); n = Math.min(n, op[1]); &#125; return m * n;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 903 - Range Addition]]></title>
    <url>%2F2019%2F09%2F22%2FLintCode-Problem-903-Range-Addition%2F</url>
    <content type="text"><![CDATA[Assume you have an array of length n initialized with all 0’s and are given k update operations. Each operation is represented as a triplet: [startIndex, endIndex, inc] which increments each element of subarray A[startIndex … endIndex] (startIndex and endIndex inclusive) with inc. Return the modified array after all k operations were executed. ExampleGiven:length = 5,updates = 12345[[1, 3, 2],[2, 4, 3],[0, 2, -2]] return [-2, 0, 3, 5, 3] Explanation:Initial state:[ 0, 0, 0, 0, 0 ]After applying operation [1, 3, 2]:[ 0, 2, 2, 2, 0 ]After applying operation [2, 4, 3]:[ 0, 2, 5, 5, 3 ]After applying operation [0, 2, -2]:[-2, 0, 3, 5, 3 ] Code1234567891011121314public int[] getModifiedArray(int length, int[][] updates) &#123; int[] array = new int[length + 1]; int[] sum = new int[length]; for (int[] update : updates) &#123; array[update[0]] += update[2]; array[update[1] + 1] -= update[2]; &#125; for (int i = 0; i &lt; sum.length; i++) sum[i] = (i == 0 ? 0 : sum[i - 1]) + array[i]; return sum;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 674 - Longest Continuous Increasing Subsequence]]></title>
    <url>%2F2019%2F09%2F18%2FLeetCode-Problem-674-Longest-Continuous-Increasing-Subsequence%2F</url>
    <content type="text"><![CDATA[Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray). ExampleNo.1Input: [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.Even though [1,3,5,7] is also an increasing subsequence, it’s not a continuous one where 5 and 7 are separated by 4. No.2Input: [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2], its length is 1. NoteLength of the array will not exceed 10,000. Code123456789101112131415161718public int findLengthOfLCIS(int[] nums) &#123; if (nums.length == 0) return 0; int result = 1; int count = 1; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &gt; nums[i - 1]) &#123; count++; result = Math.max(result, count); &#125; else count = 1; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 594 - Longest Harmonious Subsequence]]></title>
    <url>%2F2019%2F09%2F18%2FLeetCode-Problem-594-Longest-Harmonious-Subsequence%2F</url>
    <content type="text"><![CDATA[We define a harmounious array as an array where the difference between its maximum value and its minimum value is exactly 1. Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences. ExampleInput: [1,3,2,2,5,2,3,7] Output: 5 Explanation: The longest harmonious subsequence is [3,2,2,2,3]. NoteThe length of the input array will not exceed 20,000. Code12345678910111213141516public int findLHS(int[] nums) &#123; int result = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums) map.put(num, map.getOrDefault(num, 0) + 1); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; int key = entry.getKey(); if (map.containsKey(key + 1)) result = Math.max(result, entry.getValue() + map.get(key + 1)); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 581 - Shortest Unsorted Continuous Subarray]]></title>
    <url>%2F2019%2F09%2F18%2FLeetCode-Problem-581-Shortest-Unsorted-Continuous-Subarray%2F</url>
    <content type="text"><![CDATA[Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too. You need to find the shortest such subarray and output its length. ExampleInput: [2, 6, 4, 8, 10, 9, 15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order. Note Then length of the input array is in range [1, 10,000]. The input array may contain duplicates, so ascending order here means &lt;=. Code12345678910111213141516171819202122public int findUnsortedSubarray(int[] nums) &#123; int start = -1; int end = -2; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for (int i = nums.length - 1; i &gt;= 0; i--) &#123; min = Math.min(min, nums[i]); if (nums[i] &gt; min) start = i; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; max = Math.max(max, nums[i]); if (nums[i] &lt; max) end = i; &#125; return end - start + 1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 680 - Valid Palindrome II]]></title>
    <url>%2F2019%2F09%2F18%2FLeetCode-Problem-680-Valid-Palindrome-II%2F</url>
    <content type="text"><![CDATA[Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome. ExampleNo.1Input: “aba” Output: True No.2Input: “abca” Output: True Explanation: You could delete the character ‘c’. Note The string will only contain lowercase characters a-z. The maximum length of the string is 50000. Code1234567891011121314151617181920212223242526public boolean validPalindrome(String s) &#123; int left = 0; int right = s.length() - 1; while (left &lt; right) &#123; if (s.charAt(left) != s.charAt(right)) return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1); left++; right--; &#125; return true;&#125;private boolean isPalindrome(String s, int left, int right) &#123; while (left &lt; right) &#123; if (s.charAt(left) != s.charAt(right)) return false; left++; right--; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 575 - Distribute Candies]]></title>
    <url>%2F2019%2F09%2F18%2FLeetCode-Problem-575-Distribute-Candies%2F</url>
    <content type="text"><![CDATA[Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain. ExampleNo.1Input: candies = [1,1,2,2,3,3] Output: 3 Explanation:There are three different kinds of candies (1, 2 and 3), and two candies for each kind.Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.The sister has three different kinds of candies. No.2Input: candies = [1,1,2,3] Output: 2 Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1].The sister has two different kinds of candies, the brother has only one kind of candies. Note The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000]. Code1234567891011121314151617public int distributeCandies(int[] candies) &#123; int half = candies.length / 2; int count = 0; boolean[] visit = new boolean[200001]; for (int candy : candies) &#123; if (!visit[candy + 100000]) &#123; count++; visit[candy + 100000] = true; &#125; if (count == half) break; &#125; return count; &#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 566 - Reshape the Matrix]]></title>
    <url>%2F2019%2F09%2F18%2FLeetCode-Problem-566-Reshape-the-Matrix%2F</url>
    <content type="text"><![CDATA[In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data. You’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were. If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. ExampleNo.1Input:nums = 12[[1,2], [3,4]] r = 1, c = 4 Output: 1[[1,2,3,4]] Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list. No.2Input:nums = 12[[1,2], [3,4]] r = 2, c = 4 Output: 12[[1,2], [3,4]] Explanation:There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix. Note The height and width of the given matrix is in range [1, 100]. The given r and c are all positive. Code1234567891011121314public int[][] matrixReshape(int[][] nums, int r, int c) &#123; int m = nums.length; int n = nums[0].length; if (m * n != r * c) return nums; int[][] result = new int[r][c]; for (int i = 0; i &lt; m * n; i++) result[i / c][i % c] = nums[i / n][i % n]; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 532 - K-diff Pairs in an Array]]></title>
    <url>%2F2019%2F09%2F17%2FLeetCode-Problem-532-K-diff-Pairs-in-an-Array%2F</url>
    <content type="text"><![CDATA[Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k. ExampleNo.1Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs. No.2Input:[1, 2, 3, 4, 5], k = 1 Output: 4 Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5). No.3Input: [1, 3, 1, 5, 4], k = 0 Output: 1 Explanation: There is one 0-diff pair in the array, (1, 1). Note The pairs (i, j) and (j, i) count as the same pair. The length of the array won’t exceed 10,000. All the integers in the given input belong to the range: [-1e7, 1e7]. Code123456789101112131415161718192021222324public int findPairs(int[] nums, int k) &#123; int result = 0; int n = nums.length; int start = 0; int end = 0; Arrays.sort(nums); while (start &lt; n) &#123; end = Math.max(end, start + 1); while (end &lt; n &amp;&amp; nums[end] - nums[start] &lt; k) end++; if (end &lt; n &amp;&amp; nums[end] - nums[start] == k) result++; while (start &lt; n - 1 &amp;&amp; nums[start] == nums[start + 1]) start++; start++; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 188 - Best Time to Buy and Sell Stock IV]]></title>
    <url>%2F2019%2F09%2F17%2FLeetCode-Problem-188-Best-Time-to-Buy-and-Sell-Stock-IV%2F</url>
    <content type="text"><![CDATA[Say you have an array for which the i-th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. NoteYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). ExampleNo.1Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. No.2Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Code1234567891011121314151617181920212223242526272829303132333435public int maxProfit(int k, int[] prices) &#123; int n = prices.length; if (n == 0) return 0; if (k &gt;= n) return maxProfit(prices); int[] T = new int[n]; int[] prev = new int[n]; for (int j = 1; j &lt;= k; j++) &#123; int maxDiff = -prices[0]; for (int i = 1; i &lt; n; i++) &#123; T[i] = Math.max(T[i - 1], prices[i] + maxDiff); maxDiff = Math.max(maxDiff, prev[i] - prices[i]); prev[i] = T[i]; &#125; &#125; return T[n - 1];&#125;private int maxProfit(int[] prices) &#123; int result = 0; for (int i = 1; i &lt; prices.length; i++) &#123; if (prices[i] &gt; prices[i - 1]) result += prices[i] - prices[i - 1]; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 123 - Best Time to Buy and Sell Stock III]]></title>
    <url>%2F2019%2F09%2F17%2FLeetCode-Problem-123-Best-Time-to-Buy-and-Sell-Stock-III%2F</url>
    <content type="text"><![CDATA[Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. NoteYou may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). ExampleNo.1Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. No.2Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. No.3Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. Code123456789101112131415161718192021222324// T[i][j] = max&#123;T[i][j - 1], max&#123;prices[j] - prices[m] + T[i - 1][m]&#125;&#125;, 0 &lt;= m &lt;= j - 1// =&gt; T[i][j] = max&#123;T[i][j - 1], prices[j] + maxDiff&#125;// maxDiff = max&#123;maxDiff, T[i - 1][j] - prices[j]&#125;public int maxProfit(int[] prices) &#123; int n = prices.length; if (n == 0) return 0; int[] T = new int[n]; int[] prev = new int[n]; for (int k = 1; k &lt;= 2; k++) &#123; int maxDiff = -prices[0]; for (int i = 1; i &lt; n; i++) &#123; T[i] = Math.max(T[i - 1], prices[i] + maxDiff); maxDiff = Math.max(maxDiff, prev[i] - prices[i]); prev[i] = T[i]; &#125; &#125; return T[n - 1];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SQL进阶教程】让SQL飞起来]]></title>
    <url>%2F2019%2F09%2F15%2F%E3%80%90SQL%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B%E3%80%91%E8%AE%A9SQL%E9%A3%9E%E8%B5%B7%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[不管是减少排序还是使用索引，抑或是避免中间表的使用，都是为了减少对硬盘的访问。 使用高效的查询在SQL中，很多时候不同代码能够得出相同结果。从理论上来说，得到相同结果的不同代码应该有相同的性能，但遗憾的是，查询优化器生成的执行计划很大程度上要受到代码外部结构的影响。 参数是子查询时，使用EXISTS代替IN如果IN的参数是“1，2，3”这样的数值列表，一般还不需要特别注意。但是如果参数是子查询时，那么就需要注意了。在大多数时候，[NOT] IN和[NOT] EXISTS返回的结果是相同的。但是两者用于子查询时，EXISTS的速度会更快一些。 先看个例子。这里使用两张用于管理员学习过的培训课程的表作为测试数据。 试着从Class_A表中查出同时存在于Class_B表中的员工。下面两条SQL语句返回的结果是一样的，但是使用EXISTS的SQL语句更快一些。 1234SELECT *FROM Class_AWHERE id IN (SELECT id FROM Class_B); 12345SELECT *FROM Class_A AWHERE EXISTS (SELECT * FROM Class_B B WHERE A.id = B.id); 使用EXISTS时更快的原因有以下两个。 如果连接列（id）上建立了索引，那么查询Class_B时不用查实际的表，只需查索引就可以了。 如果使用EXISTS，那么只要查到一行数据满足条件就会终止查询，不用像使用IN时一样扫面全表。在这一点上NOT EXISTS也一样。 当IN的参数是子查询时，数据库首先会执行子查询，然后将结果存储在一张临时的工作表里（内联视图），然后扫描整个视图。很多情况下，这种做法都非常耗费资源。使用EXISTS的话，数据库不会生成临时的工作表。但是从代码的可读性上来看，IN要比EXISTS好。使用IN时的代码看起来更加一目了然，易于理解。因此，如果确信使用IN也能快速获取结果，就没有必要非得改成EXISTS了。 参数是子查询时，使用连接代替IN要想改善IN的性能，除了使用EXISTS，还可以使用连接。前面的查询语句就可以像下面这样“扁平化”。 123SELECT A.id, A.nameFROM Class_A AINNER JOIN Class_B B ON A.id = B.id; 这种写法至少能用到一张表的“id”列上的索引。而且，因为没有了子查询，所以数据库也不会生成中间表。很难说与EXISTS相比哪个更好，但是如果没有索引，那么与连接相比，可能EXISTS会略胜一筹。 避免排序在数据库内部频繁地进行着暗中的排序。会进行排序的代表性的运算有下面这些。 GROUP BY子句 ORDER BY子句 聚合函数（SUM、COUNT、AVG、MAX、MIN） DISTINCT 集合运算符（UNION、INTERSECT、EXCEPT） 窗口函数（RANK、ROW_NUMBER等） 灵活使用集合运算符的ALL可选项SQL中有UNION、INTERSECT、EXCEPT三个集合运算符。在默认的使用方式下，这些运算符会为了排除掉重复数据而进行排序。 123SELECT * FROM Class_AUNIONSELECT * FROM Class_B; 如果不在乎结果中是否有重复数据，或者事先知道不会有重复数据，请使用UNION ALL代替UNION。这样就不会进行排序了。 123SELECT * FROM Class_AUNION ALLSELECT * FROM Class_B; 使用EXISTS代替DISTINCT为了排除重复数据，DISTINCT也会进行排序。如果需要对两张表的连接结果进行去重，可以考虑使用EXISTS代替DISTINCT，以避免排序。 思考以下如何从上面的商品表Items中找出同时存在于销售记录表SalesHistory中的商品。简而言之，就是找出有销售记录的商品。 使用IN是一种做法。但是前面说过，当IN的参数是子查询时，使用连接要比使用IN更好。因此使用“item_no”列对两张表进行连接。因为是一对多的连接，所以“item_no”列中会出现重复数据。为了排除重复数据，需要使用DISTINCT。 123SELECT DISTINCT I.item_noFROM Items IINNER JOIN SalesHistory SH ON I.item_no = SH.item_no; 但是，其实更好的做法是使用EXISTS。 12345SELECT item_noFROM Items IWHERE EXISTS (SELECT * FROM SalesHistory SH WHERE I.item_no = SH.item_no); 这条语句在执行过程中不会进行排序。而且使用EXISTS和使用连接一样高效。 在极值函数中使用索引（MAX/MIN）SQL语言里有MAX和MIN两个极值函数。使用这两个函数时都会进行排序。但是如果参数字段上建有索引，则只需要扫面索引，不需要扫描整张表。以刚才的表Items为例来说，SQL语句可以像下面这样写。 12SELECT MAX(item_no)FROM Items; 因为item_no是表Items的唯一索引，所以效果更好。对于联合索引，只要查询条件是联合索引的第一个字段，索引就是有效的，所以也可以对表SalesHistory的sale_date字段使用极值函数。这种方法并不是去掉了排序这一过程，而是优化了排序前的查找速度，从而减弱排序对整体性能的影响。 能写在WHERE子句里的条件不要写在HAVING子句里例如，下面两条SQL语句返回的结果是一样的。 12345-- HAVINGSELECT sale_date, SUM(quantity)FROM SalesHistoryGROUP BY sale_dateHAVING sale_date = '2007-10-01'; 12345-- WHERESELECT sale_date, SUM(quantity)FROM SalesHistoryWHERE sale_date = '2007-10-01'GROUP BY sale_date; 但是从性能上来看，第二条语句写法效率更高。原因通常有两个。第一个是在使用GROUP BY子句聚合时会进行排序，如果事先通过WHERE子句筛选出一部分行，就能够减轻排序的负担。第二个是在WHERE子句的条件里可以使用索引。HAVING子句是针对聚合后生成的视图进行筛选的，但是很多时候聚合后的视图都没有继承原表的索引结构。 在GROUP BY子句和ORDER BY子句中使用索引一般来说，GROUP BY子句和ORDER BY子句都会进行排序，来对行进行排列和替换。不过，通常指定带索引的列作为GROUP BY和ORDER BY的列，可以实现高速查询。 真的用到索引了吗一般情况下，都会对数据量相对较大的表建立索引。而且最流行的B树索引还进行了一些优化，以使用二分查找来提升查询的速度。 假设在一个叫作col_1的列上建立了索引，然后来看一看下面这些SQL语句。这些SQL语句本来是想使用索引，但实际上执行时却进行了全表扫描。 在索引字段上进行运算123SELECT *FROM SomeTableWHERE col_1 * 1.1 &gt; 100; 实际上，数据库引擎连这种程度的转换也不会做。把运算的表达式放到查询条件的右侧，就能用到索引了，像下面这样写就OK了。 1WHERE col_1 &gt; 100 / 1.1 同样，在查询条件的左侧使用函数时，也不能用到索引。 123SELECT *FROM SomeTableWHERE SUBSTR(col_1, 1, 1) = 'a'; 使用索引时，条件表达式的左侧应该是原始字段。 使用IS NULL谓词通常，索引字段是不存在NULL的，所以指定IS NULL和IS NOT NULL的话会使得索引无法使用，进而导致查询性能低下。关于索引字段不存在NULL的原因，简单来说是NULL并不是值。非值不会被包含在值的集合中。 使用否定形式下面这几种否定形式不能用到索引。 &lt;&gt; != NOT IN 使用OR在col_1和col_2上分别建立了不同的索引，或者建立了(col_1, col_2)这样的联合索引时，如果使用OR连接条件，那么要么用不到索引，要么用到了但是效率比AND要差很多。 1234SELECT *FROM SomeTableWHERE col_1 &gt; 100 OR col_2 = 'abc'; 使用联合索引时，列的顺序错误假设存在这样顺序的一个联合索引”col_1, col_2, col_3“。这时，指定条件的顺序就很重要。 12345678-- OSELECT * FROM SomeTable WHERE col_1 = 10 AND col_2 = 100 AND col_3 = 500;SELECT * FROM SomeTable WHERE col_1 = 10 AND col_2 = 100;-- XSELECT * FROM SomeTable WHERE col_1 = 10 AND col_3 = 500;SELECT * FROM SomeTable WHERE col_2 = 100 AND col_3 = 500;SELECT * FROM SomeTable WHERE col_2 = 100 AND col_1 = 10; 联合索引中的第一列(col_1)必须写在查询条件的开头，而且索引中列的顺序不能颠倒。如果无法保证查询条件里列的顺序与索引一致，可以考虑将联合索引拆分为多个索引。 使用LIKE谓词进行后方一致或中间一致的匹配使用LIKE谓词时，只有前方一致的匹配才能用到索引。 123456-- XSELECT * FROM SomeTable WHERE col_1 LIKE '%a';SELECT * FROM SomeTable WHERE col_1 LIKE '%a%';-- OSELECT * FROM SomeTable WHERE col_1 LIKE 'a%'; 进行默认的类型转换123456-- XSELECT * FROM SomeTable WHERE col_1 = 10;-- OSELECT * FROM SomeTable WHERE col_1 = '10';SELECT * FROM SomeTable WHERE col_1 = CAST(10, AS CHAR(2)); 默认的类型转换不仅会增加额外的性能开销，还会导致索引不可用，可以说是有百害而无一利。 减少中间表在SQL中，子查询的结果会被看成一张新表。频繁使用中间表会带来两个问题，一是展开数据需要耗费内存资源，二是原始表中的索引不容易使用到（特别是聚合时）。 灵活使用HAVING子句对聚合结果指定筛选条件时，使用HAVING子句是基本原则。 12345SELECT *FROM (SELECT sale_date, MAX(quantity) AS max_qty FROM SalesHistory GROUP BY sale_date) TMPWHERE max_qty &gt;= 10; 1234SELECT sale_date, MAX(quantity)FROM SalesHistoryGROUP BY sale_dateHAVING MAX(quantity) &gt;= 10; HAVING子句和聚合操作是同时执行的，所以比起生成中间表后再执行的WHERE子句，效率会更高一些，而且代码看起来也更简洁。 需要对多个字段使用IN谓词时，将它们汇总到一处加入了行与行比较的功能。这样一来，比较谓词=、&lt;、&gt;和IN谓词的参数就不能是标量值，而应是值列表了。来看一下下面这个SQL语句。这里对多个字段使用了IN谓词，“id”列是主键。 12345678SELECT id, state, cityFROM Addresses1 A1WHERE state IN (SELECT state FROM Addresses2 A2 WHERE A1.id = A2.id) AND city IN (SELECT city FROM Addresses2 A2 WHERE A1.id = A2.id); 这段代码中用到了两个子查询。但是，如果像下面这样把字段连接在一起，那么就能把逻辑写在一处了。 1234SELECT *FROM Addresses1 A1WHERE id || state || city IN (SELECT id || state || city FROM Addresses2 A2); 这样一来，子查询不用考虑关联性，而且只执行一次就可以。此外，如果所用的数据库实现了行与行的比较，那么也可以像下面这样，在IN中写多个字段的组合。 1234SELECT *FROM Addresses1 A1WHERE (id, state, city) IN (SELECT id, state, city FROM Addresses2 A2); 这种方法与前面的连接字段的方法相比有两个优点。一是不用担心连接字段时出现的类型转换问题，二是这种方法不会对字段进行加工，因此可以使用索引。 先进行连接再进行聚合连接和聚合同时使用时，先进行连接操作可以避免产生中间表。原因是，从集合运算的角度来看，连接做的是“乘法运算”。连接表双方是一对一、一对多的关系时，连接运算后数据的行数不会增加。 合理地使用视图视图是非常方便的工具。但是，如果没有经过深入思考就定义复杂的视图，可能会带来巨大的性能问题。特别是视图的定义语句中包含以下运算的时候，SQL会非常低效，执行速度也会变得非常慢。 聚合函数（AVG、COUNT、SUM、MIN、MAX） 集合运算符（UNION、INTERSECT、EXCEPT等） 一般来说，要格外注意避免在视图中进行聚合操作，需要特别注意。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SQL进阶教程】HAVING子句又回来了]]></title>
    <url>%2F2019%2F09%2F13%2F%E3%80%90SQL%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B%E3%80%91HAVING%E5%AD%90%E5%8F%A5%E5%8F%88%E5%9B%9E%E6%9D%A5%E4%BA%86%2F</url>
    <content type="text"><![CDATA[整理一下在调查集合性质时经常用到的条件。这些条件可以在HAVING子句中使用，也可以通过SELECT子句在CASE表达式里使用。 各队，全体点名需要做的是查出现在可以出勤的队伍。可以出勤即队伍里所有队员都处于“待命”状态。使用的是下面这张表。 1234567-- 谓词SELECT team_id, memberFROM Teams T1WHERE NOT EXISTS (SELECT * FROM Teams T2 WHERE T1.team_id = T2.team_id AND status &lt;&gt; '待命'); 这个查询性能很好，而且结果中能体现出队员信息，这些是它好的地方。但是因为使用了双重否定，所以理解起来不是很容易。而如果使用HAVING子句，写起来就非常简单了，像下面这样。 12345-- 集合（1）SELECT team_idFROM TeamsGROUP BY team_idHAVING COUNT(*) = SUM(CASE WHEN status = '待命' THEN 1 ELSE 0 END); 顺便说一下，HAVING子句中的条件还可以像下面这样写。 123456-- 集合（2）SELECT team_idFROM TeamsGROUP BY team_idHAVING MIN(status) = '待命' AND MAX(status) = '待命'; 极值函数可以使用参数字段的索引，所以这种写法性能更好。 当然也可以把条件放在SELECT子句里，以列表形式显示出各个队伍是否所有队员都在待命，这样的结果更加一目了然。 12345SELECT team_id, CASE WHEN MIN(status) = '待命' AND MAX(status) = '待命' THEN '全部都在待命' ELSE '队长！人手不够' END AS statusFROM TeamsGROUP BY team_id; 需要注意的是，条件移到SELECT子句后，查询可能就不会被数据库优化了，所以性能上相比HAVING子句的写法会差一些。 单重集合与多重集合例如，有下面这样一张管理各个生产地的材料库存的表。 需要调查出存在重复材料的生产地。 1234SELECT centerFROM MaterialsGROUP BY centerHAVING COUNT(material) &lt;&gt; COUNT(DISTINCT material); 和前面一样，可以把条件移到SELECT子句中，这样就能在结果中清晰地看到各个生产地是否存在重复材料了。 12345SELECT center, CASE WHEN COUNT(material) &lt;&gt; COUNT(DISTINCT material) THEN '存在重复' ELSE '不存在重复' END AS statusFROM MaterialsGROUP BY center; 顺便说一下，这个问题也可以通过将HAVING改写成EXISTS的方式来解决。 1234567SELECT center, materialFROM Materials M1WHERE EXISTS (SELECT * FROM Materials M2 WHERE M1.center = M2.center AND M1.material = M2.material AND M1.reveive_date &lt;&gt; M2.receive_date); 用EXISTS改写后的SQL语句也能够查出重复的具体是哪一种材料，而且使用EXISTS后性能也很好。 寻找缺失的编号：升级版下面这样一条查询数列的缺失编号的查询语句。 123SELECT '存在缺失的编号' AS gapFROM SeqTblHAVING COUNT(*) &lt;&gt; MAX(seq); 这条SQL语句有一个前提条件，即数列的起始值必须是1.思考一下不管数列的最小值是多少，都能用来判断该数列是否连续的SQL语句。 如果数列的最小值和最大值之间没有缺失的编号，它们之间包含的元素的个数应该是“最大值-最小值+1”。因此，像下面这样写比较条件就可以了。 123SELECT '存在缺失的编号' AS gapFROM SeqTblHAVING COUNT(*) &lt;&gt; MAX(seq) - MIN(seq) + 1; 如果不论是否存在缺失的编号，都想要返回结果，那么只需要像下面这样把条件写到SELECT里就可以了。 12345SELECT CASE WHEN COUNT(*) = 0 THEN '表为空' WHEN COUNT(*) &lt;&gt; MAX(seq) - MIN(seq) + 1 THEN '存在缺失的编号' ELSE '连续' END AS gapFROM SeqTbl; 接下来也顺便改进一下查找最小的缺失编号的SQL语句，去掉起始值必须是1的限制。对于像这样表中原本就不存在1的情况，追加一个条件分支让它返回1，即像下面这样来写SQL语句。 12345678SELECT CASE WHEN COUNT(*) = 0 OR MIN(seq) &gt; 1 THEN 1 ELSE (SELECT MIN(seq + 1) FROM SeqTbl S1 WHERE NOT EXISTS (SELECT * FROM SeqTbl S2 WHERE S2.seq = S1.seq + 1)) ENDFROM SeqTbl; NOT IN改写成了NOT EXISTS，这样写是为了处理值为NULL的情况，以及略微优化一下性能。特别是如果在“seq”列上建立了索引，那么使用NOT EXISTS能明显改善性能。 为集合设置详细的条件这里以下面这张记录了学生考试成绩的表为例。 查询出75%以上的学生分数在80分以上的班级 1234SELECT classFROM TestResultsGROUP BY classHAVING COUNT(*) * 0.75 &lt;= SUM(CASE WHEN score &gt;= 80 THEN 1 ELSE 0 END); 查询出分数在50分以上的男生的人数比分数在50分以上的女生的人数多的班级 12345SELECT classFROM TestResultsGROUP BY classHAVING SUM(CASE WHEN score &gt;= 50 AND sex = '男' THEN 1 ELSE 0 END) &gt; SUM(CASE WHEN score &gt;= 50 AND sex = '女' THEN 1 ELSE 0 END); 查询出女生平均分比男生平均分高的班级 从表中的数据可以发现，D班全是女生，男生的平均分无法计算。合理的处理方法是，保证对空集求平均的结果是“未定义”。 12345SELECT classFROM TestResultsGROUP BY classHAVING AVG(CASE WHEN sex = '男' THEN score ELSE NULL END) &lt; AVG(CASE WHEN sex = '女' THEN score ELSE NULL END);]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 617 - Maximum Average Subarray II]]></title>
    <url>%2F2019%2F09%2F12%2FLintCode-Problem-617-Maximum-Average-Subarray-II%2F</url>
    <content type="text"><![CDATA[Given an array with positive and negative numbers, find the maximum average subarray which length should be greater or equal to given length k. NoteIt’s guaranteed that the size of the array is greater or equal to k. ExampleNo.1Input:[1,12,-5,-6,50,3]3 Output:15.667 Explanation: (-6 + 50 + 3) / 3 = 15.667 No.2Input:[5]1 Output:5.000 Code12345678910111213141516171819202122232425262728293031323334353637383940414243// (nums[i] + nums[i+1] + … + nums[j]) / (j-i+1) &gt;= x// =&gt;(nums[i] - x) + (nums[i+1] - x) + … + (nums[j] - x) &gt;= 0public double maxAverage(int[] nums, int k) &#123; double left = Double.MAX_VALUE; double right = Double.MIN_VALUE; for (int num : nums) &#123; left = Math.min(left, num); right = Math.max(right, num); &#125; while (right - left &gt; 1e-5) &#123; double mid = left + (right - left) / 2; if (isMidLarger(nums, k, mid)) right = mid; else left = mid; &#125; return left;&#125;private boolean isMidLarger(int[] nums, int k, double mid) &#123; double sum = 0; double preSum = 0; double minSum = 0; for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i] - mid; if (i &gt;= k) &#123; preSum += nums[i - k] - mid; minSum = Math.min(minSum, preSum); &#125; if (i &gt;= k - 1 &amp;&amp; sum - minSum &gt;= 0) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 643 - Maximum Average Subarray I]]></title>
    <url>%2F2019%2F09%2F12%2FLeetCode-Problem-643-Maximum-Average-Subarray-I%2F</url>
    <content type="text"><![CDATA[Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value. ExampleInput: [1,12,-5,-6,50,3], k = 4 Output: 12.75 Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75 Note 1 &lt;= k &lt;= n &lt;= 30,000. Elements of the given array will be in the range [-10,000, 10,000]. Code12345678910111213141516public double findMaxAverage(int[] nums, int k) &#123; int max = Integer.MIN_VALUE; int sum = 0; for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; if (i &gt;= k) sum -= nums[i - k]; if (i &gt;= k - 1) max = Math.max(max, sum); &#125; return max * 1.0 / k;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 522 - Longest Uncommon Subsequence II]]></title>
    <url>%2F2019%2F09%2F12%2FLeetCode-Problem-522-Longest-Uncommon-Subsequence-II%2F</url>
    <content type="text"><![CDATA[Given a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1. ExampleInput: “aba”, “cdc”, “eae” Output: 3 Note All the given strings’ lengths will not exceed 10. The length of the given list will be in the range of [2, 50]. Code1234567891011121314151617181920212223242526272829303132333435363738394041public int findLUSlength(String[] strs) &#123; int n = strs.length; Arrays.sort(strs, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o1.length() != o2.length() ? o2.length() - o1.length() : o2.compareTo(o1); &#125; &#125;); for (int i = 0; i &lt; n; i++) &#123; while (i &lt; n - 1 &amp;&amp; strs[i].equals(strs[i + 1])) i++; int j = 0; for (; j &lt; i; j++) &#123; if (isSubsequence(strs[i], strs[j])) break; &#125; if (j == i) return strs[i].length(); &#125; return -1;&#125;private boolean isSubsequence(String a, String b) &#123; int i = 0; int j = 0; while (i &lt; a.length() &amp;&amp; j &lt; b.length()) &#123; if (a.charAt(i) == b.charAt(j)) i++; j++; &#125; return i == a.length();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 521 - Longest Uncommon Subsequence I]]></title>
    <url>%2F2019%2F09%2F12%2FLeetCode-Problem-521-Longest-Uncommon-Subsequence-I%2F</url>
    <content type="text"><![CDATA[Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1. ExampleInput: “aba”, “cdc” Output: 3 Explanation: The longest uncommon subsequence is “aba” (or “cdc”),because “aba” is a subsequence of “aba”,but not a subsequence of any other strings in the group of two strings. Note Both strings’ lengths will not exceed 100. Only letters from a ~ z will appear in input strings. Code123public int findLUSlength(String a, String b) &#123; return a.equals(b) ? -1 : Math.max(a.length(), b.length());&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The English We Speak 3]]></title>
    <url>%2F2019%2F09%2F12%2FThe-English-We-Speak-3%2F</url>
    <content type="text"><![CDATA[In black and whiteit’s official - it’s been printed or written down - so there is no dispute! ExamplesI have it here in black and white - I’ve got the job! I’m not going to start celebrating until I’ve seen the deal in black and white. We didn’t believe the bank’s offer of a loan until we saw it in black and white. Take a back seatto give up control and let someone else take responsibility. ExamplesMary was happy to take a back seat and let Jim run the meeting. I’m going to take a back seat this year and let you decide where we go on holiday. Now he’s getting older he’s decided to take a back seat in running the company. Cyberbullyinga form of bullying in which people harass and harm other people online deliberately. And unlike the traditional bully, the electronic bully can remain anonymous. So we don’t know who they are.includes things like spreading lies and rumours online, sending or forwarding unpleasant messages via instant messaging, text or on social networks. ExamplesKate is a victim of cyberbullying. It’s so bad she doesn’t want to leave the house. Someone from school has put messages on social media saying she’s ugly and she should die. It’s terrible! Experts say people should protect themselves from cyberbullying by not taking everything to heart. Me timetime we have for ourselves to do just what we want. ExamplesI’ve just sent my mum to a spa in the countryside. She’s been taking care of the whole family and is really in need of some me time! A: Oh, six in the morning! I’m going to be late for work!B: Ignore the alarm clock today. It’s Sunday! Stay in bed till late and have some me time. To drink someone under the tableyou and your friend both drink the same amount of alcohol, your friend will be very drunk, but you will be fine.you’ve got a much higher tolerance of alcohol than another person. ExamplesI do like a gin and tonic after a hard day at work but Alan can drink me under the table! When Beth realised she could drink anyone under the table she decided to stop drinking alcohol and go into rehab. smalls, undiesunderwear ExamplesLinda, hurry up or we’ll miss the plane! Don’t forget to pack your smalls! Billy, don’t walk around the house in your undies. Your granny is coming to visit and she’ll be here at any time. Red tapethe rules and processes required to get official permits - which usually seem to be pointless ExamplesSmall firms won’t be subject to new regulations under a government plan to cut red tape and boost the economy. Andrea almost gave up studying abroad. The amount of red tape to get a visa was unbelievable! The penny droppedsomebody has finally realised or understood something. ExamplesSusan keeps postponing the wedding, Joe. When is the penny going to drop? She doesn’t love you! If your boss doesn’t appreciate you, why not leave a job advert from another company on your desk? That will make the penny drop! Out of juiceWhen you’ve used all the battery power of something like a mobile phone, so that it doesn’t work anymore.sometimes if a person feels low on energy, they could say ‘I’m out of juice’. Also if your car is low on petrol, you could say ‘The car’s running out of juice.’ ExamplesMy laptop’s out of juice. This is so frustrating. I am packing three spare phone batteries so I don’t run out of juice on my climbing trip. Hot deskan increasingly popular way of working to save office space.not like before, where everyone had their own desk, in a hot-desking office there are certain number of desks and computers available for people to use, and anyone who needs them can use them. hot-desking is the noun form of the verb ‘to hot-desk’.The actual desk we use to do hot-desking is called a ‘hot desk’. ExamplesBBC New Broadcasting House is a hot-desking environment. People just sit wherever there is a free computer. Hot desks should be kept clean and tidy at all times because you don’t know who will use them next. Many modern office workers are expected to hot-desk. To keep the wolf from the doorthey’ve only just got enough money to survive. ExamplesI’m going to have to sell my car if I’m to keep the wolf from the door. It’s tough being a student, I study all day then have to do an evening job just to keep the wolf from the door. We’ve only just saved enough money to keep the wolf from the door. Give me creditgive me praise or appreciation for something I’ve done. ExamplesWe must give credit to our sponsors who helped pay for this new building. I’ll give her credit for her beautiful handwriting, but the answers she gave in the test were all wrong! Give me credit - I worked all night to get the project finished! A face for radioan indirect way of saying they are not very good looking! ExamplesMan: Jane looked beautiful at her wedding.Woman: Really? She must have had a good make-up artist because, to be honest, she’s got a face for radio. Man: No one’s going to choose me at this speed-dating event.Woman: Why on earth not? You’re such a warm-hearted guy.Man: Thanks. But you have to admit, I’ve got a face for radio. To know something like the back of your handknow somewhere very well, or to talk about an extremely familiar place.it can used to describe things we know very well. It’s not just limited to places. ExamplesHe knows the building like the back of his hand. She lived in the village all her life, and knows the area like the back of her hand. Jenny knows that book like the back of her hand. She has read it at least twenty times. Max knows the Bond films like the back of his hand; he could recite the whole script of all of them. A barrel of laughsdescribe someone who is fun and always joking around.describe a thing such as TV show. ExamplesI shall miss having John in the office. He was a such a barrel of laughs. What a barrel of laughs that bus driver was. He made the long journey much more fun with his funny announcements! Since I split up with my boyfriend, life hasn’t been a barrel of laughs. Don’t give up the day jobsomeone’s not very good at doing something and isn’t likely ever to be successful at doing it.it’s used in a humorous and light-hearted way. ExamplesI wouldn’t give up the day job - you’re never going to be an actor! Do you really want to be a writer? I’ve read your first book and my advice is ‘don’t give up the day job’! Don’t give up the day job Pete - you’re never going to earn a living as a singer! troll, hater‘hater’ has been used to describe someone who says or writes unpleasant things about others or criticises their achievements, especially on the internet. A troll is an ugly creature from folk tales who often behaves in an antisocial way. But these days we call people who leave deliberately annoying or upsetting messages on the internet - while hiding their true identity – ‘trolls’. ExamplesJoan is fed up with a troll who posts comments on her cooking blog saying that she is fat and should only eat lettuce. Haters will always have something negative to say. As I read in a comment on Pinterest: “Haters will see you walk on water and say it’s because you can’t swim.” Bull and bear marketit’s a bull market when the price of shares on the stock market is rising.it’s a bear market when the price of shares on the stock market is falling. ExamplesStocks rose in early trading. It was a bull market which stunned even the most pessimistic analysts. The financial crisis might be over. The index of the UK’s biggest 100 companies, the FTSE 100, has fallen 15% in the last few months. However, we can only call it a bear market when the index drops 20% or more. It’s a steal!a bargain – so cheap that it’s almost as if you haven’t paid anything for it. ExamplesI got this designer shirt in the sales. At £100 cheaper than the original price it’s a steal! This is the latest model, sir. You won’t find this new computer cheaper in any other shop in the high street. It’s a steal! People personthey are good at dealing with other people. They’re helpful and have the ability to motivate people. ExamplesCallum is a people person. He gets along with everybody and would make a great manager. You know, you should go to the party even if you don’t know anybody there. You’re a people person and by the end of the night you’ll have made lots of new friends.]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SQL进阶教程】用SQL处理数列]]></title>
    <url>%2F2019%2F09%2F10%2F%E3%80%90SQL%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B%E3%80%91%E7%94%A8SQL%E5%A4%84%E7%90%86%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[生成连续编号思考一下如何使用SQL生成连续编号。例如生成0～99这100个连续编号。首先生成一张存储了各个数位上数字的表“数字表”。 这样，就可以通过对两个Digits集合求笛卡尔积而得出0～99的数字。 1234SELECT D1.digit + (D2.digit * 10) AS seqFROM Digits D1CROSS JOIN Digits D2ORDER BY seq; 同样地，通过追加D3、D4等集合，不论多少位的数都可以生成。而且，如果只想生成从1开始，或者到542结束的数，只需要在WHERE子句中加入过滤条件就可以了。 123456SELECT D1.digit + (D2.digit * 10) + (D3.digit * 100) AS seqFROM Digits D1CROSS JOIN Digits D2CROSS JOIN Digits D3WHERE D1.digit + (D2.digit * 10) + (D3.digit * 100) BETWEEN 1 AND 542ORDER BY seq; 通过将这个查询的结果存储在视图里，就可以在需要连续编号时通过简单的SELECT来获取需要的编号。 123456CREATE VIEW Sequence(seq)ASSELECT D1.digit + (D2.digit * 10) + (D3.digit * 100)FROM Digits D1CROSS JOIN Digits D2CROSS JOIN Digits D3; 求全部的缺失编号查找连续编号中的缺失编号。想要知道如何求出全部的缺失编号。作为示例，假设存在下面这样一张编号有缺失的表。 因为表中最小的值是1，最大的值是12，所以可以根据这个范围从序列视图中获取数。 1234567-- EXCEPTSELECT seqFROM SequenceWHERE seq BETWEEN 1 AND 12EXCEPTSELECT seqFROM SeqTbl; 12345-- INSELECT seqFROM SequenceWHERE seq BETWEEN 1 AND 12 AND seq NOT IN (SELECT seq FROM SeqTbl); 可能像下面这么做性能会有所下降，但是通过扩展BETWEEN谓词的参数，可以动态地指定目标表的最大值和最小值。 1234567SELECT seqFROM SequenceWHERE seq BETWEEN (SELECT MIN(seq) FROM SeqTbl) AND (SELECT MAX(seq) FROM SeqTbl) EXCEPTSELECT seqFROM SeqTbl; 这种写法在查询上限和下限未必固定的表时非常方便。如果在“seq”列上建立索引，那么极值函数的运行可以变得更快速。 三个人能坐得下吗假设存在下面这样一张存储了火车座位预定情况的表。 问题是，从1～15的座位编号中，找出连续3个空位的全部组合。假设所有的座位排成了一条直线。希望得到的结果是下面四种。 3～5 7～9 8～10 9～11 1234567SELECT S1.seat AS start_seat, '~', S2.seat AS end_seatFROM Seats S1, Seats S2WHERE S2.seat = S1.seat + (:head_cnt - 1) AND NOT EXISTS (SELECT * FROM Seats S3 WHERE S3.seat BETWEEN S1.seat AND S2.seat AND S3.status &lt;&gt; '未预订'); 其中，“:head_cnt”是表示需要的空位个数的参数。 接下来，看一下升级版，即发生换排的情况。假设这列火车每一排有5个座位。 要想解决换排的问题，除了要求序列内的所有座位全部都是空位，还需要加入“全部都在一排”这样一个条件。 12345678SELECT S1.seat AS start_seat, '~', S2.seat AS end_seatFROM Seats2 S1, Seats2 S2WHERE S2.seat = S1.seat + (:head_cnt - 1) AND NOT EXISTS (SELECT * FROM Seats2 S3 WHERE S3.seat BETWEEN S1.seat AND S2.seat AND (S3.status &lt;&gt; '未预订' OR S3.row_id &lt;&gt; S1.row_id)); 最多能坐下多少人这次要查询的是“按现在的空位状况，最多能坐下多少人”。换句话说，要求的是最长的序列。使用下面这张表Seats3。 就这张表而言，长度为4的序列“2～5”就是答案。针对表Seats3中的数据，要想保证从座位A到另一个座位B是一个序列，则下面的3个条件必须全部都满足。 条件1:起点到终点之间的所有座位状态都是“未预订”。 条件2:起点之前的座位状态不是“未预订”。 条件3:终点之后的座位状态不是“未预订”。 可以先生成一张存储了所有可能序列的视图。有了这个视图之后，只需从中查找出最长的序列就可以了。 123456789101112131415CREATE VIEW Sequences(start_seat, end_seat, seat_cnt)ASSELECT S1.seat AS start_seat, S2.seat AS end_seat, S2.seat - S1.seat + 1 AS seat_cntFROM Seats3 S1, Seats3 S2WHERE S1.seat &lt;= S2.seat AND NOT EXISTS (SELECT * FROM Seats3 S3 WHERE (S3.seat BETWEEN S1.seat AND S2.seat AND S3.status &lt;&gt; '未预订') OR (S3.seat = S2.seat + 1 AND S3.status = '未预订') OR (S3.seat = S1.seat - 1 AND S3.status = '未预订')); 123SELECT start_seat, '~', end_seat, seat_cntFROM SequencesWHERE seat_cnt = (SELECT MAX(seat_cnt) FROM Sequences); 单调递增和单调递减假设存在下面这样一张反映了某公司股价动态的表。 这里，求一下股价单调递增的时间区间。 12345678910SELECT S1.deal_date AS start_date, S2.deal_date AS end_dateFROM MyStock S1, MyStock S2WHERE S1.deal_date &lt; S2.deal_date AND NOT EXISTS (SELECT * FROM MyStock S3, MyStock S4 WHERE S3.deal_date BETWEEN S1.deal_date AND S2.deal_date AND S4.deal_date BETWEEN S1.deal_date AND S2.deal_date AND S3.deal_date &lt; S4.deal_date AND S3.price &gt;= S4.price); 要把不需要的子集排除掉。使用极值函数很容易就能实现。 12345678910111213SELECT MIN(start_date) AS start_date, end_dateFROM (SELECT S1.deal_date AS start_date, MAX(S2.deal_date) AS end_date FROM MyStock S1, MyStock S2 WHERE S1.deal_date &lt; S2.deal_date AND NOT EXISTS (SELECT * FROM MyStock S3, MyStock S4 WHERE S3.deal_date BETWEEN S1.deal_date AND S2.deal_date AND S4.deal_date BETWEEN S1.deal_date AND S2.deal_date AND S3.deal_date &lt; S4.deal_date AND S3.price &gt;= S4.price) GROUP BY S1.deal_date) TMPGROUP BY end_date; 这段代码的关键在于最大限度地延伸起点和终点。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SQL进阶教程】EXISTS谓词的用法]]></title>
    <url>%2F2019%2F09%2F09%2F%E3%80%90SQL%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B%E3%80%91EXISTS%E8%B0%93%E8%AF%8D%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[谓词是一种特殊的函数，返回值是真值。谓词逻辑提供谓词是为了判断命题的真假。参数是行数据的集合。在EXISTS的子查询里，SELECT子句的列表可以有下面这三种写法。 通配符：SELECT * 常量：SELECT ‘这里的内容任意’ 列名：SELECT col 在SQL中，为了表达全称量化，需要将“所有的行都满足条件P”这样的命题转换成“不存在不满足条件P的行”。 查询表中“不”存在的数据在有些情况下，不得不从表中查找出“不存在的数据”。例如下面这样的情况。 求“没有参加某次会议的人”，该怎么做呢？目标结果如下所示，是各次会议缺席者的列表。 思路是先假设所有人都参加了全部会议，并以此生成一个集合，然后从中减去实际参加会议的人，这样就能得到缺席会议的人。 12345678-- 存在量化SELECT DISTINCT M1.meeting, M2.personFROM Meetings M1CROSS JOIN Meetings M2WHERE NOT EXISTS (SELECT * FROM Meetings M3 WHERE M1.meeting = M3.meeting AND M2.person = M3.person); 还可以用集合论的方法，像下面这样使用差集运算。 123456-- 差集运算SELECT M1.meeting, M2.personFROM Meetings M1, Meetings M2EXCEPTSELECT meeting, personFROM Meetings; 通过以上两条SQL语句的比较可以明白，NOT EXISTS直接具备了差集运算的功能。 全称量化（1）：习惯“肯定&lt;-&gt;双重否定”之间的转换这里使用下面这样一张存储了学生考试成绩的表为例。 先来看一个简单的问题：请查询出“所有科目分数都在50分以上的学生”。 123456SELECT DISTINCT student_idFROM TestScores TS1WHERE NOT EXISTS (SELECT * FROM TestScores TS2 WHERE TS1.student_id = TS2.student_id AND TS2.score &lt; 50); 接下来把条件改得复杂一些。思考一下如何查询出满足下列条件的学生。 数学的分数在80分以上。 语文的分数在50分以上。 结果应该是学号分别为100、200、400的学生。 12345678910SELECT DISTINCT student_idFROM TestScores TS1WHERE subject IN ('数学', '语文') AND NOT EXISTS (SELECT * FROM TestScores TS2 WHERE TS1.student_id = TS2.student_id AND 1 = CASE WHEN subject = '数学' AND score &lt; 50 THEN 1 WHEN subject = '语文' AND score &lt; 80 THEN 1 ELSE 0 END); 接下来，思考一下如何排除掉没有语文分数的学号为400的学生。 123456789101112SELECT student_idFROM TestScores TS1WHERE subject IN ('数学', '语文') AND NOT EXISTS (SELECT * FROM TestScores TS2 WHERE TS1.student_id = TS2.student_id AND 1 = CASE WHEN subject = '数学' AND score &lt; 80 THEN 1 WHEN subject = '语文' AND score &lt; 50 THEN 1 ELSE 0 END)GROUP BY student_idHAVING COUNT(*) = 2; 全称量化（2）：集合VS谓词——哪个更强大？EXISTS和HAVING有一个地方很像，即都是以集合而不是个体为单位操作数据。实际上，两者在很多情况下都是可以互换的。接下来通过比较来了解一下它们各自的优点和缺点。假设存在下面这样的项目工程管理表。 这里的问题是，从这张表中查询出哪些项目已经完成到了工程1。 12345678-- 面向集合SELECT project_idFROM ProjectsGROUP BY project_idHAVING COUNT(*) = SUM(CASE WHEN step_nbr &lt;= 1 AND status = '完成' THEN 1 WHEN step_nbr &gt; 1 AND status = '等待' THEN 1 ELSE 0 END); 用谓词逻辑该如何解决呢？ 123456789-- 谓词逻辑SELECT *FROM Projects P1WHERE NOT EXISTS (SELECT status FROM Projects P2 WHERE P1.project_id = P2.project_id AND status &lt;&gt; CASE WHEN step_nbr &lt;= 1 THEN '完成' ELSE '等待' END); 与HAVING相比，使用了NOT EXISTS代码看起来不是那么容易理解，这是它的缺点。但是这种写法也有优点。第一个优点是性能好。只要有一行满足条件，查询就会终止，不一定需要查询所有行的数据。而且还能通过连接条件使用“project_id”列的索引，这样查询起来会更快。第二个优点是结果里包含的信息量更大。如果使用HAVING，结果会被聚合，只能获取到项目ID，而如果使用EXISTS，则能把集合里的元素整体都获取到。 对列进行量化：查询全是1的行 这张表的设计不好的原因是，数组中的元素可以自由地增加或者减少，而表中的列却不能这样。因此在设计表时有一条原则：让列具有一定的扩展性。数组中的元素不应该对应表中的列，而是应该对应行。 在使用这种模拟数组的表时遇到的需求一般都是下面这两种形式。 查询“都是1”的行 查询“至少有一个9”的行 对于这个问题，需要进行“列方向”的量化。 123SELECT *FROM ArrayTblWHERE 1 = ALL (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10); 反过来，如果想表达“至少有一个9”这样的存在量化命题，可以使用ALL的反义谓词ANY。 123SELECT *FROM ArrayTblWHERE 9 = ANY (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10); 或者也可以使用IN谓词代替ANY。 123SELECT *FROM ArrayTblWHERE 9 IN (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10); 但是，如果左边不是具体值而是NULL，这种写法就不行了。这种情况下，需要使用COALESCE函数。 123SELECT *FROM ArrayTblWHERE COALESCE(col1, col2, col3, col4, col5, col6, col7, col8, col9, col10) IS NULL;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 520 - Detect Capital]]></title>
    <url>%2F2019%2F09%2F08%2FLeetCode-Problem-520-Detect-Capital%2F</url>
    <content type="text"><![CDATA[Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like “USA”. All letters in this word are not capitals, like “leetcode”. Only the first letter in this word is capital, like “Google”. Otherwise, we define that this word doesn’t use capitals in a right way. ExampleNo.1Input: “USA” Output: True No.2Input: “FlaG” Output: False NoteThe input will be a non-empty word consisting of uppercase and lowercase latin letters. Code1234567891011public boolean detectCapitalUse(String word) &#123; int n = word.length(); int count = 0; for (char ch : word.toCharArray()) &#123; if (Character.isUpperCase(ch)) count++; &#125; return count == n || count == 0 || (count == 1 &amp;&amp; Character.isUpperCase(word.charAt(0)));&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 506 - Relative Ranks]]></title>
    <url>%2F2019%2F09%2F08%2FLeetCode-Problem-506-Relative-Ranks%2F</url>
    <content type="text"><![CDATA[Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: “Gold Medal”, “Silver Medal” and “Bronze Medal”. ExampleInput: [5, 4, 3, 2, 1] Output: [“Gold Medal”, “Silver Medal”, “Bronze Medal”, “4”, “5”] Explanation: The first three athletes got the top three highest scores, so they got “Gold Medal”, “Silver Medal” and “Bronze Medal”.For the left two athletes, you just need to output their relative ranks according to their scores. Note N is a positive integer and won’t exceed 10,000. All the scores of athletes are guaranteed to be unique. Code12345678910111213141516171819202122232425262728293031323334353637public class Rank &#123; private int idx; private int score; public Rank(int idx, int score) &#123; this.idx = idx; this.score = score; &#125;&#125;public String[] findRelativeRanks(int[] nums) &#123; int n = nums.length; String[] result = new String[n]; Rank[] ranks = new Rank[n]; String[] medals = &#123;"Gold", "Silver", "Bronze"&#125;; for (int i = 0; i &lt; n; i++) ranks[i] = new Rank(i, nums[i]); Arrays.sort(ranks, new Comparator&lt;Rank&gt;() &#123; @Override public int compare(Rank o1, Rank o2) &#123; return o2.score - o1.score; &#125; &#125;); for (int i = 0; i &lt; n; i++) &#123; Rank rank = ranks[i]; if (i &lt; 3) result[rank.idx] = medals[i] + " Medal"; else result[rank.idx] = String.valueOf(i + 1); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 504 - Base 7]]></title>
    <url>%2F2019%2F09%2F08%2FLeetCode-Problem-504-Base-7%2F</url>
    <content type="text"><![CDATA[Given an integer, return its base 7 string representation. ExampleNo.1Input: 100 Output: “202” No.2Input: -7 Output: “-10” NoteThe input will be in range of [-1e7, 1e7]. Code12345678910111213141516public String convertToBase7(int num) &#123; if (num == 0) return "0"; StringBuilder sb = new StringBuilder(); boolean positive = num &gt;= 0; num = Math.abs(num); while (num &gt; 0) &#123; sb.append(num % 7); num /= 7; &#125; String result = sb.reverse().toString(); return positive ? result : "-" + result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SQL进阶教程】用SQL进行集合运算]]></title>
    <url>%2F2019%2F09%2F07%2F%E3%80%90SQL%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B%E3%80%91%E7%94%A8SQL%E8%BF%9B%E8%A1%8C%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[集合运算的几个注意事项顾名思义，集合运算符的参数是集合，从数据库实现层面上来说就是表或者视图。 SQL能操作具有重复行的集合，可以通过可选项ALL来支持 集合运算符为了排除掉重复行，默认地会发生排序，而加上可选项ALL之后，就不会再排序，所以性能会有提升。 集合运算符有优先级 INTERSECT比UNION和EXCEPT优先级更高。 各个DBMS提供商在集合运算的实现程度上参差不齐 除法运算没有标准定义 比较表和表：检查集合相等性之基础篇在迁移数据库的时候，或者需要比较备份数据和最新数据的时候，需要调查两张表是否是相等的，即“是同一个集合”的意思。例如，下面的表tbl_A和tbl_B。 这两张表的行数是3。如果下面这条SQL语句的执行结果是3，则说明两张表是相等的。相反，如果结果大于3，则说明两张表不相等。 1234SELECT COUNT(*) AS row_cntFROM (SELECT * FROM tbl_A UNION SELECT * FROM tbl_B) TMP; 前面的SQL语句可以用于包含NULL数据的表，而且不需要指定列数、列名和数据类型等就能使用。 比较表和表：检查集合相等性之进阶篇在前面的解法中，在比较两张表之前，需要先查一下两张表里数据的行数。改进一下这条SQL语句，利用两个集合的并集和差集来判定其相等性。如果用SQL语言描述，那就是“如果A UNION B = A INTERSECT B，则集合A和集合B相等。”因此，只需要判定(A UNION B) EXCEPT (A INTERSECT B)的结果集是不是空集就可以了。如果A=B，则这个结果集是空集，否则，这个结果集里肯定有数据。 12345678SELECT CASE WHEN COUNT(*) = 0 THEN '相等' ELSE '不相等' END AS resultFROM ((SELECT * FROM tbl_A UNION SELECT * FROM tbl_B) EXCEPT (SELECT * FROM tbl_A INTERSECT SELECT * FROM tbl_B)) TMP; 这条SQL语句与上一部分的SQL语句具有相同的优点，也不需要知道列名和列数，还可以用于包含NULL的表，而且，这个改进版连事先查询两张表的行数这种准备工作也不需要了。但是，虽然功能改进了，却也带来了一些缺陷。由于这里需要进行4次排序（3次集合运算加上1次DISTINCT），所以性能会有所下降。 用差集实现关系除法运算关于示例数据，选用的是下面这两张员工技术信息管理表。 这里的问题是，从表EmpSkills中找出精通表Skills中所有技术的员工。 12345678SELECT DISTINCT empFROM EmpSkills ES1WHERE NOT EXISTS (SELECT skill FROM Skills EXCEPT SELECT skill FROM EmpSkills ES2 WHERE ES1.emp = ES2.emp); 从需求的技术的集合中减去每个员工自己的技术的集合，如果结果是空集，则说明该员工具备所有的需求的技术，否则说明该员工不具备某些需求的技术。 寻找相等的子集使用表示“供应商-零件”关系的表作为示例数据。 需要求的是，经营的零件在种类数和种类上都完全相同的供应商组合。 1234567891011SELECT FROM SupParts SP1, SupParts SP2WHERE SP1.sup &lt; SP2.sup AND SP1.part = SP2.partGROUP BY SP1.sup, SP2.supHAVING COUNT(*) = (SELECT COUNT(*) FROM SupParts SP3 WHERE SP1.sup = SP3.sup) AND COUNT(*) = (SELECT COUNT(*) FROM SupParts SP4 WHERE SP2.sup = SP4.sup); 用于删除重复行的高效SQL看一下没有主键的恐怖的表。 使用关联子查询，代码非常简单。 12345DELETE FROM ProductsWHERE rowid &lt; (SELECT MAX(P2.rowid) FROM Products P2 WHERE P2.name = Products.name AND P2.price = Products.price); 这种做法不算太差，只是关联子查询的性能问题是难点（光是DELETE处理就比较耗时了）。因此，这里思考一下如何不用关联子查询也能实现同样的功能。“使用极值函数让每组只留下一个rowid“这一点与之前的做法一样。不同的是，这次需要把留下的集合从表Products这个集合中减掉。SQL语句如下所示。 12345678-- 通过EXCEPT求补集DELETE FROM ProductsWHERE rowid IN (SELECT rowid FROM Products EXCEPT SELECT MAX(rowid) FROM Products GROUP BY name, price); 此外，把EXCEPT改写成NOT IN也是可以实现的。代码如下所示。 12345-- 通过NOT IN求补集DELETE FROM ProductsWHERE rowid NOT IN (SELECT MAX(rowid) FROM Products GROUP BY name, price); 这两种方法的性能优劣主要取决于表的规模，以及删除的行数与留下的行数之间的比率。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 492 - Construct the Rectangle]]></title>
    <url>%2F2019%2F09%2F07%2FLeetCode-Problem-492-Construct-the-Rectangle%2F</url>
    <content type="text"><![CDATA[For a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements: The area of the rectangular web page you designed must equal to the given target area. The width W should not be larger than the length L, which means L &gt;= W. The difference between length L and width W should be as small as possible. You need to output the length L and the width W of the web page you designed in sequence. ExampleInput: 4 Output: [2, 2] Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1].But according to requirement 2, [1,4] is illegal; according to requirement 3, [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2. Note The given area won’t exceed 10,000,000 and is a positive integer The web page’s width and length you designed must be positive integers. Code12345678910111213public int[] constructRectangle(int area) &#123; int[] result = new int[2]; for (int i = (int) Math.sqrt(area); i &gt;= 1; i--) &#123; if (area % i == 0) &#123; result[0] = area / i; result[1] = i; return result; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 482 - License Key Formatting]]></title>
    <url>%2F2019%2F09%2F07%2FLeetCode-Problem-482-License-Key-Formatting%2F</url>
    <content type="text"><![CDATA[You are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes. Given a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase. Given a non-empty string S and a number K, format the string according to the rules described above. ExampleNo.1Input: S = “5F3Z-2e-9-w”, K = 4 Output: “5F3Z-2E9W” Explanation: The string S has been split into two parts, each part has 4 characters.Note that the two extra dashes are not needed and can be removed. No.2Input: S = “2-5g-3-J”, K = 2 Output: “2-5G-3J” Explanation: The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above. Note The length of string S will not exceed 12,000, and K is a positive integer. String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-). String S is non-empty. Code1234567891011121314public String licenseKeyFormatting(String S, int K) &#123; StringBuilder sb = new StringBuilder(); for (int i = S.length() - 1; i &gt;= 0; i--) &#123; if (S.charAt(i) != '-') &#123; if (sb.length() % (K + 1) == K) sb.append('-'); sb.append(Character.toUpperCase(S.charAt(i))); &#125; &#125; return sb.reverse().toString();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 475 - Heaters]]></title>
    <url>%2F2019%2F09%2F07%2FLeetCode-Problem-475-Heaters%2F</url>
    <content type="text"><![CDATA[Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses. Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters. So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters. Note Numbers of houses and heaters you are given are non-negative and will not exceed 25000. Positions of houses and heaters you are given are non-negative and will not exceed 10^9. As long as a house is in the heaters’ warm radius range, it can be warmed. All the heaters follow your radius standard and the warm radius will the same. ExampleNo.1Input: [1,2,3],[2] Output: 1 Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed. No.2Input: [1,2,3,4],[1,4] Output: 1 Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed. Code12345678910111213141516171819202122232425262728293031public int findRadius(int[] houses, int[] heaters) &#123; int result = 0; int n = heaters.length; Arrays.sort(heaters); for (int house : houses) &#123; int idx = binarySearch(heaters, house); int distance1 = idx &gt; 0 ? house - heaters[idx - 1] : Integer.MAX_VALUE; int distance2 = idx &lt; n ? heaters[idx] - house : Integer.MAX_VALUE; result = Math.max(result, Math.min(distance1, distance2)); &#125; return result;&#125;private int binarySearch(int[] heaters, int house) &#123; int left = 0; int right = heaters.length; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (heaters[mid] &lt; house) left = mid + 1; else right = mid; &#125; return right;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SQL进阶教程】用关联子查询比较行与行]]></title>
    <url>%2F2019%2F09%2F05%2F%E3%80%90SQL%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B%E3%80%91%E7%94%A8%E5%85%B3%E8%81%94%E5%AD%90%E6%9F%A5%E8%AF%A2%E6%AF%94%E8%BE%83%E8%A1%8C%E4%B8%8E%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[关联子查询是一种非常强大的运算，也有一些它的缺点。第一个缺点是代码的可读性不好。第二个缺点是性能不好。特别是在SELECT子句里使用标量子查询时，性能可能会变差。 增长、减少、维持现状假设有下面这样一张记录了某个公司每年的营业额的表Sales。 根据这张表里的数据，使用SQL输出与上一年相比营业额是增加了还是减少了，抑或是没有变化。可以先求出“不变”这种情况。 1234567-- 关联子查询SELECT year, saleFROM Sales S1WHERE sale = (SELECT sale FROM Sales S2 WHERE S1.year - 1 = S2.year)ORDER BY year; 关联子查询和自连接在很多时候都是等价的，所以也可以像下面这样使用自连接来实现。 123456-- 自连接SELECT S1.year, S1.saleFROM Sales S1, Sales S2WHERE S1.year - 1 = S2.year AND S1.sale = S2.saleORDER BY year; 用列表展示与上一年的比较结果1234567891011121314151617-- 关联子查询SELECT S1.year, S1.sale, CASE WHEN sale = (SELECT sale FROM Sales S2 WHERE S2.year = S1.year - 1) THEN '→' WHEN sale &gt; (SELECT sale FROM Sales S2 WHERE S2.year = S1.year - 1) THEN '↑' WHEN sale &lt; (SELECT sale FROM Sales S2 WHERE S2.year = S1.year - 1) THEN '↓' ELSE '-' END AS varFROM Sales S1ORDER BY year; 同样，这里也可以改写一下SQL语句，使用自连接来实现，如下所示。 123456789-- 自连接查询SELECT S1.year, S1.sale, CASE WHEN S1.sale = S2.sale THEN '→' WHEN S1.sale &gt; S2.sale THEN '↑' WHEN S1.sale &lt; S2.sale THEN '↓' ELSE '-' END AS varFROM Sales S1, Sales S2WHERE S2.year = S1.year - 1ORDER BY year; 采用这种实现方法时，由于这里没有1990年之前的数据，所以1990年会被排除掉，执行结果会少一行。 时间轴有间断时：和过去最临近的时间进行比较比如丢失了过去个别年份的数据，如表Sales2所示。 对某一年来说，“过去最临近的年份”需要满足下面两个条件。 与该年份相比是过去的年份。 在满足条件1的年份中，年份最早的一个。 如果按这两个条件改写SQL语句，那么应该像下面这样写。 12345678SELECT year, saleFROM Sales2 S1WHERE sale = (SELECT sale FROM Sales2 S2 WHERE S2.year = (SELECT MAX(year) FROM Sales2 S3 WHERE S1.year &gt; S3.year))ORDER BY year; 如果使用自连接，可以减少一层子查询的嵌套。 12345678SELECT S1.year AS year, S1.sale AS saleFROM Sales2 S1, Sales2 S2WHERE S1.sale = S2.sale AND S2.year = (SELECT MAX(year) FROM Sales2 S3 WHERE S1.year &gt; S3.year)ORDER BY year; 通过这个方法，可以查询每一年与过去最临近的年份之间的营业额之差。 12345678910SELECT S2.year AS pre_year, S1.year AS now_year, S2.sale AS pre_sale, S1.sale AS now_sale, S1.sale - S2.sale AS diffFROM Sales2 S1, Sales2 S2WHERE S2.year = (SELECT MAX(year) FROM Sales2 S3 WHERE S1.year &gt; S3.year)ORDER BY year; 如果想让结果里出现1990年的数据，可以使用“自外连接”来实现。 1234567891011SELECT S2.year AS pre_year, S1.year AS now_year, S2.sale AS pre_sale, S1.sale AS now_sale, S1.sale - S2.sale AS diffFROM Sales2 S1LEFT OUTER JOIN Sales2 S2 ON S2.year = (SELECT MAX(year) FROM Sales2 S3 WHERE S1.year &gt; S3.year)ORDER BY year; 因为使用极值函数时会发生排序，所以这个方法在性能方面稍微逊色（如果极值函数的参数是主键，有时也是可以使用索引的）。 移动累计值和移动平均值例如下面有一张银行账户存取款历史记录表Accounts，现在思考一下如何求出累计值。 1234-- 窗口函数SELECT prc_date, prc_amt, SUM(prc_amt) OVER (ORDER BY prc_date) AS onhand_amtFROM Accounts; 使用窗口函数来实现的代码非常简洁，而且从性能方面来看，表的扫描和数据排序也都只进行了一次。 1234567-- 冯诺依曼型递归集合SELECT prc_date, A1.prc_amt, (SELECT SUM(prc_amt) FROM Accounts A2 WHERE A1.prc_date &gt;= A2.prc_date) AS onhand_amtFROM Accounts A1ORDER BY prc_date; 冯诺依曼型递归集合也是可以用来求累计值的。 接下来，考虑一下如何以3次处理为单位求累计值，即移动累计值。 如果使用窗口函数，可以像下面这样通过指定ROWS关键字来指定数据行数。 123SELECT prc_date, prc_amt, SUM(prc_amt) OVER (ORDER BY prc_date ROWS 2 PRECEDING) AS onhand_amtFROM Accounts; 如果使用关联子查询，还可以像下面这样用标量子查询来计算行数。 123456789SELECT prc_date, prc_amt, (SELECT SUM(prc_amt) FROM Accounts A2 WHERE A1.prc_date &gt;= A2.prc_date AND (SELECT COUNT(*) FROM Accounts A3 WHERE A3.prc_date BETWEEN A2.prc_date AND A1.prc_date) &lt;= 3) AS mvg_sumFROM Accounts A1ORDER BY prc_date; 在处理前2行时，即使数据不满3行，这条SQL语句还是计算出了相应的累计值。其实，可以将这样的情况作为无效来处理。 12345678910SELECT prc_date, prc_amt, (SELECT SUM(prc_amt) FROM Accounts A2 WHERE A1.prc_date &gt;= A2.prc_date AND (SELECT COUNT(*) FROM Accounts A3 WHERE A3.prc_date BETWEEN A2.prc_date AND A1.prc_date) &lt;= 3 HAVING COUNT(*) = 3) AS mvg_sumFROM Accounts A1ORDER BY prc_date; 查询重叠的时间区间假设有下面这样一张表Reservations，记录了酒店或者旅馆的预约情况。 那么，正常情况下，每天只能有一组客人在该房间住宿。从表中数据可以看出，这里存在重叠的预定日期。下面，给重叠的住宿日期分类，可知一共有下面三种类型。 充要条件是满足类型（1）和类型（2）中至少一个条件。 1234567SELECT reserver, start_date, end_dateFROM Reservations R1WHERE EXISTS (SELECT * FROM Reservations R2 WHERE R1.reserver &lt;&gt; R2.reserver AND (R1.start_date BETWEEN R2.start_date AND R2.end_date OR R1.end_date BETWEEN R2.start_date AND R2.end_date)); 如果山本的入住日期不是11月3号，而是推迟了一天，即11月4号，那么像内田这种自己的住宿期间完全包含了他人的住宿期间的情况，会被这条SQL语句排除掉。如果想把这样的住宿期间也输出，需要追加条件。 123456789SELECT reserver, start_date, end_dateFROM Reservations R1WHERE EXISTS (SELECT * FROM Reservations R2 WHERE R1.reserver &lt;&gt; R2.reserver AND ((R1.start_date BETWEEN R2.start_date AND R2.end_date OR R1.end_date BETWEEN R2.start_date AND R2.end_date) OR (R2.start_date BETWEEN R1.start_date AND R1.end_date AND R2.end_date BETWEEN R1.start_date AND R1.end_date)));]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SQL进阶教程】外连接的用法]]></title>
    <url>%2F2019%2F09%2F04%2F%E3%80%90SQL%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B%E3%80%91%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[用外连接进行行列转换（1）（行-&gt;列）：制作交叉表这里有一张用于管理员工学习过的培训课程的表，如下所示。 利用上面这张表生成下面这样一张交叉表（“课程学习记录一览表”）。 123456789-- 外连接SELECT C0.name, CASE WHEN C1.name IS NOT NULL THEN 'O' ELSE NULL END AS 'SQL入门', CASE WHEN C2.name IS NOT NULL THEN 'O' ELSE NULL END AS 'UNIX基础', CASE WHEN C3.name IS NOT NULL THEN 'O' ELSE NULL END AS 'JAVA中级'FROM (SELECT DISTINCT name FROM Courses) C0LEFT OUTER JOIN (SELECT name FROM Courses WHERE course = 'SQL入门') C1 ON C0.name = C1.nameLEFT OUTER JOIN (SELECT name FROM Courses WHERE course = 'UNIX基础') C2 ON C0.name = C2.nameLEFT OUTER JOIN (SELECT name FROM Courses WHERE course = 'JAVA中级') C3 ON C0.name = C3.name; 这种做法具有比较直观和易于理解的优点，但是因为大量用到了内嵌视图和连接操作，代码会显得很臃肿。而且，随着表头列数的增加，性能也会恶化。 一般情况下，外连接都可以用标量子查询替代，因此可以像下面这样写。 123456789101112131415-- 标量子查询SELECT C0.name, (SELECT 'O' FROM Courses C1 WHERE course = 'SQL入门' AND C0.name = C1.name) AS 'SQL入门', (SELECT 'O' FROM Courses C2 WHERE course = 'UNIX基础' AND C0.name = C2.name) AS 'UNIX基础', (SELECT 'O' FROM Courses C3 WHERE course = 'JAVA中级' AND C0.name = C3.name) AS 'JAVA中级'FROM (SELECT DISTINCT name FROM Courses) C0; 这种做法不仅利于应对需求变更，对于需要动态生成SQL的系统也是很有好处的。缺点是性能不太好，目前在SELECT子句中使用标量子查询（或者关联子查询）的话，性能开销还是相当大的。 12345678910-- CASE表达式SELECT name, CASE WHEN SUM(CASE WHEN course = 'SQL入门' THEN 1 ELSE NULL END) = 1 THEN 'O' ELSE NULL END AS 'SQL入门', CASE WHEN SUM(CASE WHEN course = 'UNIX基础' THEN 1 ELSE NULL END) = 1 THEN 'O' ELSE NULL END AS 'UNIX基础', CASE WHEN SUM(CASE WHEN course = 'JAVA中级' THEN 1 ELSE NULL END) = 1 THEN 'O' ELSE NULL END AS 'JAVA中级'FROM Courses GROUP BY name; 用外连接进行行列转换（2）（列-&gt;行）：汇总重复项于一列假设存在下面这样一张表。 需要做的是将这张表转换成行格式的数据。不过，根据具体需求，有时需要把没有孩子的吉田也留在表里，像下面这张“员工子女列表”这样。 1234567891011CREATE VIEW Children(child)AS SELECT child_1 FROM PersonnelUNIONSELECT child_2 FROM PersonnelUNIONSELECT child_3 FROM Personnel;SELECT EMP.employee, CHILDREN.childFROM Personnel EMPLEFT OUTER JOIN Children ON CHILDREN.child IN (EMP.child_1, EMP.child_2, EMP.child_3); 在交叉表里制作嵌套式表侧栏在生成统计表的工作中，经常会有制作嵌套式表头和表侧栏的需求。例如：表TblPop是一张按照县、年龄层级和性别统计的人口分布表，要求根据表TblPop生成交叉表“包含嵌套式表侧栏的统计表”。 12345678910111213SELECT MASTER.age_class AS age_class, MASTER.sex_cd AS sex_cd, DATA.pop_tohoku AS pop_tohoku, DATA.pop_kanto AS pop_kantoFROM (SELECT age_class, sex_cd FROM TblAge CROSS JOIN TblSex) MASTERLEFT OUTER JOIN (SELECT age_class, sex_cd, SUM(CASE WHEN pref_name IN ('秋田', '青森') THEN population ELSE NULL END) AS pop_tohoku, SUM(CASE WHEN pref_name IN ('东京', '千叶') THEN population ELSE NULL END) AS pop_kanto FROM TblPop GROUP BY age_class, sex_cd) DATA ON MASTER.age_class = DATA.age_class AND MASTER.sex_cd = DATA.sex_cd; 技巧是对表TblAge和表TblSex进行交叉连接运算，生成笛卡尔积。 作为乘法运算的连接有下面的商品主表和商品销售历史管理表。 使用这两张表生成一张统计表，以商品为单位汇总出各自的销量。 1234567-- 通过在连接前聚合来创建一对一的关系SELECT I.item_no, SH.total_qtyFROM Items ILEFT OUTER JOIN (SELECT item_no, SUM(quantity) AS total_qty FROM SalesHistory GROUP BY item_no) SH ON I.item_no = SH.item_no; 这种做法的确是正确的，代码也很容易理解。但是，如果从性能角度考虑，这条SQL语句还是有些问题的。比如临时视图SH的数据需要临时存储在内存里，还有就是虽然通过聚合将item_no变成了主键，但是SH上却不存在主键索引，因此也就无法利用索引优化查询。 12345-- 先进行一对多的连接再聚合SELECT I.item_no, SUM(SH.quantity) AS total_qtyFROM Items ILEFT OUTER JOIN SalesHistory SH ON I.item_no = SH.item_noGROUP BY I.item_no; 这种做法代码更简洁，而且没有使用临时视图，所以性能也会有所改善。技巧是一对一或一对多关系的两个集合，在进行连接操作后行数不会（异常地）增加。 全外连接全外连接是能够从这样两张内容不一致的表里，没有遗漏地获取全部信息的方法，所以也可以理解成“把两张表都当作主表来使用”的连接。 12345SELECT COALESCE(A.id, B.id) AS id, A.name AS A_name, B.name AS B_nameFROM Class_A AFULL OUTER JOIN Class_B B ON A.id = B.id; 用外连接求差集：A-B1234SELECT A.id AS id, A.name AS A_nameFROM Class_A ALEFT OUTER JOIN Class_B B ON A.id = B.idWHERE B.name IS NULL; 用外连接求差集：B-A1234SELECT B.id AS id, B.name AS B_nameFROM Class_A ARIGHT OUTER JOIN Class_B B ON A.id = B.idWHERE A.name IS NULL; 用全外连接求异或集SQL没有定义求异或集的运算符。如果用集合运算符，可以有两种方法。一种是(A UNION B) EXCEPT (A INTERSECT B)，另一种是(A EXCEPT B) UNION (B EXCEPT A)。两种方法都比较麻烦，性能开销也会增大。 123456SELECT COALESCE(A.id, B.id) AS id, COALESCE(A.name, B.name) AS nameFROM Class_A AFULL OUTER JOIN Class_B B ON A.id = B.idWHERE A.name IS NULL OR B.name IS NULL: 用外连接求集合的商使用“HAVING子句的力量”里的表Items和表ShopItems，可以像下面这样写。 12345678SELECT DISTINCT shopFROM ShopItems SI1WHERE NOT EXISTS (SELECT I.item FROM Items I LEFT OUTER JOIN ShopItems SI2 ON SI2.item = I.item AND SI1.shop = SI2.shop WHERE SI2.item IS NULL);]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 459 - Repeated Substring Pattern]]></title>
    <url>%2F2019%2F09%2F04%2FLeetCode-Problem-459-Repeated-Substring-Pattern%2F</url>
    <content type="text"><![CDATA[Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000. ExampleNo.1Input: “abab” Output: True Explanation: It’s the substring “ab” twice. No.2Input: “aba” Output: False No.3Input: “abcabcabcabc” Output: True Explanation: It’s the substring “abc” four times. (And the substring “abcabc” twice.) Code123456789101112131415161718192021public boolean repeatedSubstringPattern(String s) &#123; int n = s.length(); StringBuilder sb = new StringBuilder(s); for (int i = n / 2; i &gt;= 1; i--) &#123; if (n % i == 0) &#123; String str = sb.substring(0, i); int j = 1; for (; j &lt; n / i; j++) &#123; if (!str.equals(sb.substring(j * i, j * i + i))) break; &#125; if (j == n / i) return true; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 455 - Assign Cookies]]></title>
    <url>%2F2019%2F09%2F04%2FLeetCode-Problem-455-Assign-Cookies%2F</url>
    <content type="text"><![CDATA[Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number. NoteYou may assume the greed factor is always positive.You cannot assign more than one cookie to one child. ExampleNo.1Input: [1,2,3], [1,1] Output: 1 Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.You need to output 1. No.2Input: [1,2], [1,2,3] Output: 2 Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.You have 3 cookies and their sizes are big enough to gratify all of the children,You need to output 2. Code123456789101112public int findContentChildren(int[] g, int[] s) &#123; int i = 0; Arrays.sort(g); Arrays.sort(s); for (int j = 0; i &lt; g.length &amp;&amp; j &lt; s.length; j++) &#123; if (s[j] &gt;= g[i]) i++; &#125; return i;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SQL进阶教程】HAVING子句的力量]]></title>
    <url>%2F2019%2F09%2F03%2F%E3%80%90SQL%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B%E3%80%91HAVING%E5%AD%90%E5%8F%A5%E7%9A%84%E5%8A%9B%E9%87%8F%2F</url>
    <content type="text"><![CDATA[表的记录是没有顺序的，而且SQL也没有排序的运算符。SQL会将多条记录作为一个集合来处理。 寻找缺失的编号假设现有一张带有“连续编号”列的表，如表SeqTbl所示。查询这张表里是否存在数据丢失。 如果将表整体看作一个集合，就可以像下面这样解决这个问题。 123SELECT '存在缺失的编号' AS gapFROM SeqTblHAVING COUNT(*) &lt;&gt; MAX(seq); 如果这个查询结果有1行，说明存在缺失的编号；如果1行都没有，说明不存在缺失的编号。 接下来，再来查询一下缺失编号的最小值。像下面这样写SQL语句。 123SELECT MIN(seq + 1) AS gapFROM SeqTblWHERE (seq + 1) NOT IN (SELECT seq FROM SeqTbl); 如果没有缺失的编号，则查询到的结果是最大编号8的下一个编号9。 然而这两个查询还不够周全，并不能涵盖所有的情况。 用HAVING子句进行子查询：求众数 就上面的表Graduates来说，众数就是10000和20000这两个值。接下来思考一下如何用SQL求众数。 1234567-- 谓词SELECT income, COUNT(*) AS cntFROM GraduatesGROUP BY incomeHAVING COUNT(*) &gt;= ALL (SELECT COUNT(*) FROM Graduates GROUP BY income); 可以用极值函数来代替。 12345678-- 极值函数SELECT income, COUNT(*) AS cntFROM GraduatesGROUP BY incomeHAVING COUNT(*) &gt;= (SELECT MAX(cnt) FROM (SELECT COUNT(*) AS cnt FROM Graduates GROUP BY income) TMP); 用HAVING子句进行自连接：求中位数前面的表Graduates里有10行数据，所以取“史密斯，20000”和“劳伦斯，15000”的平均值17500作为中位数。来思考一下如何来查询位于集合正中间的元素。做法是，将集合里的元素按照大小分为上半部分和下半部分两个子集，同时让这2个子集共同拥有集合正中间的元素。这样，共同部分的元素的平均值就是中位数。 123456SELECT AVG(DISTINCT income)FROM (SELECT T1.income FROM Graduates T1, Graduates T2 GROUP BY T1.income HAVING SUM(CASE WHEN T1.income &lt;= T2.income THEN 1 ELSE 0 END) &gt;= COUNT(*) / 2 AND SUM(CASE WHEN T1.income &gt;= T2.income THEN 1 ELSE 0 END) &gt;= COUNT(*) / 2) TMP; 查询不包含NULL的集合这里有一张存储了学生提交报告的日期的表Students，如下所示。 现在需要从这张表里找出哪些学院的学生全部都提交了报告。 12345-- COUNT函数SELECT dptFROM StudentsGROUP BY dptHAVING COUNT(*) = COUNT(sbmt_date); 当然使用CASE表达式也可以实现同样的功能。 12345-- CASE表达式SELECT dptFROM StudentsGROUP BY dptHAVING COUNT(*) = SUM(CASE WHEN sbmt_date IS NOT NULL THEN 1 ELSE 0 END); 用关系除法运算进行购物篮分析假设有这样两张表：全国连锁折扣店的商品表Items，以及各个店铺的库存管理表ShopItems。 要查询的是囊括了表Items中所有商品的店铺。SQL语句可以像下面这样写。 12345SELECT SI.shopFROM ShopItems SI, Items IWHERE SI.item = I.itemGROUP BY SI.shopHAVING COUNT(SI.item) = (SELECT COUNT(item) FROM Items); 接下来把条件变一下，只选择没有剩余商品的店铺。解决这个问题需要使用外连接。 123456SELECT SI.shopFROM ShopItems SILEFT OUTER JOIN Items I ON SI.item = I.itemGROUP BY SI.shopHAVING COUNT(SI.item) = (SELECT COUNT(item) FROM Items) AND COUNT(I.item) = (SELECT COUNT(item) FROM Items);]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 462 - Minimum Moves to Equal Array Elements II]]></title>
    <url>%2F2019%2F09%2F03%2FLeetCode-Problem-462-Minimum-Moves-to-Equal-Array-Elements-II%2F</url>
    <content type="text"><![CDATA[Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1. You may assume the array’s length is at most 10,000. ExampleInput:[1,2,3] Output:2 Explanation:Only two moves are needed (remember each move increments or decrements one element):[1,2,3] =&gt; [2,2,3] =&gt; [2,2,2] Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public int minMoves2(int[] nums) &#123; int result = 0; int n = nums.length; int median = quickSelect(nums, n / 2, 0, n - 1); for (int num : nums) result += Math.abs(num - median); return result;&#125;private int quickSelect(int[] nums, int k, int start, int end) &#123; if (start == end) return nums[start]; int i = partition(nums, start, end); if (i == k) return nums[k]; else if (i &gt; k) return quickSelect(nums, k, start, i - 1); else return quickSelect(nums, k, i + 1, end);&#125;private int partition(int[] nums, int left, int right) &#123; int pivot = left; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; nums[left] &lt; nums[pivot]) left++; while (left &lt; right &amp;&amp; nums[right] &gt;= nums[pivot]) right--; swap(nums, left, right); &#125; swap(nums, left, pivot); return left;&#125;private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 453 - Minimum Moves to Equal Array Elements]]></title>
    <url>%2F2019%2F09%2F03%2FLeetCode-Problem-453-Minimum-Moves-to-Equal-Array-Elements%2F</url>
    <content type="text"><![CDATA[Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. ExampleInput:[1,2,3] Output:3 Explanation:Only three moves are needed (remember each move increments two elements):[1,2,3] =&gt; [2,3,3] =&gt; [3,4,3] =&gt; [4,4,4] Code1234567891011121314// 1. S + (n – 1) * m = x * n// 2. min + m = x// m = S – n * minpublic int minMoves(int[] nums) &#123; int sum = 0; int min = Integer.MAX_VALUE; for (int num : nums) &#123; sum += num; min = Math.min(min, num); &#125; return sum - nums.length * min;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 447 - Number of Boomerangs]]></title>
    <url>%2F2019%2F09%2F03%2FLeetCode-Problem-447-Number-of-Boomerangs%2F</url>
    <content type="text"><![CDATA[Given n points in the plane that are all pairwise distinct, a “boomerang” is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters). Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive). ExampleInput:[[0,0],[1,0],[2,0]] Output:2 Explanation:The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]] Code123456789101112131415161718192021222324public int numberOfBoomerangs(int[][] points) &#123; int result = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; points.length; i++) &#123; for (int j = 0; j &lt; points.length; j++) &#123; int distance = getDistance(points[i], points[j]); map.put(distance, map.getOrDefault(distance, 0) + 1); &#125; for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) result += entry.getValue() * (entry.getValue() - 1); map.clear(); &#125; return result;&#125;private int getDistance(int[] a, int[] b) &#123; int x = a[0] - b[0]; int y = a[1] - b[1]; return x * x + y * y;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 443 - String Compression]]></title>
    <url>%2F2019%2F09%2F03%2FLeetCode-Problem-443-String-Compression%2F</url>
    <content type="text"><![CDATA[Given an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1. After you are done modifying the input array in-place, return the new length of the array. Follow upCould you solve it using only O(1) extra space? ExampleNo.1Input:[“a”,”a”,”b”,”b”,”c”,”c”,”c”] Output:Return 6, and the first 6 characters of the input array should be: [“a”,”2”,”b”,”2”,”c”,”3”] Explanation:“aa” is replaced by “a2”. “bb” is replaced by “b2”. “ccc” is replaced by “c3”. No.2Input:[“a”] Output:Return 1, and the first 1 characters of the input array should be: [“a”] Explanation:Nothing is replaced. No.3Input:[“a”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”] Output:Return 4, and the first 4 characters of the input array should be: [“a”,”b”,”1”,”2”]. Explanation:Since the character “a” does not repeat, it is not compressed. “bbbbbbbbbbbb” is replaced by “b12”.Notice each digit has it’s own entry in the array. Note All characters have an ASCII value in [35, 126]. 1 &lt;= len(chars) &lt;= 1000. Code12345678910111213141516171819public int compress(char[] chars) &#123; int n = chars.length; int idx = 0; for (int i = 0, j = 0; i &lt; n; i = j) &#123; while (j &lt; n &amp;&amp; chars[i] == chars[j]) j++; chars[idx++] = chars[i]; if (j - i == 1) continue; for (char ch : String.valueOf(j - i).toCharArray()) chars[idx++] = ch; &#125; return idx;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SQL进阶教程】三值逻辑和NULL]]></title>
    <url>%2F2019%2F09%2F02%2F%E3%80%90SQL%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B%E3%80%91%E4%B8%89%E5%80%BC%E9%80%BB%E8%BE%91%E5%92%8CNULL%2F</url>
    <content type="text"><![CDATA[NULL既不是值也不是变量。NULL只是一个表示“没有值”的标记。对NULL使用比较谓词后得到的结果总是unknown。真值unknown是因关系数据库采用了NULL而被引入的的“第三个真值”，是明确的布尔型的真值。 要想解决NULL带来的各种问题，最佳方法应该是往表里添加NOT NULL约束来尽力排除NULL。 比较谓词和NULL（1）：排中律不成立假设约翰是一个人。那么，下面的语句是真是假？ 约翰是20岁，或者不是20岁，二者必居其一。 如果排中律在SQL里也成立，那么下面的查询应该能选中表里的所有行。 1234SELECT *FROM StudentsWHERE age = 20 OR age &lt;&gt; 20; 遗憾的是，在SQL的世界里，排中律是不成立的。假设表Students里的数据如下所示。 那么这条SQL语句无法查询到约翰，因为约翰年龄不详。SQL语句的查询结果里只有判断结果为true的行。要想让约翰出现在结果里，需要添加下面这样的“第3个条件”。 12345SELECT *FROM StudentsWHERE age = 20 OR age &lt;&gt; 20 OR age IS NULL; 比较谓词和NULL（2）：CASE表达式和NULL首先看下面的简单CASE表达式。 1234CASE col_1 WHEN 1 THEN 'O' WHEN NULL THEN 'X'END 这个CASE表达式一定不会返回X。CASE表达式的判断方法与WHERE子句一样，只认可真值为true的条件。正确的写法是像下面这样使用搜索CASE表达式。 123CASE WHEN col_1 = 1 THEN 'O' WHEN col_1 IS NULL THEN 'X'END NOT IN和NOT EXISTS不是等价的在对SQL语句进行性能优化时，经常用到的一个技巧是将IN改写成EXISTS。这是等价改写，并没有什么问题。问题在于，将NOT IN改写成NOT EXISTS时，结果未必一样。例如，看下面这两张班级学生表。 考虑一下如何根据这两张表查询“与B班住在东京的学生年龄不同的A班学生”。如果单纯地按照这个条件去实现，则SQL语句如下所示。 12345SELECT * FROM Class_AWHERE age NOT IN (SELECT age FROM Class_B WHERE city = '东京'); 遗憾的是这条SQL语句的结果是空，查询不到任何数据。如果NOT IN子查询中用到的表里被选择的列中存在NULL，则SQL语句整体的查询结果永远是空。 为了得到正确的结果，需要使用EXISTS谓词。 123456SELECT * FROM Class_A AWHERE NOT EXISTS (SELECT * FROM Class_B B WHERE A.age = B.age AND B.city = '东京'); 产生这样的结果，是因为EXISTS谓词永远不会返回unknown。EXISTS只会返回true或者false。 限定谓词和NULLSQL里有ALL和ANY两个限定谓词。ALL可以和比较谓词一起使用，用来表达“与所有的XX都相等”，或“比所有的XX都大”的意思。思考一下用于查询“比B班住在东京的所有学生年龄都小的A班学生”的SQL语句。 12345SELECT *FROM Class_AWHERE age &lt; ALL (SELECT age FROM Class_B WHERE city = '东京'); 如果山田年龄不详，就会有问题了。这条SQL语句的执行结果还是空。这时因为，ALL谓词其实是多个以AND连接的逻辑表达式的省略写法。 限定谓词和极值函数不是等价的使用极值函数可以代替ALL谓词。如果用极值函数重写刚才的SQL，应该是下面这样。 12345SELECT *FROM Class_AWHERE age &lt; (SELECT MIN(age) FROM Class_B WHERE city = '东京'); 没有问题。即使山田的年龄无法确定，这段代码也能查询到拉里和伯杰两人。这是因为，极值函数在统计时会把NULL的数据排除掉。 ALL谓词和极值函数表达的命题含义分别如下所示。 ALL谓词：他的年龄比在东京住的所有学生都小极值函数：他的年龄比在东京住的年龄最小的学生还要小 其实还有一种情况下，它们也是不等价的。谓词（或者函数）的输入为空集的情况。例如Class_B这张表为如下所示的情况。 这时，使用ALL谓词的SQL语句会查询到A班的所有学生。然而，用极值函数查询时一行数据都查询不到。这时因为，极值函数在输入为空表（空集）时会返回NULL。 聚合函数和NULL实际上，当输入为空表时返回NULL的不只是极值函数，COUNT以外的聚合函数也是如此。所以下面这条看似普通的SQL语句也会带来意想不到的结果。 12345SELECT *FROM Class_AWHERE age &lt; (SELECT AVG(age) FROM Class_B WHERE city = '东京'); 没有住在东京的学生时，AVG函数返回NULL，也就查询不到行。使用SUM也是一样。 聚合函数和极值函数的这个陷阱是由函数自身带来的，所以仅靠为具体列加上NOT NULL约束是无法从根本上消除的。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The English We Speak 2]]></title>
    <url>%2F2019%2F09%2F02%2FThe-English-We-Speak-2%2F</url>
    <content type="text"><![CDATA[To downsizeto describe cutting a number of jobs and making employees redundant.some people have started applying the term to their own situations. ExamplesThe growth of online sales in the UK has forced many retail businesses to downsize. Some of them have reduced their number of outlets in the high street. Now that I am going to university, my parents have decided to downsize. They are selling the house, moving to a flat and using some of the money to travel the world. Stab in the backto betray someone. ExamplesA lot of young people think you have to stab people in the back to get ahead in business, but you don’t. She told me she was in love with me, but then she stabbed me in the back and went out with Dave. I wouldn’t trust Laura if I were you. She’s nice to your face, but then she stabs you in the back. Full-onit was very intense.Some people are a bit full-on. A bit extreme. Not relaxing.Work can also be full-on when it’s busy. ExamplesManHave a good holiday?WomanTo be honest, not really. We were up at 6am every day to get as much sightseeing done as possible and didn’t get to bed till midnight. It was so full-on. I feel like I need another holiday. I really don’t like children’s parties. All those excited, screaming kids. It’s too full-on. London’s too full-on. I need to move to the countryside. Wow factoranything or anyone that is surprisingly good or impressive. ExamplesHe’s just bought a new Italian sports car – it’s really got the wow factor. We’re going to completely re-decorate the restaurant so there’s more of a wow factor when you walk in. Your CV looks OK. Your work experience is solid, but there’s no real wow factor that will impress employers. Game changersomething that is so new and different, it changes the rules of the game.It could be technology or a person with new ideas, or a new direction in music or fashion. Any new innovation that changes the current situation. ExamplesThe Beatles’ album Sergeant Pepper was a real game changer – it transformed pop music forever. Our company needs a game changer – someone who can come in and rethink the way we do everything. Last year my boss said we could all work from home whenever we needed to. It’s been a real game changer in the way we work. Out for the countthey were so tired from all the exercise that they fell asleep immediately their heads touched the pillows.This expression comes from the sport of boxing and describes a boxer who has been knocked unconscious who can’t stand up within a count of ten seconds. The boxer is said to be “out for the count” and loses the match. ExamplesJack had so much to drink last night that when he got home he was out for the count. There was some trouble outside my house last night but I didn’t hear it: I was so tired I was out for the count. Mind-blowingwhen something is so incredible, so surprising that we stop and wonder about how amazing it is, we can say it’s mind-blowing, or that it blew our minds, as though our brains have broken down because they are so overwhelmed. ExamplesThe latest tablet computer has an incredible camera and loads of other mind-blowing features. One of the most mind-blowing things about the universe is the distance between the planets. The battle scenes in the film were amazing. They just blew my mind. To be on the ballyou are alert and quick to react to things.‘to keep your eye on the ball’ which has a very similar meaning. ExamplesThe interviewer raised tough questions but Ma Yun was on the ball. Financial management is not a job that everyone can do. You have to keep your eye on the ball at all times. To keep a lid on itkeep it secret – or keep it quiet about it.keep something strongly under control. ExamplesWe need to keep a lid on the company merger – if the newspapers get to hear about this, our share price will drop. Our baby is due in November but keep a lid on the news – we haven’t told our parents yet. Please – keep a lid on your emotions – otherwise the waiter is going to ask us to leave! To take a shot / stab in the darkyou don’t really know the truth and you are just guessing. ExamplesIt might be a stab in the dark but I think my football team is in a good place to win the league this season. I don’t know how many people came to see the show, but I’ll take a stab in the dark and say about 300. John thought we could sell our old car for £500 – but really he was taking a stab in the dark! A wild cardhe is unpredictable, so we’re not sure how he’s going to behave in the future. ExamplesWe’re taking a gamble, she’s a wild card, but let’s hope she delivers what she promises. Jack is too much of a wild card to get a place on our team. The wild card in this competition is Chelsea: nobody really knows which way the score will go. Put a sock in it!‘be quiet’! It’s an impolite way of saying ‘stop talking’!keep the noise down. ExamplesPut a sock in it! We’re trying to do some work here! Oh, put a sock in it! I’ve already said I’m going to do the washing-up later. My Dad was telling me how I should work harder at school so I told him to ‘put a sock in it!’ Chill pillto calm down and relax. ExamplesStop shouting at the referee and take a chill pill. She was getting so stressed about what her boss said to her that I told her to just take a chill pill – everything would be fine. My wife’s working so hard, she needs to take a chill pill, otherwise she’ll make herself ill. Done and dustedsomething has been completed successfully, there’s no more work to be done on it. ExamplesThe dispute between me and the council about my parking ticket has been resolved. It’s done and dusted. After two months of hard work, the project is finally done and dusted. About this logo design… as far as I’m concerned, it’s done and dusted. To go around the housesyou don’t have to waste time saying lots of unimportant things before you actually say what you want to say. ExamplesDon’t go around the houses; just tell me straight, what have you done? He went all around the houses talking about the match but all I wanted to know was who won? I didn’t know how to tell him he’d failed his exams so I went all around the houses before I let him know. All over the placesomeone is disorganised and confused – they are all over the place.things are left in many places in an untidy way – your things are all over the place! ExamplesDon’t expect Simon to help you with your report. He’s all over the place right now - he can’t even finish his own work. What a windy day. My hair’s all over the place! To sleep on itthey’re going to spend some time thinking about something before making a final decision. ExamplesWe couldn’t decide which car to buy so we decided to sleep on it - we didn’t want to buy the wrong one! Thanks for your job offer but I need some time to think about it. Let me sleep on it and I’ll give you an answer tomorrow. He told me he’d have to sleep on it before he could agree to my request for a pay rise. My mind’s gone blanksuddenly you’ve completely forgotten what you were about to do or say. ExamplesI didn’t do well in the job interview. When they asked me why I wanted to work there my mind went blank. I wasn’t sure why I’d applied for that particular job at all! Alan failed the exam. He studied hard but when he got into the classroom to take it he was so nervous that his mind went blank. But he is a good student so his teacher might give him a second chance. A close shavedescribes a dangerous or unpleasant situation that has only just been avoided. It almost happened… but it didn’t. ExamplesWe ran to catch the train - it was a close shave but we just managed to get on. I had a close shave when a fast car just missed me as I was crossing the road. It was close shave but I don’t think my mum saw us smoking. A sticky situationa difficult, awkward or sensitive situation. ExamplesI’m in a sticky situation: I said I’d go to the cinema with Pete but I’ve also promised to go for a drink with John. It was a sticky situation - neither side would agree on who caused the accident. We’re in a sticky situation - we’ve got to catch the train but we haven’t got enough money to buy a ticket.]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 648 - Unique Word Abbreviation]]></title>
    <url>%2F2019%2F09%2F02%2FLintCode-Problem-648-Unique-Word-Abbreviation%2F</url>
    <content type="text"><![CDATA[An abbreviation of a word follows the form&lt;first letter&gt;&lt;number&gt;&lt;last letter&gt;. Below are some examples of word abbreviations: 123456789101112a) it --&gt; it (no abbreviation) 1b) d|o|g --&gt; d1g 1 1 1 1---5----0----5--8c) i|nternationalizatio|n --&gt; i18n 1 1---5----0d) l|ocalizatio|n --&gt; l10n Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word’s abbreviation is unique if no other word from the dictionary has the same abbreviation. ExampleNo.1Input:[ “deer”, “door”, “cake”, “card” ]isUnique(“dear”)isUnique(“cart”) Output:falsetrue Explanation:Dictionary’s abbreviation is [“d2r”, “d2r”, “c2e”, “c2d”].“dear” ‘s abbreviation is “d2r” , in dictionary.“cart” ‘s abbreviation is “c2t” , not in dictionary. No.2Input:[ “deer”, “door”, “cake”, “card” ]isUnique(“cane”)isUnique(“make”) Output:falsetrue Explanation:Dictionary’s abbreviation is [“d2r”, “d2r”, “c2e”, “c2d”].“cane” ‘s abbreviation is “c2e” , in dictionary.“make” ‘s abbreviation is “m2e” , not in dictionary. Code123456789101112131415161718Map&lt;String, Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;();public ValidWordAbbr(String[] dictionary) &#123; for (String word : dictionary) &#123; String abbr = getAbbreviation(word); map.putIfAbsent(abbr, new HashSet&lt;&gt;()); map.get(abbr).add(word); &#125;&#125;public boolean isUnique(String word) &#123; String abbr = getAbbreviation(word); return !map.containsKey(abbr) || (map.get(abbr).size() == 1 &amp;&amp; map.get(abbr).contains(word));&#125;private String getAbbreviation(String word) &#123; return word.length() &lt; 3 ? word : word.charAt(0) + String.valueOf(word.length() - 2) + word.charAt(word.length() - 1);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 779 - Generalized Abbreviation]]></title>
    <url>%2F2019%2F09%2F02%2FLintCode-Problem-779-Generalized-Abbreviation%2F</url>
    <content type="text"><![CDATA[Write a function to generate the generalized abbreviations of a word.(order does not matter) ExampleNo.1Input:word = “word”, Output:[“word”, “1ord”, “w1rd”, “wo1d”, “wor1”, “2rd”, “w2d”, “wo2”, “1o1d”, “1or1”, “w1r1”, “1o2”, “2r1”, “3d”, “w3”, “4”] No.2Input:word = “today” Output:[“1o1a1”,”1o1ay”,”1o2y”,”1o3”,”1od1y”,”1od2”,”1oda1”,”1oday”,”2d1y”,”2d2”,”2da1”,”2day”,”3a1”,”3ay”,”4y”,”5”,”t1d1y”,”t1d2”,”t1da1”,”t1day”,”t2a1”,”t2ay”,”t3y”,”t4”,”to1a1”,”to1ay”,”to2y”,”to3”,”tod1y”,”tod2”,”toda1”,”today”] Code1234567891011121314151617181920212223242526public List&lt;String&gt; generateAbbreviations(String word) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); helper(result, word, 0, 0, new StringBuilder()); return result;&#125;private void helper(List&lt;String&gt; result, String word, int idx, int count, StringBuilder sb) &#123; if (idx == word.length()) &#123; if (count &gt; 0) sb.append(count); result.add(sb.toString()); return; &#125; int length = sb.length(); helper(result, word, idx + 1, count + 1, sb); sb.setLength(length); if (count &gt; 0) helper(result, word, idx + 1, 0, sb.append(count).append(word.charAt(idx))); else helper(result, word, idx + 1, 0, sb.append(word.charAt(idx)));&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SQL进阶教程】自连接的用法]]></title>
    <url>%2F2019%2F09%2F01%2F%E3%80%90SQL%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B%E3%80%91%E8%87%AA%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[与多表之间进行的普通连接相比，自连接的性能开销更大（特别是与非等值连接结合使用的时候），因此用于自连接的列推荐使用主键或者在相关列上建立索引。 可重排列、排列、组合假设有一张存放了商品名称及价格的表，表里有“苹果、橘子、香蕉”这3条记录。在生成用于查询销售额的报表等的时候，有时会需要获取这些商品的组合。 用SQL生成有序对非常简单。像下面这样通过交叉连接生成笛卡尔积，就可以得到有序对。 123-- 可重排列SELECT P1.name AS name_1, P2.name AS name_2FROM Products P1, Products P2; 接下来，思考一下如何更改才能排除掉由相同元素构成的对。首先，为了去掉（苹果，苹果）这种由相同元素构成的对，需要像下面这样加上一个条件，然后再进行连接运算。 1234-- 排列SELECT P1.name AS name_1, P2.name AS name_2FROM Products P1, Products P2WHERE P1.name &lt;&gt; P2.name; 这次的处理结果依然是有序对。接下来进一步对（苹果，橘子）和（橘子，苹果）这样只是调换了元素顺序的对进行去重。 1234-- 组合SELECT P1.name AS name_1, P2.name AS name_2FROM Products P1, Products P2WHERE P1.name &gt; P2.name; 在需要获取列的组合时，经常需要用到“非等值自连接”。 删除重复行假设在这张商品表里，“橘子”这种商品存在重复。可怕的是，这张表里连主键都没有。现在就需要马上清理一下，去掉重复行。 通常，如果重复的列里不包含主键，就可以用主键来处理，但像这一样所有的列都重复的情况，则需要使用由数据库独自实现的行ID。在下面的SQL语句里，使用的是Oracle数据库里的rowid。 123456-- 极值函数DELETE FROM Products P1WHERE rowid &lt; (SELECT MAX(P2.rowid) FROM Products P2 WHERE P1.name = P2.name AND P1.price = P2.price); 1234567-- 非等值连接DELETE FROM Products P1WHERE EXISTS (SELECT * FROM Products P2 WHERE P1.name = P2.name AND P1.price = P2.price AND P1.rowid &lt; P2.rowid); 查找局部不一致的列假设有下面这样一张住址表，主键是人名，同一家人家庭ID一样。 一般来说，同一家人应该住在同一个地方。那么该如何找出“是一家人但住址却不同的记录”呢？实现办法有几种，不过如果用非等值自连接来实现，代码会非常简洁。 1234SELECT DISTINCT A1.name, A1.addressFROM Addresses A1, Addresses A2WHERE A1.family_id = A2.family_id AND A1.address &lt;&gt; A2.address; 排序现在，要按照价格从高到低的顺序，对下面这张表里的商品进行排序。让价格相同的商品位次也一样，而紧接着它们的商品则有两种排序方法，一种是跳过之后的位次，另一种是不跳过之后的位次。 如果使用窗口函数，可以像下面这样实现。 1234SELECT name, price, RANK() OVER (ORDER BY price DESC) AS rank_1, DENSE_RANK() OVER (ORDER BY price DESC) AS rank_2FROM Products; 考虑一下不依赖于具体数据库来实现的方法。下面是用非等值自连接写的代码。 123456SELECT P1.name, P1.price, (SELECT COUNT(P2.price) FROM Products P2 WHERE P2.price &gt; P1.price) + 1 AS rank_1FROM Products P1ORDER BY rank_1; 如果修改称COUNT(DISTINCT P2.price)，那么存在相同位次的记录时，就可以不跳过之后的位次，而是连续输出（相当于DENSE_RANK函数）。由此可知，这条SQL语句可以根据不同的需求灵活地进行扩展，实现不同的排序方式。 这个子查询的代码还可以像下面这样按照自连接的写法来改写。 1234567SELECT P1.name, MAX(P1.price) AS price, COUNT(P2.name) + 1 AS rank_1FROM Products P1LEFT OUTER JOIN Products P2 ON P1.price &lt; P2.priceGROUP BY P1.nameORDER BY rank_1;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Interpreter模式]]></title>
    <url>%2F2019%2F08%2F31%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Interpreter%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[要解决的问题会被用非常简单的“迷你语言”表述出来，用Java语言编写一个负责“翻译”的程序。这样，当需要解决的问题发生变化时，不需要修改Java语言程序，只需要修改迷你语言程序即可应对。 迷你语言迷你语言的用途是控制无线玩具车。 前进1米（go） 右转（right） 左转（left） 重复（repeat） 示例program repeat 4 repeat 3 go right go left end right end end 语法12345&lt;program&gt; ::= program &lt;command list&gt;&lt;command list&gt; ::= &lt;command&gt;* end&lt;command&gt; ::= &lt;repeat command&gt; | &lt;primitive command&gt;&lt;repeat command&gt; ::= repeat &lt;number&gt; &lt;command list&gt;&lt;primitive command&gt; ::= go | left | right 示例一个迷你程序的语法解析器。例如有如下迷你程序。 program repeat 4 go right end end 将这段迷你程序推导成为如下那样的语法树。 类图 Node类123public abstract class Node &#123; public abstract void parse(Context context) throws ParseException;&#125; ProgramNode类12345678910111213141516// &lt;program&gt; ::= program &lt;command list&gt;public class ProgramNode extends Node &#123; private Node commandListNode; @Override public void parse(Context context) throws ParseException &#123; context.skipToken("program"); commandListNode = new CommandListNode(); commandListNode.parse(context); &#125; @Override public String toString() &#123; return "[program " + commandListNode + "]"; &#125;&#125; CommandListNode类12345678910111213141516171819202122232425262728import java.util.ArrayList;// &lt;command list&gt; ::= &lt;command&gt;* endpublic class CommandListNode extends Node &#123; private ArrayList list = new ArrayList(); @Override public void parse(Context context) throws ParseException &#123; while (true) &#123; if (context.currentToken() == null) throw new ParseException("Missing 'end'"); else if (context.currentToken().equals("end")) &#123; context.skipToken("end"); break; &#125; else &#123; Node commandNode = new CommandNode(); commandNode.parse(context); list.add(commandNode); &#125; &#125; &#125; @Override public String toString() &#123; return list.toString(); &#125;&#125; CommandNode类123456789101112131415161718192021// &lt;command&gt; ::= &lt;repeat command&gt; | &lt;primitive command&gt;public class CommandNode extends Node &#123; private Node node; @Override public void parse(Context context) throws ParseException &#123; if (context.currentToken().equals("repeat")) &#123; node = new RepeatCommandNode(); node.parse(context); &#125; else &#123; node = new PrimitiveCommandNode(); node.parse(context); &#125; &#125; @Override public String toString() &#123; return node.toString(); &#125;&#125; RepeatCommandNode类12345678910111213141516171819// &lt;repeat command&gt; ::= repeat &lt;number&gt; &lt;command list&gt;public class RepeatCommandNode extends Node &#123; private int number; private Node commandListNode; @Override public void parse(Context context) throws ParseException &#123; context.skipToken("repeat"); number = context.currentNumber(); context.nextToken(); commandListNode = new CommandListNode(); commandListNode.parse(context); &#125; @Override public String toString() &#123; return "[repeat " + number + " " + commandListNode + "]"; &#125;&#125; PrimitiveCommandNode类123456789101112131415161718// &lt;primitive command&gt; ::= go | left | rightpublic class PrimitiveCommandNode extends Node &#123; private String name; @Override public void parse(Context context) throws ParseException &#123; name = context.currentToken(); context.skipToken(name); if (!name.equals("go") &amp;&amp; !name.equals("left") &amp;&amp; !name.equals("right")) throw new ParseException(name + " is undefined"); &#125; @Override public String toString() &#123; return name; &#125;&#125; Context类12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.StringTokenizer;public class Context &#123; private StringTokenizer tokenizer; private String currentToken; public Context(String text) &#123; tokenizer = new StringTokenizer(text); nextToken(); &#125; public String nextToken() &#123; if (tokenizer.hasMoreTokens()) currentToken = tokenizer.nextToken(); else currentToken = null; return currentToken; &#125; public String currentToken() &#123; return currentToken; &#125; public void skipToken(String token) throws ParseException &#123; if (!token.equals(currentToken)) throw new ParseException("Warning: " + token + " is expected, but " + currentToken + " is found."); nextToken(); &#125; public int currentNumber() throws ParseException &#123; int number = 0; try &#123; number = Integer.parseInt(currentToken); &#125; catch (NumberFormatException e) &#123; throw new ParseException("Warning: " + e); &#125; return number; &#125;&#125; ParseException类123456public class ParseException extends Exception &#123; public ParseException(String msg) &#123; super(msg); &#125;&#125; Main类1234567891011121314151617181920212223import java.io.BufferedReader;import java.io.FileReader;public class Main &#123; public static void main(String[] args) &#123; try &#123; BufferedReader reader = new BufferedReader(new FileReader("program.txt")); String text; while ((text = reader.readLine()) != null)&#123; System.out.println("text = \"" + text + "\""); Node node = new ProgramNode(); node.parse(new Context(text)); System.out.println("node = \"" + node + "\""); &#125; reader.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果12345678910text = &quot;program end&quot;node = &quot;[program []]&quot;text = &quot;program go end&quot;node = &quot;[program [go]]&quot;text = &quot;program go right go right go right go right end&quot;node = &quot;[program [go, right, go, right, go, right, go, right]]&quot;text = &quot;program repeat 4 go right end end&quot;node = &quot;[program [[repeat 4 [go, right]]]]&quot;text = &quot;program repeat 4 repeat 3 go right go left end right end end&quot;node = &quot;[program [[repeat 4 [[repeat 3 [go, right, go, left]], right]]]]&quot; 登场角色AbstractExpression（抽象表达式）AbstractExpression角色定义了语法树节点的共同接口（API）。在示例程序中，由Node类扮演此角色。 TerminalExpression（终结符表达式）TerminalExpression角色对应BNF中的终结符表达式。在示例程序中，由PrimitiveCommandNode类扮演此角色。 NonterminalExpression（非终结符表达式）NonterminalExpression角色对应BNF中的非终结符表达式。在示例程序中，由ProgramNode类、CommandNode类、RepeatCommandNode类和CommandListNode类扮演此角色。 Context（文脉、上下文）Context角色为解释器进行语法解析提供了必要的信息。在示例程序中，由Context类扮演此角色。 Client（请求者）为了推导语法树，Client角色会调用TerminalExpression角色和NonterminalExpression角色。在示例程序中，由Main类扮演此角色。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Command模式]]></title>
    <url>%2F2019%2F08%2F30%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Command%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[用对象表示“命令”来保存命令历史记录和重复执行命令。 示例一个画图软件，用户拖动鼠标时程序会绘制出红色圆点，点击clear按钮后会清除所有的圆点。 类图 时序图 Command接口12345package command;public interface Command &#123; public abstract void execute();&#125; MacroCommand类123456789101112131415161718192021222324252627282930package command;import java.util.Iterator;import java.util.Stack;public class MacroCommand implements Command &#123; private Stack commands = new Stack(); @Override public void execute() &#123; Iterator it = commands.iterator(); while (it.hasNext()) ((Command) it.next()).execute(); &#125; public void append(Command cmd) &#123; if (cmd != this) commands.push(cmd); &#125; public void undo() &#123; if (!commands.isEmpty()) commands.pop(); &#125; public void clear() &#123; commands.clear(); &#125;&#125; DrawCommand类1234567891011121314151617181920package drawer;import command.Command;import java.awt.*;public class DrawCommand implements Command &#123; private Drawable drawable; private Point position; public DrawCommand(Drawable drawable, Point position) &#123; this.drawable = drawable; this.position = position; &#125; @Override public void execute() &#123; drawable.draw(position.x, position.y); &#125;&#125; Drawable接口12345package drawer;public interface Drawable &#123; public abstract void draw(int x, int y);&#125; DrawCanvas类12345678910111213141516171819202122232425262728package drawer;import command.MacroCommand;import java.awt.*;public class DrawCanvas extends Canvas implements Drawable &#123; private Color color = Color.red; private int radius = 6; private MacroCommand history; public DrawCanvas(int width, int height, MacroCommand history) &#123; setSize(width, height); setBackground(Color.white); this.history = history; &#125; public void paint(Graphics g) &#123; history.execute(); &#125; @Override public void draw(int x, int y) &#123; Graphics g = getGraphics(); g.setColor(color); g.fillOval(x - radius, y - radius, radius * 2, radius * 2); &#125;&#125; Main类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import command.Command;import command.MacroCommand;import drawer.DrawCanvas;import drawer.DrawCommand;import javax.swing.*;import java.awt.event.*;public class Main extends JFrame implements ActionListener, MouseMotionListener, WindowListener &#123; private MacroCommand history = new MacroCommand(); private DrawCanvas canvas = new DrawCanvas(400, 400, history); private JButton clearButton = new JButton("clear"); public Main(String title) &#123; super(title); this.addWindowListener(this); canvas.addMouseMotionListener(this); clearButton.addActionListener(this); Box buttonBox = new Box(BoxLayout.X_AXIS); buttonBox.add(clearButton); Box mainBox = new Box(BoxLayout.Y_AXIS); mainBox.add(buttonBox); mainBox.add(canvas); getContentPane().add(mainBox); pack(); show(); &#125; @Override public void actionPerformed(ActionEvent e) &#123; if (e.getSource() == clearButton) &#123; history.clear(); canvas.repaint(); &#125; &#125; @Override public void mouseDragged(MouseEvent e) &#123; Command cmd = new DrawCommand(canvas, e.getPoint()); history.append(cmd); cmd.execute(); &#125; @Override public void mouseMoved(MouseEvent e) &#123;&#125; @Override public void windowOpened(WindowEvent e) &#123;&#125; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; @Override public void windowClosed(WindowEvent e) &#123;&#125; @Override public void windowIconified(WindowEvent e) &#123;&#125; @Override public void windowDeiconified(WindowEvent e) &#123;&#125; @Override public void windowActivated(WindowEvent e) &#123;&#125; @Override public void windowDeactivated(WindowEvent e) &#123;&#125; public static void main(String[] args) &#123; new Main("Command Pattern Sample"); &#125;&#125; 运行结果 登场角色Command（命令）Command角色负责定义命令的接口（API）。在示例程序中，由Command接口扮演此角色。 ConcreteCommand（具体的命令）ConcreteCommand角色负责实现在Command角色中定义的接口（API）。在示例程序中，由MacroCommand类和DrawCommand类扮演此角色。 Receiver（接受者）Receiver角色是Command角色执行命令时的对象，也可以称其为命令接收者。在示例程序中，由DrawCanvas类接收DrawCommand的命令。 Client（请求者）Client角色负责生成ConcreteCommand角色并分配Receiver角色。在示例程序中，由Main类扮演此角色。在相应鼠标拖拽事件时，它生成了DrawCommand类的实例，并将扮演Receiver角色的DrawCanvas类的实例传递给了DrawCommand类的构造函数。 Invoker（发动者）Invoker角色是开始执行命令的角色，它会调用在Command角色中定义的接口（API）。在示例程序中，由Main类和DrawCanvas类扮演此角色。这两个类都调用了Command接口中的execute方法。Main类同时扮演了Client角色和Invoker角色。 类图 时序图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 639 - Word Abbreviation]]></title>
    <url>%2F2019%2F08%2F30%2FLintCode-Problem-639-Word-Abbreviation%2F</url>
    <content type="text"><![CDATA[Given an array of n distinct non-empty strings, you need to generate minimal possible abbreviations for every word following rules below. Begin with the first character and then the number of characters abbreviated, which followed by the last character. If there are any conflict, that is more than one words share the same abbreviation, a longer prefix is used instead of only the first character until making the map from word to abbreviation become unique. In other words, a final abbreviation cannot map to more than one original words. If the abbreviation doesn’t make the word shorter, then keep it as original. Note Both n and the length of each word will not exceed 400. The length of each word is greater than 1. The words consist of lowercase English letters only. The return answers should be in the same order as the original array. ExampleNo.1Input:[“like”,”god”,”internal”,”me”,”internet”,”interval”,”intension”,”face”,”intrusion”] Output:[“l2e”,”god”,”internal”,”me”,”i6t”,”interval”,”inte4n”,”f2e”,”intr4n”] No.2Input:[“where”,”there”,”is”,”beautiful”,”way”] Output:[“w3e”,”t3e”,”is”,”b7l”,”way”] Code123456789101112131415161718192021222324252627282930313233343536public String[] wordsAbbreviation(String[] dict) &#123; int n = dict.length; String[] result = new String[n]; int[] prefix = new int[n]; for (int i = 0; i &lt; n; i++) result[i] = getAbbreviation(dict[i], prefix[i] + 1); for (int i = 0; i &lt; n; i++) &#123; while (true) &#123; Set&lt;Integer&gt; confict = new HashSet&lt;&gt;(); for (int j = i + 1; j &lt; n; j++) &#123; if (result[i].equals(result[j])) confict.add(j); &#125; if (confict.isEmpty()) break; confict.add(i); for (int idx : confict) &#123; prefix[idx]++; result[idx] = getAbbreviation(dict[idx], prefix[idx] + 1); &#125; &#125; &#125; return result;&#125;private String getAbbreviation(String word, int len) &#123; return len + 2 &gt;= word.length() ? word : word.substring(0, len) + (word.length() - len - 1) + word.charAt(word.length() - 1);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 634 - Word Squares]]></title>
    <url>%2F2019%2F08%2F30%2FLintCode-Problem-634-Word-Squares%2F</url>
    <content type="text"><![CDATA[Given a set of words without duplicates, find all word squares you can build from them. A sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 ≤ k &lt; max(numRows, numColumns). For example, the word sequence [“ball”,”area”,”lead”,”lady”] forms a word square because each word reads the same both horizontally and vertically. 1234b a l la r e al e a dl a d y Note There are at least 1 and at most 1000 words. All words will have the exact same length. Word length is at least 1 and at most 5. Each word contains only lowercase English alphabet a-z. ExampleNo.1Input:[“area”,”lead”,”wall”,”lady”,”ball”] Output:[[“wall”,”area”,”lead”,”lady”],[“ball”,”area”,”lead”,”lady”]] Explanation:The output consists of two word squares. The order of output does not matter (just the order of words in each word square matters). No.2Input:[“abat”,”baba”,”atan”,”atal”] Output: [[“baba”,”abat”,”baba”,”atan”],[“baba”,”abat”,”baba”,”atal”]] Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class TrieNode &#123; private List&lt;String&gt; words = new ArrayList&lt;&gt;(); private Map&lt;Character, TrieNode&gt; children = new HashMap&lt;&gt;();&#125;public class TrieTree &#123; private TrieNode root; public TrieTree(TrieNode root) &#123; this.root = root; &#125; public void insert(String word) &#123; TrieNode node = root; for (char ch : word.toCharArray()) &#123; node.children.putIfAbsent(ch, new TrieNode()); node.children.get(ch).words.add(word); node = node.children.get(ch); &#125; &#125; public List&lt;String&gt; findByPrefix(String prefix) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); TrieNode node = root; for (char ch : prefix.toCharArray()) &#123; if (!node.children.containsKey(ch)) return result; node = node.children.get(ch); &#125; result.addAll(node.words); return result; &#125;&#125;public List&lt;List&lt;String&gt;&gt; wordSquares(String[] words) &#123; List&lt;List&lt;String&gt;&gt; results = new ArrayList&lt;&gt;(); if (words == null || words.length == 0) return results; List&lt;String&gt; result = new ArrayList&lt;&gt;(); TrieTree trie = new TrieTree(new TrieNode()); int n = words[0].length(); for (String word : words) trie.insert(word); for (String word : words) &#123; result.add(word); helper(results, result, trie, n); result.remove(result.size() - 1); &#125; return results;&#125;private void helper(List&lt;List&lt;String&gt;&gt; results, List&lt;String&gt; result, TrieTree trie, int n) &#123; if (result.size() == n) &#123; results.add(new ArrayList(result)); return; &#125; StringBuilder prefix = new StringBuilder(); int idx = result.size(); for (String res : result) prefix.append(res.charAt(idx)); List&lt;String&gt; words = trie.findByPrefix(prefix.toString()); for (String word : words) &#123; result.add(word); helper(results, result, trie, n); result.remove(result.size() - 1); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】总结]]></title>
    <url>%2F2019%2F08%2F29%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Iterator模式一个一个遍历 Adapter模式加个“适配器”以便于复用 Template Method模式将具体处理交给子类 Factory Method模式将实例的生成交给子类 Singleton模式只有一个实例 Prototype模式通过复制生成实例 Builder模式组装复杂的实例 Abstract Factory模式将关联零件组装成产品 Bridge模式将类的功能层次结构与实现层次结构分离 Strategy模式整体地替换算法 Composite模式容器与内容的一致性 Decorator模式装饰边框与被装饰物的一致性 Visitor模式访问数据结构并处理数据 Chain of Responsibility模式推卸责任 Facade模式简单窗口 Mediator模式只有一个仲裁者 Observer模式发送状态变化通知 Memento模式保存对象状态 State模式用类表示状态 Flyweight模式共享对象，避免浪费 Proxy模式只在必要时生成实例 Command模式命令也是类 Interpreter模式语法规则也是类]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Proxy模式]]></title>
    <url>%2F2019%2F08%2F29%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Proxy%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[当不一定需要本人亲自进行工作时，就可以寻找代理人去完成工作。当代理人遇到无法自己解决的事情时就会去找本人解决该问题。 示例一个带名字的打印机。 类图 时序图 Printer类12345678910111213141516171819202122232425262728293031323334353637383940414243public class Printer implements Printable &#123; private String name; public Printer() &#123; heavyJob("Printer的实例生成中"); &#125; public Printer(String name) &#123; this.name = name; heavyJob("Printer的实例生成中（"+ name + "）"); &#125; @Override public void setPrinterName(String name) &#123; this.name = name; &#125; @Override public String getPrinterName() &#123; return name; &#125; @Override public void print(String string) &#123; System.out.println("=== " + name + " ==="); System.out.println(string); &#125; private void heavyJob(String msg) &#123; System.out.print(msg); for (int i = 0; i &lt; 5; i++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125; System.out.print("."); &#125; System.out.println("结束。"); &#125;&#125; Printable接口12345public interface Printable &#123; public abstract void setPrinterName(String name); public abstract String getPrinterName(); public abstract void print(String string);&#125; PrintableProxy类1234567891011121314151617181920212223242526272829303132public class PrinterProxy implements Printable &#123; private String name; private Printer real; public PrinterProxy(String name) &#123; this.name = name; &#125; @Override public synchronized void setPrinterName(String name) &#123; if (real != null) real.setPrinterName(name); this.name = name; &#125; @Override public String getPrinterName() &#123; return name; &#125; @Override public void print(String string) &#123; realize(); real.print(string); &#125; private synchronized void realize() &#123; if (real == null) real = new Printer(name); &#125;&#125; Main类12345678910public class Main &#123; public static void main(String[] args) &#123; Printable p = new PrinterProxy("Alice"); System.out.println("现在的名字是" + p.getPrinterName() + "。"); p.setPrinterName("Bob"); System.out.println("现在的名字是" + p.getPrinterName() + "。"); p.print("Hello, world."); &#125;&#125; 运行结果12345现在的名字是Alice。现在的名字是Bob。Printer的实例生成中（Bob）.....结束。=== Bob ===Hello, world. 登场角色Subject（主体）Subject角色定义了使Proxy角色和RealSubject角色之间具有一致性的接口。由于存在Subject角色，所以Client角色不必在意它所使用的究竟是Proxy角色还是RealSubject角色。在示例程序中，由Printable接口扮演此角色。 Proxy（代理人）Proxy角色会尽量处理来自Client角色的请求。只有当自己不能处理时，它才会将工作交给RealSubject角色。Proxy角色只有在必要时才会生成RealSubject角色。Proxy角色实现了在Subject角色中定义的接口（API）。在示例程序中，由PrinterProxy类扮演此角色。 RealSubject（实际的主体）“本人”RealSubject角色会在“代理人”Proxy角色无法胜任工作时出场。它与Proxy角色一样，也实现了在Subject角色中定义的接口（API）。在示例程序中，由Printer类扮演此角色。 Client（请求者）使用Proxy模式的角色。在示例程序中，由Main类扮演此角色。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 888 - Valid Word Square]]></title>
    <url>%2F2019%2F08%2F29%2FLintCode-Problem-888-Valid-Word-Square%2F</url>
    <content type="text"><![CDATA[Given a sequence of words, check whether it forms a valid word square. A sequence of words forms a valid word square if the k^th row and column read the exact same string, where 0 ≤ k &lt; max(numRows, numColumns). Note The number of words given is at least 1 and does not exceed 500. Word length will be at least 1 and does not exceed 500. Each word contains only lowercase English alphabet a-z. ExampleNo.1Input: 123456[ "abcd", "bnrt", "crmy", "dtye"] Output: true Explanation:The first row and first column both read “abcd”.The second row and second column both read “bnrt”.The third row and third column both read “crmy”.The fourth row and fourth column both read “dtye”.Therefore, it is a valid word square. No.2Input: 123456[ "abcd", "bnrt", "crm", "dt"] Output: true Explanation:The first row and first column both read “abcd”.The second row and second column both read “bnrt”.The third row and third column both read “crm”.The fourth row and fourth column both read “dt”.Therefore, it is a valid word square. No.3Input: 123456[ "ball", "area", "read", "lady"] Output: false Explanation:The third row reads “read” while the third column reads “lead”.Therefore, it is NOT a valid word square. Code12345678910111213public boolean validWordSquare(String[] words) &#123; if (words.length != words[0].length()) return false; for (int i = 0; i &lt; words.length; i++) &#123; for (int j = i; j &lt; words[0].length(); j++) &#123; if (j &gt;= words.length || i &gt;= words[j].length() || words[i].charAt(j) != words[j].charAt(i)) return false; &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 637 - Valid Word Abbreviation]]></title>
    <url>%2F2019%2F08%2F29%2FLintCode-Problem-637-Valid-Word-Abbreviation%2F</url>
    <content type="text"><![CDATA[Given a non-empty string word and an abbreviation abbr, return whether the string matches with the given abbreviation. A string such as “word” contains only the following valid abbreviations: [“word”, “1ord”, “w1rd”, “wo1d”, “wor1”, “2rd”, “w2d”, “wo2”, “1o1d”, “1or1”, “w1r1”, “1o2”, “2r1”, “3d”, “w3”, “4”] NoteNotice that only the above abbreviations are valid abbreviations of the string word. Any other string is not a valid abbreviation of word. ExampleNo.1Input : s = “internationalization”, abbr = “i12iz4n” Output : true No.2Input : s = “apple”, abbr = “a2e” Output : false Code1234567891011121314151617181920212223242526public boolean validWordAbbreviation(String word, String abbr) &#123; int idx = 0; int count = 0; for (int i = 0; i &lt; abbr.length(); i++) &#123; char ch = abbr.charAt(i); if (Character.isDigit(ch)) &#123; if (ch == '0' &amp;&amp; count == 0) return false; count = count * 10 + ch - '0'; &#125; else &#123; idx += count; if (idx &gt;= word.length() || word.charAt(idx) != ch) return false; idx++; count = 0; &#125; &#125; return idx + count == word.length();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Flyweight模式]]></title>
    <url>%2F2019%2F08%2F28%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Flyweight%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[通过尽量共享实例来避免new出实例。 示例将许多普通字符组合成为“大型字符”。 类图 BigChar类1234567891011121314151617181920212223242526272829303132import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class BigChar &#123; private char charname; private String fontdata; public BigChar(char charname) &#123; this.charname = charname; try &#123; BufferedReader reader = new BufferedReader(new FileReader("big" + charname + ".txt")); String line; StringBuffer buf = new StringBuffer(); while ((line = reader.readLine()) != null) &#123; buf.append(line); buf.append("\n"); &#125; reader.close(); this.fontdata = buf.toString(); &#125; catch (IOException e) &#123; this.fontdata = charname + "?"; &#125; &#125; public void print() &#123; System.out.print(fontdata); &#125;&#125; BigCharFactory类1234567891011121314151617181920212223import java.util.HashMap;public class BigCharFactory &#123; private HashMap pool = new HashMap(); private static BigCharFactory singleton = new BigCharFactory(); private BigCharFactory() &#123;&#125; public static BigCharFactory getInstance() &#123; return singleton; &#125; public synchronized BigChar getBigChar(char charname) &#123; BigChar bc = (BigChar) pool.get(charname); if (bc == null) &#123; bc = new BigChar(charname); pool.put("" + charname, bc); &#125; return bc; &#125;&#125; BigString类12345678910111213141516public class BigString &#123; private BigChar[] bigChars; public BigString(String string) &#123; bigChars = new BigChar[string.length()]; BigCharFactory factory = BigCharFactory.getInstance(); for (int i = 0; i &lt; string.length(); i++) bigChars[i] = factory.getBigChar(string.charAt(i)); &#125; public void print() &#123; for (int i = 0; i &lt; bigChars.length; i++) bigChars[i].print(); &#125;&#125; Main类12345678910111213public class Main &#123; public static void main(String[] args) &#123; if (args.length == 0) &#123; System.out.println("Usage: java Main digits"); System.out.println("Example: java Main 1212123"); System.exit(0); &#125; BigString bs = new BigString(args[0]); bs.print(); &#125;&#125; 运行结果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556......##..........######..............##..............##..............##..............##..........##########........................######........##......##..............##..........####..........##............##..............##########..........................##..........######..............##..............##..............##..............##..........##########........................######........##......##..............##..........####..........##............##..............##########..........................##..........######..............##..............##..............##..............##..........##########........................######........##......##..............##..........####..........##............##..............##########........................######........##......##..............##..........####................##......##......##........######...................... 登场角色Flyweight（轻量级）按照通常方式编写程序会导致程序变重，所以如果能够共享实例会比较好，而Flyweight角色表示的就是那些实例会被共享的类。在示例程序中，由BigChar类扮演此角色。 FlyweightFactory（轻量级工厂）FlyweightFactory角色是生成Flyweight角色的工厂。在工厂中生成Flyweight角色可以实现共享实例。在示例程序中，由BigCharFactory类扮演此角色。 Client（请求者）Client角色使用FlyweightFactory角色来生成Flyweight角色。在示例程序中，由BigString类扮演此角色。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】State模式]]></title>
    <url>%2F2019%2F08%2F27%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91State%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[用类来表示状态。 示例一个警戒状态每小时会改变一次的报警系统。 类图 时序图 State接口123456public interface State &#123; public abstract void doClock(Context context, int hour); public abstract void doUse(Context context); public abstract void doAlarm(Context context); public abstract void doPhone(Context context);&#125; DayState类1234567891011121314151617181920212223242526272829303132333435public class DayState implements State &#123; private static DayState singleton = new DayState(); private DayState() &#123;&#125; public static DayState getInstance() &#123; return singleton; &#125; @Override public void doClock(Context context, int hour) &#123; if (hour &lt; 9 || hour &gt;= 17) context.changeState(NightState.getInstance()); &#125; @Override public void doUse(Context context) &#123; context.recordLog("使用金库（白天）"); &#125; @Override public void doAlarm(Context context) &#123; context.callSecurityCenter("按下警铃（白天）"); &#125; @Override public void doPhone(Context context) &#123; context.callSecurityCenter("正常通话（白天）"); &#125; @Override public String toString() &#123; return "[白天]"; &#125;&#125; NightState类1234567891011121314151617181920212223242526272829303132333435public class NightState implements State &#123; private static NightState singleton = new NightState(); private NightState() &#123;&#125; public static NightState getInstance() &#123; return singleton; &#125; @Override public void doClock(Context context, int hour) &#123; if (hour &gt;= 9 &amp;&amp; hour &lt; 17) context.changeState(DayState.getInstance()); &#125; @Override public void doUse(Context context) &#123; context.callSecurityCenter("紧急：晚上使用金库！"); &#125; @Override public void doAlarm(Context context) &#123; context.callSecurityCenter("按下警铃（晚上）"); &#125; @Override public void doPhone(Context context) &#123; context.recordLog("晚上的通话录音"); &#125; @Override public String toString() &#123; return "[晚上]"; &#125;&#125; Context接口123456public interface Context &#123; public abstract void setClock(int hour); public abstract void changeState(State state); public abstract void callSecurityCenter(String msg); public abstract void recordLog(String msg);&#125; SafeFrame类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class SafeFrame extends Frame implements ActionListener, Context &#123; private TextField textClock = new TextField(60); private TextArea textScreen = new TextArea(10, 60); private Button buttonUse = new Button("使用金库"); private Button buttonAlarm = new Button("按下警铃"); private Button buttonPhone = new Button("正常通话"); private Button buttonExit = new Button("结束"); private State state = DayState.getInstance(); public SafeFrame(String title) &#123; super(title); setBackground(Color.lightGray); setLayout(new BorderLayout()); add(textClock, BorderLayout.NORTH); textClock.setEditable(false); add(textScreen, BorderLayout.CENTER); textScreen.setEditable(false); Panel panel = new Panel(); panel.add(buttonUse); panel.add(buttonAlarm); panel.add(buttonPhone); panel.add(buttonExit); add(panel, BorderLayout.SOUTH); pack(); show(); buttonUse.addActionListener(this); buttonAlarm.addActionListener(this); buttonPhone.addActionListener(this); buttonExit.addActionListener(this); &#125; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println(e.toString()); if (e.getSource() == buttonUse) state.doUse(this); else if (e.getSource() == buttonAlarm) state.doAlarm(this); else if (e.getSource() == buttonPhone) state.doPhone(this); else if (e.getSource() == buttonExit) System.exit(0); else System.out.println("?"); &#125; @Override public void setClock(int hour) &#123; String clockstring = "现在时间是"; if (hour &lt; 10) clockstring += "0" + hour + ":00"; else clockstring += hour + ":00"; System.out.println(clockstring); textClock.setText(clockstring); state.doClock(this, hour); &#125; @Override public void changeState(State state) &#123; System.out.println("从" + this.state + "状态变为了" + state + "状态。"); this.state = state; &#125; @Override public void callSecurityCenter(String msg) &#123; textScreen.append("call! " + msg + "\n"); &#125; @Override public void recordLog(String msg) &#123; textScreen.append("record ... " + msg + "\n"); &#125;&#125; Main类1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; SafeFrame frame = new SafeFrame("State Sample"); while (true) &#123; for (int hour = 0; hour &lt; 24; hour++) &#123; frame.setClock(hour); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; &#125;&#125; 运行结果 登场角色State（状态）State角色表示状态，定义了根据不同状态进行不同处理的接口（API）。该接口（API）是那些处理内容依赖于状态的方法的集合。在示例程序中，由State接口扮演此角色。 ConcreteState（具体状态）ConcreteState角色表示各个具体的状态，它实现了State接口。在示例程序中，由DayState类和NightState类扮演此角色。 Context（状况、前后关系、上下文）Context角色持有表示当前状态的ConcreteState角色。此外，它还定义了供外部调用者使用State模式的接口（API）。在示例程序中，由Context接口和SafeFrame类扮演此角色。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 434 - Number of Segments in a String]]></title>
    <url>%2F2019%2F08%2F27%2FLeetCode-Problem-434-Number-of-Segments-in-a-String%2F</url>
    <content type="text"><![CDATA[Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters. Please note that the string does not contain any non-printable characters. ExampleInput: “Hello, my name is John” Output: 5 Code12345678910public int countSegments(String s) &#123; int result = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) != ' ' &amp;&amp; (i == 0 || s.charAt(i - 1) == ' ')) result++; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 414 - Third Maximum Number]]></title>
    <url>%2F2019%2F08%2F27%2FLeetCode-Problem-414-Third-Maximum-Number%2F</url>
    <content type="text"><![CDATA[Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). ExampleNo.1Input: [3, 2, 1] Output: 1 Explanation: The third maximum is 1. No.2Input: [1, 2] Output: 2 Explanation: The third maximum does not exist, so the maximum (2) is returned instead. No.3Input: [2, 2, 3, 1] Output: 1 Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum. Code1234567891011121314151617181920212223public int thirdMax(int[] nums) &#123; long[] max = new long[3]; Arrays.fill(max, Long.MIN_VALUE); for (int num : nums) &#123; if (num == max[0] || num == max[1] || num == max[2]) continue; if (max[0] == Long.MIN_VALUE || num &gt; max[0]) &#123; max[2] = max[1]; max[1] = max[0]; max[0] = num; &#125; else if (max[1] == Long.MIN_VALUE || num &gt; max[1]) &#123; max[2] = max[1]; max[1] = num; &#125; else if (max[2] == Long.MIN_VALUE || num &gt; max[2]) max[2] = num; &#125; return (int) (max[2] == Long.MIN_VALUE ? max[0] : max[2]);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 405 - Convert a Number to Hexadecimal]]></title>
    <url>%2F2019%2F08%2F27%2FLeetCode-Problem-405-Convert-a-Number-to-Hexadecimal%2F</url>
    <content type="text"><![CDATA[Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used. Note All letters in hexadecimal (a-f) must be in lowercase. The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character ‘0’; otherwise, the first character in the hexadecimal string will not be the zero character. The given number is guaranteed to fit within the range of a 32-bit signed integer. You must not use any method provided by the library which converts/formats the number to hex directly. ExampleNo.1Input:26 Output:“1a” No.2Input:-1 Output:“ffffffff” Code1234567891011121314public String toHex(int num) &#123; StringBuilder sb = new StringBuilder(); String str = "0123456789abcdef"; int count = 0; while (num != 0 &amp;&amp; count &lt; 8) &#123; char ch = str.charAt(num &amp; 0xf); sb.append(ch); num &gt;&gt;= 4; count++; &#125; return sb.length() == 0 ? "0" : sb.reverse().toString();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 404 - Sum of Left Leaves]]></title>
    <url>%2F2019%2F08%2F27%2FLeetCode-Problem-404-Sum-of-Left-Leaves%2F</url>
    <content type="text"><![CDATA[Find the sum of all left leaves in a given binary tree. Example12345 3 / \9 20 / \ 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516public int sumOfLeftLeaves(TreeNode root) &#123; if (root == null) return 0; int sum = 0; if (root.left != null) &#123; if (root.left.left == null &amp;&amp; root.left.right == null) sum += root.left.val; else sum += sumOfLeftLeaves(root.left); &#125; sum += sumOfLeftLeaves(root.right); return sum;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 389 - Find the Difference]]></title>
    <url>%2F2019%2F08%2F27%2FLeetCode-Problem-389-Find-the-Difference%2F</url>
    <content type="text"><![CDATA[Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. ExampleInput:s = “abcd”t = “abcde” Output:e Explanation:‘e’ is the letter that was added. Code123456789public char findTheDifference(String s, String t) &#123; int n = s.length(); char ch = t.charAt(n); for (int i = 0; i &lt; n; i++) ch ^= s.charAt(i) ^ t.charAt(i); return ch;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 345 - Reverse Vowels of a String]]></title>
    <url>%2F2019%2F08%2F27%2FLeetCode-Problem-345-Reverse-Vowels-of-a-String%2F</url>
    <content type="text"><![CDATA[Write a function that takes a string as input and reverse only the vowels of a string. ExampleNo.1Input: “hello” Output: “holle” No.2Input: “leetcode” Output: “leotcede” NoteThe vowels does not include the letter “y”. Code12345678910111213141516171819202122public String reverseVowels(String s) &#123; String str = "aeiouAEIOU"; char[] ch = s.toCharArray(); int start = 0; int end = s.length() - 1; while (start &lt; end) &#123; while (start &lt; end &amp;&amp; str.indexOf(ch[start]) == -1) start++; while (start &lt; end &amp;&amp; str.indexOf(ch[end]) == -1) end--; char temp = ch[start]; ch[start] = ch[end]; ch[end] = temp; start++; end--; &#125; return String.valueOf(ch);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Memento模式]]></title>
    <url>%2F2019%2F08%2F26%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Memento%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[引入表示实例状态的角色，在保存和恢复实例时有效地防止对象的封装性遭到破坏。 示例一个收集水果和获取金钱数的掷骰子游戏，游戏规则很简单，具体如下。 游戏是自动进行的 游戏的主人公通过掷骰子来决定下一个状态 当骰子点数为1的时候，主人公的金钱会增加 当骰子点数为2的时候，主人公的金钱会减少 当骰子点数为6的时候，主人公会得到水果 主人公没有钱时游戏就会结束 类图 时序图 Memento类1234567891011121314151617181920212223242526package game;import java.util.ArrayList;import java.util.List;public class Memento &#123; int money; ArrayList fruits; Memento(int money) &#123; this.money = money; this.fruits = new ArrayList(); &#125; public int getMoney() &#123; return money; &#125; List getFruits() &#123; return (List) fruits.clone(); &#125; void addFruit(String fruit) &#123; fruits.add(fruit); &#125;&#125; Gamer类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package game;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Random;public class Gamer &#123; private int money; private List fruits = new ArrayList(); private Random random = new Random(); private static String[] fruitsname = &#123;"苹果", "葡萄", "香蕉", "橘子"&#125;; public Gamer(int money) &#123; this.money = money; &#125; public void bet() &#123; int dice = random.nextInt(6) + 1; if (dice == 1) &#123; money += 100; System.out.println("所持金钱增加了。"); &#125; else if (dice == 2) &#123; money /= 2; System.out.println("所持金钱减半了。"); &#125; else if (dice == 6) &#123; String f = getFruit(); System.out.println("获得了水果（" + f + "）。"); fruits.add(f); &#125; else System.out.println("什么都没有发生。"); &#125; public Memento createMemento() &#123; Memento m = new Memento(money); Iterator it = fruits.iterator(); while (it.hasNext()) &#123; String f = (String) it.next(); if (f.startsWith("好吃的")) m.addFruit(f); &#125; return m; &#125; public void restoreMemento(Memento memento) &#123; this.money = memento.money; this.fruits = memento.getFruits(); &#125; private String getFruit() &#123; String prefix = ""; if (random.nextBoolean()) prefix = "好吃的"; return prefix + fruitsname[random.nextInt(fruitsname.length)]; &#125; public int getMoney() &#123; return money; &#125; @Override public String toString() &#123; return "[money = " + money + ", fruits = " + fruits + "]"; &#125;&#125; Main类1234567891011121314151617181920212223242526272829303132333435import game.Gamer;import game.Memento;public class Main &#123; public static void main(String[] args) &#123; Gamer gamer = new Gamer(100); Memento memento = gamer.createMemento(); for (int i = 0; i &lt; 100; i++) &#123; System.out.println("==== " + i); System.out.println("当前状态：" + gamer); gamer.bet(); System.out.println("所持金钱为" + gamer.getMoney() + "元。"); if (gamer.getMoney() &gt; memento.getMoney()) &#123; System.out.println(" （所持金钱增加了许多，因此保存游戏当前的状态）"); memento = gamer.createMemento(); &#125; else if (gamer.getMoney() &lt; memento.getMoney() / 2) &#123; System.out.println(" （所持金钱减少了许多，因此将游戏恢复至以前的状态）"); gamer.restoreMemento(memento); &#125; &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125; System.out.println(""); &#125;&#125; 运行结果123456789101112131415161718192021222324252627282930313233343536373839404142==== 0当前状态：[money = 100, fruits = []]获得了水果（好吃的葡萄）。所持金钱为100元。==== 1当前状态：[money = 100, fruits = [好吃的葡萄]]所持金钱减半了。所持金钱为50元。==== 2当前状态：[money = 50, fruits = [好吃的葡萄]]什么都没有发生。所持金钱为50元。==== 3当前状态：[money = 50, fruits = [好吃的葡萄]]什么都没有发生。所持金钱为50元。==== 4当前状态：[money = 50, fruits = [好吃的葡萄]]获得了水果（香蕉）。所持金钱为50元。==== 5当前状态：[money = 50, fruits = [好吃的葡萄, 香蕉]]什么都没有发生。所持金钱为50元。==== 6当前状态：[money = 50, fruits = [好吃的葡萄, 香蕉]]什么都没有发生。所持金钱为50元。==== 7当前状态：[money = 50, fruits = [好吃的葡萄, 香蕉]]所持金钱减半了。所持金钱为25元。 （所持金钱减少了许多，因此将游戏恢复至以前的状态）==== 8当前状态：[money = 100, fruits = []]所持金钱增加了。所持金钱为200元。 （所持金钱增加了许多，因此保存游戏当前的状态）==== 9当前状态：[money = 200, fruits = []]什么都没有发生。所持金钱为200元。 登场角色Originator（生成者）Originator角色会在保存自己的最新状态时生成Memento角色。当把以前保存的Memento角色传递给Originator角色时，它会将自己恢复至生成该Memento角色时的状态。在示例程序中，由Gamer类扮演此角色。 Memento（纪念品）Memento角色会将Originator角色的内部信息整合在一起。在Memento角色中虽然保存了Originator角色的信息，但它不会向外部公开这些信息。Memento角色有以下两种接口（API）。 wide interface——宽接口（API） Memento角色提供的“宽接口（API）”是指所有用于获取恢复对象状态信息的方法的集合。由于宽接口（API）会暴露所有Memento角色的内部信息，因此能够使用宽接口（API）的只有Originator角色。 narrow interface——窄接口（API） Memento角色为外部的Caretaker角色提供了“窄接口（API）”。可以通过窄接口（API）获取的Memento角色的内部信息非常有限，因此可以有效地防止信息泄露。 通过对外提供以上两种接口（API），可以有效地防止对象的封装性被破坏。在示例程序中，由Memento类扮演此角色。Originator角色和Memento角色之间有着非常紧密的联系。 Caretaker（负责人）当Caretaker角色想要保存当前的Originator角色的状态时，会通知Originator角色。Originator角色在接收到通知后会生成Memento角色的实例并将其返回给Caretaker角色。由于以后可能会用Memento实例来将Originator恢复至原来的状态，因此Caretaker角色会一直保存Memento实例。在示例程序中，由Main类扮演此角色。不过，Caretaker角色只能使用Memento角色两种接口（API）中的窄接口（API），也就是说它无法访问Memento角色内部的所有信息。它只是将Originator角色生成的Memento角色当作一个黑盒子保存起来。虽然Originator角色和Memento角色之间是强关联关系，但Caretaker角色和Memento角色之间是弱关联关系。Memento角色对Caretaker角色隐藏了自身的内部信息。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Indexed Tree]]></title>
    <url>%2F2019%2F08%2F26%2FBinary-Indexed-Tree%2F</url>
    <content type="text"><![CDATA[A Fenwick tree or binary indexed tree is a data structure that can efficiently update elements and calculate prefix sums in a table of numbers. 1D1234567891011121314151617181920212223242526272829public class BinaryIndexedTree &#123; private int[] sum; public BinaryIndexedTree(int n) &#123; sum = new int[n + 1]; &#125; public void update(int i, int delta) &#123; while (i &lt; sum.length) &#123; sum[i] += delta; i += lowbit(i); &#125; &#125; public int query(int i) &#123; int result = 0; while (i &gt; 0) &#123; result += sum[i]; i -= lowbit(i); &#125; return result; &#125; private int lowbit(int x) &#123; return x &amp; (-x); &#125;&#125; 2D1234567891011121314151617181920212223242526272829public class BinaryIndexedTree &#123; private int[][] sum; public BinaryIndexedTree(int m, int n) &#123; sum = new int[m + 1][n + 1]; &#125; public void update(int row, int col, int delta) &#123; for (int i = row; i &lt; sum.length; i += lowbit(i)) &#123; for (int j = col; j &lt; sum[0].length; j += lowbit(j)) sum[i][j] += delta; &#125; &#125; public int query(int row, int col) &#123; int result = 0; for (int i = row; i &gt; 0; i -= lowbit(i)) &#123; for (int j = col; j &gt; 0; j -= lowbit(j)) result += sum[i][j]; &#125; return result; &#125; private int lowbit(int x) &#123; return x &amp; (-x); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Segment Tree]]></title>
    <url>%2F2019%2F08%2F26%2FSegment-Tree%2F</url>
    <content type="text"><![CDATA[A segment tree also known as a statistic tree is a tree data structure used for storing information about intervals, or segments. It allows querying which of the stored segments contain a given point. It is, in principle, a static structure; that is, it’s a structure that cannot be modified once it’s built. A similar data structure is the interval tree. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class SegmentTreeNode &#123; private int start; private int end; private int sum; private SegmentTreeNode left; private SegmentTreeNode right; public SegmentTreeNode(int start, int end, int sum) &#123; this.start = start; this.end = end; this.sum = sum; &#125;&#125;public class SegmentTree &#123; private SegmentTreeNode root; public SegmentTree (int[] nums, int start, int end) &#123; this.root = build(nums, start, end); &#125; private SegmentTreeNode build(int[] nums, int start, int end) &#123; if (start &gt; end) return null; SegmentTreeNode node = new SegmentTreeNode(start, end, 0); if (start != end) &#123; int mid = (start + end) / 2; node.left = build(nums, start, mid); node.right = build(nums, mid + 1, end); node.sum = node.left.sum + node.right.sum; &#125; else node.sum = nums[start]; return node; &#125; public void modify(int index, int value) &#123; modify(root, index, value); &#125; private void modify(SegmentTreeNode node, int index, int value) &#123; if (node.start == index &amp;&amp; node.end == index) &#123; node.sum = value; return; &#125; int mid = (node.start + node.end) / 2; if (index &lt;= mid) modify(node.left, index, value); else modify(node.right, index, value); node.sum = node.left.sum + node.right.sum; &#125; public int query(int start, int end) &#123; return query(root, start, end); &#125; private int query(SegmentTreeNode node, int start, int end) &#123; if (start == node.start &amp;&amp; end == node.end) return node.sum; int mid = (node.start + node.end) / 2; if (end &lt;= mid) return query(node.left, start, end); else if (start &gt;= mid + 1) return query(node.right, start, end); else return query(node.left, start, mid) + query(node.right, mid + 1, end); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prefix Tree]]></title>
    <url>%2F2019%2F08%2F26%2FPrefix-Tree%2F</url>
    <content type="text"><![CDATA[A trie, also called digital tree, radix tree or prefix tree, is a kind of search tree—an ordered tree data structure used to store a dynamic set or associative array where the keys are usually strings. Unlike a binary search tree, no node in the tree stores the key associated with that node; instead, its position in the tree defines the key with which it is associated. All the descendants of a node have a common prefix of the string associated with that node, and the root is associated with the empty string. Keys tend to be associated with leaves, though some inner nodes may correspond to keys of interest. Hence, keys are not necessarily associated with every node. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TrieNode &#123; private boolean word; private TrieNode[] children = new TrieNode[26];&#125;public class Trie &#123; private TrieNode root; public Trie() &#123; this.root = new TrieNode(); &#125; public void insert(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; int idx = word.charAt(i) - 'a'; if (node.children[idx] == null) node.children[idx] = new TrieNode(); node = node.children[idx]; &#125; node.word = true; &#125; public boolean search(String word) &#123; TrieNode node = find(word); return node != null &amp;&amp; node.word; &#125; public boolean startsWith(String prefix) &#123; TrieNode node = find(prefix); return node != null; &#125; private TrieNode find(String prefix) &#123; TrieNode node = root; for (int i = 0; i &lt; prefix.length(); i++) &#123; int idx = prefix.charAt(i) - 'a'; if (node.children[idx] == null) return null; node = node.children[idx]; &#125; return node; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 208 - Implement Trie (Prefix Tree)]]></title>
    <url>%2F2019%2F08%2F26%2FLeetCode-Problem-208-Implement-Trie-Prefix-Tree%2F</url>
    <content type="text"><![CDATA[Implement a trie with insert, search, and startsWith methods. Example12345678Trie trie = new Trie();trie.insert("apple");trie.search("apple"); // returns truetrie.search("app"); // returns falsetrie.startsWith("app"); // returns truetrie.insert("app"); trie.search("app"); // returns true Note You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class TrieNode &#123; private boolean word; private TrieNode[] children = new TrieNode[26];&#125;private TrieNode root;public Trie() &#123; this.root = new TrieNode();&#125;public void insert(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; int idx = word.charAt(i) - 'a'; if (node.children[idx] == null) node.children[idx] = new TrieNode(); node = node.children[idx]; &#125; node.word = true;&#125;public boolean search(String word) &#123; TrieNode node = find(word); return node != null &amp;&amp; node.word;&#125;public boolean startsWith(String prefix) &#123; TrieNode node = find(prefix); return node != null;&#125;private TrieNode find(String prefix) &#123; TrieNode node = root; for (int i = 0; i &lt; prefix.length(); i++) &#123; int idx = prefix.charAt(i) - 'a'; if (node.children[idx] == null) return null; node = node.children[idx]; &#125; return node;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.util.Observer接口]]></title>
    <url>%2F2019%2F08%2F25%2Fjava-util-Observer%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Java类库中的java.util.Observer接口和java.util.Observable类就是一种Observer模式。 java.util.Observer接口中定义了一下方法。 1public void update(Observable obj, Object arg) 而update方法的参数则接收到了如下内容。 Observable类的实例是被观察的Subject角色 Object类的实例是附加信息 但是java.util.Observer接口和java.util.Observable类并不好用。理由很简单，传递给java.util.Observer接口的Subject角色必须是java.util.Observable类型（或者它的子类型）的。但Java只能单一继承，也就是说如果Subject角色已经是某个类的子类了，那么它将无法继承java.util.Observable类。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 817 - Range Sum Query 2D - Mutable]]></title>
    <url>%2F2019%2F08%2F25%2FLintCode-Problem-817-Range-Sum-Query-2D-Mutable%2F</url>
    <content type="text"><![CDATA[Given a 2D matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). And the elements of the matrix could be changed. You have to implement three functions: NumMatrix(matrix) The constructor. sumRegion(row1, col1, row2, col2) Return the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). update(row, col, val) Update the element at (row, col) to val. Note The matrix is only modifiable by update. You may assume the number of calls to update and sumRegion function is distributed evenly. You may assume that row1 ≤ row2 and col1 ≤ col2. ExampleNo.1Input: 1234567NumMatrix( [[3,0,1,4,2], [5,6,3,2,1], [1,2,0,1,5], [4,1,0,1,7], [1,0,3,0,5]]) sumRegion(2,1,4,3)update(3,2,2)sumRegion(2,1,4,3) Output: 8 10 No.2Input:NumMatrix([[1]])sumRegion(0, 0, 0, 0)update(0, 0, -1)sumRegion(0, 0, 0, 0) Output: 1 -1 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class BinaryIndexedTree &#123; private int[][] sum; public BinaryIndexedTree(int m, int n) &#123; sum = new int[m + 1][n + 1]; &#125; public void update(int row, int col, int delta) &#123; for (int i = row; i &lt; sum.length; i += lowbit(i)) &#123; for (int j = col; j &lt; sum[0].length; j += lowbit(j)) sum[i][j] += delta; &#125; &#125; public int query(int row, int col) &#123; int result = 0; for (int i = row; i &gt; 0; i -= lowbit(i)) &#123; for (int j = col; j &gt; 0; j -= lowbit(j)) result += sum[i][j]; &#125; return result; &#125; private int lowbit(int x) &#123; return x &amp; (-x); &#125;&#125;private BinaryIndexedTree tree;private int[][] matrix;public NumMatrix(int[][] matrix) &#123; this.matrix = matrix; int m = matrix.length; int n = matrix[0].length; tree = new BinaryIndexedTree(m, n); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) tree.update(i + 1, j + 1, matrix[i][j]); &#125;&#125;public void update(int row, int col, int val) &#123; tree.update(row + 1, col + 1, val - matrix[row][col]); matrix[row][col] = val;&#125;public int sumRegion(int row1, int col1, int row2, int col2) &#123; return tree.query(row2 + 1, col2 + 1) + tree.query(row1, col1) - tree.query(row1, col2 + 1) - tree.query(row2 + 1, col1); &#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 307 - Range Sum Query - Mutable]]></title>
    <url>%2F2019%2F08%2F25%2FLeetCode-Problem-307-Range-Sum-Query-Mutable%2F</url>
    <content type="text"><![CDATA[Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. The update(i, val) function modifies nums by updating the element at index i to val. ExampleGiven nums = [1, 3, 5] sumRange(0, 2) -&gt; 9update(1, 2)sumRange(0, 2) -&gt; 8 Note The array is only modifiable by the update function. You may assume the number of calls to update and sumRange function is distributed evenly. Segment Tree12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class SegmentTreeNode &#123; private int start; private int end; private int sum; private SegmentTreeNode left; private SegmentTreeNode right; public SegmentTreeNode(int start, int end, int sum) &#123; this.start = start; this.end = end; this.sum = sum; &#125;&#125;public class SegmentTree &#123; private SegmentTreeNode root; public SegmentTree (int[] nums, int start, int end) &#123; this.root = build(nums, start, end); &#125; private SegmentTreeNode build(int[] nums, int start, int end) &#123; if (start &gt; end) return null; SegmentTreeNode node = new SegmentTreeNode(start, end, 0); if (start != end) &#123; int mid = (start + end) / 2; node.left = build(nums, start, mid); node.right = build(nums, mid + 1, end); node.sum = node.left.sum + node.right.sum; &#125; else node.sum = nums[start]; return node; &#125; public void modify(int index, int value) &#123; modify(root, index, value); &#125; private void modify(SegmentTreeNode node, int index, int value) &#123; if (node.start == index &amp;&amp; node.end == index) &#123; node.sum = value; return; &#125; int mid = (node.start + node.end) / 2; if (index &lt;= mid) modify(node.left, index, value); else modify(node.right, index, value); node.sum = node.left.sum + node.right.sum; &#125; public int query(int start, int end) &#123; return query(root, start, end); &#125; private int query(SegmentTreeNode node, int start, int end) &#123; if (start == node.start &amp;&amp; end == node.end) return node.sum; int mid = (node.start + node.end) / 2; if (end &lt;= mid) return query(node.left, start, end); else if (start &gt;= mid + 1) return query(node.right, start, end); else return query(node.left, start, mid) + query(node.right, mid + 1, end); &#125;&#125;private SegmentTree tree;public NumArray(int[] nums) &#123; tree = new SegmentTree(nums, 0, nums.length - 1);&#125;public void update(int i, int val) &#123; tree.modify(i, val);&#125;public int sumRange(int i, int j) &#123; return tree.query(i, j);&#125; Binary Indexed Tree12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class BinaryIndexedTree &#123; private int[] sum; public BinaryIndexedTree(int n) &#123; sum = new int[n + 1]; &#125; public void update(int i, int delta) &#123; while (i &lt; sum.length) &#123; sum[i] += delta; i += lowbit(i); &#125; &#125; public int query(int i) &#123; int result = 0; while (i &gt; 0) &#123; result += sum[i]; i -= lowbit(i); &#125; return result; &#125; private int lowbit(int x) &#123; return x &amp; (-x); &#125;&#125;private BinaryIndexedTree tree;private int[] nums;public NumArray(int[] nums) &#123; this.nums = nums; tree = new BinaryIndexedTree(nums.length); for (int i = 0; i &lt; nums.length; i++) tree.update(i + 1, nums[i]);&#125;public void update(int i, int val) &#123; tree.update(i + 1, val - nums[i]); nums[i] = val;&#125;public int sumRange(int i, int j) &#123; return tree.query(j + 1) - tree.query(i);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Observer模式]]></title>
    <url>%2F2019%2F08%2F25%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Observer%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[当观察对象的状态发生变化时，会通知给观察者。适用于根据对象状态进行相应处理的场景。 示例观察者将观察一个会生成数值的对象，并将它生成的数值结果显示出来。不同的观察者的显示方式不一样。 类图 Observer接口123public interface Observer &#123; public abstract void update(NumberGenerator generator);&#125; NumberGenerator类1234567891011121314151617181920212223242526import java.util.ArrayList;import java.util.Iterator;public abstract class NumberGenerator &#123; private ArrayList observers = new ArrayList(); public void addObserver(Observer observer) &#123; observers.add(observer); &#125; public void deleteObserver(Observer observer) &#123; observers.remove(observer); &#125; public void notifyObservers() &#123; Iterator it = observers.iterator(); while (it.hasNext()) &#123; Observer o = (Observer) it.next(); o.update(this); &#125; &#125; public abstract int getNumber(); public abstract void execute();&#125; RandomNumberGenerator类12345678910111213141516171819import java.util.Random;public class RandomNumberGenerator extends NumberGenerator &#123; private Random random = new Random(); private int number; @Override public int getNumber() &#123; return number; &#125; @Override public void execute() &#123; for (int i = 0; i &lt; 20; i++) &#123; number = random.nextInt(50); notifyObservers(); &#125; &#125;&#125; DigitObserver类1234567891011public class DigitObserver implements Observer &#123; @Override public void update(NumberGenerator generator) &#123; System.out.println("DigitObserver:" + generator.getNumber()); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125; GraphObserver类12345678910111213141516public class GraphObserver implements Observer &#123; @Override public void update(NumberGenerator generator) &#123; System.out.print("GraphObserver:"); for (int i = 0; i &lt; generator.getNumber(); i++) System.out.print("*"); System.out.println(""); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125; Main类1234567891011public class Main &#123; public static void main(String[] args) &#123; NumberGenerator generator = new RandomNumberGenerator(); Observer observer1 = new DigitObserver(); Observer observer2 = new GraphObserver(); generator.addObserver(observer1); generator.addObserver(observer2); generator.execute(); &#125;&#125; 运行结果12345678910111213141516171819202122232425262728293031323334353637383940DigitObserver:14GraphObserver:**************DigitObserver:43GraphObserver:*******************************************DigitObserver:21GraphObserver:*********************DigitObserver:33GraphObserver:*********************************DigitObserver:36GraphObserver:************************************DigitObserver:43GraphObserver:*******************************************DigitObserver:19GraphObserver:*******************DigitObserver:32GraphObserver:********************************DigitObserver:33GraphObserver:*********************************DigitObserver:5GraphObserver:*****DigitObserver:20GraphObserver:********************DigitObserver:13GraphObserver:*************DigitObserver:30GraphObserver:******************************DigitObserver:28GraphObserver:****************************DigitObserver:9GraphObserver:*********DigitObserver:22GraphObserver:**********************DigitObserver:26GraphObserver:**************************DigitObserver:34GraphObserver:**********************************DigitObserver:7GraphObserver:*******DigitObserver:42GraphObserver:****************************************** 登场角色Subject（观察对象）Subject角色表示观察对象。Subject角色定义了注册观察者和删除观察者的方法。此外，它还声明了“获取现在的状态”的方法。在示例程序中，由NumberGenerator类扮演此角色。 ConcreteSubject（具体的观察对象）ConcreteSubject角色表示具体的被观察对象。当自身状态发生变化后，它会通知所有已经注册的Observer角色。在示例程序中，由RandomNumberGenerator类扮演此角色。 Observer（观察者）Observer角色负责接收来自Subject角色的状态变化的通知。为此，它声明了update方法。在示例程序中，由Observer接口扮演此角色。 ConcreteObserver（具体的观察者）ConcreteObserver角色表示具体的Observer。当它的update方法被调用后，会去获取要观察的对象的最新状态。在示例程序中，由DigitObserver类和GraphObserver类扮演此角色。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Mediator模式]]></title>
    <url>%2F2019%2F08%2F24%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Mediator%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[组员向仲裁者报告，仲裁者向组员下达指示。组员之间不再相互询问和相互指示。 示例一个GUI应用程序，它展示了一个登录对话框，用户在其中输入正确的用户名和密码后可以登录。 可以选择作为游客访问（Guest）或是作为用户登录（Login） 作为用户登录时，需要输入正确的用户名（Username）和密码（Password） 点击OK按钮可以登录，点击Cancel按钮可以取消登录 类图 时序图 Mediator接口1234public interface Mediator &#123; public abstract void createColleagues(); public abstract void colleagueChanged();&#125; Colleague接口1234public interface Colleague &#123; public abstract void setMediator(Mediator mediator); public abstract void setColleagueEnabled(boolean enabled);&#125; ColleagueButton类12345678910111213141516171819import java.awt.*;public class ColleagueButton extends Button implements Colleague &#123; private Mediator mediator; public ColleagueButton(String caption) &#123; super(caption); &#125; @Override public void setMediator(Mediator mediator) &#123; this.mediator = mediator; &#125; @Override public void setColleagueEnabled(boolean enabled) &#123; setEnabled(enabled); &#125;&#125; ColleagueTextField类123456789101112131415161718192021222324252627import java.awt.*;import java.awt.event.TextEvent;import java.awt.event.TextListener;public class ColleagueTextField extends TextField implements TextListener, Colleague &#123; private Mediator mediator; public ColleagueTextField(String text, int columns) &#123; super(text, columns); &#125; @Override public void setMediator(Mediator mediator) &#123; this.mediator = mediator; &#125; @Override public void setColleagueEnabled(boolean enabled) &#123; setEnabled(enabled); setBackground(enabled ? Color.white : Color.lightGray); &#125; @Override public void textValueChanged(TextEvent e) &#123; mediator.colleagueChanged(); &#125;&#125; ColleagueCheckbox类1234567891011121314151617181920212223242526import java.awt.*;import java.awt.event.ItemEvent;import java.awt.event.ItemListener;public class ColleagueCheckbox extends Checkbox implements ItemListener, Colleague &#123; private Mediator mediator; public ColleagueCheckbox(String caption, CheckboxGroup group, boolean state) &#123; super(caption, group, state); &#125; @Override public void setMediator(Mediator mediator) &#123; this.mediator = mediator; &#125; @Override public void setColleagueEnabled(boolean enabled) &#123; setEnabled(enabled); &#125; @Override public void itemStateChanged(ItemEvent e) &#123; mediator.colleagueChanged(); &#125;&#125; LoginFrame类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class LoginFrame extends Frame implements ActionListener, Mediator &#123; private ColleagueCheckbox checkGuest; private ColleagueCheckbox checkLogin; private ColleagueTextField textUser; private ColleagueTextField textPass; private ColleagueButton buttonOk; private ColleagueButton buttonCancel; public LoginFrame(String title) &#123; super(title); setBackground(Color.lightGray); setLayout(new GridLayout(4, 2)); createColleagues(); add(checkGuest); add(checkLogin); add(new Label("Username:")); add(textUser); add(new Label("Password:")); add(textPass); add(buttonOk); add(buttonCancel); colleagueChanged(); pack(); show(); &#125; @Override public void createColleagues() &#123; CheckboxGroup g = new CheckboxGroup(); checkGuest = new ColleagueCheckbox("Guest", g, true); checkLogin = new ColleagueCheckbox("Login", g, false); textUser = new ColleagueTextField("", 10); textPass = new ColleagueTextField("", 10); textPass.setEchoChar('*'); buttonOk = new ColleagueButton("OK"); buttonCancel = new ColleagueButton("Cancel"); checkGuest.setMediator(this); checkLogin.setMediator(this); textUser.setMediator(this); textPass.setMediator(this); buttonOk.setMediator(this); buttonCancel.setMediator(this); checkGuest.addItemListener(checkGuest); checkLogin.addItemListener(checkLogin); textUser.addTextListener(textUser); textPass.addTextListener(textPass); buttonOk.addActionListener(this); buttonCancel.addActionListener(this); &#125; @Override public void colleagueChanged() &#123; if (checkGuest.getState()) &#123; textUser.setColleagueEnabled(false); textPass.setColleagueEnabled(false); buttonOk.setColleagueEnabled(true); &#125; else &#123; textUser.setColleagueEnabled(true); userpassChanged(); &#125; &#125; private void userpassChanged() &#123; if (textUser.getText().length() &gt; 0) &#123; textPass.setColleagueEnabled(true); if (textPass.getText().length() &gt; 0) buttonOk.setColleagueEnabled(true); else buttonOk.setColleagueEnabled(false); &#125; else &#123; textPass.setColleagueEnabled(false); buttonOk.setColleagueEnabled(false); &#125; &#125; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println(e.toString()); System.exit(0); &#125;&#125; Main类123456public class Main &#123; public static void main(String[] args) &#123; new LoginFrame("Mediator Sample"); &#125;&#125; 运行结果 登场角色Mediator（仲裁者、中介者）Mediator角色负责定义与Colleague角色进行通信和做出决定的接口（API）。在示例程序中，由Mediator接口扮演此角色。 ConcreteMediator（具体的仲裁者、中介者）ConcreteMediator角色负责实现Mediator角色的接口（API），负责实际做出决定。在示例程序中，由LoginFrame类扮演此角色。 Colleague（同事）Colleague角色负责定义与Mediator角色进行通信的接口（API）。在示例程序中，由Colleague接口扮演此角色。 ConcreteColleague（具体的同事）ConcreteColleague角色负责实现Colleague角色的接口（API）。在示例程序中，由ColleagueButton类、ColleagueTextField类和ColleagueCheckbox类扮演此角色。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 304 - Range Sum Query 2D - Immutable]]></title>
    <url>%2F2019%2F08%2F24%2FLeetCode-Problem-304-Range-Sum-Query-2D-Immutable%2F</url>
    <content type="text"><![CDATA[Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8. ExampleGiven matrix = 1234567[ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]] sumRegion(2, 1, 4, 3) -&gt; 8sumRegion(1, 1, 2, 2) -&gt; 11sumRegion(1, 2, 2, 4) -&gt; 12 Note You may assume that the matrix does not change. There are many calls to sumRegion function. You may assume that row1 ≤ row2 and col1 ≤ col2. Code1234567891011121314151617private int[][] sum;public NumMatrix(int[][] matrix) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return; sum = new int[matrix.length + 1][matrix[0].length + 1]; for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[0].length; j++) sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + matrix[i][j]; &#125;&#125;public int sumRegion(int row1, int col1, int row2, int col2) &#123; return sum[row2 + 1][col2 + 1] - sum[row1][col2 + 1] - sum[row2 + 1][col1] + sum[row1][col1];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 303 - Range Sum Query - Immutable]]></title>
    <url>%2F2019%2F08%2F24%2FLeetCode-Problem-303-Range-Sum-Query-Immutable%2F</url>
    <content type="text"><![CDATA[Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. ExampleGiven nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 Note You may assume that the array does not change. There are many calls to sumRange function. Code123456789101112private int[] sum;public NumArray(int[] nums) &#123; sum = new int[nums.length + 1]; for (int i = 0; i &lt; nums.length; i++) sum[i + 1] = sum[i] + nums[i];&#125;public int sumRange(int i, int j) &#123; return sum[j + 1] - sum[i];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 292 - Nim Game]]></title>
    <url>%2F2019%2F08%2F24%2FLeetCode-Problem-292-Nim-Game%2F</url>
    <content type="text"><![CDATA[You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. ExampleInput: 4 Output: false Explanation: If there are 4 stones in the heap, then you will never win the game; No matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend. Code123public boolean canWinNim(int n) &#123; return n % 4 != 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 283 - Move Zeroes]]></title>
    <url>%2F2019%2F08%2F24%2FLeetCode-Problem-283-Move-Zeroes%2F</url>
    <content type="text"><![CDATA[Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. ExampleInput: [0,1,0,3,12] Output: [1,3,12,0,0] Note You must do this in-place without making a copy of the array. Minimize the total number of operations. Code123456789101112131415public void moveZeroes(int[] nums) &#123; int start = 0; int end = 0; while (end &lt; nums.length) &#123; if (nums[end] != 0) &#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; &#125; end++; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 278 - First Bad Version]]></title>
    <url>%2F2019%2F08%2F24%2FLeetCode-Problem-278-First-Bad-Version%2F</url>
    <content type="text"><![CDATA[You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. ExampleGiven n = 5, and version = 4 is the first bad version. call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; true Then 4 is the first bad version. Code123456789101112131415public int firstBadVersion(int n) &#123; int left = 1; int right = n; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (!isBadVersion(mid)) left = mid + 1; else right = mid; &#125; return left;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The English We Speak 1]]></title>
    <url>%2F2019%2F08%2F24%2FThe-English-We-Speak-1%2F</url>
    <content type="text"><![CDATA[Proof is in the puddingyou can judge the value or the quality of something only after you have tried it, experienced it or used it. ExamplesA: I don’t believe this new flash washing machine can save water and energy.B: But you haven’t used it yet. The proof is the pudding. A: This second-hand car does look a bit old – can you still drive it?B: Well, why don’t you test drive it? The proof is in the pudding. A: Do you think this will work?B: I don’t know. But let’s wait and see – the proof is in the pudding. Frogmarchto force someone who is unwilling to move forward or to walk somewhere, often by holding their arms tightly. ExamplesThe drunken suspect was handcuffed by the police and frogmarched to the waiting police van. In major sporting events, if you disrupt the game, you risk being frogmarched out of the stadium by security guards. Food for thoughtserious ideas or topics for us to think about. ExamplesThe football coach was really disappointed when his team lost 3-0 to an amateur side. But it gave him food for thought. Mary’s divorce gave her food for thought. She decided to go back to university, get a diploma, and change her life around. Butter upyou’ll be especially nice to them in the hope they’ll do something good for you in return. ExamplesJohnny: I was very impressed with your presentation, Mrs Beany. You are really intelligent and perceptive and…Mrs Beany: Don’t waste your time buttering me up, Johnny. I’m not raising your salary anytime soon. The director was always ready to butter up Angelina Jolie. He knew she was looking for her next role and he wanted her in his movie. Joe Bloggswhen we want to refer to the average person we can use the name ‘Joe Bloggs’. ExamplesA: Bright purple jacket? Sparkly blue skirt? Who wears such outrageous clothes?B: Well, this fashion designer is popular among the very trendy. These clothes are not for Joe Bloggs! Listen, this is a very exclusive party I’m inviting you to. Don’t go around talking about it or every Tom, Dick and Harry will end up there. Detective: The John Doe found at the scene is in the morgue right now. We’re waiting for the DNA test results to identify the body. Don’t throw the baby out with the bathwater‘don’t lose something valuable while we’re getting rid of something else that we don’t want’. ExamplesI know you don’t like the dress, but I think if you make a few changes to it, it will look lovely. It’s such beautiful material. Don’t throw the baby out with the bathwater. Don’t throw the baby out with the bathwater. I know the wallpaper is ugly, but this is a lovely house. We can always redecorate. Take for a ridehe is deceiving you. ExamplesThat hotel took me for a ride. When I booked a room they said they’d give me a full cooked breakfast but all I got was a cup of coffee and a piece of toast. I’m never going back there again. Don’t be taken for a ride. If an offer seems too good to be true, it’s probably not real. Like water off a duck’s backcriticisms or negative things have no effect on you - they’re just like water off a duck’s back - we don’t let them upset or affect us. ExamplesI won’t give up on my singing career just because someone said I’m no good. Criticism is water off a duck’s back to me! I told John not to drive so fast but it was like water off a duck’s back. Last week he crashed his new car. Thankfully nobody was hurt. Eat humble piethey have to admit they can’t do something they boasted about. ExamplesThe factory owner had to eat humble pie after a lot of customers complained about his product. Peter is so arrogant. He said he could finish the work much quicker than anybody else in the office. I hope he has to eat humble pie. Take to the cleanerswe’re going to take a lot of money from them. ExamplesMy husband cheated on me with my best friend! I’m going to get the best divorce lawyer in town and take him to the cleaners! My team has the best players and we’ll take you to the cleaners in this Sunday’s match! PhishingIt’s the name of a particular kind of fraud on the internet.when someone sends you an email pretending to be a reputable company or person hoping you’ll respond and give them your personal information. They want things like your bank account number, password, that kind of thing. ExamplesOur bank never sends emails to clients asking them to reply to a message confirming their password. I’m afraid you’ve been a victim of phishing, sir. I’ve just received an email informing me that I won the lottery. They want my bank details to deposit the prize. But I’ve never entered the lottery. This must be phishing! Give the cold shoulderthey’re behaving in a way that is not friendly at all and they’re doing it for no obvious reason.they are rejecting you or ignoring you. ExamplesAfter Mary divorced her rich husband all their friends gave her the cold shoulder. She was not invited to their lavish parties anymore. My brother told our parents I haven’t been studying at all and my marks are low. I’m not happy and I’ve been giving him the cold shoulder. Let’s see if he’s got the message. Viral‘to go viral’ is used for a picture or a video which has become extremely popular by being circulated quickly and broadly on the internet. ExamplesA video of First Lady Michelle Obama dancing with a turnip has gone viral on the internet. Hundreds of thousands of people have watched her video in support of healthy eating. Viral videos are big business nowadays and even marketing companies are posting amateur-looking videos in the hope of cashing in on the trend. Snail mailthe traditional letter delivering service in which you have a postman and a post box. It’s different from email or electronic mail, when the message sent on the computer travels quickly to its destination. ExamplesI’m sending my auntie Marge this lovely birthday card via snail mail. She lives in Japan. I much prefer using email these days. All I get by snail mail are these marketing leaflets! PostIf you write an opinion on a social media website - you ‘post’ a comment - your comment is… well, ‘a post’! Before, you had to go to the post office to… post your letters. ExamplesThis website’s all about how trendy it is to wear fur. I don’t like it at all. I think I’ll post a comment! Mary has a blog about food and she publishes new posts every day. Hard copythe paper version of a document you write on your computer or of a digital picture you take. ExamplesI’ll give you a hard copy of my report, Mary. You can read it on the bus, on your way home. I have a digital copy of my wedding picture as a screensaver at work but I much prefer my hard copy in a frame. It’s much nicer. Face the musicyou have to accept the consequence of your mistakes. ExamplesWhoever keeps missing these deadlines will have to face the music. After two years of stealing from the family who hired her, the nanny was caught stealing red-handed. Now she has to face the music. Like turkeys voting for Christmassomeone accepts a situation which will have a negative outcome for them. ExamplesWorkers agreeing to pay cuts would be like turkeys voting for Christmas. It would be like turkeys voting for Christmas if people asked for a tax rise. Killing timeto do something which isn’t really important just to keep you occupied until the start of your next plan or arrangement. ExamplesI turned up an hour early for my flight, so I just looked at the duty free to kill some time. I had an hour between work and meeting my friends so I killed time in a department store. I always arrive hours early for job interviews. I’d rather have to kill time than deal with the stress of being late! romcom, whodunnit, sci-fi‘Romcom’ is a word which takes the first two halves of the words ‘romantic’ and ‘comedy’. ‘Whodunnit’ is short for ‘who has done it’. The point of these films is for the audience to try to guess who committed a serious crime – usually murder. ‘Sci-fi is a word which takes the first two halves of the words ‘science’ and ‘fiction.’ These films usually feature robots, aliens and inventions from the future. ExamplesMy favourite sci-fi movie is Star Wars. I can’t wait for the next film in the series! I’m catching a movie with my friends after work. We’re going to watch the latest romcom. Alfred Hitchcock was the master of the whodunnit. Nobody makes better films in that genre than he did!]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 776 - Strobogrammatic Number II]]></title>
    <url>%2F2019%2F08%2F24%2FLintCode-Problem-776-Strobogrammatic-Number-II%2F</url>
    <content type="text"><![CDATA[A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).Find all strobogrammatic numbers that are of length = n. ExampleNo.1Input: n = 2, Output: [“11”,”69”,”88”,”96”] No.2Input: n = 1, Output: [“0”,”1”,”8”] Code12345678910111213141516171819202122232425public List&lt;String&gt; findStrobogrammatic(int n) &#123; return helper(n, n);&#125;private List&lt;String&gt; helper(int n, int len) &#123; if (n == 0) return new ArrayList&lt;&gt;(Arrays.asList("")); else if (n == 1) return new ArrayList&lt;&gt;(Arrays.asList("0", "1", "8")); List&lt;String&gt; result = new ArrayList&lt;&gt;(); List&lt;String&gt; subList = helper(n - 2, len); for (String sub : subList) &#123; if (n != len) result.add("0" + sub + "0"); result.add("1" + sub + "1"); result.add("6" + sub + "9"); result.add("8" + sub + "8"); result.add("9" + sub + "6"); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 644 - Strobogrammatic Number]]></title>
    <url>%2F2019%2F08%2F24%2FLintCode-Problem-644-Strobogrammatic-Number%2F</url>
    <content type="text"><![CDATA[A mirror number is a number that looks the same when rotated 180 degrees (looked at upside down).For example, the numbers “69”, “88”, and “818” are all mirror numbers. Write a function to determine if a number is mirror. The number is represented as a string. ExampleNo.1Input : “69” Output : true No.2Input : “68” Output : false Code12345678910111213141516171819202122public boolean isStrobogrammatic(String num) &#123; Map&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;()&#123;&#123; put('0', '0'); put('1', '1'); put('6', '9'); put('8', '8'); put('9', '6'); &#125;&#125;; int i = 0; int j = num.length() - 1; while (i &lt;= j) &#123; if (!map.containsKey(num.charAt(i)) || map.get(num.charAt(i)) != num.charAt(j)) return false; i++; j--; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 258 - Add Digits]]></title>
    <url>%2F2019%2F08%2F23%2FLeetCode-Problem-258-Add-Digits%2F</url>
    <content type="text"><![CDATA[Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. ExampleInput: 38 Output: 2 Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow upCould you do it without any loop/recursion in O(1) runtime? Code123public int addDigits(int num) &#123; return num == 0 ? 0 : (num - 1) % 9 + 1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 257 - Binary Tree Paths]]></title>
    <url>%2F2019%2F08%2F23%2FLeetCode-Problem-257-Binary-Tree-Paths%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return all root-to-leaf paths. NoteA leaf is a node with no children. ExampleInput: 12345 1 / \2 3 \ 5 Output: [“1-&gt;2-&gt;5”, “1-&gt;3”] Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617181920212223242526272829public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; StringBuilder sb = new StringBuilder(); helper(result, root, sb.append(root.val)); return result;&#125;private void helper(List&lt;String&gt; result, TreeNode root, StringBuilder sb) &#123; if (root.left == null &amp;&amp; root.right == null) &#123; result.add(sb.toString()); return; &#125; int length = sb.length(); if (root.left != null) &#123; helper(result, root.left, sb.append("-&gt;").append(root.left.val)); sb.setLength(length); &#125; if (root.right != null) &#123; helper(result, root.right, sb.append("-&gt;").append(root.right.val)); sb.setLength(length); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 242 - Valid Anagram]]></title>
    <url>%2F2019%2F08%2F23%2FLeetCode-Problem-242-Valid-Anagram%2F</url>
    <content type="text"><![CDATA[Given two strings s and t , write a function to determine if t is an anagram of s. ExampleNo.1Input: s = “anagram”, t = “nagaram” Output: true No.2Input: s = “rat”, t = “car” Output: false NoteYou may assume the string contains only lowercase alphabets. Follow upWhat if the inputs contain unicode characters? How would you adapt your solution to such case? Code123456789101112131415161718public boolean isAnagram(String s, String t) &#123; if (s.length() != t.length()) return false; int[] array = new int[26]; for (char ch : s.toCharArray()) array[ch - 'a']++; for (char ch : t.toCharArray()) &#123; array[ch - 'a']--; if (array[ch - 'a'] &lt; 0) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 234 - Palindrome Linked List]]></title>
    <url>%2F2019%2F08%2F23%2FLeetCode-Problem-234-Palindrome-Linked-List%2F</url>
    <content type="text"><![CDATA[Given a singly linked list, determine if it is a palindrome. ExampleNo.1Input: 1-&gt;2 Output: false No.2Input: 1-&gt;2-&gt;2-&gt;1 Output: true Follow upCould you do it in O(n) time and O(1) space? Code12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public boolean isPalindrome(ListNode head) &#123; if (head == null || head.next == null) return true; ListNode middle = findMiddle(head); middle.next = reverse(middle.next); ListNode node1 = head; ListNode node2 = middle.next; while (node1 != null &amp;&amp; node2 != null) &#123; if (node1.val != node2.val) return false; node1 = node1.next; node2 = node2.next; &#125; return true;&#125;private ListNode findMiddle(ListNode head) &#123; ListNode slow = head; ListNode fast = slow.next; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; return slow;&#125;private ListNode reverse(ListNode current) &#123; ListNode prev = null; while (current != null) &#123; ListNode next = current.next; current.next = prev; prev = current; current = next; &#125; return prev;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Facade模式]]></title>
    <url>%2F2019%2F08%2F23%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Facade%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[可以为系统提供一个简单窗口。 示例编写简单的Web页面。 类图 Database类12345678910111213141516171819202122package pagemaker;import java.io.FileInputStream;import java.io.IOException;import java.util.Properties;public class Database &#123; private Database() &#123;&#125; public static Properties getProperties(String dbname) &#123; String filename = dbname + ".txt"; Properties prop = new Properties(); try &#123; prop.load(new FileInputStream(filename)); &#125; catch (IOException e) &#123; System.out.println("Warning: " + filename + " is not found."); &#125; return prop; &#125;&#125; HtmlWriter类123456789101112131415161718192021222324252627282930313233343536373839package pagemaker;import java.io.IOException;import java.io.Writer;public class HtmlWriter &#123; private Writer writer; public HtmlWriter(Writer writer) &#123; this.writer = writer; &#125; public void title(String title) throws IOException &#123; writer.write("&lt;html&gt;"); writer.write("&lt;head&gt;"); writer.write("&lt;title&gt;" + title + "&lt;/title&gt;"); writer.write("&lt;/head&gt;"); writer.write("&lt;body&gt;\n"); writer.write("&lt;h1&gt;" + title + "&lt;/h1&gt;\n"); &#125; public void paragraph(String msg) throws IOException &#123; writer.write("&lt;p&gt;" + msg + "&lt;/p&gt;\n"); &#125; public void link(String href, String caption) throws IOException &#123; paragraph("&lt;a href=\"" + href + "\"&gt;" + caption + "&lt;/a&gt;"); &#125; public void mailto(String mailaddr, String username) throws IOException &#123; link("mailto:" + mailaddr, username); &#125; public void close() throws IOException &#123; writer.write("&lt;/body&gt;"); writer.write("&lt;/html&gt;\n"); writer.close(); &#125;&#125; PageMaker类12345678910111213141516171819202122232425package pagemaker;import java.io.FileWriter;import java.io.IOException;import java.util.Properties;public class PageMaker &#123; private PageMaker() &#123;&#125; public static void makeWelcomePage(String mailaddr, String filename) &#123; try &#123; Properties mailprop = Database.getProperties("./xxx/maildata"); String username = mailprop.getProperty(mailaddr); HtmlWriter writer = new HtmlWriter(new FileWriter(filename)); writer.title("Welcome to " + username + "'s page!"); writer.paragraph(username + "欢迎来到" + username + "的主页。"); writer.paragraph("等着你的邮件哦！"); writer.mailto(mailaddr, username); writer.close(); System.out.println(filename + " is created for " + mailaddr + " (" + username + ")"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Main类12345678import pagemaker.PageMaker;public class Main &#123; public static void main(String[] args) &#123; PageMaker.makeWelcomePage("hyuki@hyuki.com", "welcome.html"); &#125;&#125; 运行结果1welcome.html is created for hyuki@hyuki.com (Hiroshi Yuki) 登场角色Facade（窗口）Facade角色是代表构成系统的许多其他角色的“简单窗口”。Facade角色向系统外部提供高层接口（API）。在示例程序中，由PageMaker类扮演此角色。 构成系统的许多其他角色这些角色各自完成自己的工作，它们并不知道Facade角色。Facade角色调用其他角色进行工作，但是其他角色不会调用Facade角色。在示例程序中，由Database类和HtmlWriter类扮演此角色。 Client（请求者）Client角色负责调用Facade角色。在示例程序中，由Main类扮演此角色。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 205 - Isomorphic Strings]]></title>
    <url>%2F2019%2F08%2F22%2FLeetCode-Problem-205-Isomorphic-Strings%2F</url>
    <content type="text"><![CDATA[Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. ExampleNo.1Input: s = “egg”, t = “add” Output: true No.2Input: s = “foo”, t = “bar” Output: false No.3Input: s = “paper”, t = “title” Output: true NoteYou may assume both s and t have the same length. Code1234567891011121314151617public boolean isIsomorphic(String s, String t) &#123; int[] array1 = new int[256]; int[] array2 = new int[256]; for (int i = 1; i &lt;= s.length(); i++) &#123; int idx1 = s.charAt(i - 1); int idx2 = t.charAt(i - 1); if (array1[idx1] != array2[idx2]) return false; array1[idx1] = i; array2[idx2] = i; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 189 - Rotate Array]]></title>
    <url>%2F2019%2F08%2F22%2FLeetCode-Problem-189-Rotate-Array%2F</url>
    <content type="text"><![CDATA[Given an array, rotate the array to the right by k steps, where k is non-negative. ExampleNo.1Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation:rotate 1 steps to the right: [7,1,2,3,4,5,6]rotate 2 steps to the right: [6,7,1,2,3,4,5]rotate 3 steps to the right: [5,6,7,1,2,3,4] No.2Input: [-1,-100,3,99] and k = 2 Output: [3,99,-1,-100] Explanation:rotate 1 steps to the right: [99,-1,-100,3]rotate 2 steps to the right: [3,99,-1,-100] Note Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space? Code123456789101112131415161718public void rotate(int[] nums, int k) &#123; int n = nums.length; k %= n; reverse(nums, 0, n - k - 1); reverse(nums, n - k, n - 1); reverse(nums, 0, n - 1);&#125;private void reverse(int[] nums, int i, int j) &#123; while (i &lt; j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; i++; j--; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 607 - Two Sum III - Data structure design]]></title>
    <url>%2F2019%2F08%2F22%2FLintCode-Problem-607-Two-Sum-III-Data-structure-design%2F</url>
    <content type="text"><![CDATA[Design and implement a TwoSum class. It should support the following operations: add and find. add - Add the number to an internal data structure.find - Find if there exists any pair of numbers which sum is equal to the value. Example123add(1); add(3); add(5);find(4) // return truefind(7) // return false Code1234567891011121314151617181920private Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();public void add(int number) &#123; map.put(number, map.getOrDefault(number, 0) + 1);&#125;public boolean find(int value) &#123; for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; int val = value - entry.getKey(); if (map.containsKey(val)) &#123; if (val * 2 != value) return true; else if (val * 2 == value &amp;&amp; map.get(val) &gt; 1) return true; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 191 - Number of 1 Bits]]></title>
    <url>%2F2019%2F08%2F22%2FLeetCode-Problem-191-Number-of-1-Bits%2F</url>
    <content type="text"><![CDATA[Write a function that takes an unsigned integer and return the number of ‘1’ bits it has (also known as the Hamming weight). ExampleNo.1Input: 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three ‘1’ bits. No.2Input: 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one ‘1’ bit. No.3Input: 11111111111111111111111111111101 Output: 31 Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one ‘1’ bits. Note Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 3 above the input represents the signed integer -3. Follow upIf this function is called many times, how would you optimize it? Code12345678910public int hammingWeight(int n) &#123; int count = 0; for (int i = 0; i &lt; 32; i++) &#123; count += (n &amp; 1); n &gt;&gt;= 1; &#125; return count;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 190 - Reverse Bits]]></title>
    <url>%2F2019%2F08%2F22%2FLeetCode-Problem-190-Reverse-Bits%2F</url>
    <content type="text"><![CDATA[Reverse bits of a given 32 bits unsigned integer. ExampleNo.1Input: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. No.2Input: 11111111111111111111111111111101 Output: 10111111111111111111111111111111 Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001. Note: Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 2 above the input represents the signed integer -3 and the output represents the signed integer -1073741825. Follow upIf this function is called many times, how would you optimize it? Code12345678910public int reverseBits(int n) &#123; int result = 0; for (int i = 0; i &lt; 32; i++) &#123; result = (result &lt;&lt; 1) | (n &amp; 1); n &gt;&gt;= 1; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 172 - Factorial Trailing Zeroes]]></title>
    <url>%2F2019%2F08%2F22%2FLeetCode-Problem-172-Factorial-Trailing-Zeroes%2F</url>
    <content type="text"><![CDATA[Given an integer n, return the number of trailing zeroes in n!. ExampleNo.1Input: 3 Output: 0 Explanation: 3! = 6, no trailing zero. No.2Input: 5 Output: 1 Explanation: 5! = 120, one trailing zero. NoteYour solution should be in logarithmic time complexity. Code123public int trailingZeroes(int n) &#123; return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 160 - Intersection of Two Linked Lists]]></title>
    <url>%2F2019%2F08%2F21%2FLeetCode-Problem-160-Intersection-of-Two-Linked-Lists%2F</url>
    <content type="text"><![CDATA[Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: begin to intersect at node c1. ExampleNo.1 Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 Output: Reference of the node with value = 8 Input Explanation: The intersected node’s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. No.2 Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 Output: Reference of the node with value = 2 Input Explanation: The intersected node’s value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B. No.3 Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 Output: null Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.Explanation: The two lists do not intersect, so return null. Note If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. Code12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode currentA = headA; ListNode currentB = headB; while (currentA != currentB) &#123; currentA = currentA != null ? currentA.next : headB; currentB = currentB != null ? currentB.next : headA; &#125; return currentA;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 1049 - Last Stone Weight II]]></title>
    <url>%2F2019%2F08%2F21%2FLeetCode-Problem-1049-Last-Stone-Weight-II%2F</url>
    <content type="text"><![CDATA[We have a collection of rocks, each rock has a positive integer weight. Each turn, we choose any two rocks and smash them together. Suppose the stones have weights x and y with x &lt;= y. The result of this smash is: If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x. At the end, there is at most 1 stone left. Return the smallest possible weight of this stone (the weight is 0 if there are no stones left.) ExampleInput: [2,7,4,1,8,1] Output: 1 Explanation:We can combine 2 and 4 to get 2 so the array converts to [2,7,1,8,1] then,we can combine 7 and 8 to get 1 so the array converts to [2,1,1,1] then,we can combine 2 and 1 to get 1 so the array converts to [1,1,1] then,we can combine 1 and 1 to get 0 so the array converts to [1] then that’s the optimal value. Note 1 &lt;= stones.length &lt;= 30 1 &lt;= stones[i] &lt;= 100 Code12345678910111213141516171819// dp[i][j] = max&#123;dp[i - 1][j], dp[i - 1][j - stone[i]] + stone[i]&#125;public int lastStoneWeightII(int[] stones) &#123; int sum = 0; for (int stone : stones) sum += stone; int n = sum / 2; int[] dp = new int[n + 1]; for (int i = 0; i &lt; stones.length; i++) &#123; int stone = stones[i]; for (int j = n; j &gt;= stone; j--) dp[j] = Math.max(dp[j], dp[j - stone] + stone); &#125; return sum - 2 * dp[n];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 1046 - Last Stone Weight]]></title>
    <url>%2F2019%2F08%2F21%2FLeetCode-Problem-1046-Last-Stone-Weight%2F</url>
    <content type="text"><![CDATA[We have a collection of rocks, each rock has a positive integer weight. Each turn, we choose the two heaviest rocks and smash them together. Suppose the stones have weights x and y with x &lt;= y. The result of this smash is: If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x. At the end, there is at most 1 stone left. Return the weight of this stone (or 0 if there are no stones left.) ExampleInput: [2,7,4,1,8,1] Output: 1 Explanation:We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,we combine 1 and 1 to get 0 so the array converts to [1] then that’s the value of last stone. Note 1 &lt;= stones.length &lt;= 30 1 &lt;= stones[i] &lt;= 1000 Code123456789101112131415161718192021public int lastStoneWeight(int[] stones) &#123; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2 - o1; &#125; &#125;); for (int stone : stones) pq.offer(stone); while (pq.size() &gt; 1) &#123; int x = pq.poll(); int y = pq.poll(); if (x != y) pq.offer(x - y); &#125; return pq.isEmpty() ? 0 : pq.poll();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 1040 - Moving Stones Until Consecutive II]]></title>
    <url>%2F2019%2F08%2F21%2FLeetCode-Problem-1040-Moving-Stones-Until-Consecutive-II%2F</url>
    <content type="text"><![CDATA[On an infinite number line, the position of the i-th stone is given by stones[i]. Call a stone an endpoint stone if it has the smallest or largest position. Each turn, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone. In particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone. The game ends when you cannot make any more moves, ie. the stones are in consecutive positions. When the game ends, what is the minimum and maximum number of moves that you could have made? Return the answer as an length 2 array: answer = [minimum_moves, maximum_moves] ExampleNo.1Input: [7,4,9] Output: [1,2] Explanation:We can move 4 -&gt; 8 for one move to finish the game.Or, we can move 9 -&gt; 5, 4 -&gt; 6 for two moves to finish the game. No.2Input: [6,5,4,3,10] Output: [2,3] We can move 3 -&gt; 8 then 10 -&gt; 7 to finish the game.Or, we can move 3 -&gt; 7, 4 -&gt; 8, 5 -&gt; 9 to finish the game.Notice we cannot move 10 -&gt; 2 to finish the game, because that would be an illegal move. No.3Input: [100,101,104,102,103] Output: [0,0] Note 3 &lt;= stones.length &lt;= 10^4 1 &lt;= stones[i] &lt;= 10^9 stones[i] have distinct values. Code1234567891011121314151617181920212223public int[] numMovesStonesII(int[] stones) &#123; int n = stones.length; Arrays.sort(stones); int max = Math.max(stones[n - 1] - stones[1] - n + 2, stones[n - 2] - stones[0] - n + 2); int min = n; int start = 0; int end = 0; while (end &lt; n) &#123; while (stones[end] &gt; stones[start] + n - 1) start++; if (start + n - 2 == end &amp;&amp; stones[start] + n - 2 == stones[end]) min = Math.min(min, 2); // 1,2,3,4,10 -&gt; 2,3,4,5,6 else min = Math.min(min, n - (end - start + 1)); // 1,2,4,5,10 -&gt; 1,2,3,4,5 end++; &#125; return new int[] &#123;min, max&#125;;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 1033 - Moving Stones Until Consecutive]]></title>
    <url>%2F2019%2F08%2F21%2FLeetCode-Problem-1033-Moving-Stones-Until-Consecutive%2F</url>
    <content type="text"><![CDATA[Three stones are on a number line at positions a, b, and c. Each turn, you pick up a stone at an endpoint (ie., either the lowest or highest position stone), and move it to an unoccupied position between those endpoints. Formally, let’s say the stones are currently at positions x, y, z with x &lt; y &lt; z. You pick up the stone at either position x or position z, and move that stone to an integer position k, with x &lt; k &lt; z and k != y. The game ends when you cannot make any more moves, ie. the stones are in consecutive positions. When the game ends, what is the minimum and maximum number of moves that you could have made? Return the answer as an length 2 array: answer = [minimum_moves, maximum_moves] ExampleNo.1Input: a = 1, b = 2, c = 5 Output: [1,2] Explanation: Move the stone from 5 to 3, or move the stone from 5 to 4 to 3. No.2Input: a = 4, b = 3, c = 2 Output: [0,0] Explanation: We cannot make any moves. No.3Input: a = 3, b = 5, c = 1 Output: [1,2] Explanation: Move the stone from 1 to 4; or move the stone from 1 to 2 to 4. Note 1 &lt;= a &lt;= 100 1 &lt;= b &lt;= 100 1 &lt;= c &lt;= 100 a != b, b != c, c != a Code1234567891011121314public int[] numMovesStones(int a, int b, int c) &#123; int[] num = &#123;a, b, c&#125;; Arrays.sort(num); int max = num[2] - num[0] - 2; int min = 2; if (num[1] - num[0] == 1 &amp;&amp; num[2] - num[1] == 1) min = 0; else if (num[1] - num[0] &lt;= 2 || num[2] - num[1] &lt;= 2) min = 1; return new int[] &#123;min, max&#125;;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 1140 - Stone Game II]]></title>
    <url>%2F2019%2F08%2F20%2FLeetCode-Problem-1140-Stone-Game-II%2F</url>
    <content type="text"><![CDATA[Alex and Lee continue their games with piles of stones. There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones. Alex and Lee take turns, with Alex starting first. Initially, M = 1. On each player’s turn, that player can take all the stones in the first X remaining piles, where 1 &lt;= X &lt;= 2M. Then, we set M = max(M, X). The game continues until all the stones have been taken. Assuming Alex and Lee play optimally, return the maximum number of stones Alex can get. ExampleInput: piles = [2,7,9,4,4] Output: 10 Explanation: If Alex takes one pile at the beginning, Lee takes two piles, then Alex takes 2 piles again. Alex can get 2 + 4 + 4 = 10 piles in total. If Alex takes two piles at the beginning, then Lee can take all three piles left. In this case, Alex get 2 + 7 = 9 piles in total. So we return 10 since it’s larger. Constraints 1 &lt;= piles.length &lt;= 100 1 &lt;= piles[i] &lt;= 10 ^ 4 Code12345678910111213141516171819202122232425262728293031323334private int[] sum;private int[][] memo;public int stoneGameII(int[] piles) &#123; int n = piles.length; sum = new int[n]; memo = new int[n][n]; for (int i = 0; i &lt; n; i++) sum[i] = (i == 0 ? 0 : sum[i - 1]) + piles[i]; return (sum[n - 1] + helper(piles, n, 0, 1)) / 2;&#125;private int helper(int[] piles, int n, int s, int M) &#123; if (s &gt;= n) return 0; if (memo[s][M] != 0) return memo[s][M]; int max = Integer.MIN_VALUE; for (int x = 1; x &lt;= 2 * M; x++) &#123; if (s + x &gt; n) break; max = Math.max(max, sum[s + x - 1] - (s == 0 ? 0 : sum[s - 1]) - helper(piles, n, s + x, Math.max(x, M))); &#125; memo[s][M] = max; return max;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 877 - Stone Game]]></title>
    <url>%2F2019%2F08%2F20%2FLeetCode-Problem-877-Stone-Game%2F</url>
    <content type="text"><![CDATA[Alex and Lee play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones. The total number of stones is odd, so there are no ties. Alex and Lee take turns, with Alex starting first. Each turn, a player takes the entire pile of stones from either the beginning or the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins. Assuming Alex and Lee play optimally, return True if and only if Alex wins the game. ExampleInput: [5,3,4,5] Output: true Explanation:Alex starts first, and can only take the first 5 or the last 5.Say he takes the first 5, so that the row becomes [3, 4, 5].If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.This demonstrated that taking the first 5 was a winning move for Alex, so we return true. Note 2 &lt;= piles.length &lt;= 500 piles.length is even. 1 &lt;= piles[i] &lt;= 500 sum(piles) is odd. Code123456789101112// dp[i][j] = max&#123;piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])&#125;public boolean stoneGame(int[] piles) &#123; int n = piles.length; int[] dp = piles.clone(); for (int len = 2; len &lt;= n; len++) &#123; for (int i = 0; i + len - 1 &lt; n; i++) dp[i] = Math.max(piles[i] - dp[i + 1], piles[i + len - 1] - dp[i]); &#125; return dp[0] &gt; 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 312 - Burst Balloons]]></title>
    <url>%2F2019%2F08%2F20%2FLeetCode-Problem-312-Burst-Balloons%2F</url>
    <content type="text"><![CDATA[Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them. 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 ExampleInput: [3,1,5,8] Output: 167 Explanation: nums = [3,1,5,8] –&gt; [3,5,8] –&gt; [3,8] –&gt; [8] –&gt; [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 Code1234567891011121314151617181920212223// dp[i][j] = max&#123;dp[i][k - 1] + val[i - 1] * val[k] * val[j + 1] + dp[k + 1][j]&#125;public int maxCoins(int[] nums) &#123; int n = nums.length; int[][] dp = new int[n + 2][n + 2]; int[] val = new int[n + 2]; val[0] = 1; val[n + 1] = 1; for (int i = 1; i &lt;= n; i++) val[i] = nums[i - 1]; for (int len = 1; len &lt;= n; len++) &#123; for (int i = 1; i + len - 1 &lt;= n; i++) &#123; int j = i + len - 1; for (int k = i; k &lt;= j; k++) dp[i][j] = Math.max(dp[i][j], dp[i][k - 1] + val[i - 1] * val[k] * val[j + 1] + dp[k + 1][j]); &#125; &#125; return dp[1][n];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 778 - Swim in Rising Water]]></title>
    <url>%2F2019%2F08%2F20%2FLeetCode-Problem-778-Swim-in-Rising-Water%2F</url>
    <content type="text"><![CDATA[On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j). Now rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim. You start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)? ExampleNo.1Input: [[0,2],[1,3]] Output: 3 Explanation:At time 0, you are in grid location (0, 0).You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.You cannot reach point (1, 1) until time 3.When the depth of water is 3, we can swim anywhere inside the grid. No.2Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] Output: 16 Explanation:00 01 02 03 0424 23 22 21 0512 13 14 15 1611 17 18 19 2010 09 08 07 06 The final route is marked in bold.We need to wait until time 16 so that (0, 0) and (4, 4) are connected. Note 2 &lt;= N &lt;= 50. grid[i][j] is a permutation of [0, …, N*N - 1]. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Point implements Comparable&lt;Point&gt; &#123; private int x; private int y; private int time; public Point(int x, int y, int time) &#123; this.x = x; this.y = y; this.time = time; &#125; @Override public int compareTo(Point o) &#123; return this.time - o.time; &#125;&#125;public int swimInWater(int[][] grid) &#123; int n = grid.length; int[][] dirs = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; boolean[][] visit = new boolean[n][n]; PriorityQueue&lt;Point&gt; pq = new PriorityQueue&lt;Point&gt;(); visit[0][0] = true; pq.offer(new Point(0, 0, grid[0][0])); while (!pq.isEmpty()) &#123; Point point = pq.poll(); if (point.x == n - 1 &amp;&amp; point.y == n - 1) return point.time; for (int[] dir : dirs) &#123; int x = point.x + dir[0]; int y = point.y + dir[1]; if (x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= n || visit[x][y]) continue; visit[x][y] = true; int time = Math.max(grid[x][y], point.time); pq.offer(new Point(x, y, time)); &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 329 - Longest Increasing Path in a Matrix]]></title>
    <url>%2F2019%2F08%2F19%2FLeetCode-Problem-329-Longest-Increasing-Path-in-a-Matrix%2F</url>
    <content type="text"><![CDATA[Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). ExampleNo.1Input: nums = 12345[ [9,9,4], [6,6,8], [2,1,1]] Output: 4 Explanation: The longest increasing path is [1, 2, 6, 9]. No.2Input: nums = 12345[ [3,4,5], [3,2,6], [2,2,1]] Output: 4 Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed. Code1234567891011121314151617181920212223242526272829303132333435363738394041private int[][] dirs = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;public int longestIncreasingPath(int[][] matrix) &#123; int result = 0; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return result; int m = matrix.length; int n = matrix[0].length; int[][] path = new int[m][n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) result = Math.max(result, dfs(matrix, path, m, n, i, j)); &#125; return result;&#125;private int dfs(int[][] matrix, int[][] path, int m, int n, int x, int y) &#123; if (path[x][y] != 0) return path[x][y]; path[x][y] = 1; for (int[] dir : dirs) &#123; int newX = x + dir[0]; int newY = y + dir[1]; if (newX &lt; 0 || newY &lt; 0 || newX &gt;= m || newY &gt;= n) continue; if (matrix[x][y] &gt;= matrix[newX][newY]) continue; path[x][y] = Math.max(path[x][y], 1 + dfs(matrix, path, m, n, newX, newY)); &#125; return path[x][y];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 1004 - Max Consecutive Ones III]]></title>
    <url>%2F2019%2F08%2F19%2FLeetCode-Problem-1004-Max-Consecutive-Ones-III%2F</url>
    <content type="text"><![CDATA[Given an array A of 0s and 1s, we may change up to K values from 0 to 1. Return the length of the longest (contiguous) subarray that contains only 1s. ExampleNo.1Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2 Output: 6 Explanation:[1,1,1,0,0,1,1,1,1,1,1]Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. No.2Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3 Output: 10 Explanation:[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. Note 1 &lt;= A.length &lt;= 20000 0 &lt;= K &lt;= A.length A[i] is 0 or 1 Code1234567891011121314151617181920212223public int longestOnes(int[] A, int K) &#123; int max = 0; int start = 0; int end = 0; int zero = 0; while (end &lt; A.length) &#123; if (A[end] == 0) zero++; while (zero &gt; K) &#123; if (A[start] == 0) zero--; start++; &#125; max = Math.max(max, end - start + 1); end++; &#125; return max;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 883 - Max Consecutive Ones II]]></title>
    <url>%2F2019%2F08%2F19%2FLintCode-Problem-883-Max-Consecutive-Ones-II%2F</url>
    <content type="text"><![CDATA[Given a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0. Note The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000. ExampleNo.1Input: nums = [1,0,1,1,0] Output: 4 Explanation:Flip the first zero will get the the maximum number of consecutive 1s.After flipping, the maximum number of consecutive 1s is 4. No.2Input: nums = [1,0,1,0,1] Output: 3 Explanation:Flip each zero will get the the maximum number of consecutive 1s.After flipping, the maximum number of consecutive 1s is 3. Code1234567891011121314151617181920212223public int findMaxConsecutiveOnes(int[] nums) &#123; int max = 0; int start = 0; int end = 0; int zero = 0; while (end &lt; nums.length) &#123; if (nums[end] == 0) zero++; while (zero &gt; 1) &#123; if (nums[start] == 0) zero--; start++; &#125; max = Math.max(max, end - start + 1); end++; &#125; return max;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 485 - Max Consecutive Ones]]></title>
    <url>%2F2019%2F08%2F19%2FLeetCode-Problem-485-Max-Consecutive-Ones%2F</url>
    <content type="text"><![CDATA[Given a binary array, find the maximum number of consecutive 1s in this array. ExampleInput: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000 Code1234567891011public int findMaxConsecutiveOnes(int[] nums) &#123; int max = 0; int count = 0; for (int num : nums) &#123; count = (num == 0) ? 0 : count + 1; max = Math.max(max, count); &#125; return max;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 789 - The Maze III]]></title>
    <url>%2F2019%2F08%2F18%2FLintCode-Problem-789-The-Maze-III%2F</url>
    <content type="text"><![CDATA[There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up (u), down (d), left (l) or right (r), but it won’t stop rolling until hitting a wall. When the ball stops, it could choose the next direction. There is also a hole in this maze. The ball will drop into the hole if it rolls on to the hole. Given the ball position, the hole position and the maze, find out how the ball could drop into the hole by moving the shortest distance. The distance is defined by the number of empty spaces traveled by the ball from the start position (excluded) to the hole (included). Output the moving directions by using ‘u’, ‘d’, ‘l’ and ‘r’. Since there could be several different shortest ways, you should output the lexicographically smallest way. If the ball cannot reach the hole, output “impossible”. The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The ball and the hole coordinates are represented by row and column indexes. Note There is only one ball and one hole in the maze. Both the ball and hole exist on an empty space, and they will not be at the same position initially. The given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls. The maze contains at least 2 empty spaces, and the width and the height of the maze won’t exceed 30. ExampleNo.1Input:[[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]][4,3][0,1] Output:“lul” No.2Input:[[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]][0,0][1,1][2,2][3,3] Output:“impossible” Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Point implements Comparable&lt;Point&gt; &#123; private int x; private int y; private int distance; private String path; public Point(int x, int y, int distance, String path) &#123; this.x = x; this.y = y; this.distance = distance; this.path = path; &#125; @Override public int compareTo(Point o) &#123; return this.distance == o.distance ? this.path.compareTo(o.path) : this.distance - o.distance; &#125;&#125;public String findShortestWay(int[][] maze, int[] ball, int[] hole) &#123; int n = maze.length; int m = maze[0].length; int[][] directions = &#123;&#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;&#125;; String[] dirs = &#123;"d", "l", "r", "u"&#125;; boolean[][] visit = new boolean[n][m]; PriorityQueue&lt;Point&gt; pq = new PriorityQueue&lt;&gt;(); pq.offer(new Point(ball[0], ball[1], 0, "")); while (!pq.isEmpty()) &#123; Point point = pq.poll(); if (point.x == hole[0] &amp;&amp; point.y == hole[1]) return point.path; else if (visit[point.x][point.y]) continue; visit[point.x][point.y] = true; for (int i = 0; i &lt; directions.length; i++) &#123; int x = point.x; int y = point.y; int distance = point.distance; String path = point.path; while (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; m &amp;&amp; maze[x][y] == 0 &amp;&amp; !(x == hole[0] &amp;&amp; y == hole[1])) &#123; x += directions[i][0]; y += directions[i][1]; distance++; &#125; if (!(x == hole[0] &amp;&amp; y == hole[1])) &#123; x -= directions[i][0]; y -= directions[i][1]; distance--; &#125; pq.offer(new Point(x, y, distance, path + dirs[i])); &#125; &#125; return "impossible";&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 905 - Nested List Weight Sum II]]></title>
    <url>%2F2019%2F08%2F18%2FLintCode-Problem-905-Nested-List-Weight-Sum-II%2F</url>
    <content type="text"><![CDATA[Given a nested list of integers, return the sum of all integers in the list weighted by their depth. Each element is either an integer, or a list – whose elements may also be integers or other lists. Different from the previous question where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight. ExampleNo.1Input: nestedList = [[1,1],2,[1,1]] Output: 8 Explanation:four 1’s at depth 1, one 2 at depth 2 No.2Input: nestedList = [1,[4,[6]]] Output: 17 Explanation:one 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1*3 + 4*2 + 6*1 = 17 Code12345public interface NestedInteger &#123; public boolean isInteger(); public Integer getInteger(); public List&lt;NestedInteger&gt; getList();&#125; 1234567891011121314151617181920public int depthSumInverse(List&lt;NestedInteger&gt; nestedList) &#123; return helper(nestedList, 0);&#125;private int helper(List&lt;NestedInteger&gt; nestedList, int intSum) &#123; List&lt;NestedInteger&gt; nextList = new ArrayList&lt;&gt;(); int listSum = 0; for (NestedInteger nestedInteger : nestedList) &#123; if (nestedInteger.isInteger()) intSum += nestedInteger.getInteger(); else nextList.addAll(nestedInteger.getList()); &#125; if (!nextList.isEmpty()) listSum = helper(nextList, intSum); return listSum + intSum;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 551 - Nested List Weight Sum]]></title>
    <url>%2F2019%2F08%2F18%2FLintCode-Problem-551-Nested-List-Weight-Sum%2F</url>
    <content type="text"><![CDATA[Given a nested list of integers, return the sum of all integers in the list weighted by their depth. Each element is either an integer, or a list – whose elements may also be integers or other lists. ExampleNo.1Input: the list [[1,1],2,[1,1]], Output: 10. Explanation:four 1’s at depth 2, one 2 at depth 1, 4 * 1 * 2 + 1 * 2 * 1 = 10 No.2Input: the list [1,[4,[6]]], Output: 27. Explanation:one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4 * 2 + 6 * 3 = 27 Code12345public interface NestedInteger &#123; public boolean isInteger(); public Integer getInteger(); public List&lt;NestedInteger&gt; getList();&#125; 1234567891011121314151617181920212223242526public int depthSum(List&lt;NestedInteger&gt; nestedList) &#123; Queue&lt;NestedInteger&gt; queue = new LinkedList&lt;&gt;(); int level = 0; int sum = 0; for (NestedInteger nestedInteger : nestedList) queue.offer(nestedInteger); while (!queue.isEmpty()) &#123; int size = queue.size(); level++; for (int i = 0; i &lt; size; i++) &#123; NestedInteger nestedInteger = queue.poll(); if (nestedInteger.isInteger()) sum += level * nestedInteger.getInteger(); else &#123; for (NestedInteger list : nestedInteger.getList()) queue.offer(list); &#125; &#125; &#125; return sum;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 804 - Number of Distinct Islands II]]></title>
    <url>%2F2019%2F08%2F18%2FLintCode-Problem-804-Number-of-Distinct-Islands-II%2F</url>
    <content type="text"><![CDATA[Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Count the number of distinct islands. An island is considered to be the same as another if they have the same shape, or have the same shape after rotation (90, 180, or 270 degrees only) or reflection (left/right direction or up/down direction). NoteThe length of each dimension in the given grid does not exceed 50. ExampleNo.1Input: [[1,1,0,0,0],[1,0,0,0,0],[0,0,0,0,1],[0,0,0,1,1]] Output: 1 Explanation:The island is look like this: 123411000100000000100011 Notice that: 12111 and 12 111 are considered same island shapes. Because if we make a 180 degrees clockwise rotation on the first island, then two islands will have the same shapes. No.2Input: [[1,1,1,0,0],[1,0,0,0,1],[0,1,0,0,1],[0,1,1,1,0]] Output: 2 Explanation:The island is look like this: 123411100100010100101110 Here are the two distinct islands: 121111 and 1211 Notice that: 121111 and 121111 are considered same island shapes. Because if we flip the first array in the up/down direction, then they have the same shapes. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private int[][] dirs = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;private int[][] trans = &#123;&#123;1, 1&#125;, &#123;-1, 1&#125;, &#123;1, -1&#125;, &#123;-1, -1&#125;&#125;;private Comparator&lt;int[]&gt; comparator = new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1, int[] o2) &#123; return o1[0] == o2[0] ? o1[1] - o2[1] : o1[0] - o2[0]; &#125;&#125;;public int numDistinctIslands2(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; Set&lt;String&gt; set = new HashSet&lt;&gt;(); boolean[][] visit = new boolean[m][n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 1 &amp;&amp; !visit[i][j]) &#123; List&lt;int[]&gt; island = new ArrayList&lt;&gt;(); dfs(island, grid, visit, m, n, i, j); set.add(normalize(island)); &#125; &#125; &#125; return set.size();&#125;private void dfs(List&lt;int[]&gt; island, int[][] grid, boolean[][] visit, int m, int n, int x, int y) &#123; island.add(new int[] &#123;x, y&#125;); visit[x][y] = true; for (int[] dir : dirs) &#123; int newX = x + dir[0]; int newY = y + dir[1]; if (newX &lt; 0 || newY &lt; 0 || newX &gt;= m || newY &gt;= n || grid[newX][newY] == 0 || visit[newX][newY]) continue; dfs(island, grid, visit, m, n, newX, newY); &#125;&#125;private String normalize(List&lt;int[]&gt; island) &#123; List&lt;int[]&gt;[] shapes = new ArrayList[8]; String[] results = new String[8]; for (int i = 0; i &lt; trans.length; i++) &#123; int[] tran = trans[i]; shapes[i] = new ArrayList&lt;&gt;(); shapes[i + 4] = new ArrayList&lt;&gt;(); for (int[] point : island) &#123; shapes[i].add(new int[] &#123;point[0] * tran[0], point[1] * tran[1]&#125;); shapes[i + 4].add(new int[] &#123;point[1] * tran[1], point[0] * tran[0]&#125;); &#125; Collections.sort(shapes[i], comparator); Collections.sort(shapes[i + 4], comparator); &#125; for (int i = 0; i &lt; shapes.length; i++) &#123; StringBuilder sb = new StringBuilder(); int originX = shapes[i].get(0)[0]; int originY = shapes[i].get(0)[1]; for (int[] point : shapes[i]) sb.append(point[0] - originX).append(",").append(point[1] - originY).append(","); results[i] = sb.toString(); &#125; Arrays.sort(results); return results[0];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 434 - Number of Islands II]]></title>
    <url>%2F2019%2F08%2F17%2FLintCode-Problem-434-Number-of-Islands-II%2F</url>
    <content type="text"><![CDATA[Given a n,m which means the row and column of the 2D matrix and an array of pair A(size k). Originally, the 2D matrix is all 0 which means there is only sea in the matrix. The list pair has k operator and each operator has two integer A[i].x, A[i].y means that you can change the grid matrix[A[i].x][A[i].y] from sea to island. Return how many island are there in the matrix after each operator. Note0 is represented as the sea, 1 is represented as the island. If two 1 is adjacent, we consider them in the same island. We only consider up/down/left/right adjacent. ExampleNo.1Input: n = 4, m = 5, A = [[1,1],[0,1],[3,3],[3,4]] Output: [1,1,2,2] Explanation: 12345678910111213141516171819200. 00000 00000 00000 000001. 00000 01000 00000 000002. 01000 01000 00000 000003. 01000 01000 00000 000104. 01000 01000 00000 00011 No.2Input: n = 3, m = 3, A = [[0,0],[0,1],[2,2],[2,1]] Output: [1,1,2,2] Code123456public class Point &#123; int x; int y; Point() &#123; x = 0; y = 0; &#125; Point(int a, int b) &#123; x = a; y = b; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class UnionFind&#123; private int[] id; private int[] size; private int count; public UnionFind(int n) &#123; this.id = new int[n+1]; this.size = new int[n+1]; this.count = n; for (int i = 1; i &lt;= n; i++) &#123; id[i] = i; size[i] = 1; &#125; &#125; public int count() &#123; return count; &#125; public boolean union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return false; if (size[pRoot] &lt; size[qRoot]) &#123; id[pRoot] = qRoot; size[qRoot] += size[pRoot]; &#125; else &#123; id[qRoot] = pRoot; size[pRoot] += size[qRoot]; &#125; count--; return true; &#125; public int find(int p) &#123; while (p != id[p]) p = id[p]; return p; &#125;&#125;public List&lt;Integer&gt; numIslands2(int n, int m, Point[] operators) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (operators == null || operators.length == 0) return result; int[][] dirs = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; Set&lt;Integer&gt; island = new HashSet&lt;&gt;(); UnionFind uf = new UnionFind(n * m); for (Point operator : operators) &#123; int idx = operator.x * m + operator.y; island.add(idx); for (int[] dir : dirs) &#123; int x = operator.x + dir[0]; int y = operator.y + dir[1]; int newIdx = x * m + y; if (x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= m || !island.contains(newIdx)) continue; uf.union(idx, newIdx); &#125; result.add(uf.count() - n * m + island.size()); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookies池的搭建]]></title>
    <url>%2F2019%2F08%2F17%2FCookies%E6%B1%A0%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Cookie池 存储模块负责存储每个账号的用户名密码以及每个账号对应的Cookies信息，同时还需要提供一些方法来实现方便的存取操作。 生成模块负责生成新的Cookies。此模块会从存储模块逐个拿取账号的用户名和密码，然后模拟登录目标页面，判断登录成功，就将Cookies返回并交给存储模块存储。 检测模块需要定时检测数据库中的Cookies。逐个拿取账号对应的Cookies去请求链接，如果返回的状态是有效的，那么此Cookies没有失效，否则Cookies失效并移除。接下来等待生成模块重新生成即可。 接口模块需要用API来提供对外服务的接口。由于可用的Cookies可能有多个，可以随机返回Cookies的接口，这样保证每个Cookies都有可能被取到。Cookies越多，每个Cookies被取到的概率就会越小，从而减少被封号的风险。]]></content>
      <categories>
        <category>Web Crawler</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web Crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理池的维护]]></title>
    <url>%2F2019%2F08%2F17%2F%E4%BB%A3%E7%90%86%E6%B1%A0%E7%9A%84%E7%BB%B4%E6%8A%A4%2F</url>
    <content type="text"><![CDATA[代理池 存储模块使用Redis的有序集合，用来做代理的去重和状态标识，同时它也是中心模块和基础模块，将其他模块串联起来。 获取模块定时从代理网站获取代理，将获取的代理传递给存储模块，并保存到数据库。 检测模块定时通过存储模块获取所有代理，并对代理进行检测，根据不同的检测结果对代理设置不同的标识。 接口模块通过Web API提供服务接口，接口通过连接数据库并通过Web形式返回可用的代理。]]></content>
      <categories>
        <category>Web Crawler</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web Crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 672 - Bulb Switcher II]]></title>
    <url>%2F2019%2F08%2F16%2FLeetCode-Problem-672-Bulb-Switcher-II%2F</url>
    <content type="text"><![CDATA[There is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be. Suppose n lights are labeled as number [1, 2, 3 …, n], function of these 4 buttons are given below: Flip all the lights. Flip lights with even numbers. Flip lights with odd numbers. Flip lights with (3k + 1) numbers, k = 0, 1, 2, … ExampleNo.1Input: n = 1, m = 1. Output: 2 Explanation: Status can be: [on], [off] No.2Input: n = 2, m = 1. Output: 3 Explanation: Status can be: [on, off], [off, on], [off, off] No.3Input: n = 3, m = 1. Output: 4 Explanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on]. Noten and m both fit in range [0, 1000]. Code123456789101112public int flipLights(int n, int m) &#123; if (m == 0) return 1; else if (n == 1) return 2; else if (n == 2) return m == 1 ? 3 : 4; else if (m == 1) return 4; else return m == 2 ? 7 : 8; &#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 319 - Bulb Switcher]]></title>
    <url>%2F2019%2F08%2F16%2FLeetCode-Problem-319-Bulb-Switcher%2F</url>
    <content type="text"><![CDATA[There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the i-th round, you toggle every i bulb. For the n-th round, you only toggle the last bulb. Find how many bulbs are on after n rounds. ExampleInput: 3 Output: 1 Explanation:At first, the three bulbs are [off, off, off].After first round, the three bulbs are [on, on, on].After second round, the three bulbs are [on, off, on].After third round, the three bulbs are [on, off, off].So you should return 1, because there is only one bulb is on. Code123public int bulbSwitch(int n) &#123; return (int) Math.sqrt(n);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 275 - H-Index II]]></title>
    <url>%2F2019%2F08%2F15%2FLeetCode-Problem-275-H-Index-II%2F</url>
    <content type="text"><![CDATA[Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index. According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.” ExampleInput: citations = [0,1,3,5,6] Output: 3 Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, her h-index is 3. NoteIf there are several possible values for h, the maximum one is taken as the h-index. Follow up This is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order. Could you solve it in logarithmic time complexity? Code12345678910111213141516public int hIndex(int[] citations) &#123; int n = citations.length; int left = 0; int right = n; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (citations[n - mid - 1] &lt;= mid) right = mid; else left = mid + 1; &#125; return left;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 274 - H-Index]]></title>
    <url>%2F2019%2F08%2F15%2FLeetCode-Problem-274-H-Index%2F</url>
    <content type="text"><![CDATA[Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index. According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.” ExampleInput: citations = [3,0,6,1,5] Output: 3 Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, her h-index is 3. NoteIf there are several possible values for h, the maximum one is taken as the h-index. Code12345678910111213141516171819public int hIndex(int[] citations) &#123; int n = citations.length; int[] stats = new int[n + 1]; // stats[i]表示有多少文章被引用了i次 int sum = 0; for (int i = 0; i &lt; n; i++) &#123; int idx = citations[i] &gt; n ? n : citations[i]; stats[idx]++; &#125; for (int i = n; i &gt;= 0; i--) &#123; sum += stats[i]; if (sum &gt;= i) return i; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POJ] Problem 3782 - Equal Sum Partitions]]></title>
    <url>%2F2019%2F08%2F15%2FPOJ-Problem-3782-Equal-Sum-Partitions%2F</url>
    <content type="text"><![CDATA[An equal sum partition of a sequence of numbers is a grouping of the numbers (in the same order as the original sequence) in such a way that each group has the same sum. For example, the sequence:2 5 1 3 3 7 may be grouped as:(2 5) (1 3 3) (7) to yield an equal sum of 7. Note: The partition that puts all the numbers in a single group is an equal sum partition with the sum equal to the sum of all the numbers in the sequence. For this problem, you will write a program that takes as input a sequence of positive integers and returns the smallest sum for an equal sum partition of the sequence. Time Limit: 1000MSMemory Limit: 65536K InputThe first line of input contains a single integer P, (1 ≤ P ≤ 1000), which is the number of data sets that follow. The first line of each data set contains the data set number, followed by a space, followed bya decimal integer M, (1 ≤ M ≤ 10000), giving the total number of integers in the sequence. The remaining line(s) in the dataset consist of the values, 10 per line, separated by a single space. The last line in the dataset may contain less than 10 values. OutputFor each data set, generate one line of output with the following values: The data set number as a decimal integer, a space, and the smallest sum for an equal sum partition of the sequence. Sample Input31 62 5 1 3 3 72 61 2 3 4 5 63 201 1 2 1 1 2 1 1 2 11 2 1 1 2 1 1 2 1 1 Sample Output1 72 213 2 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int P = sc.nextInt(); if (P &lt; 1 || P &gt; 1000) return; for (int i = 1; i &lt;= P; i++) &#123; int p = sc.nextInt(); int M = sc.nextInt(); if (M &lt; 1 || M &gt; 10000) return; int[] sum = new int[M + 1]; for (int j = 1; j &lt;= M; j++) &#123; int m = sc.nextInt(); sum[j] = sum[j - 1] + m; &#125; int result = equalSumPartitions(sum); System.out.println(p + " " + result); &#125; &#125; private static int equalSumPartitions(int[] sum) &#123; int n = sum.length - 1; int[][] dp = new int[n + 1][n + 1]; for (int len = 1; len &lt;= n; len++) &#123; for (int i = 1; i &lt;= n; i++) &#123; int j = i + len - 1; if (j &gt; n) break; dp[i][j] = sum[j] - sum[i - 1]; for (int k = i; k &lt; j; k++) &#123; if (sum[j] - sum[k] == dp[i][k]) dp[i][j] = Math.min(dp[i][j], dp[i][k]); if (sum[k] - sum[i - 1] == dp[k + 1][j]) dp[i][j] = Math.min(dp[i][j], dp[k + 1][j]); if (dp[i][k] == dp[k + 1][j]) dp[i][j] = Math.min(dp[i][j], dp[i][k]); &#125; &#125; &#125; return dp[1][n]; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 981 - Time Based Key-Value Store]]></title>
    <url>%2F2019%2F08%2F15%2FLeetCode-Problem-981-Time-Based-Key-Value-Store%2F</url>
    <content type="text"><![CDATA[Create a timebased key-value store class TimeMap, that supports two operations. set(string key, string value, int timestamp) Stores the key and value, along with the given timestamp. get(string key, int timestamp) Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev &lt;= timestamp. If there are multiple such values, it returns the one with the largest timestamp_prev. If there are no values, it returns the empty string (“”). ExampleNo.1Input: inputs = [“TimeMap”,”set”,”get”,”get”,”set”,”get”,”get”], inputs = [[],[“foo”,”bar”,1],[“foo”,1],[“foo”,3],[“foo”,”bar2”,4],[“foo”,4],[“foo”,5]] Output: [null,null,”bar”,”bar”,null,”bar2”,”bar2”] Explanation:TimeMap kv;kv.set(“foo”, “bar”, 1); // store the key “foo” and value “bar” along with timestamp = 1kv.get(“foo”, 1); // output “bar”kv.get(“foo”, 3); // output “bar” since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 ie “bar”kv.set(“foo”, “bar2”, 4);kv.get(“foo”, 4); // output “bar2”kv.get(“foo”, 5); //output “bar2” No.2Input: inputs = [“TimeMap”,”set”,”set”,”get”,”get”,”get”,”get”,”get”], inputs = [[],[“love”,”high”,10],[“love”,”low”,20],[“love”,5],[“love”,10],[“love”,15],[“love”,20],[“love”,25]] Output: [null,null,null,””,”high”,”high”,”low”,”low”] Note All key/value strings are lowercase. All key/value strings have length in the range [1, 100] The timestamps for all TimeMap.set operations are strictly increasing. 1 &lt;= timestamp &lt;= 10^7 TimeMap.set and TimeMap.get functions will be called a total of 120000 times (combined) per test case. Code123456789101112131415161718192021222324252627282930313233343536373839public class Pair &#123; private int timestamp; private String value; public Pair(int timestamp, String value) &#123; this.timestamp = timestamp; this.value = value; &#125;&#125;private Map&lt;String, List&lt;Pair&gt;&gt; map;public TimeMap() &#123; map = new HashMap&lt;&gt;();&#125;public void set(String key, String value, int timestamp) &#123; map.putIfAbsent(key, new ArrayList&lt;&gt;()); map.get(key).add(new Pair(timestamp, value));&#125;public String get(String key, int timestamp) &#123; if (!map.containsKey(key)) return ""; int idx = Collections.binarySearch(map.get(key), new Pair(timestamp, ""), new Comparator&lt;Pair&gt;() &#123; @Override public int compare(Pair o1, Pair o2) &#123; return o1.timestamp - o2.timestamp; &#125; &#125;); if (idx &gt;= 0) return map.get(key).get(idx).value; else if (idx == -1) return ""; else return map.get(key).get(-idx-2).value;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 911 - Online Election]]></title>
    <url>%2F2019%2F08%2F15%2FLeetCode-Problem-911-Online-Election%2F</url>
    <content type="text"><![CDATA[In an election, the i-th vote was cast for persons[i] at time times[i]. Now, we would like to implement the following query function: TopVotedCandidate.q(int t) will return the number of the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins. ExampleInput: [“TopVotedCandidate”,”q”,”q”,”q”,”q”,”q”,”q”], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]] Output: [null,0,1,1,0,0,1] Explanation:At time 3, the votes are [0], and 0 is leading.At time 12, the votes are [0,1,1], and 1 is leading.At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)This continues for 3 more queries at time 15, 24, and 8. Note 1 &lt;= persons.length = times.length &lt;= 5000 0 &lt;= persons[i] &lt;= persons.length times is a strictly increasing array with all elements in [0, 10^9]. TopVotedCandidate.q is called at most 10000 times per test case. TopVotedCandidate.q(int t) is always called with t &gt;= times[0]. Code12345678910111213141516171819202122private int[] leads;private int[] times;public TopVotedCandidate(int[] persons, int[] times) &#123; int n = persons.length; int lead = 0; int[] votes = new int[n + 1]; leads = new int[n]; this.times = times; for (int i = 0; i &lt; n; i++) &#123; if (++votes[persons[i]] &gt;= votes[lead]) lead = persons[i]; leads[i] = lead; &#125;&#125;public int q(int t) &#123; int idx = Arrays.binarySearch(times, t); return idx &gt;= 0 ? leads[idx] : leads[-idx-2];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 744 - Find Smallest Letter Greater Than Target]]></title>
    <url>%2F2019%2F08%2F15%2FLeetCode-Problem-744-Find-Smallest-Letter-Greater-Than-Target%2F</url>
    <content type="text"><![CDATA[Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target. Letters also wrap around. For example, if the target is target = ‘z’ and letters = [‘a’, ‘b’], the answer is ‘a’. ExampleNo.1Input:letters = [“c”, “f”, “j”]target = “a” Output: “c” No.2Input:letters = [“c”, “f”, “j”]target = “c” Output: “f” No.3Input:letters = [“c”, “f”, “j”]target = “d” Output: “f” No.4Input:letters = [“c”, “f”, “j”]target = “g” Output: “j” No.5Input:letters = [“c”, “f”, “j”]target = “j” Output: “c” No.6Input:letters = [“c”, “f”, “j”]target = “k” Output: “c” Note letters has a length in range [2, 10000]. letters consists of lowercase letters, and contains at least 2 unique letters. target is a lowercase letter. Code1234567891011121314151617181920public char nextGreatestLetter(char[] letters, char target) &#123; int n = letters.length; if (target &lt; letters[0] || target &gt;= letters[n - 1]) return letters[0]; int left = 0; int right = n - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (letters[mid] &lt;= target) left = mid + 1; else right = mid; &#125; return letters[left];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 704 - Binary Search]]></title>
    <url>%2F2019%2F08%2F15%2FLeetCode-Problem-704-Binary-Search%2F</url>
    <content type="text"><![CDATA[Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1. ExampleNo.1Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4 No.2Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1 Note You may assume that all elements in nums are unique. n will be in the range [1, 10000]. The value of each element in nums will be in the range [-9999, 9999]. Code1234567891011121314151617public int search(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else right = mid - 1; &#125; return -1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 718 - Maximum Length of Repeated Subarray]]></title>
    <url>%2F2019%2F08%2F15%2FLeetCode-Problem-718-Maximum-Length-of-Repeated-Subarray%2F</url>
    <content type="text"><![CDATA[Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays. ExampleInput:A: [1,2,3,2,1]B: [3,2,1,4,7] Output: 3 Explanation:The repeated subarray with maximum length is [3, 2, 1]. Note 1 &lt;= len(A), len(B) &lt;= 1000 0 &lt;= A[i], B[i] &lt; 100 Code1234567891011121314151617181920212223// dp[i][j] = dp[i - 1][j - 1] + 1, A[i] = B[j]public int findLength(int[] A, int[] B) &#123; if (A.length &lt; B.length) return findLength(B, A); int max = 0; int m = A.length; int n = B.length; int[] dp = new int[n + 1]; for (int i = 1; i &lt;= m; i++) &#123; for (int j = n; j &gt;= 1; j--) &#123; if (A[i - 1] == B[j - 1]) &#123; dp[j] = dp[j - 1] + 1; max = Math.max(max, dp[j]); &#125; else dp[j] = 0; &#125; &#125; return max;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 454 - 4Sum II]]></title>
    <url>%2F2019%2F08%2F14%2FLeetCode-Problem-454-4Sum-II%2F</url>
    <content type="text"><![CDATA[Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero. To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1. ExampleInput:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2] Output:2 Explanation:The two tuples are: (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 Code123456789101112131415161718public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123; int result = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int a : A) &#123; for (int b : B) map.put(a + b, map.getOrDefault(a + b, 0) + 1); &#125; for (int c : C) &#123; for (int d : D) &#123; if (map.containsKey(-c-d)) result += map.get(-c-d); &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 885 - Spiral Matrix III]]></title>
    <url>%2F2019%2F08%2F14%2FLeetCode-Problem-885-Spiral-Matrix-III%2F</url>
    <content type="text"><![CDATA[On a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east. Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column. Now, we walk in a clockwise spiral shape to visit every position in this grid. Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) Eventually, we reach all R * C spaces of the grid. Return a list of coordinates representing the positions of the grid in the order they were visited. ExampleNo.1Input: R = 1, C = 4, r0 = 0, c0 = 0 Output: [[0,0],[0,1],[0,2],[0,3]] No.2Input: R = 5, C = 6, r0 = 1, c0 = 4 Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]] Note 1 &lt;= R &lt;= 100 1 &lt;= C &lt;= 100 0 &lt;= r0 &lt; R 0 &lt;= c0 &lt; C Code12345678910111213141516171819202122232425262728293031323334public int[][] spiralMatrixIII(int R, int C, int r0, int c0) &#123; int[][] result = new int[R * C][2]; result[0][0] = r0; result[0][1] = c0; int size = 1; if (size == R * C) return result; int step = 1; int dir = 0; int[][] dirs = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;; while (true) &#123; for (int idx = dir; idx &lt; dir + 2; idx++) &#123; for (int i = 0; i &lt; step; i++) &#123; r0 += dirs[idx][0]; c0 += dirs[idx][1]; if (r0 &lt; 0 || c0 &lt; 0 || r0 &gt;= R || c0 &gt;= C) continue; result[size][0] = r0; result[size][1] = c0; if (++size == R * C) return result; &#125; &#125; dir = (dir + 2) % 4; step++; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 59 - Spiral Matrix II]]></title>
    <url>%2F2019%2F08%2F14%2FLeetCode-Problem-59-Spiral-Matrix-II%2F</url>
    <content type="text"><![CDATA[Given a positive integer n, generate a square matrix filled with elements from 1 to n^2 in spiral order. ExampleInput: 3 Output: 12345[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] Code123456789101112131415161718192021222324252627282930313233343536private int number = 0;public int[][] generateMatrix(int n) &#123; int[][] matrix = new int[n][n]; int start = 0; while (start * 2 &lt; n) &#123; generateMatrixHelper(matrix, n, start); start++; &#125; return matrix;&#125;private void generateMatrixHelper(int[][] matrix, int n, int start) &#123; int endX = n - start - 1; int endY = n - start - 1; for (int i = start; i &lt;= endX; i++) matrix[start][i] = ++number; if (endY &gt; start) &#123; for (int i = start + 1; i &lt;= endY; i++) matrix[i][endX] = ++number; &#125; if (endX &gt; start &amp;&amp; endY &gt; start) &#123; for (int i = endX - 1; i &gt;= start; i--) matrix[endY][i] = ++number; &#125; if (endX &gt; start &amp;&amp; endY &gt; start + 1) &#123; for (int i = endY - 1; i &gt; start; i--) matrix[i][start] = ++number; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 980 - Unique Paths III]]></title>
    <url>%2F2019%2F08%2F14%2FLeetCode-Problem-980-Unique-Paths-III%2F</url>
    <content type="text"><![CDATA[On a 2-dimensional grid, there are 4 types of squares: 1 represents the starting square. There is exactly one starting square. 2 represents the ending square. There is exactly one ending square. 0 represents empty squares we can walk over. -1 represents obstacles that we cannot walk over. Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once. ExampleNo.1Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]] Output: 2 Explanation: We have the following two paths: (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2) (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2) No.2Input: [[1,0,0,0],[0,0,0,0],[0,0,0,2]] Output: 4 Explanation: We have the following four paths: (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3) (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3) (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3) (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3) No.3Input: [[0,1],[2,0]] Output: 0 Explanation:There is no path that walks over every empty square exactly once.Note that the starting and ending square can be anywhere in the grid. Note 1 &lt;= grid.length * grid[0].length &lt;= 20 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public int uniquePathsIII(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; int[][][] dp = new int[m][n][1 &lt;&lt; (m * n)]; int state = 0; int startX = 0; int startY = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 0 || grid[i][j] == 2) state |= getKey(i, j, n); else if (grid[i][j] == 1) &#123; startX = i; startY = j; &#125; &#125; &#125; return dfs(grid, dp, state, m, n, startX, startY);&#125;private int dfs(int[][] grid, int[][][] dp, int state, int m, int n, int x, int y) &#123; if (dp[x][y][state] != 0) return dp[x][y][state]; else if (grid[x][y] == 2) return state == 0 ? 1 : 0; int[][] dirs = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; int result = 0; for (int[] dir : dirs)&#123; int newX = x + dir[0]; int newY = y + dir[1]; if (newX &lt; 0 || newY &lt; 0 || newX &gt;= m || newY &gt;= n || grid[newX][newY] == -1) continue; if ((state &amp; getKey(newX, newY, n)) == 0) continue; result += dfs(grid, dp, state ^ getKey(newX, newY, n), m, n, newX, newY); &#125; dp[x][y][state] = result; return dp[x][y][state];&#125;private int getKey(int x, int y, int n) &#123; return 1 &lt;&lt; (x * n + y);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 419 - Battleships in a Board]]></title>
    <url>%2F2019%2F08%2F14%2FLeetCode-Problem-419-Battleships-in-a-Board%2F</url>
    <content type="text"><![CDATA[Given an 2D board, count how many battleships are in it. The battleships are represented with ‘X’s, empty slots are represented with ‘.’s. You may assume the following rules: You receive a valid board, made of only battleships or empty slots. Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size. At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships. Example: 123X..X...X...X In the above board there are 2 battleships. Invalid Example: 123...XXXXX...X This is an invalid board that you will not receive - as battleships will always have a cell separating between them. Follow upCould you do it in one-pass, using only O(1) extra memory and without modifying the value of the board? Code12345678910111213public int countBattleships(char[][] board) &#123; int count = 0; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; if (board[i][j] == 'X' &amp;&amp; (i == 0 || board[i - 1][j] == '.') &amp;&amp; (j == 0 || board[i][j - 1] == '.')) count++; &#125; &#125; return count;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 894 - All Possible Full Binary Trees]]></title>
    <url>%2F2019%2F08%2F13%2FLeetCode-Problem-894-All-Possible-Full-Binary-Trees%2F</url>
    <content type="text"><![CDATA[A full binary tree is a binary tree where each node has exactly 0 or 2 children. Return a list of all possible full binary trees with N nodes. Each element of the answer is the root node of one possible tree. Each node of each tree in the answer must have node.val = 0. You may return the final list of trees in any order. ExampleInput: 7 Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]] Explanation: Note 1 &lt;= N &lt;= 20 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324252627282930313233private Map&lt;Integer, List&lt;TreeNode&gt;&gt; map = new HashMap&lt;&gt;();public List&lt;TreeNode&gt; allPossibleFBT(int N) &#123; List&lt;TreeNode&gt; result = new ArrayList&lt;&gt;(); if (N == 1) &#123; result.add(new TreeNode(0)); return result; &#125; else if (N % 2 == 0) return result; if (map.containsKey(N)) return map.get(N); for (int i = 1; i &lt; N; i += 2) &#123; List&lt;TreeNode&gt; left = allPossibleFBT(i); List&lt;TreeNode&gt; right = allPossibleFBT(N - i - 1); for (TreeNode l : left) &#123; for (TreeNode r : right) &#123; TreeNode root = new TreeNode(0); root.left = l; root.right = r; result.add(root); &#125; &#125; &#125; map.put(N, result); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 797 - All Paths From Source to Target]]></title>
    <url>%2F2019%2F08%2F13%2FLeetCode-Problem-797-All-Paths-From-Source-to-Target%2F</url>
    <content type="text"><![CDATA[Given a directed, acyclic graph of N nodes. Find all possible paths from node 0 to node N-1, and return them in any order. The graph is given as follows: the nodes are 0, 1, …, graph.length - 1. graph[i] is a list of all nodes j for which the edge (i, j) exists. ExampleInput: [[1,2], [3], [3], []] Output: [[0,1,3],[0,2,3]] Explanation: The graph looks like this: 12340---&gt;1| |v v2---&gt;3 There are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3. Note The number of nodes in the graph will be in the range [2, 15]. You can print different paths in any order, but you should keep the order of nodes inside one path. Code1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(int[][] graph) &#123; List&lt;List&lt;Integer&gt;&gt; paths = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); path.add(0); findPath(paths, path, graph, 0); return paths;&#125;private void findPath(List&lt;List&lt;Integer&gt;&gt; paths, List&lt;Integer&gt; path, int[][] graph, int node) &#123; if (node == graph.length - 1) &#123; paths.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int nextNode : graph[node]) &#123; path.add(nextNode); findPath(paths, path, graph, nextNode); path.remove(path.size() - 1); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 921 - Minimum Add to Make Parentheses Valid]]></title>
    <url>%2F2019%2F08%2F13%2FLeetCode-Problem-921-Minimum-Add-to-Make-Parentheses-Valid%2F</url>
    <content type="text"><![CDATA[Given a string S of ‘(‘ and ‘)’ parentheses, we add the minimum number of parentheses ( ‘(‘ or ‘)’, and in any positions ) so that the resulting parentheses string is valid. Formally, a parentheses string is valid if and only if: It is the empty string, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid. ExampleNo.1Input: “())” Output: 1 No.2Input: “(((“ Output: 3 No.3Input: “()” Output: 0 No.4Input: “()))((“ Output: 4 Note S.length &lt;= 1000 S only consists of ‘(‘ and ‘)’ characters. Code123456789101112131415public int minAddToMakeValid(String S) &#123; int left = 0; int right = 0; for (char ch : S.toCharArray()) &#123; if (ch == '(') left++; else if (left &gt; 0) left--; else right++; &#125; return left + right;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 890 - Find and Replace Pattern]]></title>
    <url>%2F2019%2F08%2F13%2FLeetCode-Problem-890-Find-and-Replace-Pattern%2F</url>
    <content type="text"><![CDATA[You have a list of words and a pattern, and you want to know which words in words matches the pattern. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. (Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.) Return a list of the words in words that match the given pattern. You may return the answer in any order. ExampleInput: words = [“abc”,”deq”,”mee”,”aqq”,”dkd”,”ccc”], pattern = “abb” Output: [“mee”,”aqq”] Explanation: “mee” matches the pattern because there is a permutation {a -&gt; m, b -&gt; e, …}.“ccc” does not match the pattern because {a -&gt; c, b -&gt; c, …} is not a permutation,since a and b map to the same letter. Note 1 &lt;= words.length &lt;= 50 1 &lt;= pattern.length = words[i].length &lt;= 20 Code1234567891011121314151617181920212223242526public List&lt;String&gt; findAndReplacePattern(String[] words, String pattern) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); for (String word : words) &#123; if (match(word, pattern)) result.add(word); &#125; return result;&#125;private boolean match(String word, String pattern) &#123; int[] w = new int[26]; int[] p = new int[26]; Arrays.fill(w, -1); Arrays.fill(p, -1); for (int i = 0; i &lt; pattern.length(); i++) &#123; if (w[word.charAt(i) - 'a'] != p[pattern.charAt(i) - 'a']) return false; w[word.charAt(i) - 'a'] = p[pattern.charAt(i) - 'a'] = i; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 807 - Max Increase to Keep City Skyline]]></title>
    <url>%2F2019%2F08%2F13%2FLeetCode-Problem-807-Max-Increase-to-Keep-City-Skyline%2F</url>
    <content type="text"><![CDATA[In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well. At the end, the “skyline” when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city’s skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example. What is the maximum total sum that the height of the buildings can be increased? ExampleInput: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]] Output: 35 Explanation:The grid is: 1234[ [3, 0, 8, 4], [2, 4, 5, 7], [9, 2, 6, 3], [0, 3, 1, 0] ] The skyline viewed from top or bottom is: [9, 4, 8, 7]The skyline viewed from left or right is: [8, 7, 9, 3] The grid after increasing the height of buildings without affecting skylines is: gridNew = 1234[ [8, 4, 8, 7], [7, 4, 7, 7], [9, 4, 8, 7], [3, 3, 3, 3] ] Notes 1 &lt; grid.length = grid[0].length &lt;= 50. All heights grid[i][j] are in the range [0, 100]. All buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism. Code1234567891011121314151617181920public int maxIncreaseKeepingSkyline(int[][] grid) &#123; int result = 0; int n = grid.length; int[] row = new int[n]; int[] col = new int[n]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; row[i] = Math.max(row[i], grid[i][j]); col[i] = Math.max(col[i], grid[j][i]); &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) result += Math.min(row[i], col[j]) - grid[i][j]; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 476 - Number Complement]]></title>
    <url>%2F2019%2F08%2F13%2FLeetCode-Problem-476-Number-Complement%2F</url>
    <content type="text"><![CDATA[Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Note The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation. ExampleNo.1Input: 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. No.2Input: 1 Output: 0 Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0. Code12345678public int findComplement(int num) &#123; int mask = ~0; while ((num &amp; mask) != 0) mask &lt;&lt;= 1; return ~num ^ mask;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 669 - Trim a Binary Search Tree]]></title>
    <url>%2F2019%2F08%2F12%2FLeetCode-Problem-669-Trim-a-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree. ExampleNo.1Input: 123456 1 / \0 2L = 1R = 2 Output: 1231 \ 2 No.2Input: 12345678910 3 / \0 4 \ 2 /1L = 1R = 3 Output: 12345 3 / 2 /1 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213public TreeNode trimBST(TreeNode root, int L, int R) &#123; if (root == null) return null; if (root.val &gt; R) return trimBST(root.left, L, R); else if (root.val &lt; L) return trimBST(root.right, L, R); root.left = trimBST(root.left, L, R); root.right = trimBST(root.right, L, R); return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 682 - Baseball Game]]></title>
    <url>%2F2019%2F08%2F12%2FLeetCode-Problem-682-Baseball-Game%2F</url>
    <content type="text"><![CDATA[You’re now a baseball game point recorder. Given a list of strings, each string can be one of the 4 following types: Integer (one round’s score): Directly represents the number of points you get in this round. “+” (one round’s score): Represents that the points you get in this round are the sum of the last two valid round’s points. “D” (one round’s score): Represents that the points you get in this round are the doubled data of the last valid round’s points. “C” (an operation, which isn’t a round’s score): Represents the last valid round’s points you get were invalid and should be removed. Each round’s operation is permanent and could have an impact on the round before and the round after. You need to return the sum of the points you could get in all the rounds. ExampleNo.1Input: [“5”,”2”,”C”,”D”,”+”] Output: 30 Explanation:Round 1: You could get 5 points. The sum is: 5.Round 2: You could get 2 points. The sum is: 7.Operation 1: The round 2’s data was invalid. The sum is: 5.Round 3: You could get 10 points (the round 2’s data has been removed). The sum is: 15.Round 4: You could get 5 + 10 = 15 points. The sum is: 30. No.2Input: [“5”,”-2”,”4”,”C”,”D”,”9”,”+”,”+”] Output: 27 Explanation:Round 1: You could get 5 points. The sum is: 5.Round 2: You could get -2 points. The sum is: 3.Round 3: You could get 4 points. The sum is: 7.Operation 1: The round 3’s data is invalid. The sum is: 3.Round 4: You could get -4 points (the round 3’s data has been removed). The sum is: -1.Round 5: You could get 9 points. The sum is: 8.Round 6: You could get -4 + 9 = 5 points. The sum is 13.Round 7: You could get 9 + 5 = 14 points. The sum is 27. Note The size of the input list will be between 1 and 1000. Every integer represented in the list will be between -30000 and 30000. Code123456789101112131415161718192021222324252627public int calPoints(String[] ops) &#123; int result = 0; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (String op : ops) &#123; int n = list.size(); if (op.equals("+")) &#123; list.add(list.get(n - 1) + list.get(n - 2)); result += list.get(n); &#125; else if (op.equals("D")) &#123; list.add(list.get(n - 1) * 2); result += list.get(n); &#125; else if (op.equals("C")) &#123; result -= list.get(n - 1); list.remove(n - 1); &#125; else &#123; list.add(Integer.valueOf(op)); result += list.get(n); &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 888 - Fair Candy Swap]]></title>
    <url>%2F2019%2F08%2F12%2FLeetCode-Problem-888-Fair-Candy-Swap%2F</url>
    <content type="text"><![CDATA[Alice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has. Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy. (The total amount of candy a person has is the sum of the sizes of candy bars they have.) Return an integer array ans where ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange. If there are multiple answers, you may return any one of them. It is guaranteed an answer exists. ExampleNo.1Input: A = [1,1], B = [2,2] Output: [1,2] No.2Input: A = [1,2], B = [2,3] Output: [1,2] No.3Input: A = [2], B = [1,3] Output: [2,3] No.4Input: A = [1,2,5], B = [2,4] Output: [5,4] Note 1 &lt;= A.length &lt;= 10000 1 &lt;= B.length &lt;= 10000 1 &lt;= A[i] &lt;= 100000 1 &lt;= B[i] &lt;= 100000 It is guaranteed that Alice and Bob have different total amounts of candy. It is guaranteed there exists an answer. Code123456789101112131415161718192021222324252627// - a + b = diff = (sumB - sumA) / 2public int[] fairCandySwap(int[] A, int[] B) &#123; int[] result = new int[2]; int sumA = 0; int sumB = 0; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int a : A) sumA += a; for (int b : B) &#123; sumB += b; set.add(b); &#125; int diff = (sumB - sumA) / 2; for (int a : A) &#123; if (set.contains(a + diff)) &#123; result[0] = a; result[1] = a + diff; break; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 884 - Uncommon Words from Two Sentences]]></title>
    <url>%2F2019%2F08%2F12%2FLeetCode-Problem-884-Uncommon-Words-from-Two-Sentences%2F</url>
    <content type="text"><![CDATA[We are given two sentences A and B. (A sentence is a string of space separated words. Each word consists only of lowercase letters.) A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence. Return a list of all uncommon words. You may return the list in any order. ExampleNo.1Input: A = “this apple is sweet”, B = “this apple is sour” Output: [“sweet”,”sour”] No.2Input: A = “apple apple”, B = “banana” Output: [“banana”] Note 0 &lt;= A.length &lt;= 200 0 &lt;= B.length &lt;= 200 A and B both contain only spaces and lowercase letters. Code1234567891011121314151617public String[] uncommonFromSentences(String A, String B) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (String str : A.split(" ")) map.put(str, map.getOrDefault(str, 0) + 1); for (String str : B.split(" ")) map.put(str, map.getOrDefault(str, 0) + 1); for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123; if (entry.getValue() == 1) result.add(entry.getKey()); &#125; return result.toArray(new String[result.size()]);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 766 - Toeplitz Matrix]]></title>
    <url>%2F2019%2F08%2F12%2FLeetCode-Problem-766-Toeplitz-Matrix%2F</url>
    <content type="text"><![CDATA[A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz. ExampleNo.1Input: 12345matrix = [ [1,2,3,4], [5,1,2,3], [9,5,1,2]] Output: True Explanation:In the above grid, the diagonals are:“[9]”, “[5, 5]”, “[1, 1, 1]”, “[2, 2, 2]”, “[3, 3]”, “[4]”.In each diagonal all elements are the same, so the answer is True. No.2Input: 1234matrix = [ [1,2], [2,2]] Output: False Explanation:The diagonal “[1, 2]” has different elements. Note matrix will be a 2D array of integers. matrix will have a number of rows and columns in range [1, 20]. matrix[i][j] will be integers in range [0, 99]. Follow up What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once? What if the matrix is so large that you can only load up a partial row into the memory at once? Code1234567891011121314151617181920212223public boolean isToeplitzMatrix(int[][] matrix) &#123; int m = matrix.length; int n = matrix[0].length; int x = m - 1; int y = 0; while (x &gt;= 0 &amp;&amp; y &lt; n) &#123; int i = x; int j = y; while (++i &lt; m &amp;&amp; ++j &lt; n) &#123; if (matrix[i][j] != matrix[x][y]) return false; &#125; if (x &gt; 0) x--; else y++; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 500 - Keyboard Row]]></title>
    <url>%2F2019%2F08%2F12%2FLeetCode-Problem-500-Keyboard-Row%2F</url>
    <content type="text"><![CDATA[Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below. ExampleInput: [“Hello”, “Alaska”, “Dad”, “Peace”] Output: [“Alaska”, “Dad”] Note You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet. Code12345678910111213141516171819202122232425private String[] rows = &#123;"qwertyuiop", "asdfghjkl", "zxcvbnm"&#125;;public String[] findWords(String[] words) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); for (String word : words) &#123; for (String row : rows) &#123; if (check(word.toLowerCase(), row)) &#123; result.add(word); break; &#125; &#125; &#125; return result.toArray(new String[result.size()]);&#125;private boolean check(String word, String row) &#123; for (char ch : word.toCharArray()) &#123; if (row.indexOf(ch) == -1) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 999 - Available Captures for Rook]]></title>
    <url>%2F2019%2F08%2F12%2FLeetCode-Problem-999-Available-Captures-for-Rook%2F</url>
    <content type="text"><![CDATA[On an 8 x 8 chessboard, there is one white rook. There also may be empty squares, white bishops, and black pawns. These are given as characters ‘R’, ‘.’, ‘B’, and ‘p’ respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces. The rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies. Also, rooks cannot move into the same square as other friendly bishops. Return the number of pawns the rook can capture in one move. ExampleNo.1 Input: 12345678[[".",".",".",".",".",".",".","."], [".",".",".","p",".",".",".","."], [".",".",".","R",".",".",".","p"], [".",".",".",".",".",".",".","."], [".",".",".",".",".",".",".","."], [".",".",".","p",".",".",".","."], [".",".",".",".",".",".",".","."], [".",".",".",".",".",".",".","."]] Output: 3 Explanation:In this example the rook is able to capture all the pawns. No.2 Input: 12345678[[".",".",".",".",".",".",".","."], [".","p","p","p","p","p",".","."], [".","p","p","B","p","p",".","."], [".","p","B","R","B","p",".","."], [".","p","p","B","p","p",".","."], [".","p","p","p","p","p",".","."], [".",".",".",".",".",".",".","."], [".",".",".",".",".",".",".","."]] Output: 0 Explanation:Bishops are blocking the rook to capture any pawn. No.3 Input: 12345678[[".",".",".",".",".",".",".","."], [".",".",".","p",".",".",".","."], [".",".",".","p",".",".",".","."], ["p","p",".","R",".","p","B","."], [".",".",".",".",".",".",".","."], [".",".",".","B",".",".",".","."], [".",".",".","p",".",".",".","."], [".",".",".",".",".",".",".","."]] Output: 3 Explanation:The rook can capture the pawns at positions b5, d6 and f5. Note board.length == board[i].length == 8 board[i][j] is either ‘R’, ‘.’, ‘B’, or ‘p’ There is exactly one cell with board[i][j] == ‘R’ Code12345678910111213141516171819202122232425262728293031public int numRookCaptures(char[][] board) &#123; int result = 0; int[][] dirs = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; loop: for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 8; j++) &#123; if (board[i][j] == 'R') &#123; for (int[] dir : dirs) result += findCapture(board, i, j, dir); break loop; &#125; &#125; &#125; return result;&#125;private int findCapture(char[][] board, int x, int y, int[] dir) &#123; while (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; 8 &amp;&amp; y &lt; 8) &#123; if (board[x][y] == 'p') return 1; else if (board[x][y] == 'B') return 0; x += dir[0]; y += dir[1]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 893 - Groups of Special-Equivalent Strings]]></title>
    <url>%2F2019%2F08%2F12%2FLeetCode-Problem-893-Groups-of-Special-Equivalent-Strings%2F</url>
    <content type="text"><![CDATA[You are given an array A of strings. Two strings S and T are special-equivalent if after any number of moves, S == T. A move consists of choosing two indices i and j with i % 2 == j % 2, and swapping S[i] with S[j]. Now, a group of special-equivalent strings from A is a non-empty subset S of A such that any string not in S is not special-equivalent with any string in S. Return the number of groups of special-equivalent strings from A. ExampleNo.1Input: [“a”,”b”,”c”,”a”,”c”,”c”] Output: 3 Explanation: 3 groups [“a”,”a”], [“b”], [“c”,”c”,”c”] No.2Input: [“aa”,”bb”,”ab”,”ba”] Output: 4 Explanation: 4 groups [“aa”], [“bb”], [“ab”], [“ba”] No.3Input: [“abc”,”acb”,”bac”,”bca”,”cab”,”cba”] Output: 3 Explanation: 3 groups [“abc”,”cba”], [“acb”,”bca”], [“bac”,”cab”] No.4Input: [“abcd”,”cdab”,”adcb”,”cbad”] Output: 1 Explanation: 1 group [“abcd”,”cdab”,”adcb”,”cbad”] Note 1 &lt;= A.length &lt;= 1000 1 &lt;= A[i].length &lt;= 20 All A[i] have the same length. All A[i] consist of only lowercase letters. Code12345678910111213141516171819202122public int numSpecialEquivGroups(String[] A) &#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (String str : A) &#123; int n = str.length(); char[] odd = new char[n / 2]; char[] even = new char[(n + 1) / 2]; for (int i = 0; i &lt; n; i++) &#123; if (i % 2 == 0) even[i / 2] = str.charAt(i); else odd[i / 2] = str.charAt(i); &#125; Arrays.sort(even); Arrays.sort(odd); set.add(String.valueOf(odd) + String.valueOf(even)); &#125; return set.size();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 806 - Number of Lines To Write String]]></title>
    <url>%2F2019%2F08%2F11%2FLeetCode-Problem-806-Number-of-Lines-To-Write-String%2F</url>
    <content type="text"><![CDATA[We are to write the letters of a given string S, from left to right into lines. Each line has maximum width 100 units, and if writing a letter would cause the width of the line to exceed 100 units, it is written on the next line. We are given an array widths, an array where widths[0] is the width of ‘a’, widths[1] is the width of ‘b’, …, and widths[25] is the width of ‘z’. Now answer two questions: how many lines have at least one character from S, and what is the width used by the last such line? Return your answer as an integer list of length 2. ExampleNo.1Input:widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]S = “abcdefghijklmnopqrstuvwxyz” Output: [3, 60] Explanation:All letters have the same length of 10. To write all 26 letters,we need two full lines and one line with 60 units. No.2Input:widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]S = “bbbcccdddaaa” Output: [2, 4] Explanation:All letters except ‘a’ have the same length of 10, and“bbbcccdddaa” will cover 9 * 10 + 2 * 4 = 98 units.For the last ‘a’, it is written on the second line becausethere is only 2 units left in the first line.So the answer is 2 lines, plus 4 units in the second line. Note The length of S will be in the range [1, 1000]. S will only contain lowercase letters. widths is an array of length 26. widths[i] will be in the range of [2, 10]. Code123456789101112131415public int[] numberOfLines(int[] widths, String S) &#123; int lines = 1; int units = 0; for (char ch : S.toCharArray()) &#123; if (units + widths[ch - 'a'] &gt; 100) &#123; lines++; units = 0; &#125; units += widths[ch - 'a']; &#125; return new int[] &#123;lines, units&#125;;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 821 - Shortest Distance to a Character]]></title>
    <url>%2F2019%2F08%2F11%2FLeetCode-Problem-821-Shortest-Distance-to-a-Character%2F</url>
    <content type="text"><![CDATA[Given a string S and a character C, return an array of integers representing the shortest distance from the character C in the string. ExampleInput: S = “loveleetcode”, C = ‘e’Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] Note S string length is in [1, 10000]. C is a single character, and guaranteed to be in string S. All letters in S and C are lowercase. Code1234567891011121314151617public int[] shortestToChar(String S, char C) &#123; int n = S.length(); int[] result = new int[n]; Arrays.fill(result, n); for (int i = 0; i &lt; n; i++) &#123; if (S.charAt(i) == C) result[i] = 0; else if (i &gt; 0) result[i] = result[i - 1] + 1; &#125; for (int i = n - 2; i &gt;= 0; i--) result[i] = Math.min(result[i], result[i + 1] + 1); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 867 - Transpose Matrix]]></title>
    <url>%2F2019%2F08%2F11%2FLeetCode-Problem-867-Transpose-Matrix%2F</url>
    <content type="text"><![CDATA[Given a matrix A, return the transpose of A. The transpose of a matrix is the matrix flipped over it’s main diagonal, switching the row and column indices of the matrix. ExampleNo.1Input: [[1,2,3],[4,5,6],[7,8,9]] Output: [[1,4,7],[2,5,8],[3,6,9]] No.2Input: [[1,2,3],[4,5,6]] Output: [[1,4],[2,5],[3,6]] Note 1 &lt;= A.length &lt;= 1000 1 &lt;= A[0].length &lt;= 1000 Code123456789101112public int[][] transpose(int[][] A) &#123; int m = A.length; int n = A[0].length; int[][] result = new int[n][m]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) result[j][i] = A[i][j]; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 876 - Middle of the Linked List]]></title>
    <url>%2F2019%2F08%2F11%2FLeetCode-Problem-876-Middle-of-the-Linked-List%2F</url>
    <content type="text"><![CDATA[Given a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node. ExampleNo.1Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5])The returned node has value 3. (The judge’s serialization of this node is [3,4,5]).Note that we returned a ListNode object ans, such that:ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL. No.2Input: [1,2,3,4,5,6] Output: Node 4 from this list (Serialization: [4,5,6])Since the list has two middle nodes with values 3 and 4, we return the second one. Note The number of nodes in the given list will be between 1 and 100. Code12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 1234567891011public ListNode middleNode(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; return slow;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 559 - Maximum Depth of N-ary Tree]]></title>
    <url>%2F2019%2F08%2F11%2FLeetCode-Problem-559-Maximum-Depth-of-N-ary-Tree%2F</url>
    <content type="text"><![CDATA[Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. For example, given a 3-ary tree: We should return its max depth, which is 3. Note The depth of the tree is at most 1000. The total number of nodes is at most 5000. Code12345678public class Node &#123; public int val; public List&lt;Node&gt; children; public Node(int _val, List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125; 1234567891011public int maxDepth(Node root) &#123; if (root == null) return 0; int max = 0; for (Node child : root.children) max = Math.max(max, maxDepth(child)); return max + 1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 883 - Projection Area of 3D Shapes]]></title>
    <url>%2F2019%2F08%2F11%2FLeetCode-Problem-883-Projection-Area-of-3D-Shapes%2F</url>
    <content type="text"><![CDATA[On a N * N grid, we place some 1 * 1 * 1 cubes that are axis-aligned with the x, y, and z axes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Now we view the projection of these cubes onto the xy, yz, and zx planes. A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional plane. Here, we are viewing the “shadow” when looking at the cubes from the top, the front, and the side. Return the total area of all three projections. ExampleNo.1Input: [[2]] Output: 5 No.2Input: [[1,2],[3,4]] Output: 17 Explanation:Here are the three projections (“shadows”) of the shape made with each axis-aligned plane. No.3Input: [[1,0],[0,2]] Output: 8 No.4Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 14 No.5Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 21 Note 1 &lt;= grid.length = grid[0].length &lt;= 50 0 &lt;= grid[i][j] &lt;= 50 Code123456789101112131415161718192021public int projectionArea(int[][] grid) &#123; int result = 0; int n = grid.length; for (int i = 0; i &lt; n; i++) &#123; int row = 0; int col = 0; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] &gt; 0) result++; row = Math.max(row, grid[i][j]); col = Math.max(col, grid[j][i]); &#125; result += row + col; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 811 - Subdomain Visit Count]]></title>
    <url>%2F2019%2F08%2F11%2FLeetCode-Problem-811-Subdomain-Visit-Count%2F</url>
    <content type="text"><![CDATA[A website domain like “discuss.leetcode.com” consists of various subdomains. At the top level, we have “com”, at the next level, we have “leetcode.com”, and at the lowest level, “discuss.leetcode.com”. When we visit a domain like “discuss.leetcode.com”, we will also visit the parent domains “leetcode.com” and “com” implicitly. Now, call a “count-paired domain” to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be “9001 discuss.leetcode.com”. We are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain. ExampleNo.1Input:[“9001 discuss.leetcode.com”] Output:[“9001 discuss.leetcode.com”, “9001 leetcode.com”, “9001 com”] Explanation:We only have one website domain: “discuss.leetcode.com”. As discussed above, the subdomain “leetcode.com” and “com” will also be visited. So they will all be visited 9001 times. No.2Input:[“900 google.mail.com”, “50 yahoo.com”, “1 intel.mail.com”, “5 wiki.org”] Output:[“901 mail.com”,”50 yahoo.com”,”900 google.mail.com”,”5 wiki.org”,”5 org”,”1 intel.mail.com”,”951 com”] Explanation:We will visit “google.mail.com” 900 times, “yahoo.com” 50 times, “intel.mail.com” once and “wiki.org” 5 times. For the subdomains, we will visit “mail.com” 900 + 1 = 901 times, “com” 900 + 50 + 1 = 951 times, and “org” 5 times. Notes The length of cpdomains will not exceed 100. The length of each domain name will not exceed 100. Each address will have either 1 or 2 “.” characters. The input count in any count-paired domain will not exceed 10000. The answer output can be returned in any order. Code12345678910111213141516171819202122232425public List&lt;String&gt; subdomainVisits(String[] cpdomains) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (String cpdomain : cpdomains) &#123; int idx = cpdomain.indexOf(" "); int count = Integer.valueOf(cpdomain.substring(0, idx)); String domain = cpdomain.substring(idx + 1); while (true) &#123; map.put(domain, map.getOrDefault(domain, 0) + count); idx = domain.indexOf("."); if (idx == -1) break; domain = domain.substring(idx + 1); &#125; &#125; for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) result.add(entry.getValue() + " " + entry.getKey()); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 401 - Binary Watch]]></title>
    <url>%2F2019%2F08%2F10%2FLeetCode-Problem-401-Binary-Watch%2F</url>
    <content type="text"><![CDATA[A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right. For example, the above binary watch reads “3:25”. Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent. ExampleInput: n = 1 Return: [“1:00”, “2:00”, “4:00”, “8:00”, “0:01”, “0:02”, “0:04”, “0:08”, “0:16”, “0:32”] Note The order of output does not matter. The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”. The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”. Code123456789101112public List&lt;String&gt; readBinaryWatch(int num) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); for (int h = 0; h &lt; 12; h++) &#123; for (int m = 0; m &lt; 60; m++) &#123; if (Integer.bitCount((h &lt;&lt; 6) + m) == num) result.add(h + ":" + (m &lt; 10 ? "0" + m : m));; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 392 - Is Subsequence]]></title>
    <url>%2F2019%2F08%2F10%2FLeetCode-Problem-392-Is-Subsequence%2F</url>
    <content type="text"><![CDATA[Given a string s and a string t, check if s is subsequence of t. You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&lt;=100). A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ace” is a subsequence of “abcde” while “aec” is not). ExampleNo.1s = “abc”, t = “ahbgdc” Return true. No.2s = “axc”, t = “ahbgdc” Return false. Follow upIf there are lots of incoming S, say S1, S2, … , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? Code1234567891011121314public boolean isSubsequence(String s, String t) &#123; int idx = 0; int n = t.length(); for (char ch : s.toCharArray()) &#123; while (idx &lt; n &amp;&amp; ch != t.charAt(idx)) idx++; if (idx++ == n) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 383 - Ransom Note]]></title>
    <url>%2F2019%2F08%2F10%2FLeetCode-Problem-383-Ransom-Note%2F</url>
    <content type="text"><![CDATA[Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. NoteYou may assume that both strings contain only lowercase letters. canConstruct(“a”, “b”) -&gt; falsecanConstruct(“aa”, “ab”) -&gt; falsecanConstruct(“aa”, “aab”) -&gt; true Code123456789101112131415public boolean canConstruct(String ransomNote, String magazine) &#123; int[] count = new int[26]; for (char ch : magazine.toCharArray()) count[ch - 'a']++; for (char ch : ransomNote.toCharArray()) &#123; if (count[ch - 'a'] &lt;= 0) return false; count[ch - 'a']--; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 371 - Sum of Two Integers]]></title>
    <url>%2F2019%2F08%2F10%2FLeetCode-Problem-371-Sum-of-Two-Integers%2F</url>
    <content type="text"><![CDATA[Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. ExampleNo.1Input: a = 1, b = 2 Output: 3 No.2Input: a = -2, b = 3 Output: 1 Code123456// 1.不考虑进位的加法就是异或运算；// 2.只考虑进位就是与运算并左移一位；// 3.重复前面两步操作直到第二步进位结果为0。public int getSum(int a, int b) &#123; return b == 0 ? a : getSum(a ^ b, (a &amp; b) &lt;&lt; 1);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Chain of Responsibility模式]]></title>
    <url>%2F2019%2F08%2F10%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Chain-of-Responsibility%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[将多个对象组成一条职责链，然后按照它们在职责链上的顺序一个一个地找出到底应该谁来负责处理。 示例当一个人被要求做什么事情时，如果他可以做就自己做，如果不能做就将“要求”转给另外一个人。下一个人如果可以自己处理，就自己做；如果也不能自己处理，就再转给另外一个人… 类图 时序图 Trouble类12345678910111213141516public class Trouble &#123; private int number; public Trouble(int number) &#123; this.number = number; &#125; public int getNumber() &#123; return number; &#125; @Override public String toString() &#123; return "[Trouble " + number + "]"; &#125;&#125; Support类12345678910111213141516171819202122232425262728293031323334353637public abstract class Support &#123; private String name; private Support next; public Support(String name) &#123; this.name = name; &#125; public Support setNext(Support next) &#123; this.next = next; return next; &#125; @Override public String toString() &#123; return "[" + name + "]"; &#125; protected abstract boolean resolve(Trouble trouble); protected void done(Trouble trouble) &#123; System.out.println(trouble + " is resolved by " + this + "."); &#125; protected void fail(Trouble trouble) &#123; System.out.println(trouble + " cannot be resolved."); &#125; public final void support(Trouble trouble) &#123; if (resolve(trouble)) done(trouble); else if (next != null) next.support(trouble); else fail(trouble); &#125;&#125; NoSupport类12345678910public class NoSupport extends Support &#123; public NoSupport(String name) &#123; super(name); &#125; @Override protected boolean resolve(Trouble trouble) &#123; return false; &#125;&#125; LimitSupport类12345678910111213public class LimitSupport extends Support &#123; private int limit; public LimitSupport(String name, int limit) &#123; super(name); this.limit = limit; &#125; @Override protected boolean resolve(Trouble trouble) &#123; return trouble.getNumber() &lt; limit; &#125;&#125; OddSupport类12345678910public class OddSupport extends Support &#123; public OddSupport(String name) &#123; super(name); &#125; @Override protected boolean resolve(Trouble trouble) &#123; return trouble.getNumber() % 2 == 1; &#125;&#125; SpecialSupport类12345678910111213public class SpecialSupport extends Support &#123; private int number; public SpecialSupport(String name, int number) &#123; super(name); this.number = number; &#125; @Override protected boolean resolve(Trouble trouble) &#123; return trouble.getNumber() == number; &#125;&#125; Main类12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; Support alice = new NoSupport("Alice"); Support bob = new LimitSupport("Bob", 100); Support charlie = new SpecialSupport("Charlie", 429); Support diana = new LimitSupport("Diana", 200); Support elmo = new OddSupport("Elmo"); Support fred = new LimitSupport("Fred", 300); alice.setNext(bob).setNext(charlie).setNext(diana).setNext(elmo).setNext(fred); for (int i = 0; i &lt; 500; i += 33) alice.support(new Trouble(i)); &#125;&#125; 运行结果12345678910111213141516[Trouble 0] is resolved by [Bob].[Trouble 33] is resolved by [Bob].[Trouble 66] is resolved by [Bob].[Trouble 99] is resolved by [Bob].[Trouble 132] is resolved by [Diana].[Trouble 165] is resolved by [Diana].[Trouble 198] is resolved by [Diana].[Trouble 231] is resolved by [Elmo].[Trouble 264] is resolved by [Fred].[Trouble 297] is resolved by [Elmo].[Trouble 330] cannot be resolved.[Trouble 363] is resolved by [Elmo].[Trouble 396] cannot be resolved.[Trouble 429] is resolved by [Charlie].[Trouble 462] cannot be resolved.[Trouble 495] is resolved by [Elmo]. 登场角色Handler（处理者）Handler角色定义了处理请求的接口（API）。Handler角色知道“下一个处理者”是谁，如果自己无法处理请求，它会将请求转给“下一个处理者”。当然，“下一个处理者”也是Handler角色。在示例程序中，由Support类扮演此角色。负责处理请求的是support方法。 ConcreteHandler（具体的处理者）ConcreteHandler角色是处理请求的具体角色。在示例程序中，由NoSupport、LimitSupport、OddSupport、SpecialSupport等各个类扮演此角色。 Client（请求者）Client角色是向第一个ConcreteHandler角色发送请求的角色。在示例程序中，由Main类扮演此角色。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Visitor模式]]></title>
    <url>%2F2019%2F08%2F09%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Visitor%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[数据结构与处理被分离开来。表示“访问者”的类来访问数据结构中的元素，并把对各元素的处理交给访问者类。 示例用文件和文件夹的例子作为访问者要访问的数据结构。访问者会访问由文件和文件夹构成的数据结构，然后显示出文件和文件夹的一览。 类图 时序图 Visitor类1234public abstract class Visitor &#123; public abstract void visit(File file); public abstract void visit(Directory directory);&#125; Element接口123public interface Element &#123; public abstract void accept(Visitor v);&#125; Entry类12345678910111213141516171819import java.util.Iterator;public abstract class Entry implements Element &#123; public abstract String getName(); public abstract int getSize(); public Entry add(Entry entry) throws FileTreatmentException &#123; throw new FileTreatmentException(); &#125; public Iterator iterator() throws FileTreatmentException &#123; throw new FileTreatmentException(); &#125; @Override public String toString() &#123; return getName() + " (" + getSize() + ")"; &#125;&#125; File类123456789101112131415161718192021222324public class File extends Entry &#123; private String name; private int size; public File(String name, int size) &#123; this.name = name; this.size = size; &#125; @Override public String getName() &#123; return name; &#125; @Override public int getSize() &#123; return size; &#125; @Override public void accept(Visitor v) &#123; v.visit(this); &#125;&#125; Directory类123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.ArrayList;import java.util.Iterator;public class Directory extends Entry &#123; private String name; private ArrayList directory = new ArrayList(); public Directory(String name) &#123; this.name = name; &#125; @Override public String getName() &#123; return name; &#125; @Override public int getSize() &#123; int size = 0; Iterator it = directory.iterator(); while (it.hasNext()) &#123; Entry entry = (Entry) it.next(); size += entry.getSize(); &#125; return size; &#125; @Override public Entry add(Entry entry) &#123; directory.add(entry); return this; &#125; @Override public Iterator iterator() &#123; return directory.iterator(); &#125; @Override public void accept(Visitor v) &#123; v.visit(this); &#125;&#125; ListVisitor类12345678910111213141516171819202122232425import java.util.Iterator;public class ListVisitor extends Visitor &#123; private String currentdir = ""; @Override public void visit(File file) &#123; System.out.println(currentdir + "/" + file); &#125; @Override public void visit(Directory directory) &#123; System.out.println(currentdir + "/" + directory); String savedir = currentdir; currentdir = currentdir + "/" + directory.getName(); Iterator it = directory.iterator(); while (it.hasNext()) &#123; Entry entry = (Entry) it.next(); entry.accept(this); &#125; currentdir = savedir; &#125;&#125; FileTreatmentException类1234567public class FileTreatmentException extends RuntimeException &#123; public FileTreatmentException() &#123;&#125; public FileTreatmentException(String msg) &#123; super(msg); &#125;&#125; Main类123456789101112131415161718192021222324252627282930313233343536public class Main &#123; public static void main(String[] args) &#123; try &#123; System.out.println("Making root entries..."); Directory rootdir = new Directory("root"); Directory bindir = new Directory("bin"); Directory tmpdir = new Directory("tmp"); Directory usrdir = new Directory("usr"); rootdir.add(bindir); rootdir.add(tmpdir); rootdir.add(usrdir); bindir.add(new File("vi", 10000)); bindir.add(new File("latex", 20000)); rootdir.accept(new ListVisitor()); System.out.println(""); System.out.println("Making user entries..."); Directory yuki = new Directory("yuki"); Directory hanako = new Directory("hanako"); Directory tomura = new Directory("tomura"); usrdir.add(yuki); usrdir.add(hanako); usrdir.add(tomura); yuki.add(new File("diary.html", 100)); yuki.add(new File("Composite.java", 200)); hanako.add(new File("memo.tex", 300)); tomura.add(new File("game.doc", 400)); tomura.add(new File("junk.mail", 500)); rootdir.accept(new ListVisitor()); &#125; catch (FileTreatmentException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果1234567891011121314151617181920212223Making root entries.../root (30000)/root/bin (30000)/root/bin/vi (10000)/root/bin/latex (20000)/root/tmp (0)/root/usr (0)Making user entries.../root (31500)/root/bin (30000)/root/bin/vi (10000)/root/bin/latex (20000)/root/tmp (0)/root/usr (1500)/root/usr/yuki (300)/root/usr/yuki/diary.html (100)/root/usr/yuki/Composite.java (200)/root/usr/hanako (300)/root/usr/hanako/memo.tex (300)/root/usr/tomura (900)/root/usr/tomura/game.doc (400)/root/usr/tomura/junk.mail (500) 登场角色Visitor（访问者）Visitor角色负责对数据结构中每个具体的元素（ConcreteElement角色）声明一个用于访问XXXXX的visit(XXXXX)方法。visit(XXXXX)是用于处理XXXXX的方法，负责实现该方法的是ConcreteVisitor角色。在示例程序中，由Visitor类扮演此角色。 ConcreteVisitor（具体的访问者）ConcreteVisitor角色负责实现Visitor所定义的接口（API）。它要实现所有visit(XXXXX)方法，即实现如何处理每个ConcreteElement角色。在示例程序中，由ListVisitor类扮演此角色。如同在ListVisitor中，currentdir字段的值不断发生变化一样，随着visit(XXXXX)处理的进行，ConcreteVisitor角色的内部状态也会不断地发生变化。 Element（元素）Element角色表示Visitor角色的访问对象。它声明了接受访问者的accept方法。accept方法接收到的参数是Visitor角色。在示例程序中，由Element接口扮演此角色。 ConcreteElementConcreteElement角色负责实现Element角色所定义的接口（API）。在示例程序中，由File类和Directory类扮演此角色。 ObjectStructure（对象结构）ObjectStructure角色负责处理Element角色的集合。ConcreteVisitor角色为每个Element角色都准备了处理方法。在示例程序中，由Directory类扮演此角色。为了让ConcreteVisitor角色可以遍历处理每个Element角色，在示例程序中，在Directory类中实现了iterator方法。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.io包与Decorator模式]]></title>
    <url>%2F2019%2F08%2F09%2Fjava-io%E5%8C%85%E4%B8%8EDecorator%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[java.io包是用于输入输出（I/O）的包。这里，使用了Decorator模式。 首先，可以像下面这样生成一个读取文件的实例。 1Reader reader = new FileReader("datafile.txt"); 然后，也可以像下面这样在读取文件时将文件内容放入缓冲区。 12Reader reader = new BufferedReader( new FileReader("datafile.txt")); 这样，在生成BufferedReader类的实例时，会指定将文件读取到FileReader类的实例中。再然后，也可以像下面这样管理行号。 123Reader reader = new LineNumberReader( new BufferedReader( new FileReader("datafile.txt"))); 无论是LineNumberReader类的构造函数还是BufferedReader类的构造函数，都可以接收Reader类（的子类）的实例作为参数，因此可以像上面那样自由地进行各种组合。还可以管理行号，但不进行缓存处理。 12Reader reader = new LineNumberReader( new FileReader("datafile.txt")); 接下来，还会管理行号，进行缓存，但是不从文件中读取数据，而是从网络中读取数据。 1234567java.net.Socket socket = new Socket(hostname, portnumber);...Reader reader = new LineNumberReader( new BufferedReader( new InputStreamReader( socket.getInputStream() ))); 这里使用的InputStreamReader类既接收getInputStream方法返回的InputStream类的实例作为构造函数的参数，也提供了Reader类的接口（API）。]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 784 - Letter Case Permutation]]></title>
    <url>%2F2019%2F08%2F09%2FLeetCode-Problem-784-Letter-Case-Permutation%2F</url>
    <content type="text"><![CDATA[Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create. ExampleNo.1Input: S = “a1b2” Output: [“a1b2”, “a1B2”, “A1b2”, “A1B2”] No.2Input: S = “3z4” Output: [“3z4”, “3Z4”] No.3Input: S = “12345” Output: [“12345”] Note S will be a string with length between 1 and 12. S will consist only of letters or digits. Code123456789101112131415161718192021public List&lt;String&gt; letterCasePermutation(String S) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); dfs(result, S.toCharArray(), 0); return result;&#125;private void dfs(List&lt;String&gt; result, char[] str, int idx) &#123; if (idx == str.length) &#123; result.add(String.valueOf(str)); return; &#125; dfs(result, str, idx + 1); char ch = str[idx]; if (Character.isLetter(ch)) &#123; str[idx] = (char) (ch ^ (1 &lt;&lt; 5)); dfs(result, str, idx + 1); str[idx] = ch; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Decorator模式]]></title>
    <url>%2F2019%2F08%2F09%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Decorator%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[不断地为对象添加装饰。 示例给文字添加装饰边框。 类图 Display类12345678910public abstract class Display &#123; public abstract int getColumns(); public abstract int getRows(); public abstract String getRowText(int row); public final void show() &#123; for (int i = 0; i &lt; getRows(); i++) System.out.println(getRowText(i)); &#125;&#125; StringDisplay类12345678910111213141516171819202122public class StringDisplay extends Display &#123; private String string; public StringDisplay(String string) &#123; this.string = string; &#125; @Override public int getColumns() &#123; return string.getBytes().length; &#125; @Override public int getRows() &#123; return 1; &#125; @Override public String getRowText(int row) &#123; return row == 0 ? string : null; &#125;&#125; Border类1234567public abstract class Border extends Display &#123; protected Display display; protected Border(Display display) &#123; this.display = display; &#125;&#125; SideBorder类1234567891011121314151617181920212223public class SideBorder extends Border &#123; private char borderChar; public SideBorder(Display display, char ch) &#123; super(display); this.borderChar = ch; &#125; @Override public int getColumns() &#123; return display.getColumns() + 2; &#125; @Override public int getRows() &#123; return display.getRows(); &#125; @Override public String getRowText(int row) &#123; return borderChar + display.getRowText(row) + borderChar; &#125;&#125; FullBorder类12345678910111213141516171819202122232425262728293031323334public class FullBorder extends Border &#123; public FullBorder(Display display) &#123; super(display); &#125; @Override public int getColumns() &#123; return display.getColumns() + 2; &#125; @Override public int getRows() &#123; return display.getRows() + 2; &#125; @Override public String getRowText(int row) &#123; if (row == 0) return "+" + makeLine('-', display.getColumns()) + "+"; else if (row == display.getRows() + 1) return "+" + makeLine('-', display.getColumns()) + "+"; else return "|" + display.getRowText(row - 1) + "|"; &#125; private String makeLine(char ch, int count) &#123; StringBuffer buf = new StringBuffer(); for (int i = 0; i &lt; count; i++) buf.append(ch); return buf.toString(); &#125;&#125; Main类123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; Display b1 = new StringDisplay("Hello, world."); Display b2 = new SideBorder(b1, '#'); Display b3 = new FullBorder(b2); b1.show(); b2.show(); b3.show(); Display b4 = new SideBorder( new FullBorder( new FullBorder( new SideBorder( new FullBorder( new StringDisplay("你好，世界。")), '*'))), '/'); b4.show(); &#125;&#125; 运行结果123456789101112Hello, world.#Hello, world.#+---------------+|#Hello, world.#|+---------------+/+------------------------+//|+----------------------+|//||*+------------------+*||//||*|你好，世界。|*||//||*+------------------+*||//|+----------------------+|//+------------------------+/ 登场角色Component增加功能时的核心角色。在示例程序中，由Display类扮演此角色。 ConcreteComponent该角色实现了Component角色所定义的接口（API）。在示例程序中，由StringDisplay类扮演此角色。 Decorator（装饰物）该角色具有与Component角色相同的接口（API）。在它内部保存了被装饰对象——Component角色。Decorator角色知道自己要装饰的对象。在示例程序中，由Border类扮演此角色。 ConcreteDecorator（具体的装饰物）该角色是具体的Decorator角色。在示例程序中，由SideBorder类和FullBorder类扮演此角色。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Composite模式]]></title>
    <url>%2F2019%2F08%2F08%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Composite%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[能够使容器与内容具有一致性，创造出递归结构。 示例列出文件和文件夹的一览。 类图 Entry类12345678910111213141516171819public abstract class Entry &#123; public abstract String getName(); public abstract int getSize(); public Entry add(Entry entry) throws FileTreatmentException &#123; throw new FileTreatmentException(); &#125; public void printList() &#123; printList(""); &#125; protected abstract void printList(String prefix); @Override public String toString() &#123; return getName() + " (" + getSize() + ")"; &#125;&#125; File类123456789101112131415161718192021222324public class File extends Entry &#123; private String name; private int size; public File(String name, int size) &#123; this.name = name; this.size = size; &#125; @Override public String getName() &#123; return name; &#125; @Override public int getSize() &#123; return size; &#125; @Override protected void printList(String prefix) &#123; System.out.println(prefix + "/" + this); &#125;&#125; Directory类12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.ArrayList;import java.util.Iterator;public class Directory extends Entry &#123; private String name; private ArrayList directory = new ArrayList(); public Directory(String name) &#123; this.name = name; &#125; @Override public String getName() &#123; return name; &#125; @Override public int getSize() &#123; int size = 0; Iterator it = directory.iterator(); while (it.hasNext()) &#123; Entry entry = (Entry) it.next(); size += entry.getSize(); &#125; return size; &#125; @Override protected void printList(String prefix) &#123; System.out.println(prefix + "/" + this); Iterator it = directory.iterator(); while (it.hasNext()) &#123; Entry entry = (Entry) it.next(); entry.printList(prefix + "/" + name); &#125; &#125; @Override public Entry add(Entry entry) &#123; directory.add(entry); return this; &#125;&#125; FileTreatmentException类1234567public class FileTreatmentException extends RuntimeException &#123; public FileTreatmentException() &#123;&#125; public FileTreatmentException(String msg) &#123; super(msg); &#125;&#125; Main类123456789101112131415161718192021222324252627282930313233343536public class Main &#123; public static void main(String[] args) &#123; try &#123; System.out.println("Making root entries..."); Directory rootdir = new Directory("root"); Directory bindir = new Directory("bin"); Directory tmpdir = new Directory("tmp"); Directory usrdir = new Directory("usr"); rootdir.add(bindir); rootdir.add(tmpdir); rootdir.add(usrdir); bindir.add(new File("vi", 10000)); bindir.add(new File("latex", 20000)); rootdir.printList(); System.out.println(""); System.out.println("Making user entries..."); Directory yuki = new Directory("yuki"); Directory hanako = new Directory("hanako"); Directory tomura = new Directory("tomura"); usrdir.add(yuki); usrdir.add(hanako); usrdir.add(tomura); yuki.add(new File("diary.html", 100)); yuki.add(new File("Composite.java", 200)); hanako.add(new File("memo.tex", 300)); tomura.add(new File("game.doc", 400)); tomura.add(new File("junk.mail", 500)); rootdir.printList(); &#125; catch (FileTreatmentException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果1234567891011121314151617181920212223Making root entries.../root (30000)/root/bin (30000)/root/bin/vi (10000)/root/bin/latex (20000)/root/tmp (0)/root/usr (0)Making user entries.../root (31500)/root/bin (30000)/root/bin/vi (10000)/root/bin/latex (20000)/root/tmp (0)/root/usr (1500)/root/usr/yuki (300)/root/usr/yuki/diary.html (100)/root/usr/yuki/Composite.java (200)/root/usr/hanako (300)/root/usr/hanako/memo.tex (300)/root/usr/tomura (900)/root/usr/tomura/game.doc (400)/root/usr/tomura/junk.mail (500) 登场角色Leaf（树叶）表示“内容”的角色。在该角色中不能放入其他对象。在示例程序中，由File类扮演此角色。 Composite（复合物）表示容器的角色。可以在其中放入Leaf角色和Composite角色。在示例程序中，由Directory类扮演此角色。 Component使Leaf角色和Composite角色具有一致性的角色。Component角色是Leaf角色和Composite角色的父类。在示例程序中，由Entry类扮演此角色。 Client使用Composite模式的角色。在示例程序中，由Main类扮演此角色。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 792 - Number of Matching Subsequences]]></title>
    <url>%2F2019%2F08%2F07%2FLeetCode-Problem-792-Number-of-Matching-Subsequences%2F</url>
    <content type="text"><![CDATA[Given string S and a dictionary of words words, find the number of words[i] that is a subsequence of S. ExampleInput:S = “abcde”words = [“a”, “bb”, “acd”, “ace”] Output: 3 Explanation: There are three words in words that are a subsequence of S: “a”, “acd”, “ace”. Note All words in words and S will only consists of lowercase letters. The length of S will be in the range of [1, 50000]. The length of words will be in the range of [1, 5000]. The length of words[i] will be in the range of [1, 50]. Code123456789101112131415161718192021222324252627282930313233343536public int numMatchingSubseq(String S, String[] words) &#123; List&lt;List&lt;Integer&gt;&gt; pos = new ArrayList&lt;&gt;(); int result = 0; for (int i = 0; i &lt; 26; i++) pos.add(new ArrayList&lt;&gt;()); for (int i = 0; i &lt; S.length(); i++) pos.get(S.charAt(i) - 'a').add(i); for (String word : words) &#123; if (match(pos, word)) result++; &#125; return result;&#125;private boolean match(List&lt;List&lt;Integer&gt;&gt; pos, String word) &#123; int prev = -1; for (char ch : word.toCharArray()) &#123; List&lt;Integer&gt; list = pos.get(ch - 'a'); int current = Collections.binarySearch(list, prev + 1); if (current &lt; 0) current = - current - 1; if (current &gt;= list.size()) return false; prev = list.get(current); &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 848 - Shifting Letters]]></title>
    <url>%2F2019%2F08%2F07%2FLeetCode-Problem-848-Shifting-Letters%2F</url>
    <content type="text"><![CDATA[We have a string S of lowercase letters, and an integer array shifts. Call the shift of a letter, the next letter in the alphabet, (wrapping around so that ‘z’ becomes ‘a’). For example, shift(‘a’) = ‘b’, shift(‘t’) = ‘u’, and shift(‘z’) = ‘a’. Now for each shifts[i] = x, we want to shift the first i+1 letters of S, x times. Return the final string after all such shifts to S are applied. ExampleInput: S = “abc”, shifts = [3,5,9] Output: “rpl” Explanation:We start with “abc”.After shifting the first 1 letters of S by 3, we have “dbc”.After shifting the first 2 letters of S by 5, we have “igc”.After shifting the first 3 letters of S by 9, we have “rpl”, the answer. Note 1 &lt;= S.length = shifts.length &lt;= 20000 0 &lt;= shifts[i] &lt;= 10 ^ 9 Code1234567891011public String shiftingLetters(String S, int[] shifts) &#123; char[] ch = S.toCharArray(); int shift = 0; for (int i = shifts.length - 1; i &gt;= 0; i--) &#123; shift += shifts[i] % 26; ch[i] = (char) ('a' + (ch[i] - 'a' + shift) % 26); &#125; return String.valueOf(ch);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 851 - Pour Water]]></title>
    <url>%2F2019%2F08%2F06%2FLintCode-Problem-851-Pour-Water%2F</url>
    <content type="text"><![CDATA[Given an elevation map, heights[i] representing the height of the terrain at that index. The width at each index is 1. After V units of water fall at index K, how much water is at each index? Water first drops at index K, and then it flows according to the following rules: First, the droplet can not move to higher level. If the droplet would eventually fall by moving left, then move left. Otherwise, if the droplet would eventually fall by moving right, then move right. Otherwise, rise at it’s current position. Here, “eventually fall” means that the droplet will eventually be at a lower level if it moves in that direction. Also, “level” means the height of the terrain plus any water in that column. You can assume there’s infinitely high terrain on the two sides out of bounds of the array. Also, there could not be partial water being spread out evenly on more than 1 grid block - each unit of water has to be in exactly one block. Note heights will have length in [1, 100][1,100] and contain integers in [0, 99][0,99]. V will be in range [0, 2000][0,2000]. K will be in range [0, heights.length - 1][0,heights.length−1]. ExampleNo.1Input: heights = [2,1,1,2,1,2,2], V = 4, K = 3 Output: [2,2,2,3,2,2,2] Explanation: 123456# ## ### # ############ 0123456 &lt;- index 2112122 &lt;- level(height) The first drop of water lands at index K = 3: 12345# ## w ### # ############ 0123456 When moving left or right, the water can only move to the same level or a lower level.(By level, we mean the total height of the terrain plus any water in that column.)Since moving left will eventually make it fall, it moves left.(A droplet “made to fall” means go to a lower height than it was at previously.) 123456# ## ### w# ############ 0123456 2122122 Since moving left will not make it fall, it stays in place. The next droplet falls: 12345# ## w ### w# ############ 0123456 Since the new droplet moving left will eventually make it fall, it moves left.Notice that the droplet still preferred to move left,even though it could move right (and moving right makes it fall quicker.) 12345# ## w ### w# ############ 0123456 123456# ## ###ww# ############ 0123456 2222122 After those steps, the third droplet falls.Since moving left would not eventually make it fall, it tries to move right.Since moving right would eventually make it fall, it moves right. 12345# ## w ###ww# ############ 0123456 123456# ## ###ww#w############ 0123456 2222222 Finally, the fourth droplet falls.Since moving left would not eventually make it fall, it tries to move right.Since moving right would not eventually make it fall, it stays in place: 123456# ## w ###ww#w############ 0123456 2223222 The final answer is [2,2,2,3,2,2,2]: 1234 # ####### ####### 0123456 No.2Input: heights = [1,2,3,4], V = 2, K = 2 Output: [2,3,3,4] Explanation: The last droplet settles at index 1, since moving further left would not cause it to eventually fall to a lower height. No.3Input: heights = [3,1,3], V = 5, K = 1 Output: [4,4,4] Code12345678910111213141516171819202122232425262728public int[] pourWater(int[] heights, int V, int K) &#123; while (V &gt; 0) &#123; drop(heights, K); V--; &#125; return heights;&#125;private void drop(int[] heights, int K) &#123; int pos = K; for (int d = -1; d &lt;= 1; d += 2) &#123; int i = K + d; while (i &gt;= 0 &amp;&amp; i &lt; heights.length &amp;&amp; heights[i] &lt;= heights[i - d]) &#123; if (heights[i] &lt; heights[pos]) pos = i; i += d; &#125; if (pos != K) break; &#125; heights[pos]++;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 773 - Sliding Puzzle]]></title>
    <url>%2F2019%2F08%2F06%2FLeetCode-Problem-773-Sliding-Puzzle%2F</url>
    <content type="text"><![CDATA[On a 2x3 board, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it. The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]]. Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1. ExamplesNo.1Input: board = [[1,2,3],[4,0,5]] Output: 1 Explanation: Swap the 0 and the 5 in one move. No.2Input: board = [[1,2,3],[5,4,0]] Output: -1 Explanation: No number of moves will make the board solved. No.3Input: board = [[4,1,2],[5,0,3]] Output: 5 Explanation: 5 is the smallest number of moves that solves the board.An example path:After move 0: [[4,1,2],[5,0,3]]After move 1: [[4,1,2],[0,5,3]]After move 2: [[0,1,2],[4,5,3]]After move 3: [[1,0,2],[4,5,3]]After move 4: [[1,2,0],[4,5,3]]After move 5: [[1,2,3],[4,5,0]] No.4Input: board = [[3,2,4],[1,5,0]] Output: 14 Note board will be a 2 x 3 array as described above. board[i][j] will be a permutation of [0, 1, 2, 3, 4, 5]. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public int slidingPuzzle(int[][] board) &#123; int result = 0; String target = "123450"; String start = ""; int[][] idxs = &#123;&#123;1, 3&#125;, &#123;0, 2, 4&#125;, &#123;1, 5&#125;, &#123;0, 4&#125;, &#123;1, 3, 5&#125;, &#123;2, 4&#125;&#125;; for (int[] row : board) &#123; for (int col : row) start += String.valueOf(col); &#125; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); Set&lt;String&gt; visit = new HashSet&lt;&gt;(); queue.offer(start); visit.add(start); while (!queue.isEmpty()) &#123; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; String string = queue.poll(); if (string.equals(target)) return result; char[] ch = string.toCharArray(); int pos = string.indexOf("0"); for (int idx : idxs[pos]) &#123; swap(ch, pos, idx); String newString = String.valueOf(ch); swap(ch, pos, idx); if (visit.contains(newString)) continue; queue.offer(newString); visit.add(newString); &#125; &#125; result++; &#125; return -1;&#125;private void swap(char[] ch, int i, int j) &#123; char temp = ch[i]; ch[i] = ch[j]; ch[j] = temp;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 332 - Reconstruct Itinerary]]></title>
    <url>%2F2019%2F08%2F06%2FLeetCode-Problem-332-Reconstruct-Itinerary%2F</url>
    <content type="text"><![CDATA[Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”]. All airports are represented by three capital letters (IATA code). You may assume all tickets form at least one valid itinerary. ExampleNo.1Input: [[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]] Output: [“JFK”, “MUC”, “LHR”, “SFO”, “SJC”] No.2Input: [[“JFK”,”SFO”],[“JFK”,”ATL”],[“SFO”,”ATL”],[“ATL”,”JFK”],[“ATL”,”SFO”]] Output: [“JFK”,”ATL”,”JFK”,”SFO”,”ATL”,”SFO”] Explanation: Another possible reconstruction is [“JFK”,”SFO”,”ATL”,”JFK”,”ATL”,”SFO”]. But it is larger in lexical order. Code12345678910111213141516171819202122public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); Map&lt;String, PriorityQueue&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (List&lt;String&gt; ticket : tickets) &#123; map.putIfAbsent(ticket.get(0), new PriorityQueue&lt;&gt;()); map.get(ticket.get(0)).offer(ticket.get(1)); &#125; dfs(result, map, "JFK"); Collections.reverse(result); return result;&#125;private void dfs(List&lt;String&gt; result, Map&lt;String, PriorityQueue&lt;String&gt;&gt; map, String departure) &#123; while (map.containsKey(departure) &amp;&amp; !map.get(departure).isEmpty()) &#123; String arrival = map.get(departure).poll(); dfs(result, map, arrival); &#125; result.add(departure);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 875 - Koko Eating Bananas]]></title>
    <url>%2F2019%2F08%2F06%2FLeetCode-Problem-875-Koko-Eating-Bananas%2F</url>
    <content type="text"><![CDATA[Koko loves to eat bananas. There are N piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in H hours. Koko can decide her bananas-per-hour eating speed of K. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than K bananas, she eats all of them instead, and won’t eat any more bananas during this hour. Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. Return the minimum integer K such that she can eat all the bananas within H hours. ExampleNo.1Input: piles = [3,6,7,11], H = 8 Output: 4 No.2Input: piles = [30,11,23,4,20], H = 5 Output: 30 No.3Input: piles = [30,11,23,4,20], H = 6 Output: 23 Note 1 &lt;= piles.length &lt;= 10^4 piles.length &lt;= H &lt;= 10^9 1 &lt;= piles[i] &lt;= 10^9 Code12345678910111213141516171819public int minEatingSpeed(int[] piles, int H) &#123; int left = 1; int right = (int) Math.pow(10, 9); while (left &lt; right) &#123; int mid = left + (right - left) / 2; int h = 0; for (int pile : piles) h += (pile + mid - 1) / mid; if (h &lt;= H) right = mid; else left = mid + 1; &#125; return left;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Strategy模式]]></title>
    <url>%2F2019%2F08%2F04%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Strategy%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[整体地替换算法的实现部分，能轻松地以不同的算法去解决同一个问题。 示例让电脑玩“猜拳”游戏。第一种策略是“如果这局猜拳获胜，那么下一局也出一样的手势”；另外一种策略是“根据上一局的手势从概率上计算出下一局的手势”。 类图 Hand类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Hand &#123; public static final int HANDVALUE_GUU = 0; public static final int HANDVALUE_CHO = 1; public static final int HANDVALUE_PAA = 2; public static final Hand[] hand = &#123; new Hand(HANDVALUE_GUU), new Hand(HANDVALUE_CHO), new Hand(HANDVALUE_PAA) &#125;; public static final String[] name = &#123; "石头", "剪刀", "布" &#125;; private int handvalue; private Hand(int handvalue) &#123; this.handvalue = handvalue; &#125; public static Hand getHand(int handvalue) &#123; return hand[handvalue]; &#125; public boolean isStrongerThan(Hand h) &#123; return fight(h) == 1; &#125; public boolean isWeakerThan(Hand h) &#123; return fight(h) == -1; &#125; private int fight(Hand h) &#123; if (this == h) return 0; else if ((this.handvalue + 1) % 3 == h.handvalue) return 1; else return -1; &#125; @Override public String toString() &#123; return name[handvalue]; &#125;&#125; Strategy接口1234public interface Strategy &#123; public abstract Hand nextHand(); public abstract void study(boolean win);&#125; WinningStrategy类123456789101112131415161718192021222324import java.util.Random;public class WinningStrategy implements Strategy &#123; private Random random; private boolean won = false; private Hand prevHand; public WinningStrategy(int seed) &#123; random = new Random(seed); &#125; @Override public Hand nextHand() &#123; if (!won) prevHand = Hand.getHand(random.nextInt(3)); return prevHand; &#125; @Override public void study(boolean win) &#123; won = win; &#125;&#125; ProbStrategy类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.Random;public class ProbStrategy implements Strategy &#123; private Random random; private int prevHandValue = 0; private int currentHandValue = 0; // history[上一局出的手势][这一局出的手势] private int[][] history = &#123; &#123;1, 1, 1&#125;, &#123;1, 1, 1&#125;, &#123;1, 1, 1&#125; &#125;; public ProbStrategy(int seed) &#123; random = new Random(seed); &#125; @Override public Hand nextHand() &#123; int bet = random.nextInt(getSum(currentHandValue)); int handvalue; if (bet &lt; history[currentHandValue][0]) handvalue = 0; else if (bet &lt; history[currentHandValue][0] + history[currentHandValue][1]) handvalue = 1; else handvalue = 2; prevHandValue = currentHandValue; currentHandValue = handvalue; return Hand.getHand(handvalue); &#125; @Override public void study(boolean win) &#123; if (win) history[prevHandValue][currentHandValue]++; else &#123; history[prevHandValue][(currentHandValue + 1) % 3]++; history[prevHandValue][(currentHandValue + 2) % 3]++; &#125; &#125; private int getSum(int hv) &#123; int sum = 0; for (int i = 0; i &lt; 3; i++) sum += history[hv][i]; return sum; &#125;&#125; Player类1234567891011121314151617181920212223242526272829303132333435363738public class Player &#123; private String name; private Strategy strategy; private int wincount; private int losecount; private int gamecount; public Player(String name, Strategy strategy) &#123; this.name = name; this.strategy = strategy; &#125; public Hand nextHand() &#123; return strategy.nextHand(); &#125; public void win() &#123; strategy.study(true); wincount++; gamecount++; &#125; public void lose() &#123; strategy.study(false); losecount++; gamecount++; &#125; public void even() &#123; gamecount++; &#125; @Override public String toString() &#123; return "[" + name + ":" + gamecount + " games, " + wincount + " win, " + losecount + " lose" + "]"; &#125;&#125; Main类12345678910111213141516171819202122232425262728293031323334353637383940public class Main &#123; public static void main(String[] args) &#123; if (args.length != 2) &#123; System.out.println("Usage: java Main randomseed1 randomseed2"); System.out.println("Example: java Main 314 15"); System.exit(0); &#125; int seed1 = Integer.parseInt(args[0]); int seed2 = Integer.parseInt(args[1]); Player player1 = new Player("Taro", new WinningStrategy(seed1)); Player player2 = new Player("Hana", new ProbStrategy(seed2)); for (int i = 0; i &lt; 10000; i++) &#123; Hand nextHand1 = player1.nextHand(); Hand nextHand2 = player2.nextHand(); if (nextHand1.isStrongerThan(nextHand2)) &#123; System.out.println("Winner:" + player1); player1.win(); player2.lose(); &#125; else if (nextHand1.isWeakerThan(nextHand2)) &#123; System.out.println("Winner:" + player2); player1.lose(); player2.win(); &#125; else &#123; System.out.println("Even..."); player1.even(); player2.even(); &#125; &#125; System.out.println("Total result:"); System.out.println(player1.toString()); System.out.println(player2.toString()); &#125;&#125; 运行结果123456789101112131415161718192021222324252627Even...Winner:[Hana:1 games, 0 win, 0 lose]Winner:[Taro:2 games, 0 win, 1 lose]Even...Winner:[Hana:4 games, 1 win, 1 lose]Winner:[Taro:5 games, 1 win, 2 lose]Even...Even...Winner:[Taro:8 games, 2 win, 2 lose]Winner:[Taro:9 games, 3 win, 2 lose]Winner:[Taro:10 games, 4 win, 2 lose]Even......Even...Winner:[Taro:9992 games, 3164 win, 3488 lose]Winner:[Hana:9993 games, 3488 win, 3165 lose]Winner:[Taro:9994 games, 3165 win, 3489 lose]Winner:[Taro:9995 games, 3166 win, 3489 lose]Winner:[Hana:9996 games, 3489 win, 3167 lose]Even...Even...Even...Total result:[Taro:10000 games, 3167 win, 3490 lose][Hana:10000 games, 3490 win, 3167 lose] 登场角色Strategy（策略）Strategy角色负责决定实现策略所必需的接口（API）。在示例程序中，由Strategy接口扮演此角色。 ConcreteStrategy（具体的策略）ConcreteStrategy角色负责实现Strategy角色的接口（API），即负责实现具体的策略（战略、方向、方法和算法）。在示例程序中，由WinningStrategy类和ProbStrategy类扮演此角色。 Context（上下文）负责使用Strategy角色。Context角色保存了ConcreteStrategy角色的实例，并使用ConcreteStrategy角色去实现需求（总之，还是要调用Strategy角色的接口（API））。在示例程序中，由Player类扮演此角色。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Bridge模式]]></title>
    <url>%2F2019%2F08%2F04%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Bridge%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在“类的功能层次结构”和“类的实现层次结构”之间搭建桥梁。 父类具有基本功能 在子类中增加新的功能 这种层次结构被称为“类的功能层次结构”。 父类通过声明抽象方法来定义接口（API） 子类通过实现具体方法来实现接口（API） 这种层次结构被称为“类的实现层次结构”。 示例显示一些东西。 类图 Display类12345678910111213141516171819202122232425public class Display &#123; private DisplayImpl impl; public Display(DisplayImpl impl) &#123; this.impl = impl; &#125; public void open() &#123; impl.rawOpen(); &#125; public void print() &#123; impl.rawPrint(); &#125; public void close() &#123; impl.rawClose(); &#125; public final void display() &#123; open(); print(); close(); &#125;&#125; CountDisplay类1234567891011121314public class CountDisplay extends Display &#123; public CountDisplay(DisplayImpl impl) &#123; super(impl); &#125; public void multiDisplay(int times) &#123; open(); for (int i = 0; i &lt; times; i++) print(); close(); &#125;&#125; DisplayImpl类12345public abstract class DisplayImpl &#123; public abstract void rawOpen(); public abstract void rawPrint(); public abstract void rawClose();&#125; StringDisplayImpl类123456789101112131415161718192021222324252627282930313233public class StringDisplayImpl extends DisplayImpl &#123; private String string; private int width; public StringDisplayImpl(String string) &#123; this.string = string; this.width = string.getBytes().length; &#125; @Override public void rawOpen() &#123; printLine(); &#125; @Override public void rawPrint() &#123; System.out.println("|" + string + "|"); &#125; @Override public void rawClose() &#123; printLine(); &#125; private void printLine() &#123; System.out.print("+"); for (int i = 0; i &lt; width; i++) System.out.print("-"); System.out.println("+"); &#125;&#125; Main类12345678910111213public class Main &#123; public static void main(String[] args) &#123; Display d1 = new Display(new StringDisplayImpl("Hello, China.")); Display d2 = new CountDisplay(new StringDisplayImpl("Hello, World.")); CountDisplay d3 = new CountDisplay(new StringDisplayImpl("Hello, Universe.")); d1.display(); d2.display(); d3.display(); d3.multiDisplay(5); &#125;&#125; 运行结果12345678910111213141516+-------------+|Hello, China.|+-------------++-------------+|Hello, World.|+-------------++----------------+|Hello, Universe.|+----------------++----------------+|Hello, Universe.||Hello, Universe.||Hello, Universe.||Hello, Universe.||Hello, Universe.|+----------------+ 登场角色Abstraction（抽象化）该角色位于“类的功能层次结构”的最上层。它使用Implementor角色的方法定义了基本的功能。该角色中保存了Implementor角色的实例。在示例程序中，由Display类扮演此角色。 RefinedAbstraction（改善后的抽象化）在Abstraction角色的基础上增加了新功能的角色。在示例程序中，由CountDisplay类扮演此角色。 Implementor（实现者）该角色位于“类的实现层次结构”的最上层。它定义了用于实现Abstraction角色的接口（API）的方法。在示例程序中，由DisplayImpl类扮演此角色。 ConcreteImplementor（具体实现者）该角色负责实现Implementor角色中定义的接口（API）。在示例程序中，由StringDisplayImpl类扮演此角色。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种生成实例的方法]]></title>
    <url>%2F2019%2F08%2F04%2F%E5%90%84%E7%A7%8D%E7%94%9F%E6%88%90%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[new使用Java关键字new生成实例。可以像下面这样生成Something类的实例并将其保存在obj变量中。 1Something obj = new Something(); 这时，类名（此处的Something）会出现在代码中。 clone使用clone方法，根据现有的实例复制出一个新的实例。可以像下面这样根据自身来复制出新的实例（不过不会调用构造函数）。 12345678910111213class Something &#123; public Something createClone() &#123; Something obj = null; try &#123; obj = (Something) clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return obj; &#125;&#125; newInstance使用java.lang.Class类的newInstance方法可以通过Class类的实例生成出Class类所表示的类的实例（会调用无参构造函数）。假设现在已经有了Something类的实例someobj，通过下面的表达式可以生成另外一个Something类的实例。 1someobj.getClass().newInstance() 实际上，调用newInstance方法可能会导致抛出InstantiationException异常或是IllegalAccessException异常，因此需要将其置于try…catch语句块中或是用throws关键字指定调用newInstance方法的方法可能会抛出的异常。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Abstract Factory模式]]></title>
    <url>%2F2019%2F08%2F03%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Abstract-Factory%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[抽象工厂将抽象零件组装为抽象产品。 示例将带有层次关系的链接的集合制作成HTML文件。 类图 Item类1234567891011package factory;public abstract class Item &#123; protected String caption; public Item(String caption) &#123; this.caption = caption; &#125; public abstract String makeHTML();&#125; Link类12345678910package factory;public abstract class Link extends Item &#123; protected String url; public Link(String caption, String url) &#123; super(caption); this.url = url; &#125;&#125; Tray类123456789101112131415package factory;import java.util.ArrayList;public abstract class Tray extends Item &#123; protected ArrayList tray = new ArrayList(); public Tray(String caption) &#123; super(caption); &#125; public void add(Item item) &#123; tray.add(item); &#125;&#125; Page类1234567891011121314151617181920212223242526272829303132333435package factory;import java.io.FileWriter;import java.io.IOException;import java.io.Writer;import java.util.ArrayList;public abstract class Page &#123; protected String title; protected String author; protected ArrayList content = new ArrayList(); public Page(String title, String author) &#123; this.title = title; this.author = author; &#125; public void add(Item item) &#123; content.add(item); &#125; public void output() &#123; try &#123; String filename = title + ".html"; Writer writer = new FileWriter(filename); writer.write(this.makeHTML()); writer.close(); System.out.println(filename + "编写完成。"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public abstract String makeHTML();&#125; Factory类123456789101112131415161718192021package factory;public abstract class Factory &#123; public static Factory getFactory(String classname) &#123; Factory factory = null; try &#123; factory = (Factory) Class.forName(classname).newInstance(); &#125; catch (ClassNotFoundException e) &#123; System.err.println("没有找到" + classname + "类。"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return factory; &#125; public abstract Link createLink(String caption, String url); public abstract Tray createTray(String caption); public abstract Page createPage(String title, String author);&#125; Main类1234567891011121314151617181920212223242526272829303132333435363738394041424344import factory.Factory;import factory.Link;import factory.Page;import factory.Tray;public class Main &#123; public static void main(String[] args) &#123; if (args.length != 1) &#123; System.out.println("Usage: java Main class.name.of.ConcreteFactory"); System.out.println("Example 1: java Main listfactory.ListFactory"); System.out.println("Example 2: java Main tablefactory.TableFactory"); System.exit(0); &#125; Factory factory = Factory.getFactory(args[0]); Link people = factory.createLink("人民日报", "http://www.people.com.cn/"); Link gmw = factory.createLink("光明日报", "http://www.gmw.cn/"); Link us_yahoo = factory.createLink("Yahoo!", "http://www.yahoo.com/"); Link jp_yahoo = factory.createLink("Yahoo!Japan", "http://www.yahoo.co.jp/"); Link excite = factory.createLink("Excite", "http://www.excite.com/"); Link google = factory.createLink("Google", "http://www.google.com/"); Tray traynews = factory.createTray("日报"); traynews.add(people); traynews.add(gmw); Tray trayyahoo = factory.createTray("Yahoo!"); trayyahoo.add(us_yahoo); trayyahoo.add(jp_yahoo); Tray traysearch = factory.createTray("检索引擎"); traysearch.add(trayyahoo); traysearch.add(excite); traysearch.add(google); Page page = factory.createPage("LinkPage", "杨文轩"); page.add(traynews); page.add(traysearch); page.output(); &#125;&#125; ListFactory类1234567891011121314151617181920212223package listfactory;import factory.Factory;import factory.Link;import factory.Page;import factory.Tray;public class ListFactory extends Factory &#123; @Override public Link createLink(String caption, String url) &#123; return new ListLink(caption, url); &#125; @Override public Tray createTray(String caption) &#123; return new ListTray(caption); &#125; @Override public Page createPage(String title, String author) &#123; return new ListPage(title, author); &#125;&#125; ListLink类1234567891011121314package listfactory;import factory.Link;public class ListLink extends Link &#123; public ListLink(String caption, String url) &#123; super(caption, url); &#125; @Override public String makeHTML() &#123; return " &lt;li&gt;&lt;a href=\"" + url + "\"&gt;" + caption + "&lt;/a&gt;&lt;/li&gt;\n"; &#125;&#125; ListTray类123456789101112131415161718192021222324252627282930package listfactory;import factory.Item;import factory.Tray;import java.util.Iterator;public class ListTray extends Tray &#123; public ListTray(String caption) &#123; super(caption); &#125; @Override public String makeHTML() &#123; StringBuffer buffer = new StringBuffer(); buffer.append("&lt;li&gt;\n"); buffer.append(caption + "\n"); buffer.append("&lt;ul&gt;\n"); Iterator it = tray.iterator(); while (it.hasNext()) &#123; Item item = (Item) it.next(); buffer.append(item.makeHTML()); &#125; buffer.append("&lt;/ul&gt;\n"); buffer.append("&lt;/li&gt;\n"); return buffer.toString(); &#125;&#125; ListPage类1234567891011121314151617181920212223242526272829303132package listfactory;import factory.Item;import factory.Page;import java.util.Iterator;public class ListPage extends Page &#123; public ListPage(String title, String author) &#123; super(title, author); &#125; @Override public String makeHTML() &#123; StringBuffer buffer = new StringBuffer(); buffer.append("&lt;html&gt;&lt;head&gt;&lt;title&gt;" + title + "&lt;/title&gt;&lt;/head&gt;\n"); buffer.append("&lt;body&gt;\n"); buffer.append("&lt;h1&gt;" + title + "&lt;/h1&gt;\n"); buffer.append("&lt;ul&gt;\n"); Iterator it = content.iterator(); while (it.hasNext()) &#123; Item item = (Item) it.next(); buffer.append(item.makeHTML()); &#125; buffer.append("&lt;/ul&gt;\n"); buffer.append("&lt;hr&gt;&lt;address&gt;" + author + "&lt;/address&gt;"); buffer.append("&lt;/body&gt;&lt;/html&gt;\n"); return buffer.toString(); &#125;&#125; 运行结果123456789101112131415161718192021222324252627&lt;html&gt;&lt;head&gt;&lt;title&gt;LinkPage&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;LinkPage&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;日报&lt;ul&gt; &lt;li&gt;&lt;a href="http://www.people.com.cn/"&gt;人民日报&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://www.gmw.cn/"&gt;光明日报&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;检索引擎&lt;ul&gt;&lt;li&gt;Yahoo!&lt;ul&gt; &lt;li&gt;&lt;a href="http://www.yahoo.com/"&gt;Yahoo!&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://www.yahoo.co.jp/"&gt;Yahoo!Japan&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://www.excite.com/"&gt;Excite&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://www.google.com/"&gt;Google&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;address&gt;杨文轩&lt;/address&gt;&lt;/body&gt;&lt;/html&gt; TableFactory类1234567891011121314151617181920212223package tablefactory;import factory.Factory;import factory.Link;import factory.Page;import factory.Tray;public class TableFactory extends Factory &#123; @Override public Link createLink(String caption, String url) &#123; return new TableLink(caption, url); &#125; @Override public Tray createTray(String caption) &#123; return new TableTray(caption); &#125; @Override public Page createPage(String title, String author) &#123; return new TablePage(title, author); &#125;&#125; TableLink类1234567891011121314package tablefactory;import factory.Link;public class TableLink extends Link &#123; public TableLink(String caption, String url) &#123; super(caption, url); &#125; @Override public String makeHTML() &#123; return "&lt;td&gt;&lt;a href=\"" + url + "\"&gt;" + caption + "&lt;/a&gt;&lt;/td&gt;\n"; &#125;&#125; TableTray类123456789101112131415161718192021222324252627282930313233package tablefactory;import factory.Item;import factory.Tray;import java.util.Iterator;public class TableTray extends Tray &#123; public TableTray(String caption) &#123; super(caption); &#125; @Override public String makeHTML() &#123; StringBuffer buffer = new StringBuffer(); buffer.append("&lt;td&gt;"); buffer.append("&lt;table width=\"100%\" border=\"1\"&gt;&lt;tr&gt;"); buffer.append("&lt;td bgcolor=\"#cccccc\" align=\"center\" colspan=\"" + tray.size() + "\"&gt;&lt;b&gt;" + caption + "&lt;/b&gt;&lt;/td&gt;"); buffer.append("&lt;/tr&gt;\n"); buffer.append("&lt;tr&gt;\n"); Iterator it = tray.iterator(); while (it.hasNext()) &#123; Item item = (Item) it.next(); buffer.append(item.makeHTML()); &#125; buffer.append("&lt;/tr&gt;&lt;/table&gt;"); buffer.append("&lt;/td&gt;"); return buffer.toString(); &#125;&#125; TablePage类1234567891011121314151617181920212223242526272829303132package tablefactory;import factory.Item;import factory.Page;import java.util.Iterator;public class TablePage extends Page &#123; public TablePage(String title, String author) &#123; super(title, author); &#125; @Override public String makeHTML() &#123; StringBuffer buffer = new StringBuffer(); buffer.append("&lt;html&gt;&lt;head&gt;&lt;title&gt;" + title + "&lt;/title&gt;&lt;/head&gt;\n"); buffer.append("&lt;body&gt;\n"); buffer.append("&lt;h1&gt;" + title + "&lt;/h1&gt;\n"); buffer.append("&lt;table width=\"80%\" border=\"3\"&gt;\n"); Iterator it = content.iterator(); while (it.hasNext()) &#123; Item item = (Item) it.next(); buffer.append("&lt;tr&gt;" + item.makeHTML() + "&lt;/tr&gt;"); &#125; buffer.append("&lt;/table&gt;\n"); buffer.append("&lt;hr&gt;&lt;address&gt;" + author + "&lt;/address&gt;"); buffer.append("&lt;/body&gt;&lt;/html&gt;\n"); return buffer.toString(); &#125;&#125; 运行结果123456789101112131415161718&lt;html&gt;&lt;head&gt;&lt;title&gt;LinkPage&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;LinkPage&lt;/h1&gt;&lt;table width="80%" border="3"&gt;&lt;tr&gt;&lt;td&gt;&lt;table width="100%" border="1"&gt;&lt;tr&gt;&lt;td bgcolor="#cccccc" align="center" colspan="2"&gt;&lt;b&gt;日报&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href="http://www.people.com.cn/"&gt;人民日报&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="http://www.gmw.cn/"&gt;光明日报&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;table width="100%" border="1"&gt;&lt;tr&gt;&lt;td bgcolor="#cccccc" align="center" colspan="3"&gt;&lt;b&gt;检索引擎&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;table width="100%" border="1"&gt;&lt;tr&gt;&lt;td bgcolor="#cccccc" align="center" colspan="2"&gt;&lt;b&gt;Yahoo!&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href="http://www.yahoo.com/"&gt;Yahoo!&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="http://www.yahoo.co.jp/"&gt;Yahoo!Japan&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="http://www.excite.com/"&gt;Excite&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="http://www.google.com/"&gt;Google&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;hr&gt;&lt;address&gt;杨文轩&lt;/address&gt;&lt;/body&gt;&lt;/html&gt; 登场角色AbstractProduct（抽象产品）AbstractProduct角色负责定义AbstractFactory角色所产生的抽象零件和产品的接口（API）。在示例程序中，由Link类、Tray类和Page类扮演此角色。 AbstractFactory（抽象工厂）AbstractFactory角色负责定义用于生成抽象产品的接口（API）。在示例程序中，由Factory类扮演此角色。 Client（委托者）Client角色仅会调用AbstractFactory角色和AbstractProduct角色的接口（API）来进行工作，对于具体的零件、产品和工厂一无所知。在示例程序中，由Main类扮演此角色。 ConcreteProduct（具体产品）ConcreteProduct角色负责实现AbstractProduct角色的接口（API）。在示例程序中，由以下包中的以下类扮演此角色： listfactory包：ListLink类、ListTray类和ListPage类 tablefactory包：TableLink类、TableTray类和TablePage类 ConcreteFactory（具体工厂）ConcreteFactory角色负责实现AbstractFactory角色的接口（API）。在示例程序中，由以下包中的以下类扮演此角色： listfactory包：ListFactory类 tablefactory包：TableFactory类 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SQL进阶教程】CASE表达式]]></title>
    <url>%2F2019%2F08%2F01%2F%E3%80%90SQL%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B%E3%80%91CASE%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[CASE表达式概述CASE表达式有简单CASE表达式(simple case expression)和搜索CASE表达式(searched case expression)两种写法。在编写SQL语句的时候需要注意，在发现为真的WHEN子句时，CASE表达式的真假值判断就会中止，而剩余的WHEN子句会被忽略。为了避免引起不必要的混乱，使用WHEN子句时要注意条件的排他性。 此外，使用CASE表达式的时候，还需要注意以下几点。 统一各分支返回的数据类型 不要忘了写END 养成写ELSE子句的习惯 将已有编号方式转换为新的方式并统计在进行非定制化统计时，经常会遇到将已有编号方式转换为另外一种便于分析的方式并进行统计的需求。例如，现在有一张按照“’1:北海道’、’2:青森’、…、’47:冲绳’”这种编号方式来统计都道府县人口的表，需要以东北、关东、九州等地区为单位来分组，并统计人口数量。 如果使用CASE表达式，则用如下所示的一条SQL语句就可以完成。 12345678910111213141516171819202122SELECT CASE pref_name WHEN '德岛' THEN '四国' WHEN '香川' THEN '四国' WHEN '爱媛' THEN '四国' WHEN '高知' THEN '四国' WHEN '福冈' THEN '九州' WHEN '佐贺' THEN '九州' WHEN '长崎' THEN '九州' ELSE '其他' END AS district, SUM(population)From PopTblGROUP BY CASE pref_name WHEN '德岛' THEN '四国' WHEN '香川' THEN '四国' WHEN '爱媛' THEN '四国' WHEN '高知' THEN '四国' WHEN '福冈' THEN '九州' WHEN '佐贺' THEN '九州' WHEN '长崎' THEN '九州' ELSE '其他' END; 这里的关键在于将SELECT子句里的CASE表达式复制到GROUP BY子句里。需要注意的是，如果对转换前的列“pref_name”进行GROUP BY，就得不到正确的结果。 用一条SQL语句进行不同条件的统计进行不同条件的统计是CASE表达式的著名用法之一。例如，需要往存储各县人口数量的表PopTbl里添加上“性别”列，然后求按性别、县名汇总的人数。 如果使用CASE表达式，下面这一条简单的SQL语句就可以搞定。 12345SELECT pref_name, SUM(CASE WHEN sex = '1' THEN population ELSE 0 END) AS cnt_m, SUM(CASE WHEN sex = '2' THEN population ELSE 0 END) AS cnt_fFROM PopTbl2GROUP BY pref_name; 这个技巧可贵的地方在于，它能将SQL的查询结果转换为二维表的格式。如果只是简单地用GROUP BY进行聚合，那么查询后必须通过宿主语言或者Excel等应用程序将结果的格式转换一下，才能使之称为交叉表。 用CHECK约束定义多个列的条件关系其实，CASE表达式和CHECK约束是很般配的一对组合。假设某公司规定“女性员工的工资必须在20万日元以下”，而在这个公司的人事表中，这条无理的规定是使用CHECK约束来描述的，代码如下所示。 12345CONSTRAINT check_salary CHECK (CASE WHEN sex = '2' THEN CASE WHEN salary &lt;= 200000 THEN 1 ELSE 0 END ELSE 1 END = 1) 在这段代码里，CASE表达式被嵌入到CHECK约束里，描述了“如果是女性员工，则工资是20万日元以下”这个命题。这里需要重点理解的是蕴含式(conditional)和逻辑与(logical product)的区别。用逻辑与改写的CHECK约束如下所示。 12CONSTRAINT check_salary CHECK (sex = '2' AND salary &lt;= 200000) 当然，这两个约束的程序行为不一样。如果在CHECK约束里使用逻辑与，该公司将不能雇佣男性员工。而如果使用蕴含式，男性也可以在这里工作。 在UPDATE语句里进行条件分支以某数值型的列的当前值为判断对象，将其更新成别的值。例如，通过下面这样一张公司人事部的员工工资信息表Salaries来看一下这种情况。 假设现在需要根据以下条件对该表的数据进行更新。 对当前工资为30万日元以上的员工，降薪10%。 对当前工资为25万日元以上且不满28万日元的员工，加薪20%。 为了避免问题，准确地表达出可恶的人事部长的意图，可以像下面这样用CASE表达式来写SQL。 12345UPDATE SalariesSET salary = CASE WHEN salary &gt;= 300000 THEN salary * 0.9 WHEN salary &gt;= 250000 AND salary &lt; 280000 THEN salary * 1.2 ELSE salary END; 这条SQL语句不仅执行结果正确，而且因为只需执行一次，所以速度也更快。 表之间的数据匹配在CASE表达式里，可以使用BETWEEN、LIKE、&lt;、&gt;等便利的谓词组合，以及能嵌套子查询的IN和EXISTS谓词。因此，CASE表达式具有非常强大的表达能力。如下所示，这里有一张资格培训学校的课程一览表和一张管理每个月所设课程的表。 要用这两张表生成下面这样的交叉表，以便于一目了然地知道每个月开设的课程。 123456789101112131415161718192021-- INSELECT course_name, CASE WHEN course_id IN (SELECT course_id FROM OpenCourses WHERE month = 200706) THEN 'O' ELSE 'X' END AS '6月', CASE WHEN course_id IN (SELECT course_id FROM OpenCourses WHERE month = 200707) THEN 'O' ELSE 'X' END AS '7月', CASE WHEN course_id IN (SELECT course_id FROM OpenCourses WHERE month = 200708) THEN 'O' ELSE 'X' END AS '8月'FROM CourseMaster; 123456789101112131415161718192021222324-- EXISTSSELECT CM.course_name, CASE WHEN EXISTS (SELECT course_id FROM OpenCourses OC WHERE month = 200706 AND OC.course_id = CM.course_id) THEN 'O' ELSE 'X' END AS '6月', CASE WHEN EXISTS (SELECT course_id FROM OpenCourses OC WHERE month = 200707 AND OC.course_id = CM.course_id) THEN 'O' ELSE 'X' END AS '7月', CASE WHEN EXISTS (SELECT course_id FROM OpenCourses OC WHERE month = 200708 AND OC.course_id = CM.course_id) THEN 'O' ELSE 'X' END AS '8月'FROM CourseMaster CM; 无论使用IN还是EXISTS，得到的结果是一样的，但从性能方面来说，EXISTS更好。通过EXISTS进行的子查询能够用到“month, course_id”这样的主键索引，因此尤其是当表OpenCourses里数据比较多的时候更有优势。 在CASE表达式中使用聚合函数假设这里有一张显示了学生及其加入的社团的一览表。如表StudentClub所示，这张表的主键是“学生、社团ID”，存储了学生和社团之间多对多的关系。 接下来，按照下面的条件查询这张表里的数据。 获取只加入了一个社团的学生的社团ID。 获取加入了多个社团的学生的主社团ID。 如果使用CASE表达式，下面这一条SQL语句就可以了。 12345678SELECT std_id, CASE WHEN COUNT(*) = 1 THEN MAX(club_id) ELSE MAX(CASE WHEN main_club_flg = 'Y' THEN club_id ELSE NULL END) END AS main_clubFROM StudentClubGROUP BY std_id; CASE表达式用在SELECT子句里时，既可以写在聚合函数内部，也可以写在聚合函数外部。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SQL基础教程】GROUPING运算符]]></title>
    <url>%2F2019%2F08%2F01%2F%E3%80%90SQL%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%91GROUPING%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[同时得到合计行如果想要获得同时得出小计和合计的结果，通常的做法是分别计算出合计行和按照商品种类进行汇总的结果，然后通过UNION ALL连接在一起。 123456SELECT '合计' AS product_type, SUM(sale_price)FROM ProductUNION ALLSELECT product_type, SUM(sale_price)FROM ProductGROUP BY product_type; 这样一来，为了得到想要的结果，需要执行两次几乎相同的SELECT语句，再将其结果进行连接，不但看上去十分繁琐，而且DBMS内部的处理成本也非常高。 ROLLUP——同时得出合计和小计标准SQL引入了GROUPING运算符。使用该运算符就能通过非常简单的SQL得到之前那样的汇总单位不同的汇总结果了。 GROUPING运算符包含以下3种： ROLLUP CUBE GROUPING SETS ROLLUP的使用方法使用ROLLUP就可以通过非常简单的SELECT语句同时计算出合计行了。 123SELECT product_type, SUM(sale_price) AS sum_priceFROM ProductGROUP BY ROLLUP(product_type); 从语法上来说，就是将GROUP BY子句中的聚合键清单像ROLLUP(&lt;列1&gt;,&lt;列2&gt;,…)这样使用。该运算符的作用，就是“一次计算出不同聚合键组合的结果”。例如，在本例中就是一次计算出了如下两种组合的汇总结果。 GROUP BY () GROUP BY (product_type) 1中的GROUP BY()表示没有聚合键，也就相当于没有GROUP BY子句（这时会得到全部数据的合计行的记录），该合计行记录称为超级分组记录。超级分组记录的product_type列的键值（对DBMS来说）并不明确，因此会默认使用NULL。 将“登记日期”添加到聚合键当中下面再添加一个聚合键“登记日期(regist_date)”试试看吧。 123SELECT product_type, regist_date, SUM(sale_price) AS sum_priceFROM ProductGROUP BY ROLLUP(product_type, regist_date); 将上述两个结果进行比较后发现，使用ROLLUP时多出了最上方的合计行以及3条不同商品种类的小计行（也就是未使用登记日期作为聚合键的记录），这4行就是超级分组记录。也就是说，该SELECT语句的结果相当于使用UNION对如下3种模式的聚合级的不同结果进行连接。 GROUP BY () GROUP BY (product_type) GROUP BY (product_type, regist_date) ROLLUP是“卷起”的意思。其名称也形象地说明了该操作能够得到像从小计到合计这样，从最小的聚合级开始，聚合单位逐渐扩大的结果。 GROUPING函数——让NULL更加容易分辨之前使用ROLLUP所得到的结果有些蹊跷，问题就出在“衣服”的分组之中，有两条记录的regist_date为NULL，但其原因却并不相同。sum_price为4000日元的记录，因为商品表中运动T恤的注册日期为NULL，所以就把NULL作为聚合键了。相反，sum_price为5000日元的记录毫无疑问就是超级分组记录的NULL了。但两者看上去都是“NULL“，实在是难以分辨。 为了避免混淆，SQL提供了一个用来判断超级分组记录的NULL的特定函数——GROUPING函数。该函数在其参数列的值为超级分组记录所产生的NULL时返回1，其他情况返回0。 12345SELECT GROUPING(product_type) AS product_type, GROUPING(regist_date) AS regist_date, SUM(sale_price) AS sum_priceFROM ProductGROUP BY ROLLUP(product_type, regist_date); 这样就能分辨超级分组记录中的NULL和原始数据本身的NULL了。使用GROUPING函数还能在超级分组记录的键值中插入字符串。也就是说，当GROUPING函数的返回值为1时，指定“合计”或者“小计”等字符串，其他情况返回通常的列的值。 1234567SELECT CASE WHEN GROUPING(product_type) = 1 THEN '商品种类 合计' ELSE product_type END AS product_type, CASE WHEN GROUPING(regist_date) = 1 THEN '登记日期 合计' ELSE CAST(regist_date AS VARCHAR(16)) END AS regist_date, SUM(sale_price) AS sum_priceFROM ProductGROUP BY ROLLUP(product_type, regist_date); 那为什么还要将SELECT子句中的regist_date列转换为CAST(regist_date AS VARCHAR(16))形式的字符串呢？这是为了满足CASE表达式所有分支的返回值必须一致的条件。如果不这样的话，那么各个分支会分别返回日期类型和字符串类型的值，执行时就会发生语法错误。 CUBE——用数据来搭积木ROLLUP之后来介绍另一个常用的GROUPING运算符——CUBE。CUBE的语法和ROLLUP相同，只需要将ROLLUP替换为CUBE就可以了。 1234567SELECT CASE WHEN GROUPING(product_type) = 1 THEN '商品种类 合计' ELSE product_type END AS product_type, CASE WHEN GROUPING(regist_date) = 1 THEN '登记日期 合计' ELSE CAST(regist_date AS VARCHAR(16)) END AS regist_date, SUM(sale_price) AS sum_priceFROM ProductGROUP BY CUBE(product_type, regist_date); 与ROLLUP的结果相比，CUBE的结果中多出了几行记录。多出来的记录就是只把regist_date作为聚合键所得到的汇总结果。 GROUP BY () GROUP BY (product_type) GROUP BY (regist_date) &lt;- 添加的组合 GROUP BY (product_type, regist_date) 所谓CUBE，就是将GROUP BY子句中聚合键的“所有可能的组合”的汇总结果集中到一个结果中。因此，组合的个数就是2^n（n是聚合键的个数）。本例中聚合键有2个，所以2^2=4。 究竟CUBE运算符和立方体有什么关系呢？众所周知，立方体由长、宽、高3个轴构成。对于CUBE来说，一个聚合键就相当于其中的一个轴，而结果就是将数据像积木那样堆积起来。 GROUPING SETS取得期望的积木最后要介绍的GROUPING运算符是GROUPING SETS。该运算符可以用于从ROLLUP或者CUBE的结果中取出部分记录。例如，之前的CUBE的结果就是根据聚合键的所有可能的组合计算而来的。如果希望从中选取出将“商品种类”和“登记日期”各自作为聚合键的结果，或者不想得到“合计记录和使用2个聚合键的记录”时，可以使用GROUPING SETS。 1234567SELECT CASE WHEN GROUPING(product_type) = 1 THEN '商品种类 合计' ELSE product_type END AS product_type, CASE WHEN GROUPING(regist_date) = 1 THEN '登记日期 合计' ELSE CAST(regist_date AS VARCHAR(16)) END AS regist_date, SUM(sale_price) AS sum_priceFROM ProductGROUP BY GROUPING SETS (product_type, regist_date); 与ROLLUP或者CUBE能够得到规定的结果相对，GROUPING SETS用于从中取出个别条件对应的不固定的结果。然而，由于期望获得不固定结果的情况少之又少，因此与ROLLUP或者CUBE比起来，使用GROUPING SETS的机会也就很少了。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SQL基础教程】窗口函数]]></title>
    <url>%2F2019%2F07%2F30%2F%E3%80%90SQL%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%91%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[什么是窗口函数窗口函数也称为OLAP函数。OLAP是Online Analytical Processing的简称，意思是对数据库数据进行实时分析处理。例如，市场分析、创建财务报表、创建计划等日常性商务工作。窗口函数就是为了实现OLAP而添加的标准SQL功能。 窗口函数的语法1&lt;窗口函数&gt; OVER ([PARTITION BY &lt;列清单&gt;] ORDER BY &lt;排序用列清单&gt;) 其中重要的关键字是PARTITION BY和ORDER BY。 在学习PARTITION BY和ORDER BY之前，先来列举一下能够作为窗口函数使用的函数。窗口函数大体可以分为以下两种。 能够作为窗口函数的聚集函数(SUM、AVG、COUNT、MAX、MIN) RANK、DENSE_RANK、ROW_NUMBER等专用窗口函数 语法的基本使用方法——使用RANK函数首先通过专用窗口函数RANK来理解一下窗口函数的语法。正如其名称所示，RANK是用来计算记录排序的函数。例如，对于Product表中的8件商品，根据不同的商品种类(product_type)，按照销售单价(sale_price)从低到高的顺序排序，结果如下所示。 能够得到上述结果的SELECT语句： 123SELECT product_name, product_type, sale_price, RANK () OVER (PARTITION BY product_type ORDER BY sale_price) AS rankingFROM Product; PARTITION BY能够设定排序的对象范围。本例中，为了按照商品种类进行排序，指定了product_type。ORDER BY能够指定按照哪一列、何种顺序进行排序。为了按照销售单价的升序进行排列，指定了sale_price。此外，窗口函数中的ORDER BY与SELECT语句末尾的ORDER BY一样，可以通过关键字ASC/DESC来指定升序和降序。省略该关键字时会默认按照ASC，也就是升序进行排序。 通过图，就很容易理解PARTITION BY和ORDER BY的作用了。如图所示，PARTITION BY在横向上对表进行分组，而ORDER BY决定了纵向排序的规则。 窗口函数兼具GROUP BY子句的分组功能以及ORDER BY子句的排序功能。但是PARTITION BY子句并不具备GROUP BY子句的汇总功能。因此，使用RANK函数并不会减少原表中记录的行数，结果中仍然包含8行数据。 通过PARTITION BY分组后的记录集合称为窗口。此处的窗口代表范围。这也是“窗口函数”名称的由来。此外，各个窗口在定义上绝对不会包含共通的部分。这与通过GROUP BY子句分割后的集合具有相同的特征。 无需指定PARTITION BY使用窗口函数时起到关键作用的是PARTITION BY和GROUP BY。其中，PARTITION BY并不是必需的，即使不指定也可以正常使用窗口函数。这和使用没有GROUP BY的聚合函数时的效果一样，也就是将整个表作为一个大的窗口来使用。 123SELECT product_name, product_type, sale_price, RANK () OVER (ORDER BY sale_price) AS rankingFROM Product; 上述SELECT语句的结果如下所示。 之前得到的是按照商品种类分组后的排序，而这次变成了全部商品的排序。像这样，当希望先将表中的数据分为多个部分（窗口），再使用窗口函数时，可以使用PARTITION BY选项。 专用窗口函数的种类从上述结果中可以看到，“打卡器”和“叉子”都排在第2位，而之后的“擦菜板”跳过了第3位，直接排到了第4位，这也是通常的排序方法，但某些情况下可能并不希望跳过某个位次来进行排序。这时可以使用RANK函数之外的函数来实现。下面就来总结一下具有代表性的专用窗口函数。 RANK函数 计算排序时，如果存在相同位次的记录，则会跳过之后的位次。例）有3条记录排在第1位时：1位、1位、1位、4位… DENSE_RANK函数 同样是计算排序，即使存在相同位次的记录，也不会跳过之后的位次。例）有3条记录排在第1位时：1位、1位、1位、2位… ROW_NUMBER函数 赋予唯一的连续位次。例）有3条记录排在第1位时：1位、2位、3位、4位… 除此之外，各DBMS还提供了各自特有的窗口函数。上述3个函数在所有的DBMS中都能够使用。下面就来比较一下使用这3个函数所得到的结果吧。 12345SELECT product_name, product_type, sale_price, RANK () OVER (ORDER BY sale_price) AS ranking, DENSE_RANK () OVER (ORDER BY sale_price) AS dense_ranking, ROW_NUMBER () OVER (ORDER BY sale_price) AS row_numFROM Product; 使用RANK或ROW_NUMBER时无需任何参数，只需要像RANK()或者ROW_NUMBER()这样保持括号中为空就可以了。这也是专用窗口函数通常的使用方式。这一点与作为窗口函数使用的聚合函数有很大的不同。 窗口函数的适用范围使用窗口函数的位置有非常大的限制。更确切地说，窗口函数只能书写在一个特定的位置。这个位置就是SELECT子句之中。反过来说，就是这类函数不能再WHERE子句或者GROUP BY子句中使用。 其理由就是，在DBMS内部，窗口函数是对WHERE子句或者GROUP BY子句处理后的“结果”进行的操作。在得到用户想要的结果之前，即使进行了排序处理，结果也是错误的。在得到排序结果之后，如果通过WHERE子句中的条件除去了某些记录，或者使用GROUP BY子句进行了汇总处理，那好不容易得到的排序结果也无法使用了。正是由于这样的原因，在SELECT子句之外“使用窗口函数是没有意义的”，所以在语法上才会有这样的限制。 作为窗口函数使用的聚合函数前面介绍了使用专用窗口函数的示例，下面再来看一看把SUM或者AVG等聚合函数作为窗口函数使用的方法。 先来看一个将SUM函数作为窗口函数使用的例子。 123SELECT product_id, product_name, sale_price, SUM (sale_price) OVER (ORDER BY product_id) AS current_sumFROM Product; 使用SUM函数时，并不像RANK或者ROW_NUMBER那样括号中的内容为空，而是需要在括号内指定作为汇总对象的列。本例中计算出了销售单价(sale_price)的合计值(current_sum)。但是得到的并不仅仅是合计值，而是按照ORDER BY子句指定的product_id的升序进行排列，计算出商品编号“小于自己”的商品的销售单价的合计值。因此，计算该合计值的逻辑就像金字塔堆积那样，一行一行逐渐添加计算对象。 使用其他聚合函数时的操作逻辑也和本例相同。例如，使用AVG来代替SELECT语句中的SUM。 123SELECT product_id, product_name, sale_price, AVG (sale_price) OVER (ORDER BY product_id) AS current_avgFROM Product; 从结果中可以看到，current_avg的计算方法确实是计算平均值的方法，但作为统计对象的却只是“排在自己之上”的记录。像这样以“自身记录（当前记录）”所谓基准进行统计，就是将聚合函数当作窗口函数使用时的最大特征。 计算移动平均窗口函数就是将表以窗口为单位进行分割，并在其中进行排序的函数。其实其中还包含在窗口中指定更加详细的汇总范围的备选功能，该备选功能中的汇总范围称为框架。其语法需要在ORDER BY子句之后使用指定范围的关键字。 123SELECT product_id, product_name, sale_price, AVG (sale_price) OVER (ORDER BY product_id ROWS 2 PRECEDING) AS moving_avgFROM Product; 指定框架（汇总范围）这里使用了ROWS（“行”）和PRECEDING（“之前”）两个关键字，将框架指定为“截止到之前～行”，因此“ROWS 2 PRECEDING”就是将框架指定为“截止到之前2行”，也就是将作为汇总对象的记录限定为如下的“最靠近的3行”。 自身（当前记录） 之前1行的记录 之前2行的记录 也就是说，由于框架是根据当前记录来确定的，因此和固定的窗口不同，其范围会随着当前记录的变化而变化。 这样的统计方法称为移动平均(moving average)。由于这种方法在希望实时把握“最近状态”时非常方便，因此常常会应用在对股市趋势的实时跟踪当中。 使用关键字FOLLOWING（“之后”）替换PRECEDING，就可以指定“截止到之后～行”作为框架了。 将当前记录的前后行作为汇总对象如果希望将当前记录的前后行作为汇总对象时，就可以同时使用PRECEDING（“之前”）和FOLLOWING（“之后”）关键字来实现。 123SELECT product_id, product_name, sale_price, AVG (sale_price) OVER (ORDER BY product_id ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS moving_avgFROM Product; 在上述代码中，通过指定框架，将“1 PRECEDING”（之前1行）和“1 FOLLOWING”（之后1行）的区间作为汇总对象。具体来说，就是将如下3行作为汇总对象来进行计算。 之前1行的记录 自身（当前记录） 之后1行的记录 两个ORDER BY最后来介绍一下使用窗口函数时与结果形式相关的注意事项，那就是记录的排列顺序。OVER子句中的ORDER BY只是用来决定窗口函数按照什么样的顺序进行计算的，对结果的排列顺序并没有影响。因此也有可能得到一个记录的排列顺序比较混乱的结果。有些DBMS也可以按照窗口函数的ORDER BY子句所指定的顺序对结果进行排序，但那也仅仅是个例而已。 那么，如何才能让记录切实按照ranking列的升序进行排列呢？答案非常简单。那就是在SELECT语句的最后，使用ORDER BY子句进行指定。这样就能保证SELECT语句的结果中记录的排列顺序了。 1234SELECT product_name, product_type, sale_price, RANK () OVER (ORDER BY sale_price) AS rankingFROM ProductORDER BY ranking;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 599 - Minimum Index Sum of Two Lists]]></title>
    <url>%2F2019%2F07%2F28%2FLeetCode-Problem-599-Minimum-Index-Sum-of-Two-Lists%2F</url>
    <content type="text"><![CDATA[Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer. ExampleNo.1Input:[“Shogun”, “Tapioca Express”, “Burger King”, “KFC”][“Piatti”, “The Grill at Torrey Pines”, “Hungry Hunter Steakhouse”, “Shogun”] Output: [“Shogun”] Explanation: The only restaurant they both like is “Shogun”. No.2Input:[“Shogun”, “Tapioca Express”, “Burger King”, “KFC”][“KFC”, “Shogun”, “Burger King”] Output: [“Shogun”] Explanation: The restaurant they both like and have the least index sum is “Shogun” with index sum 1 (0+1). Note The length of both lists will be in the range of [1, 1000]. The length of strings in both lists will be in the range of [1, 30]. The index is starting from 0 to the list length minus 1. No duplicates in both lists. Code12345678910111213141516171819202122232425public String[] findRestaurant(String[] list1, String[] list2) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); int min = Integer.MAX_VALUE; for (int i = 0; i &lt; list1.length; i++) map.put(list1[i], i); for (int i = 0; i &lt; list2.length; i++) &#123; if (!map.containsKey(list2[i])) continue; int sum = i + map.get(list2[i]); if (sum &lt; min) &#123; min = sum; result.clear(); &#125; if (sum &lt;= min) result.add(list2[i]); &#125; return result.toArray(new String[result.size()]);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 863 - All Nodes Distance K in Binary Tree]]></title>
    <url>%2F2019%2F07%2F28%2FLeetCode-Problem-863-All-Nodes-Distance-K-in-Binary-Tree%2F</url>
    <content type="text"><![CDATA[We are given a binary tree (with root node root), a target node, and an integer value K. Return a list of the values of all nodes that have a distance K from the target node. The answer can be returned in any order. ExampleInput: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2 Output: [7,4,1] Explanation:The nodes that are a distance 2 from the target node (with value 5)have values 7, 4, and 1. Note that the inputs “root” and “target” are actually TreeNodes.The descriptions of the inputs above are just serializations of these objects. Note: The given tree is non-empty. Each node in the tree has unique values 0 &lt;= node.val &lt;= 500. The target node is a node in the tree. 0 &lt;= K &lt;= 1000. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); helper(result, root, target, K); return result;&#125;private int helper(List&lt;Integer&gt; result, TreeNode root, TreeNode target, int K) &#123; if (root == null) return -1; if (root == target) &#123; collect(result, root, K); return 0; &#125; int left = helper(result, root.left, target, K); int right = helper(result, root.right, target, K); if (left &gt;= 0) &#123; if (left + 1 == K) result.add(root.val); collect(result, root.right, K - left - 2); return left + 1; &#125; else if (right &gt;= 0) &#123; if (right + 1 == K) result.add(root.val); collect(result, root.left, K - right - 2); return right + 1; &#125; else return -1;&#125;private void collect(List&lt;Integer&gt; result, TreeNode root, int K) &#123; if (root == null || K &lt; 0) return; if (K == 0) &#123; result.add(root.val); return; &#125; collect(result, root.left, K - 1); collect(result, root.right, K - 1);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 4 - Median of Two Sorted Arrays]]></title>
    <url>%2F2019%2F07%2F26%2FLeetCode-Problem-4-Median-of-Two-Sorted-Arrays%2F</url>
    <content type="text"><![CDATA[There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. ExampleNo.1nums1 = [1, 3]nums2 = [2] The median is 2.0 No.2nums1 = [1, 2]nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 Code1234567891011121314151617181920212223242526272829303132333435public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int n1 = nums1.length; int n2 = nums2.length; if (n1 &gt; n2) return findMedianSortedArrays(nums2, nums1); int k = (n1 + n2 + 1) / 2; int left = 0; int right = n1; while (left &lt; right) &#123; int m1 = left + (right - left) / 2; int m2 = k - m1; if (nums1[m1] &gt; nums2[m2 - 1]) right = m1; else left = m1 + 1; &#125; int m1 = left; int m2 = k - m1; int mid1 = Math.max(m1 &lt;= 0 ? Integer.MIN_VALUE : nums1[m1 - 1], m2 &lt;= 0 ? Integer.MIN_VALUE : nums2[m2 - 1]); if ((n1 + n2) % 2 == 1) return mid1; int mid2 = Math.min(m1 &gt;= n1 ? Integer.MAX_VALUE : nums1[m1], m2 &gt;= n2 ? Integer.MAX_VALUE : nums2[m2]); return (mid1 + mid2) * 0.5;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 480 - Sliding Window Median]]></title>
    <url>%2F2019%2F07%2F25%2FLeetCode-Problem-480-Sliding-Window-Median%2F</url>
    <content type="text"><![CDATA[Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. Examples: [2,3,4] , the median is 3[2,3], the median is (2 + 3) / 2 = 2.5 Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array. For example,Given nums = [1,3,-1,-3,5,3,6,7], and k = 3. 12345678Window position Median--------------- -----[1 3 -1] -3 5 3 6 7 1 1 [3 -1 -3] 5 3 6 7 -1 1 3 [-1 -3 5] 3 6 7 -1 1 3 -1 [-3 5 3] 6 7 3 1 3 -1 -3 [5 3 6] 7 5 1 3 -1 -3 5 [3 6 7] 6 Therefore, return the median sliding window as [1,-1,-1,3,5,6]. NoteYou may assume k is always valid, ie: k is always smaller than input array’s size for non-empty array. Code123456789101112131415161718192021222324252627282930313233343536373839404142public double[] medianSlidingWindow(int[] nums, int k) &#123; if (nums == null || nums.length &lt; 1 || k &lt; 1) return new double[] &#123;&#125;; double[] result = new double[nums.length - k + 1]; Comparator&lt;Integer&gt; comparator = new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return nums[o1] != nums[o2] ? Integer.compare(nums[o1], nums[o2]) : o1 - o2; &#125; &#125;; TreeSet&lt;Integer&gt; low = new TreeSet&lt;&gt;(comparator); TreeSet&lt;Integer&gt; high = new TreeSet&lt;&gt;(comparator); for (int i = 0; i &lt; k; i++) high.add(i); balance(low, high); result[0] = getMedian(nums, low, high, k); for (int i = k; i &lt; nums.length; i++) &#123; if (!low.remove(i - k)) high.remove(i - k); low.add(i); high.add(low.pollLast()); balance(low, high); result[i - k + 1] = getMedian(nums, low, high, k); &#125; return result;&#125;private void balance(TreeSet&lt;Integer&gt; low, TreeSet&lt;Integer&gt; high) &#123; while (high.size() &gt; low.size()) low.add(high.pollFirst());&#125;private double getMedian(int[] nums, TreeSet&lt;Integer&gt; low, TreeSet&lt;Integer&gt; high, int k) &#123; return k % 2 != 0 ? (double) nums[low.last()] : ((double) nums[low.last()] + nums[high.first()]) / 2;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 239 - Sliding Window Maximum]]></title>
    <url>%2F2019%2F07%2F25%2FLeetCode-Problem-239-Sliding-Window-Maximum%2F</url>
    <content type="text"><![CDATA[Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. ExampleInput: nums = [1,3,-1,-3,5,3,6,7], and k = 3 Output: [3,3,5,5,6,7] Explanation: 12345678Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 NoteYou may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array. Follow upCould you solve it in linear time? Code12345678910111213141516171819202122public int[] maxSlidingWindow(int[] nums, int k) &#123; if (nums == null || nums.length &lt; 1 || k &lt; 1) return new int[] &#123;&#125;; int[] result = new int[nums.length - k + 1]; Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; while (!deque.isEmpty() &amp;&amp; nums[i] &gt; nums[deque.peekLast()]) deque.pollLast(); deque.offerLast(i); if (i &gt;= k - 1) result[i - k + 1] = nums[deque.peekFirst()]; if (i - k + 1 &gt;= deque.peekFirst()) deque.pollFirst(); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 57 - Insert Interval]]></title>
    <url>%2F2019%2F07%2F23%2FLeetCode-Problem-57-Insert-Interval%2F</url>
    <content type="text"><![CDATA[Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. ExampleNo.1Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] No.2Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. Code1234567891011121314151617181920public int[][] insert(int[][] intervals, int[] newInterval) &#123; List&lt;int[]&gt; result = new ArrayList&lt;&gt;(); int pos = 0; for (int i = 0; i &lt; intervals.length; i++) &#123; if (intervals[i][1] &lt; newInterval[0]) &#123; result.add(intervals[i]); pos++; &#125; else if (intervals[i][0] &gt; newInterval[1]) result.add(intervals[i]); else &#123; newInterval[0] = Math.min(newInterval[0], intervals[i][0]); newInterval[1] = Math.max(newInterval[1], intervals[i][1]); &#125; &#125; result.add(pos, newInterval); return result.toArray(new int[result.size()][]);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 50 - Pow(x, n)]]></title>
    <url>%2F2019%2F07%2F20%2FLeetCode-Problem-50-Pow-x-n%2F</url>
    <content type="text"><![CDATA[Implement pow(x, n), which calculates x raised to the power n (x^n). ExampleNo.1Input: 2.00000, 10 Output: 1024.00000 No.2Input: 2.10000, 3 Output: 9.26100 No.3Input: 2.00000, -2 Output: 0.25000 Explanation: 2^-2 = 1/2^2 = 1/4 = 0.25 Note -100.0 &lt; x &lt; 100.0 n is a 32-bit signed integer, within the range [−231, 231 − 1] Code123456789101112public double myPow(double x, int n) &#123; return n &gt;= 0 ? pow(x, n) : 1 / pow(x, -n);&#125;private double pow(double x, int n) &#123; if (n == 0) return 1; double result = pow(x, n / 2); return n % 2 == 0 ? result * result : result * result * x;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 342 - Power of Four]]></title>
    <url>%2F2019%2F07%2F20%2FLeetCode-Problem-342-Power-of-Four%2F</url>
    <content type="text"><![CDATA[Given an integer (signed 32 bits), write a function to check whether it is a power of 4. ExampleNo.1Input: 16 Output: true No.2Input: 5 Output: false Follow upCould you solve it without loops/recursion? Code1234567public boolean isPowerOfFour(int num) &#123; if (num &lt;= 0) return false; // 1010101010101010101010101010101 return (num &amp; (num - 1)) == 0 &amp;&amp; (num &amp; 0x55555555) == num;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 326 - Power of Three]]></title>
    <url>%2F2019%2F07%2F20%2FLeetCode-Problem-326-Power-of-Three%2F</url>
    <content type="text"><![CDATA[Given an integer, write a function to determine if it is a power of three. ExampleNo.1Input: 27 Output: true No.2Input: 0 Output: false No.3Input: 9 Output: true No.4Input: 45 Output: false Follow upCould you do it without using any loop / recursion? Code1234567public boolean isPowerOfThree(int n) &#123; if (n &lt;= 0) return false; // 3^19 return 1162261467 % n == 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 231 - Power of Two]]></title>
    <url>%2F2019%2F07%2F20%2FLeetCode-Problem-231-Power-of-Two%2F</url>
    <content type="text"><![CDATA[Given an integer, write a function to determine if it is a power of two. ExampleNo.1Input: 1 Output: true Explanation: 2^0 = 1 No.2Input: 16 Output: true Explanation: 2^4 = 16 No.3Input: 218 Output: false Code123456public boolean isPowerOfTwo(int n) &#123; if (n &lt;= 0) return false; return (n &amp; (n - 1)) == 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 412 - Fizz Buzz]]></title>
    <url>%2F2019%2F07%2F20%2FLeetCode-Problem-412-Fizz-Buzz%2F</url>
    <content type="text"><![CDATA[Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Examplen = 15, Return: 1234567891011121314151617[ "1", "2", "Fizz", "4", "Buzz", "Fizz", "7", "8", "Fizz", "Buzz", "11", "Fizz", "13", "14", "FizzBuzz"] Code123456789101112131415161718192021public List&lt;String&gt; fizzBuzz(int n) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); StringBuilder sb = new StringBuilder(); for (int i = 1; i &lt;= n; i++) &#123; sb.append(getWord(i, 3, "Fizz")); sb.append(getWord(i, 5, "Buzz")); if (sb.length() == 0) sb.append(i); result.add(sb.toString()); sb.setLength(0); &#125; return result;&#125;private String getWord(int n, int div, String word) &#123; return (n % div == 0) ? word : "";&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 509 - Fibonacci Number]]></title>
    <url>%2F2019%2F07%2F20%2FLeetCode-Problem-509-Fibonacci-Number%2F</url>
    <content type="text"><![CDATA[The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), for N &gt; 1. Given N, calculate F(N). ExampleNo.1Input: 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1. No.2Input: 3 Output: 2 Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2. No.3Input: 4 Output: 3 Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3. Note0 ≤ N ≤ 30. Code123456789101112131415public int fib(int N) &#123; if (N &lt; 2) return N; int a = 0; int b = 1; for (int i = 2; i &lt;= N; i++) &#123; int sum = a + b; a = b; b = sum; &#125; return b;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 37 - Sudoku Solver]]></title>
    <url>%2F2019%2F07%2F20%2FLeetCode-Problem-37-Sudoku-Solver%2F</url>
    <content type="text"><![CDATA[Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. Empty cells are indicated by the character ‘.’. A sudoku puzzle… …and its solution numbers marked in red. Note The given board contain only digits 1-9 and the character ‘.’. You may assume that the given Sudoku puzzle will have a single unique solution. The given board size is always 9x9. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private boolean[][] row = new boolean[9][9];private boolean[][] col = new boolean[9][9];private boolean[][] cell = new boolean[9][9];public void solveSudoku(char[][] board) &#123; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] == '.') continue; int num = board[i][j] - '1'; row[i][num] = true; col[j][num] = true; cell[(i / 3) * 3 + (j / 3)][num] = true; &#125; &#125; helper(board, 0);&#125;private boolean helper(char[][] board, int pos) &#123; if (pos == 81) return true; int x = pos / 9; int y = pos % 9; if (board[x][y] != '.') return helper(board, pos + 1); for (int k = 0; k &lt; 9; k++) &#123; int p = (x / 3) * 3 + (y / 3); if (!row[x][k] &amp;&amp; !col[y][k] &amp;&amp; !cell[p][k]) &#123; board[x][y] = (char) (k + 1 + '0'); row[x][k] = true; col[y][k] = true; cell[p][k] = true; if (helper(board, pos + 1)) return true; board[x][y] = '.'; row[x][k] = false; col[y][k] = false; cell[p][k] = false; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 36 - Valid Sudoku]]></title>
    <url>%2F2019%2F07%2F20%2FLeetCode-Problem-36-Valid-Sudoku%2F</url>
    <content type="text"><![CDATA[Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. ExampleNo.1Input: 1234567891011[ ["5","3",".",".","7",".",".",".","."], ["6",".",".","1","9","5",".",".","."], [".","9","8",".",".",".",".","6","."], ["8",".",".",".","6",".",".",".","3"], ["4",".",".","8",".","3",".",".","1"], ["7",".",".",".","2",".",".",".","6"], [".","6",".",".",".",".","2","8","."], [".",".",".","4","1","9",".",".","5"], [".",".",".",".","8",".",".","7","9"]] Output: true No.2Input: 1234567891011[ ["8","3",".",".","7",".",".",".","."], ["6",".",".","1","9","5",".",".","."], [".","9","8",".",".",".",".","6","."], ["8",".",".",".","6",".",".",".","3"], ["4",".",".","8",".","3",".",".","1"], ["7",".",".",".","2",".",".",".","6"], [".","6",".",".",".",".","2","8","."], [".",".",".","4","1","9",".",".","5"], [".",".",".",".","8",".",".","7","9"]] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8’s in the top left 3x3 sub-box, it is invalid. Note A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character ‘.’. The given board size is always 9x9. Code1234567891011121314151617181920212223public boolean isValidSudoku(char[][] board) &#123; boolean[][] row = new boolean[9][9]; boolean[][] col = new boolean[9][9]; boolean[][] cell = new boolean[9][9]; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] == '.') continue; int num = board[i][j] - '1'; if (row[i][num] || col[j][num] || cell[(i / 3) * 3 + (j / 3)][num]) return false; row[i][num] = true; col[j][num] = true; cell[(i / 3) * 3 + (j / 3)][num] = true; &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 794 - Valid Tic-Tac-Toe State]]></title>
    <url>%2F2019%2F07%2F19%2FLeetCode-Problem-794-Valid-Tic-Tac-Toe-State%2F</url>
    <content type="text"><![CDATA[A Tic-Tac-Toe board is given as a string array board. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game. The board is a 3 x 3 array, and consists of characters “ “, “X”, and “O”. The “ “ character represents an empty square. Here are the rules of Tic-Tac-Toe: Players take turns placing characters into empty squares (“ “). The first player always places “X” characters, while the second player always places “O” characters. “X” and “O” characters are always placed into empty squares, never filled ones. The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal. The game also ends if all squares are non-empty. No more moves can be played if the game is over. ExampleNo.1Input: board = [“O “, “ “, “ “] Output: false Explanation: The first player always plays “X”. No.2Input: board = [“XOX”, “ X “, “ “] Output: false Explanation: Players take turns making moves. No.3Input: board = [“XXX”, “ “, “OOO”] Output: false No.4Input: board = [“XOX”, “O O”, “XOX”] Output: true Note board is a length-3 array of strings, where each string board[i] has length 3. Each board[i][j] is a character in the set {“ “, “X”, “O”}. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// X X X// O O _// O _ _public boolean validTicTacToe(String[] board) &#123; int[] xRes = getWin(board, 'X'); int[] oRes = getWin(board, 'O'); int xCount = xRes[0]; int xWin = xRes[1]; int oCount = oRes[0]; int oWin = oRes[1]; if (xCount != oCount &amp;&amp; xCount != oCount + 1) return false; if (xWin &gt; 1 &amp;&amp; oWin &gt; 1) return false; if ((xWin == 1 &amp;&amp; xCount == oCount) || (oWin == 1 &amp;&amp; xCount == oCount + 1)) return false; return true;&#125;private int[] getWin(String[] board, char ch) &#123; int count = 0; int win = 0; char[][] col = new char[3][3]; char[] diag1 = new char[3]; char[] diag2 = new char[3]; char[] pattern = new char[] &#123;ch, ch, ch&#125;; for (int i = 0; i &lt; 3; i++) &#123; diag1[i] = board[i].charAt(i); diag2[i] = board[i].charAt(2 - i); for (int j = 0; j &lt; 3; j++) &#123; if (board[i].charAt(j) == ch) count++; col[j][i] = board[i].charAt(j); &#125; &#125; win += Arrays.equals(diag1, pattern) ? 1 : 0; win += Arrays.equals(diag2, pattern) ? 1 : 0; for (int i = 0; i &lt; 3; i++) &#123; win += Arrays.equals(board[i].toCharArray(), pattern) ? 1 : 0; win += Arrays.equals(col[i], pattern) ? 1 : 0; &#125; return new int[] &#123;count, win&#125;;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 855 - Sentence Similarity II]]></title>
    <url>%2F2019%2F07%2F18%2FLintCode-Problem-855-Sentence-Similarity-II%2F</url>
    <content type="text"><![CDATA[Given two sentences words1, words2 (each represented as an array of strings), and a list of similar word pairs pairs, determine if two sentences are similar. For example, words1 = [“great”, “acting”, “skills”] and words2 = [“fine”, “drama”, “talent”] are similar, if the similar word pairs are pairs = [[“great”, “good”], [“fine”, “good”], [“acting”,”drama”], [“skills”,”talent”]]. Note that the similarity relation is transitive. For example, if “great” and “good” are similar, and “fine” and “good” are similar, then “great” and “fine” are similar. Similarity is also symmetric. For example, “great” and “fine” being similar is the same as “fine” and “great” being similar. Also, a word is always similar with itself. For example, the sentences words1 = [“great”], words2 = [“great”], pairs = [] are similar, even though there are no specified similar word pairs. Finally, sentences can only be similar if they have the same number of words. So a sentence like words1 = [“great”] can never be similar to words2 = [“doubleplus”,”good”]. Note The length of words1 and words2 will not exceed 1000. The length of pairs will not exceed 2000. The length of each pairs[i] will be 2. The length of each words[i] and pairs[i][j] will be in the range [1, 20]. ExampleNo.1Input:[“7”, “5”, “4”, “11”, “13”, “15”, “19”, “12”, “0”, “10”][“16”, “1”, “7”, “3”, “15”, “10”, “13”, “2”, “19”, “8”][[“6”, “18”], [“8”, “17”], [“1”, “13”], [“0”, “8”], [“9”, “14”], [“11”, “17”], [“11”, “19”], [“13”, “16”], [“0”, “18”], [“3”, “11”], [“1”, “9”], [“2”, “11”], [“2”, “4”], [“0”, “19”], [“8”, “12”], [“8”, “19”], [“16”, “19”], [“1”, “11”], [“2”, “18”], [“0”, “16”], [“7”, “11”], [“6”, “8”], [“9”, “17”], [“8”, “16”], [“3”, “13”], [“7”, “9”], [“7”, “10”], [“3”, “6”], [“15”, “19”], [“1”, “5”], [“2”, “14”], [“1”, “18”], [“8”, “15”], [“14”, “19”], [“3”, “17”], [“6”, “10”], [“5”, “17”], [“10”, “15”], [“1”, “10”], [“4”, “6”]] Output:true No.2Input:[“great”,”acting”,”skills”][“fine”,”drama”,”talent”][[“great”,”good”],[“fine”,”good”],[“drama”,”acting”],[“skills”,”talent”]] Output:true Code12345678910111213141516171819202122232425262728293031private Map&lt;String, String&gt; map = new HashMap&lt;&gt;();public boolean areSentencesSimilarTwo(List&lt;String&gt; words1, List&lt;String&gt; words2, List&lt;List&lt;String&gt;&gt; pairs) &#123; if (words1.size() != words2.size()) return false; for (List&lt;String&gt; pair : pairs) &#123; String parent1 = getParent(pair.get(0)); String parent2 = getParent(pair.get(1)); if (!parent1.equals(parent2)) map.put(parent1, parent2); &#125; for (int i = 0; i &lt; words1.size(); i++) &#123; if (words1.get(i).equals(words2.get(i))) continue; if (!getParent(words1.get(i)).equals(getParent(words2.get(i)))) return false; &#125; return true;&#125;private String getParent(String word) &#123; if (!map.containsKey(word)) map.put(word, word); return word.equals(map.get(word)) ? word : getParent(map.get(word));&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 856 - Sentence Similarity]]></title>
    <url>%2F2019%2F07%2F18%2FLintCode-Problem-856-Sentence-Similarity%2F</url>
    <content type="text"><![CDATA[Given two sentences words1, words2 (each represented as an array of strings), and a list of similar word pairs pairs, determine if two sentences are similar. For example, words1 = great acting skills and words2 = fine drama talent are similar, if the similar word pairs are pairs = [[“great”, “fine”], [“acting”,”drama”], [“skills”,”talent”]]. Note that the similarity relation is not transitive. For example, if “great” and “fine” are similar, and “fine” and “good” are similar, “great” and “good” are not necessarily similar. However, similarity is symmetric. For example, “great” and “fine” being similar is the same as “fine” and “great” being similar. Also, a word is always similar with itself. For example, the sentences words1 = [“great”], words2 = [“great”], pairs = [] are similar, even though there are no specified similar word pairs. Finally, sentences can only be similar if they have the same number of words. So a sentence like words1 = [“great”] can never be similar to words2 = [“doubleplus”,”good”]. Note The length of words1 and words2 will not exceed 1000. The length of pairs will not exceed 2000. The length of each pairs[i] will be 2. The length of each words[i] and pairs[i][j] will be in the range [1, 20]. ExampleNo.1Input: words1 = [“great”,”acting”,”skills”], words2 = [“fine”,”drama”,”talent”] and pairs = [[“great”,”fine”],[“drama”,”acting”],[“skills”,”talent”]] Output: true Explanation:“great” is similar with “fine”“acting” is similar with “drama”“skills” is similar with “talent” No.2Input: words1 = [“fine”,”skills”,”acting”], words2 = [“fine”,”drama”,”talent”] and pairs = [[“great”,”fine”],[“drama”,”acting”],[“skills”,”talent”]] Output: false Explanation:“fine” is the same as “fine”“skills” is not similar with “drama”“acting” is not similar with “talent” Code123456789101112131415161718192021222324252627public boolean isSentenceSimilarity(String[] words1, String[] words2, List&lt;List&lt;String&gt;&gt; pairs) &#123; if (words1.length != words2.length) return false; Map&lt;String, Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (List&lt;String&gt; pair : pairs) &#123; map.putIfAbsent(pair.get(0), new HashSet&lt;&gt;()); map.get(pair.get(0)).add(pair.get(1)); map.putIfAbsent(pair.get(1), new HashSet&lt;&gt;()); map.get(pair.get(1)).add(pair.get(0)); &#125; for (int i = 0; i &lt; words1.length; i++) &#123; if (words1[i].equals(words2[i])) continue; if (!map.containsKey(words1[i])) return false; if (!map.get(words1[i]).contains(words2[i])) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 407 - Trapping Rain Water II]]></title>
    <url>%2F2019%2F07%2F18%2FLeetCode-Problem-407-Trapping-Rain-Water-II%2F</url>
    <content type="text"><![CDATA[Given an m x n matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining. NoteBoth m and n are less than 110. The height of each unit cell is greater than 0 and is less than 20,000. ExampleGiven the following 3x6 height map: 12345[ [1,4,3,1,3,2], [3,2,1,3,2,4], [2,3,3,2,3,1]] Return 4. The above image represents the elevation map [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] before the rain. After the rain, water is trapped between the blocks. The total volume of water trapped is 4. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Cell&#123; private int x; private int y; private int h; public Cell(int x, int y, int h) &#123; this.x = x; this.y = y; this.h = h; &#125;&#125;public int trapRainWater(int[][] heightMap) &#123; if (heightMap == null || heightMap.length == 0 || heightMap[0].length == 0) return 0; int result = 0; int m = heightMap.length; int n = heightMap[0].length; boolean[][] visit = new boolean[m][n]; int[][] directions = new int[][] &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; int level = 0; PriorityQueue&lt;Cell&gt; minHeap = new PriorityQueue&lt;&gt;(new Comparator&lt;Cell&gt;() &#123; @Override public int compare(Cell o1, Cell o2) &#123; return o1.h - o2.h; &#125; &#125;); for (int i = 0; i &lt; n; i++) &#123; minHeap.offer(new Cell(0, i, heightMap[0][i])); minHeap.offer(new Cell(m - 1, i, heightMap[m - 1][i])); visit[0][i] = true; visit[m - 1][i] = true; &#125; for (int i = 1; i &lt; m - 1; i++) &#123; minHeap.offer(new Cell(i, 0, heightMap[i][0])); minHeap.offer(new Cell(i, n - 1, heightMap[i][n - 1])); visit[i][0] = true; visit[i][n - 1] = true; &#125; while (!minHeap.isEmpty()) &#123; Cell cell = minHeap.poll(); level = Math.max(level, cell.h); for (int[] direction : directions) &#123; int x = cell.x + direction[0]; int y = cell.y + direction[1]; if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n || visit[x][y]) continue; if (heightMap[x][y] &lt; level) result += level - heightMap[x][y]; visit[x][y] = true; minHeap.offer(new Cell(x, y, heightMap[x][y])); &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 42 - Trapping Rain Water]]></title>
    <url>%2F2019%2F07%2F17%2FLeetCode-Problem-42-Trapping-Rain-Water%2F</url>
    <content type="text"><![CDATA[Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. ExampleInput: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Stack1234567891011121314151617181920public int trap(int[] height) &#123; int result = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; height.length; i++) &#123; while (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123; int low = height[stack.pop()]; if (stack.isEmpty()) break; int high = Math.min(height[i], height[stack.peek()]); result += (high - low) * (i - stack.peek() - 1); &#125; stack.push(i); &#125; return result;&#125; Other123456789101112131415161718192021222324public int trap(int[] height) &#123; int result = 0; int left = 0; int right = height.length - 1; while (left &lt; right) &#123; int h = Math.min(height[left], height[right]); if (height[left] == h) &#123; left++; while (left &lt; right &amp;&amp; height[left] &lt; h) result += h - height[left++]; &#125; else &#123; right--; while (left &lt; right &amp;&amp; height[right] &lt; h) result += h - height[right--]; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 337 - House Robber III]]></title>
    <url>%2F2019%2F07%2F17%2FLeetCode-Problem-337-House-Robber-III%2F</url>
    <content type="text"><![CDATA[The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. ExampleNo.1Input: [3,2,3,null,3,null,1] 12345 3 / \2 3 \ \ 3 1 Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. No.2Input: [3,4,5,1,3,null,1] 12345 3 / \ 4 5 / \ \ 1 3 1 Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617public int rob(TreeNode root) &#123; int[] result = helper(root); return Math.max(result[0], result[1]);&#125;private int[] helper(TreeNode root) &#123; if (root == null) return new int[] &#123;0, 0&#125;; int[] left = helper(root.left); int[] right = helper(root.right); int[] res = new int[2]; res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); res[1] = left[0] + right[0] + root.val; return res;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 514 - Paint Fence]]></title>
    <url>%2F2019%2F07%2F17%2FLintCode-Problem-514-Paint-Fence%2F</url>
    <content type="text"><![CDATA[There is a fence with n posts, each post can be painted with one of the k colors.You have to paint all the posts such that no more than two adjacent fence posts have the same color.Return the total number of ways you can paint the fence. Noten and k are non-negative integers. ExampleNo.1Input: n=3, k=2 Output: 6 Explanation: 1234567 post 1, post 2, post 3way1 0 0 1 way2 0 1 0way3 0 1 1way4 1 0 0way5 1 0 1way6 1 1 0 No.2Input: n=2, k=2 Output: 4 Explanation: 12345 post 1, post 2way1 0 0 way2 0 1 way3 1 0 way4 1 1 Code123456789101112131415161718// dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2]);public int numWays(int n, int k) &#123; int[] dp = new int[4]; dp[0] = 0; dp[1] = k; dp[2] = k * k; if (n &lt;= 2) return dp[n]; for (int i = 2; i &lt;= n; i++) &#123; dp[3] = (k - 1) * (dp[1] + dp[2]); dp[1] = dp[2]; dp[2] = dp[3]; &#125; return dp[3];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 516 - Paint House II]]></title>
    <url>%2F2019%2F07%2F16%2FLintCode-Problem-516-Paint-House-II%2F</url>
    <content type="text"><![CDATA[There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on… Find the minimum cost to paint all houses. NoteAll costs are positive integers. ExampleNo.1Input:costs = [[14,2,11],[11,14,5],[14,3,10]] Output: 10 Explanation:The three house use color [1,2,1] for each house. The total cost is 10. No.2Input:costs = [[5]] Output: 5 Explanation:There is only one color and one house. ChallengeCould you solve it in O(nk)? Code1234567891011121314151617181920212223242526272829public int minCostII(int[][] costs) &#123; int min1 = 0; int min2 = 0; int idx = 0; for (int i = 0; i &lt; costs.length; i++) &#123; int curMin1 = Integer.MAX_VALUE; int curMin2 = Integer.MAX_VALUE; int curIdx = 0; for (int j = 0; j &lt; costs[i].length; j++) &#123; int cost = costs[i][j] + (j == idx ? min2 : min1); if (cost &lt; curMin1) &#123; curMin2 = curMin1; curMin1 = cost; curIdx = j; &#125; else if (cost &lt; curMin2) curMin2 = cost; &#125; min1 = curMin1; min2 = curMin2; idx = curIdx; &#125; return min1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 515 - Paint House]]></title>
    <url>%2F2019%2F07%2F16%2FLintCode-Problem-515-Paint-House%2F</url>
    <content type="text"><![CDATA[There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color, and you need to cost the least. Return the minimum cost. The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on… Find the minimum cost to paint all houses. NoteAll costs are positive integers. ExampleNo.1Input: [[14,2,11],[11,14,5],[14,3,10]] Output: 10 Explanation: blue green blue, 2 + 5 + 3 = 10 No.2Input: [[1,2,3],[1,4,6]] Output: 3 Code1234567891011121314151617// dp[i][j] = dp[i][j] + min(dp[i - 1][(j + 1) % 3], dp[i - 1][(j + 2) % 3]), 1 &lt;= i &lt;= n, 0 &lt;= j &lt;= 2public int minCost(int[][] costs) &#123; int[][] dp = new int[2][3]; int n = costs.length; for (int i = 1; i &lt;= n; i++) &#123; int cur = i % 2; int prev = 1 - cur; for (int j = 0; j &lt; 3; j++) &#123; dp[cur][j] = costs[i - 1][j]; dp[cur][j] += Math.min(dp[prev][(j + 1) % 3] , dp[prev][(j + 2) % 3]); &#125; &#125; return Math.min(Math.min(dp[n % 2][0], dp[n % 2][1]), dp[n % 2][2]);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 229 - Majority Element II]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode-Problem-229-Majority-Element-II%2F</url>
    <content type="text"><![CDATA[Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. NoteThe algorithm should run in linear time and in O(1) space. ExampleNo.1Input: [3,2,3] Output: [3] No.2Input: [1,1,1,3,3,2,2,2] Output: [1,2] Code12345678910111213141516171819202122232425262728293031323334353637383940414243public List&lt;Integer&gt; majorityElement(int[] nums) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int candidate1 = 0; int candidate2 = 0; int count1 = 0; int count2 = 0; for (int num : nums) &#123; if (num == candidate1) count1++; else if (num == candidate2) count2++; else if (count1 == 0) &#123; count1 = 1; candidate1 = num; &#125; else if (count2 == 0) &#123; count2 = 1; candidate2 = num; &#125; else &#123; count1--; count2--; &#125; &#125; count1 = 0; count2 = 0; for (int num : nums) &#123; if (num == candidate1) count1++; else if (num == candidate2) count2++; &#125; if (count1 &gt; nums.length / 3) result.add(candidate1); if (count2 &gt; nums.length / 3) result.add(candidate2); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 169 - Majority Element]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode-Problem-169-Majority-Element%2F</url>
    <content type="text"><![CDATA[Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. ExampleNo.1Input: [3,2,3] Output: 3 No.2Input: [2,2,1,1,1,2,2] Output: 2 Code1234567891011121314151617public int majorityElement(int[] nums) &#123; int result = 0; int count = 0; for (int num : nums) &#123; if (count == 0) &#123; result = num; count = 1; &#125; else if (num != result) count--; else count++; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 901 - Closest Binary Search Tree Value II]]></title>
    <url>%2F2019%2F07%2F16%2FLintCode-Problem-901-Closest-Binary-Search-Tree-Value-II%2F</url>
    <content type="text"><![CDATA[Given a non-empty binary search tree and a target value, find k values in the BST that are closest to the target. Note Given target value is a floating point. You may assume k is always valid, that is: k ≤ total nodes. You are guaranteed to have only one unique set of k values in the BST that are closest to the target. ExampleNo.1Input:{1}0.0000001 Output:[1] Explanation：Binary tree {1}, denote the following structure: 11 No.2Input:{3,1,4,#,2}0.2750002 Output:[1,2] Explanation：Binary tree {3,1,4,#,2}, denote the following structure: 12345 3 / \1 4 \ 2 ChallengeAssume that the BST is balanced, could you solve it in less than O(n) runtime (where n = total nodes)? Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private Stack&lt;TreeNode&gt; predecessor = new Stack&lt;&gt;();private Stack&lt;TreeNode&gt; successor = new Stack&lt;&gt;();public List&lt;Integer&gt; closestKValues(TreeNode root, double target, int k) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); TreeNode node; getStack(root, target); while (k-- &gt; 0) &#123; if (successor.isEmpty() || !predecessor.isEmpty() &amp;&amp; target - predecessor.peek().val &lt; successor.peek().val - target) &#123; node = predecessor.pop(); result.add(node.val); getPredecessor(node); &#125; else &#123; node = successor.pop(); result.add(node.val); getSuccessor(node); &#125; &#125; return result;&#125;private void getStack(TreeNode root, double target) &#123; while (root != null) &#123; if (root.val &lt; target) &#123; predecessor.push(root); root = root.right; &#125; else &#123; successor.push(root); root = root.left; &#125; &#125;&#125;private void getPredecessor(TreeNode root) &#123; if (root.left == null) return; root = root.left; while (root != null) &#123; predecessor.push(root); root = root.right; &#125;&#125;private void getSuccessor(TreeNode root) &#123; if (root.right == null) return; root = root.right; while (root != null) &#123; successor.push(root); root = root.left; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 900 - Closest Binary Search Tree Value]]></title>
    <url>%2F2019%2F07%2F16%2FLintCode-Problem-900-Closest-Binary-Search-Tree-Value%2F</url>
    <content type="text"><![CDATA[Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target. Note Given target value is a floating point. You are guaranteed to have only one unique value in the BST that is closest to the target. ExampleNo.1Input: root = {5,4,9,2,#,8,10} and target = 6.124780 Output: 5 No.2Input: root = {3,2,4,1} and target = 4.142857 Output: 4 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213public int closestValue(TreeNode root, double target) &#123; if (root == null) return 0; int val; if (root.val &gt; target) val = closestValue(root.left, target); else val = closestValue(root.right, target); return Math.abs(root.val - target) &lt; Math.abs(val - target) ? root.val : val;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 45 - Jump Game II]]></title>
    <url>%2F2019%2F07%2F15%2FLeetCode-Problem-45-Jump-Game-II%2F</url>
    <content type="text"><![CDATA[Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. ExampleInput: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. NoteYou can assume that you can always reach the last index. Code12345678910111213141516171819public int jump(int[] nums) &#123; int result = 0; int current = 0; int prev = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (i &gt; prev) &#123; prev = current; result++; if (current &gt;= nums.length - 1) break; &#125; current = Math.max(current, i + nums[i]); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 55 - Jump Game]]></title>
    <url>%2F2019%2F07%2F15%2FLeetCode-Problem-55-Jump-Game%2F</url>
    <content type="text"><![CDATA[Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. ExampleNo.1Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. No.2Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Code123456789101112public boolean canJump(int[] nums) &#123; int distance = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (i &lt;= distance) distance = Math.max(distance, i + nums[i]); else return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 52 - N-Queens II]]></title>
    <url>%2F2019%2F07%2F15%2FLeetCode-Problem-52-N-Queens-II%2F</url>
    <content type="text"><![CDATA[The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle. ExampleInput: 4 Output: 2 Explanation: There are two distinct solutions to the 4-queens puzzle as shown below. 1234567891011[ [".Q..", // Solution 1 "...Q", "Q...", "..Q."], ["..Q.", // Solution 2 "Q...", "...Q", ".Q.."]] Code12345678910111213141516171819202122232425262728293031323334353637383940private boolean[] column;private boolean[] diagonal1;private boolean[] diagonal2;private int result = 0;public int totalNQueens(int n) &#123; column = new boolean[n]; diagonal1 = new boolean[2 * n - 1]; diagonal2 = new boolean[2 * n - 1]; helper(n, 0); return result;&#125;private void helper(int n, int x) &#123; if (x == n) &#123; result++; return; &#125; for (int y = 0; y &lt; n; y++) &#123; if (!isValid(n, x, y)) continue; update(n, x, y, true); helper(n, x + 1); update(n, x, y, false); &#125;&#125;private boolean isValid(int n, int x, int y) &#123; return !column[y] &amp;&amp; !diagonal1[x + y] &amp;&amp; !diagonal2[y - x + n - 1];&#125;private void update(int n, int x, int y, boolean put) &#123; column[y] = put; diagonal1[x + y] = put; diagonal2[y - x + n - 1] = put;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 51 - N-Queens]]></title>
    <url>%2F2019%2F07%2F15%2FLeetCode-Problem-51-N-Queens%2F</url>
    <content type="text"><![CDATA[The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively. ExampleInput: 4 Output: 1234567891011[ [".Q..", // Solution 1 "...Q", "Q...", "..Q."], ["..Q.", // Solution 2 "Q...", "...Q", ".Q.."]] Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private boolean[] column;private boolean[] diagonal1;private boolean[] diagonal2;public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); column = new boolean[n]; diagonal1 = new boolean[2 * n - 1]; diagonal2 = new boolean[2 * n - 1]; char[][] board = new char[n][n]; for (int i = 0; i &lt; n; i++) Arrays.fill(board[i], '.'); helper(result, board, n, 0); return result;&#125;private void helper(List&lt;List&lt;String&gt;&gt; result, char[][] board, int n, int x) &#123; if (x == n) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (char[] row : board) list.add(new String(row)); result.add(list); return; &#125; for (int y = 0; y &lt; n; y++) &#123; if (!isValid(n, x, y)) continue; update(board, n, x, y, true); helper(result, board, n, x + 1); update(board, n, x, y, false); &#125;&#125;private boolean isValid(int n, int x, int y) &#123; return !column[y] &amp;&amp; !diagonal1[x + y] &amp;&amp; !diagonal2[y - x + n - 1];&#125;private void update(char[][] board, int n, int x, int y, boolean put) &#123; column[y] = put; diagonal1[x + y] = put; diagonal2[y - x + n - 1] = put; board[x][y] = put ? 'Q' : '.';&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Builder模式]]></title>
    <url>%2F2019%2F07%2F14%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Builder%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[用于组装具有复杂结构的实例。 示例编写“文档”。编写出的文档具有以下结构： 含有一个标题 含有几个字符串 含有条目项目 类图 Builder类123456public abstract class Builder &#123; public abstract void makeTitle(String title); public abstract void makeString(String str); public abstract void makeItems(String[] items); public abstract void close();&#125; Director类1234567891011121314151617181920212223public class Director &#123; private Builder builder; public Director(Builder builder) &#123; this.builder = builder; &#125; public void construct() &#123; builder.makeTitle("Greeting"); builder.makeString("从早上至下午"); builder.makeItems(new String[]&#123; "早上好。", "下午好。" &#125;); builder.makeString("晚上"); builder.makeItems(new String[]&#123; "晚上好。", "晚安。", "再见。" &#125;); builder.close(); &#125;&#125; TextBuilder类123456789101112131415161718192021222324252627282930313233public class TextBuilder extends Builder &#123; private StringBuffer buffer = new StringBuffer(); @Override public void makeTitle(String title) &#123; buffer.append("==============================\n"); buffer.append("『" + title + "』\n"); buffer.append("\n"); &#125; @Override public void makeString(String str) &#123; buffer.append("■" + str + "\n"); buffer.append("\n"); &#125; @Override public void makeItems(String[] items) &#123; for (int i = 0; i &lt; items.length; i++) buffer.append(" ㆍ" + items[i] + "\n"); buffer.append("\n"); &#125; @Override public void close() &#123; buffer.append("==============================\n"); &#125; public String getResult() &#123; return buffer.toString(); &#125;&#125; HTMLBuilder类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter;public class HTMLBuilder extends Builder &#123; private String filename; private PrintWriter writer; @Override public void makeTitle(String title) &#123; filename = title + ".html"; try &#123; writer = new PrintWriter(new FileWriter(filename)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; writer.println("&lt;html&gt;&lt;head&gt;&lt;title&gt;" + title + "&lt;/title&gt;&lt;/head&gt;&lt;body&gt;"); writer.println("&lt;h1&gt;" + title + "&lt;/h1&gt;"); &#125; @Override public void makeString(String str) &#123; writer.println("&lt;p&gt;" + str + "&lt;/p&gt;"); &#125; @Override public void makeItems(String[] items) &#123; writer.println("&lt;ul&gt;"); for (int i = 0; i &lt; items.length; i++) writer.println("&lt;li&gt;" + items[i] + "&lt;/li&gt;"); writer.println("&lt;/ul&gt;"); &#125; @Override public void close() &#123; writer.println("&lt;/body&gt;&lt;/html&gt;"); writer.close(); &#125; public String getResult() &#123; return filename; &#125;&#125; Main类123456789101112131415161718192021222324252627282930313233public class Main &#123; public static void main(String[] args) &#123; if (args.length != 1) &#123; usage(); System.exit(0); &#125; if (args[0].equals("plain")) &#123; TextBuilder textbuilder = new TextBuilder(); Director director = new Director(textbuilder); director.construct(); String result = textbuilder.getResult(); System.out.println(result); &#125; else if (args[0].equals("html")) &#123; HTMLBuilder htmlbuilder = new HTMLBuilder(); Director director = new Director(htmlbuilder); director.construct(); String filename = htmlbuilder.getResult(); System.out.println(filename + "文件编写完成。"); &#125; else &#123; usage(); System.exit(0); &#125; &#125; public static void usage() &#123; System.out.println("Usage: java Main plain 编写纯文本文档"); System.out.println("Usage: java Main html 编写HTML文档"); &#125;&#125; 运行结果123456789101112131415==============================『Greeting』■从早上至下午 ㆍ早上好。 ㆍ下午好。■晚上 ㆍ晚上好。 ㆍ晚安。 ㆍ再见。============================== 1234567891011121314&lt;html&gt;&lt;head&gt;&lt;title&gt;Greeting&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Greeting&lt;/h1&gt;&lt;p&gt;从早上至下午&lt;/p&gt;&lt;ul&gt;&lt;li&gt;早上好。&lt;/li&gt;&lt;li&gt;下午好。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;晚上&lt;/p&gt;&lt;ul&gt;&lt;li&gt;晚上好。&lt;/li&gt;&lt;li&gt;晚安。&lt;/li&gt;&lt;li&gt;再见。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 登场角色Builder（建造者）Builder角色负责定义用于生成实例的接口（API）。Builder角色中准备了用于生成实例的方法。在示例程序中，由Builder类扮演此角色。 ConcreteBuilder（具体的建造者）ConcreteBuilder角色是负责实现Builder角色的接口的类（API）。这里定义了在生成实例时实际被调用的方法。此外，在ConcreteBuilder角色中还定义了获取最终生成结果的方法。在示例程序中，由TextBuilder类和HTMLBuilder类扮演此角色。 Director（监工）Director角色负责使用Builder角色的接口（API）来生成实例。它并不依赖于ConcreteBuilder角色。为了确保不论ConcreteBuilder角色是如何被定义的，Director角色都能正常工作，它只调用在Builder角色中被定义的方法。在示例程序中，由Director类扮演此角色。 Client（使用者）该角色使用了Builder模式。在示例程序中，由Main类扮演此角色。 类图 时序图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 117 - Populating Next Right Pointers in Each Node II]]></title>
    <url>%2F2019%2F07%2F12%2FLeetCode-Problem-117-Populating-Next-Right-Pointers-in-Each-Node-II%2F</url>
    <content type="text"><![CDATA[Given a binary tree 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Example Input:{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:null,”right”:null,”val”:4},”next”:null,”right”:{“$id”:”4”,”left”:null,”next”:null,”right”:null,”val”:5},”val”:2},”next”:null,”right”:{“$id”:”5”,”left”:null,”next”:null,”right”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:7},”val”:3},”val”:1} Output:{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:{“$id”:”4”,”left”:null,”next”:{“$id”:”5”,”left”:null,”next”:null,”right”:null,”val”:7},”right”:null,”val”:5},”right”:null,”val”:4},”next”:{“$id”:”6”,”left”:null,”next”:null,”right”:{“$ref”:”5”},”val”:3},”right”:{“$ref”:”4”},”val”:2},”next”:null,”right”:{“$ref”:”6”},”val”:1} Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. Note You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. Code12345678910111213public class Node &#123; public int val; public Node left; public Node right; public Node next; public Node(int _val, Node _left, Node _right, Node _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125; 123456789101112131415161718192021222324252627282930public Node connect(Node root) &#123; if (root == null) return null; Node parent = root; Node dummy = new Node(0, null, null, null); Node current = dummy; while (parent != null) &#123; if (parent.left != null) &#123; current.next = parent.left; current = current.next; &#125; if (parent.right != null) &#123; current.next = parent.right; current = current.next; &#125; parent = parent.next; if (parent == null) &#123; parent = dummy.next; dummy.next = null; current = dummy; &#125; &#125; return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 116 - Populating Next Right Pointers in Each Node]]></title>
    <url>%2F2019%2F07%2F12%2FLeetCode-Problem-116-Populating-Next-Right-Pointers-in-Each-Node%2F</url>
    <content type="text"><![CDATA[You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Example Input:{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:null,”right”:null,”val”:4},”next”:null,”right”:{“$id”:”4”,”left”:null,”next”:null,”right”:null,”val”:5},”val”:2},”next”:null,”right”:{“$id”:”5”,”left”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:6},”next”:null,”right”:{“$id”:”7”,”left”:null,”next”:null,”right”:null,”val”:7},”val”:3},”val”:1} Output:{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:{“$id”:”4”,”left”:null,”next”:{“$id”:”5”,”left”:null,”next”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:7},”right”:null,”val”:6},”right”:null,”val”:5},”right”:null,”val”:4},”next”:{“$id”:”7”,”left”:{“$ref”:”5”},”next”:null,”right”:{“$ref”:”6”},”val”:3},”right”:{“$ref”:”4”},”val”:2},”next”:null,”right”:{“$ref”:”7”},”val”:1} Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. Note You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. Code12345678910111213public class Node &#123; public int val; public Node left; public Node right; public Node next; public Node(int _val, Node _left, Node _right, Node _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125; 1234567891011121314151617181920212223public Node connect(Node root) &#123; if (root == null) return null; Node parent = root; while (parent.left != null) &#123; Node current = parent; while (current != null) &#123; current.left.next = current.right; if (current.next != null) current.right.next = current.next.left; current = current.next; &#125; parent = parent.left; &#125; return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 375 - Guess Number Higher or Lower II]]></title>
    <url>%2F2019%2F07%2F10%2FLeetCode-Problem-375-Guess-Number-Higher-or-Lower-II%2F</url>
    <content type="text"><![CDATA[We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I’ll tell you whether the number I picked is higher or lower. However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked. Examplen = 10, I pick 8. First round: You guess 5, I tell you that it’s higher. You pay $5.Second round: You guess 7, I tell you that it’s higher. You pay $7.Third round: You guess 9, I tell you that it’s lower. You pay $9. Game over. 8 is the number I picked. You end up paying $5 + $7 + $9 = $21. Given a particular n ≥ 1, find out how much money you need to have to guarantee a win. Code1234567891011121314151617181920// dp[i][j] = min&#123;k + max&#123;dp[i][k-1], dp[k+1][j]&#125;&#125;, i &lt;= k &lt;= jpublic int getMoneyAmount(int n) &#123; int[][] dp = new int[n+2][n+2]; for (int len = 2; len &lt;= n; len++) &#123; for (int i = 1; i &lt;= n - len + 1; i++) &#123; int j = i + len - 1; int min = Integer.MAX_VALUE; for (int k = i; k &lt;= j; k++) &#123; int max = k + Math.max(dp[i][k-1], dp[k+1][j]); min = Math.min(min, max); &#125; dp[i][j] = min; &#125; &#125; return dp[1][n];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 374 - Guess Number Higher or Lower]]></title>
    <url>%2F2019%2F07%2F10%2FLeetCode-Problem-374-Guess-Number-Higher-or-Lower%2F</url>
    <content type="text"><![CDATA[We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I’ll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): -1 : My number is lower 1 : My number is higher 0 : Congrats! You got it! ExampleInput: n = 10, pick = 6 Output: 6 Code123456789101112131415161718public int guessNumber(int n) &#123; int left = 1; int right = n; while (left &lt; right) &#123; int mid = left + (right - left) / 2; int result = guess(mid); if (result == 0) return mid; else if (result == -1) right = mid - 1; else left = mid + 1; &#125; return left;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 552 - Student Attendance Record II]]></title>
    <url>%2F2019%2F07%2F10%2FLeetCode-Problem-552-Student-Attendance-Record-II%2F</url>
    <content type="text"><![CDATA[Given a positive integer n, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 10^9 + 7. A student attendance record is a string that only contains the following three characters: ‘A’ : Absent. ‘L’ : Late. ‘P’ : Present. A record is regarded as rewardable if it doesn’t contain more than one ‘A’ (absent) or more than two continuous ‘L’ (late). ExampleInput: n = 2 Output: 8 Explanation:There are 8 records with length 2 will be regarded as rewardable:“PP” , “AP”, “PA”, “LP”, “PL”, “AL”, “LA”, “LL”Only “AA” won’t be regarded as rewardable owing to more than one absent times. NoteThe value of n won’t exceed 100,000. Code123456789101112131415161718192021222324// dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3], without A : "...+P", "...P+L", "...PL+L"// dp[i - 1] * dp[n - i], 1 &lt;= i &lt;= n, with A : "...+A+..."// dp[i] + sum&#123;dp[i - 1] * dp[n - i]&#125;public int checkRecord(int n) &#123; int mod = (int) Math.pow(10, 9) + 7; long[] dp = new long[n+1]; dp[0] = 1; dp[1] = 2; if (n &gt; 1) dp[2] = 4; // without A for (int i = 3; i &lt;= n; i++) dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % mod; // with A long result = dp[n]; for (int i = 1; i &lt;= n; i++) result = (dp[i - 1] * dp[n - i] + result) % mod; return (int) result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 551 - Student Attendance Record I]]></title>
    <url>%2F2019%2F07%2F10%2FLeetCode-Problem-551-Student-Attendance-Record-I%2F</url>
    <content type="text"><![CDATA[You are given a string representing an attendance record for a student. The record only contains the following three characters: ‘A’ : Absent. ‘L’ : Late. ‘P’ : Present. A student could be rewarded if his attendance record doesn’t contain more than one ‘A’ (absent) or more than two continuous ‘L’ (late). You need to return whether the student could be rewarded according to his attendance record. ExampleNo.1Input: “PPALLP” Output: True No.2Input: “PPALLL” Output: False Code12345678910111213141516171819public boolean checkRecord(String s) &#123; int countA = 0; int countL = 0; for (char ch : s.toCharArray()) &#123; if (ch == 'A') countA++; if (ch == 'L') countL++; else countL = 0; if (countA &gt; 1 || countL &gt; 2) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 350 - Intersection of Two Arrays II]]></title>
    <url>%2F2019%2F07%2F10%2FLeetCode-Problem-350-Intersection-of-Two-Arrays-II%2F</url>
    <content type="text"><![CDATA[Given two arrays, write a function to compute their intersection. ExampleNo.1Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] No.2Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Note Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Follow up What if the given array is already sorted? How would you optimize your algorithm? What if nums1’s size is small compared to nums2’s size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? Code123456789101112131415161718192021public int[] intersect(int[] nums1, int[] nums2) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int num : nums1) map.put(num, map.getOrDefault(num, 0) + 1); for (int num : nums2) &#123; if (map.containsKey(num) &amp;&amp; map.get(num) &gt; 0) &#123; map.put(num, map.get(num) - 1); list.add(num); &#125; &#125; int[] result = new int[list.size()]; for (int i = 0; i &lt; result.length; i++) result[i] = list.get(i); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 349 - Intersection of Two Arrays]]></title>
    <url>%2F2019%2F07%2F10%2FLeetCode-Problem-349-Intersection-of-Two-Arrays%2F</url>
    <content type="text"><![CDATA[Given two arrays, write a function to compute their intersection. ExampleNo.1Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2] No.2Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4] Note Each element in the result must be unique. The result can be in any order. Code12345678910111213141516171819202122public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int num : nums1) set.add(num); for (int num : nums2) &#123; if (!set.contains(num)) continue; list.add(num); set.remove(num); &#125; int[] result = new int[list.size()]; for (int i = 0; i &lt; result.length; i++) result[i] = list.get(i); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 685 - Redundant Connection II]]></title>
    <url>%2F2019%2F07%2F06%2FLeetCode-Problem-685-Redundant-Connection-II%2F</url>
    <content type="text"><![CDATA[In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents. The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, …, N), with one additional directed edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed. The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] that represents a directed edge connecting nodes u and v, where u is a parent of child v. Return an edge that can be removed so that the resulting graph is a rooted tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. ExampleNo.1Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given directed graph will be like this: 1234 1 / \v v2--&gt;3 No.2Input: [[1,2], [2,3], [3,4], [4,1], [1,5]] Output: [4,1] Explanation: The given directed graph will be like this: 12345 &lt;- 1 -&gt; 2 ^ | | v 4 &lt;- 3 Note The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class UnionFind&#123; private int[] id; private int[] size; public UnionFind(int n) &#123; this.id = new int[n+1]; this.size = new int[n+1]; for (int i = 1; i &lt;= n; i++) &#123; id[i] = i; size[i] = 1; &#125; &#125; public boolean union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return false; if (size[pRoot] &lt; size[qRoot]) &#123; id[pRoot] = qRoot; size[qRoot] += size[pRoot]; &#125; else &#123; id[qRoot] = pRoot; size[pRoot] += size[qRoot]; &#125; return true; &#125; public int find(int p) &#123; while (p != id[p]) p = id[p]; return p; &#125;&#125;public int[] findRedundantDirectedConnection(int[][] edges) &#123; int[] candidate1 = new int[2]; int[] candidate2 = new int[2]; int[] parent = new int[edges.length+1]; for (int[] edge : edges) &#123; int u = edge[0]; int v = edge[1]; if (parent[v] &gt; 0) &#123; candidate1 = new int[] &#123;parent[v], v&#125;; candidate2 = new int[] &#123;u, v&#125;; edge[0] = 0; edge[1] = 0; &#125; else parent[v] = u; &#125; UnionFind uf = new UnionFind(edges.length); for (int[] edge : edges) &#123; int u = edge[0]; int v = edge[1]; if (v == 0 || u == 0) continue; if (!uf.union(u, v)) return candidate1[0] == 0 ? new int[] &#123;u, v&#125; : candidate1; &#125; return candidate2;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 684 - Redundant Connection]]></title>
    <url>%2F2019%2F07%2F06%2FLeetCode-Problem-684-Redundant-Connection%2F</url>
    <content type="text"><![CDATA[In this problem, a tree is an undirected graph that is connected and has no cycles. The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, …, N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed. The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] with u &lt; v, that represents an undirected edge connecting nodes u and v. Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u &lt; v. ExampleNo.1Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given undirected graph will be like this: 123 1 / \2 - 3 No.2Input: [[1,2], [2,3], [3,4], [1,4], [1,5]] Output: [1,4] Explanation: The given undirected graph will be like this: 1235 - 1 - 2 | | 4 - 3 Note The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class UnionFind&#123; private int[] id; private int[] size; public UnionFind(int n) &#123; this.id = new int[n+1]; this.size = new int[n+1]; for (int i = 1; i &lt;= n; i++) &#123; id[i] = i; size[i] = 1; &#125; &#125; public boolean union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return false; if (size[pRoot] &lt; size[qRoot]) &#123; id[pRoot] = qRoot; size[qRoot] += size[pRoot]; &#125; else &#123; id[qRoot] = pRoot; size[pRoot] += size[qRoot]; &#125; return true; &#125; public int find(int p) &#123; while (p != id[p]) p = id[p]; return p; &#125;&#125;public int[] findRedundantConnection(int[][] edges) &#123; UnionFind uf = new UnionFind(edges.length); for (int[] edge : edges) &#123; if (!uf.union(edge[0], edge[1])) return edge; &#125; return null;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 547 - Friend Circles]]></title>
    <url>%2F2019%2F07%2F06%2FLeetCode-Problem-547-Friend-Circles%2F</url>
    <content type="text"><![CDATA[There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends. Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students. ExampleNo.1Input:[[1,1,0], [1,1,0], [0,0,1]] Output: 2 Explanation:The 0th and 1st students are direct friends, so they are in a friend circle.The 2nd student himself is in a friend circle. So return 2. No.2Input:[[1,1,0], [1,1,1], [0,1,1]] Output: 1 Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends,so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1. Note N is in range [1,200]. M[i][i] = 1 for all students. If M[i][j] = 1, then M[j][i] = 1. Code1234567891011121314151617181920212223242526public int findCircleNum(int[][] M) &#123; int result = 0; int n = M.length; boolean[] visit = new boolean[n]; for (int i = 0; i &lt; n; i++) &#123; if (!visit[i]) &#123; dfs(M, visit, n, i); result++; &#125; &#125; return result;&#125;private void dfs(int[][] M, boolean[] visit, int n, int x) &#123; if (visit[x]) return; visit[x] = true; for (int i = 0; i &lt; n; i++) &#123; if (!visit[i] &amp;&amp; M[x][i] == 1) dfs(M, visit, n, i); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 841 - Keys and Rooms]]></title>
    <url>%2F2019%2F07%2F05%2FLeetCode-Problem-841-Keys-and-Rooms%2F</url>
    <content type="text"><![CDATA[There are N rooms and you start in room 0. Each room has a distinct number in 0, 1, 2, …, N-1, and each room may have some keys to access the next room. Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, …, N-1] where N = rooms.length. A key rooms[i][j] = v opens the room with number v. Initially, all the rooms start locked (except for room 0). You can walk back and forth between rooms freely. Return true if and only if you can enter every room. ExampleNo.1Input: [[1],[2],[3],[]] Output: true Explanation:We start in room 0, and pick up key 1.We then go to room 1, and pick up key 2.We then go to room 2, and pick up key 3.We then go to room 3. Since we were able to go to every room, we return true. No.2Input: [[1,3],[3,0,1],[2],[0]] Output: false Explanation: We can’t enter the room with number 2. Note 1 &lt;= rooms.length &lt;= 1000 0 &lt;= rooms[i].length &lt;= 1000 The number of keys in all rooms combined is at most 3000. Code123456789101112131415public boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) &#123; Set&lt;Integer&gt; visit = new HashSet&lt;&gt;(); dfs(visit, rooms, 0); return visit.size() == rooms.size();&#125;private void dfs(Set&lt;Integer&gt; visit, List&lt;List&lt;Integer&gt;&gt; rooms, int door) &#123; if (visit.contains(door)) return; visit.add(door); for (int key : rooms.get(door)) dfs(visit, rooms, key);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 934 - Shortest Bridge]]></title>
    <url>%2F2019%2F07%2F05%2FLeetCode-Problem-934-Shortest-Bridge%2F</url>
    <content type="text"><![CDATA[In a given 2D binary array A, there are two islands. (An island is a 4-directionally connected group of 1s not connected to any other 1s.) Now, we may change 0s to 1s so as to connect the two islands together to form 1 island. Return the smallest number of 0s that must be flipped. (It is guaranteed that the answer is at least 1.) ExampleNo.1Input: [[0,1],[1,0]] Output: 1 No.2Input: [[0,1,0],[0,0,0],[0,0,1]] Output: 2 No.3Input: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] Output: 1 Note 1 &lt;= A.length = A[0].length &lt;= 100 A[i][j] == 0 or A[i][j] == 1 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public int shortestBridge(int[][] A) &#123; int result = 0; int m = A.length; int n = A[0].length; int[][] directions = new int[][] &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); findIsland: for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (A[i][j] == 1) &#123; dfs(queue, A, i, j, m, n); break findIsland; &#125; &#125; &#125; while (!queue.isEmpty()) &#123; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; int[] pos = queue.poll(); for (int[] direction : directions) &#123; int x = pos[0] + direction[0]; int y = pos[1] + direction[1]; if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n || A[x][y] == 2) continue; if (A[x][y] == 1) return result; A[x][y] = 2; queue.offer(new int[] &#123;x, y&#125;); &#125; &#125; result++; &#125; return -1;&#125;private void dfs(Queue&lt;int[]&gt; queue, int[][] A, int x, int y, int m, int n) &#123; if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n || A[x][y] != 1) return; queue.offer(new int[] &#123;x, y&#125;); A[x][y] = 2; dfs(queue, A, x + 1, y, m, n); dfs(queue, A, x - 1, y, m, n); dfs(queue, A, x, y + 1, m, n); dfs(queue, A, x, y - 1, m, n);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 909 - Snakes and Ladders]]></title>
    <url>%2F2019%2F07%2F05%2FLeetCode-Problem-909-Snakes-and-Ladders%2F</url>
    <content type="text"><![CDATA[On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row. For example, for a 6 x 6 board, the numbers are written as follows: You start on square 1 of the board (which is always in the last row and first column). Each move, starting from square x, consists of the following: You choose a destination square S with number x+1, x+2, x+3, x+4, x+5, or x+6, provided this number is &lt;= N*N.(This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations, regardless of the size of the board.) If S has a snake or ladder, you move to the destination of that snake or ladder. Otherwise, you move to S. A board square on row r and column c has a “snake or ladder” if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Note that you only take a snake or ladder at most once per move: if the destination to a snake or ladder is the start of another snake or ladder, you do not continue moving. (For example, if the board is [[4,-1],[-1,3]], and on the first move your destination square is 2, then you finish your first move at 3, because you do not continue moving to 4.) Return the least number of moves required to reach square N*N. If it is not possible, return -1. ExampleInput: [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]] Output: 4 Explanation:At the beginning, you start at square 1 [at row 5, column 0].You decide to move to square 2, and must take the ladder to square 15.You then decide to move to square 17 (row 3, column 5), and must take the snake to square 13.You then decide to move to square 14, and must take the ladder to square 35.You then decide to move to square 36, ending the game.It can be shown that you need at least 4 moves to reach the N*N-th square, so the answer is 4. Note 2 &lt;= board.length = board[0].length &lt;= 20 board[i][j] is between 1 and N*N or is equal to -1. The board square with number 1 has no snake or ladder. The board square with number N*N has no snake or ladder. Code12345678910111213141516171819202122232425262728293031323334353637383940414243public int snakesAndLadders(int[][] board) &#123; int result = 0; int n = board.length; boolean[] visit = new boolean[n * n + 1]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.offer(1); visit[1] = true; while (!queue.isEmpty()) &#123; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; int s = queue.poll(); if (s == n * n) return result; for (int x = s + 1; x &lt;= s + 6 &amp;&amp; x &lt;= n * n; x++) &#123; int[] pos = getPosition(n, x); int newX = (board[pos[0]][pos[1]] == -1) ? x : board[pos[0]][pos[1]]; if (visit[newX]) continue; queue.offer(newX); visit[newX] = true; &#125; &#125; result++; &#125; return -1;&#125;private int[] getPosition(int n, int s)&#123; int quot = (s - 1) / n; int rem = (s - 1) % n; int x = n - 1 - quot; int y = ((quot + 1) % 2 == 0) ? n - 1 - rem : rem; return new int[] &#123;x, y&#125;;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 864 - Shortest Path to Get All Keys]]></title>
    <url>%2F2019%2F07%2F05%2FLeetCode-Problem-864-Shortest-Path-to-Get-All-Keys%2F</url>
    <content type="text"><![CDATA[We are given a 2-dimensional grid. “.” is an empty cell, “#” is a wall, “@” is the starting point, (“a”, “b”, …) are keys, and (“A”, “B”, …) are locks. We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions. We cannot walk outside the grid, or walk into a wall. If we walk over a key, we pick it up. We can’t walk over a lock unless we have the corresponding key. For some 1 &lt;= K &lt;= 6, there is exactly one lowercase and one uppercase letter of the first K letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet. Return the lowest number of moves to acquire all keys. If it’s impossible, return -1. ExampleNo.1Input: [“@.a.#”,”###.#”,”b.A.B”] Output: 8 No.2Input: [“@..aA”,”..B#.”,”….b”] Output: 6 Note 1 &lt;= grid.length &lt;= 30 1 &lt;= grid[0].length &lt;= 30 grid[i][j] contains only ‘.’, ‘#’, ‘@’, ‘a’-‘f’ and ‘A’-‘F’ The number of keys is in [1, 6]. Each key has a different letter and opens exactly one lock. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public int shortestPathAllKeys(String[] grid) &#123; int result = 0; int target = 0; int m = grid.length; int n = grid[0].length(); int[][] directions = new int[][] &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; boolean[][][] visit = new boolean[m][n][64]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; char ch = grid[i].charAt(j); if (ch == '@') &#123; queue.offer((i &lt;&lt; 16) | (j &lt;&lt; 8)); visit[i][j][0] = true; &#125; else if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f') target |= (1 &lt;&lt; (ch - 'a')); &#125; &#125; while (!queue.isEmpty()) &#123; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; int state = queue.poll(); int posX = state &gt;&gt; 16; int posY = (state &gt;&gt; 8) &amp; 255; int key = state &amp; 255; if (key == target) return result; for (int[] direction : directions) &#123; int x = posX + direction[0]; int y = posY + direction[1]; if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n) continue; char ch = grid[x].charAt(y); if (ch == '#') continue; // no key if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F' &amp;&amp; ((key &gt;&gt; (ch - 'A')) &amp; 1) == 0) continue; int newKey = key; if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f') newKey |= (1 &lt;&lt; (ch - 'a')); if (visit[x][y][newKey]) continue; // 000xxxxx 000yyyyy 00kkkkkk queue.offer((x &lt;&lt; 16) | (y &lt;&lt; 8) | newKey); visit[x][y][newKey] = true; &#125; &#125; result++; &#125; return -1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 847 - Shortest Path Visiting All Nodes]]></title>
    <url>%2F2019%2F07%2F05%2FLeetCode-Problem-847-Shortest-Path-Visiting-All-Nodes%2F</url>
    <content type="text"><![CDATA[An undirected, connected graph of N nodes (labeled 0, 1, 2, …, N-1) is given as graph. graph.length = N, and j != i is in the list graph[i] exactly once, if and only if nodes i and j are connected. Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges. ExampleNo.1Input: [[1,2,3],[0],[0],[0]] Output: 4 Explanation: One possible path is [1,0,2,0,3] No.2Input: [[1],[0,2,4],[1,3,4],[2],[1,2]] Output: 4 Explanation: One possible path is [0,1,4,2,3] Note 1 &lt;= graph.length &lt;= 12 0 &lt;= graph[i].length &lt; graph.length Code123456789101112131415161718192021222324252627282930313233343536373839404142434445public class State&#123; private int currentNode; private int visitedNode; public State(int currentNode, int visitedNode) &#123; this.currentNode = currentNode; this.visitedNode = visitedNode; &#125;&#125;public int shortestPathLength(int[][] graph) &#123; int result = 0; int n = graph.length; int target = (1 &lt;&lt; n) - 1; boolean[][] visit = new boolean[n][1 &lt;&lt; n]; Queue&lt;State&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) queue.offer(new State(i, 1 &lt;&lt; i)); while (!queue.isEmpty()) &#123; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; State state = queue.poll(); if (state.visitedNode == target) return result; for (int nextNode : graph[state.currentNode]) &#123; int nextVisitedNode = state.visitedNode | 1 &lt;&lt; nextNode; if (visit[nextNode][nextVisitedNode]) continue; visit[nextNode][nextVisitedNode] = true; queue.offer(new State(nextNode, nextVisitedNode)); &#125; &#125; result++; &#125; return -1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 815 - Bus Routes]]></title>
    <url>%2F2019%2F07%2F03%2FLeetCode-Problem-815-Bus-Routes%2F</url>
    <content type="text"><![CDATA[We have a list of bus routes. Each routes[i] is a bus route that the i-th bus repeats forever. For example if routes[0] = [1, 5, 7], this means that the first bus (0-th indexed) travels in the sequence 1-&gt;5-&gt;7-&gt;1-&gt;5-&gt;7-&gt;1-&gt;… forever. We start at bus stop S (initially not on a bus), and we want to go to bus stop T. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible. ExampleInput:routes = [[1, 2, 7], [3, 6, 7]]S = 1T = 6 Output: 2 Explanation:The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6. Note 1 &lt;= routes.length &lt;= 500. 1 &lt;= routes[i].length &lt;= 500. 0 &lt;= routes[i][j] &lt; 10 ^ 6. Code123456789101112131415161718192021222324252627282930313233343536373839404142public int numBusesToDestination(int[][] routes, int S, int T) &#123; if (S == T) return 0; int result = 0; Map&lt;Integer, List&lt;Integer&gt;&gt; buses = new HashMap&lt;&gt;(); Set&lt;Integer&gt; visit = new HashSet&lt;&gt;(); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.offer(S); for (int i = 0; i &lt; routes.length; i++) &#123; for (int stop : routes[i]) &#123; buses.putIfAbsent(stop, new ArrayList&lt;&gt;()); buses.get(stop).add(i); &#125; &#125; while (!queue.isEmpty()) &#123; int size = queue.size(); result++; for (int i = 0; i &lt; size; i++) &#123; int currentStop = queue.poll(); for (int bus : buses.get(currentStop)) &#123; if (visit.contains(bus)) continue; visit.add(bus); for (int stop : routes[bus]) &#123; if (stop == T) return result; queue.offer(stop); &#125; &#125; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 787 - Cheapest Flights Within K Stops]]></title>
    <url>%2F2019%2F07%2F02%2FLeetCode-Problem-787-Cheapest-Flights-Within-K-Stops%2F</url>
    <content type="text"><![CDATA[There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w. Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1. ExampleNo.1Input:n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]src = 0, dst = 2, k = 1 Output: 200 Explanation:The graph looks like this: The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture. No.2Input:n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]src = 0, dst = 2, k = 0 Output: 500 Explanation:The graph looks like this: The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture. Note The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1. The size of flights will be in range [0, n * (n - 1) / 2]. The format of each flight will be (src, dst, price). The price of each flight will be in the range [1, 10000]. k is in the range of [0, n - 1]. There will not be any duplicated flights or self cycles. Code12345678910111213141516171819202122232425262728293031323334353637public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) &#123; List&lt;int[]&gt;[] graph = new List[n]; int[] distance = new int[n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); Arrays.fill(distance, Integer.MAX_VALUE); distance[src] = 0; queue.offer(new int[] &#123;src, 0&#125;); for (int i = 0; i &lt; n; i++) graph[i] = new ArrayList&lt;&gt;(); for (int[] flight : flights) graph[flight[0]].add(new int[] &#123;flight[1], flight[2]&#125;); while (!queue.isEmpty() &amp;&amp; K &gt;= 0) &#123; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; int[] from = queue.poll(); int u = from[0]; for (int[] to : graph[u]) &#123; int v = to[0]; if (distance[v] &gt; from[1] + to[1]) &#123; distance[v] = from[1] + to[1]; queue.offer(new int[] &#123;v, distance[v]&#125;); &#125; &#125; &#125; K--; &#125; return distance[dst] == Integer.MAX_VALUE ? -1 : distance[dst];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 785 - Is Graph Bipartite?]]></title>
    <url>%2F2019%2F07%2F02%2FLeetCode-Problem-785-Is-Graph-Bipartite%2F</url>
    <content type="text"><![CDATA[Given an undirected graph, return true if and only if it is bipartite. Recall that a graph is bipartite if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B. The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists. Each node is an integer between 0 and graph.length - 1. There are no self edges or parallel edges: graph[i] does not contain i, and it doesn’t contain any element twice. ExampleNo.1Input: [[1,3], [0,2], [1,3], [0,2]] Output: true Explanation:The graph looks like this: 12340----1| || |3----2 We can divide the vertices into two groups: {0, 2} and {1, 3}. No.2Input: [[1,2,3], [0,2], [0,1,3], [0,2]] Output: false Explanation:The graph looks like this: 12340----1| \ || \ |3----2 We cannot find a way to divide the set of nodes into two independent subsets. Note graph will have length in range [1, 100]. graph[i] will contain integers in range [0, graph.length - 1]. graph[i] will not contain i or duplicate values. The graph is undirected: if any element j is in graph[i], then i will be in graph[j]. Code1234567891011121314151617181920212223242526public boolean isBipartite(int[][] graph) &#123; int[] color = new int[graph.length]; for (int i = 0; i &lt; color.length; i++) &#123; if (color[i] == 0) &#123; if (!dfs(graph, color, i, 1)) return false; &#125; &#125; return true;&#125;private boolean dfs(int[][] graph, int[] color, int s, int c) &#123; if (color[s] != 0) return color[s] == c; color[s] = c; for (int neighbor : graph[s]) &#123; if (!dfs(graph, color, neighbor, -c)) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 529 - Minesweeper]]></title>
    <url>%2F2019%2F07%2F01%2FLeetCode-Problem-529-Minesweeper%2F</url>
    <content type="text"><![CDATA[Let’s play the minesweeper game! You are given a 2D char matrix representing the game board. ‘M’ represents an unrevealed mine, ‘E’ represents an unrevealed empty square, ‘B’ represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit (‘1’ to ‘8’) represents how many mines are adjacent to this revealed square, and finally ‘X’ represents a revealed mine. Now given the next click position (row and column indices) among all the unrevealed squares (‘M’ or ‘E’), return the board after revealing this position according to the following rules: If a mine (‘M’) is revealed, then the game is over - change it to ‘X’. If an empty square (‘E’) with no adjacent mines is revealed, then change it to revealed blank (‘B’) and all of its adjacent unrevealed squares should be revealed recursively. If an empty square (‘E’) with at least one adjacent mine is revealed, then change it to a digit (‘1’ to ‘8’) representing the number of adjacent mines. Return the board when no more squares will be revealed. ExampleNo.1Input: [[‘E’, ‘E’, ‘E’, ‘E’, ‘E’], [‘E’, ‘E’, ‘M’, ‘E’, ‘E’], [‘E’, ‘E’, ‘E’, ‘E’, ‘E’], [‘E’, ‘E’, ‘E’, ‘E’, ‘E’]] Click : [3,0] Output: [[‘B’, ‘1’, ‘E’, ‘1’, ‘B’], [‘B’, ‘1’, ‘M’, ‘1’, ‘B’], [‘B’, ‘1’, ‘1’, ‘1’, ‘B’], [‘B’, ‘B’, ‘B’, ‘B’, ‘B’]] Explanation: No.2Input: [[‘B’, ‘1’, ‘E’, ‘1’, ‘B’], [‘B’, ‘1’, ‘M’, ‘1’, ‘B’], [‘B’, ‘1’, ‘1’, ‘1’, ‘B’], [‘B’, ‘B’, ‘B’, ‘B’, ‘B’]] Click : [1,2] Output: [[‘B’, ‘1’, ‘E’, ‘1’, ‘B’], [‘B’, ‘1’, ‘X’, ‘1’, ‘B’], [‘B’, ‘1’, ‘1’, ‘1’, ‘B’], [‘B’, ‘B’, ‘B’, ‘B’, ‘B’]] Explanation: Note The range of the input matrix’s height and width is [1,50]. The click position will only be an unrevealed square (‘M’ or ‘E’), which also means the input board contains at least one clickable square. The input board won’t be a stage when game is over (some mines have been revealed). For simplicity, not mentioned rules should be ignored in this problem. For example, you don’t need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344public char[][] updateBoard(char[][] board, int[] click) &#123; int m = board.length; int n = board[0].length; if (board[click[0]][click[1]] == 'M') board[click[0]][click[1]] = 'X'; else &#123; int count = 0; for (int i = -1; i &lt;= 1; i++) &#123; for (int j = -1; j &lt;= 1; j++) &#123; int x = click[0] + i; int y = click[1] + j; if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n) continue; if (board[x][y] == 'M') count++; &#125; &#125; if (count &gt; 0) board[click[0]][click[1]] = (char) (count + '0'); else &#123; board[click[0]][click[1]] = 'B'; for (int i = -1; i &lt;= 1; i++) &#123; for (int j = -1; j &lt;= 1; j++) &#123; int x = click[0] + i; int y = click[1] + j; if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n) continue; if (board[x][y] == 'E') updateBoard(board, new int[] &#123;x, y&#125;); &#125; &#125; &#125; &#125; return board;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 752 - Open the Lock]]></title>
    <url>%2F2019%2F07%2F01%2FLeetCode-Problem-752-Open-the-Lock%2F</url>
    <content type="text"><![CDATA[You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’. The wheels can rotate freely and wrap around: for example we can turn ‘9’ to be ‘0’, or ‘0’ to be ‘9’. Each move consists of turning one wheel one slot. The lock initially starts at ‘0000’, a string representing the state of the 4 wheels. You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it. Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible. ExampleNo.1Input: deadends = [“0201”,”0101”,”0102”,”1212”,”2002”], target = “0202” Output: 6 Explanation:A sequence of valid moves would be “0000” -&gt; “1000” -&gt; “1100” -&gt; “1200” -&gt; “1201” -&gt; “1202” -&gt; “0202”.Note that a sequence like “0000” -&gt; “0001” -&gt; “0002” -&gt; “0102” -&gt; “0202” would be invalid, because the wheels of the lock become stuck after the display becomes the dead end “0102”. No.2Input: deadends = [“8888”], target = “0009” Output: 1 Explanation:We can turn the last wheel in reverse to move from “0000” -&gt; “0009”. No.3:Input: deadends = [“8887”,”8889”,”8878”,”8898”,”8788”,”8988”,”7888”,”9888”], target = “8888” Output: -1 Explanation:We can’t reach the target without getting stuck. No.4Input: deadends = [“0000”], target = “8888” Output: -1 ##Note The length of deadends will be in the range [1, 500]. target will not be in the list deadends. Every string in deadends and the string target will be a string of 4 digits from the 10,000 possibilities ‘0000’ to ‘9999’. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public int openLock(String[] deadends, String target) &#123; int result = 0; String start = "0000"; Set&lt;String&gt; dict = new HashSet&lt;&gt;(); Set&lt;String&gt; visit = new HashSet&lt;&gt;(); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); visit.add(start); queue.offer(start); for (String deadend : deadends) dict.add(deadend); if (dict.contains(start)) return -1; while (!queue.isEmpty()) &#123; int size = queue.size(); result++; for (int i = 0; i &lt; size; i++) &#123; char[] str = queue.poll().toCharArray(); for (int j = 0; j &lt; 4; j++) &#123; char ch = str[j]; str[j] = (ch == '9') ? '0' : (char) (ch + 1); String newStr1 = String.valueOf(str); str[j] = (ch == '0') ? '9' : (char) (ch - 1); String newStr2 = String.valueOf(str); str[j] = ch; if (newStr1.equals(target) || newStr2.equals(target)) return result; if (!visit.contains(newStr1) &amp;&amp; !dict.contains(newStr1)) &#123; queue.offer(newStr1); visit.add(newStr1); &#125; if (!visit.contains(newStr2) &amp;&amp; !dict.contains(newStr2)) &#123; queue.offer(newStr2); visit.add(newStr2); &#125; &#125; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 743 - Network Delay Time]]></title>
    <url>%2F2019%2F07%2F01%2FLeetCode-Problem-743-Network-Delay-Time%2F</url>
    <content type="text"><![CDATA[There are N network nodes, labelled 1 to N. Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target. Now, we send a signal from a certain node K. How long will it take for all nodes to receive the signal? If it is impossible, return -1. Example Input: times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2 Output: 2 Note N will be in the range [1, 100]. K will be in the range [1, N]. The length of times will be in the range [1, 6000]. All edges times[i] = (u, v, w) will have 1 &lt;= u, v &lt;= N and 0 &lt;= w &lt;= 100. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445public int networkDelayTime(int[][] times, int N, int K) &#123; int result = 0; List&lt;int[]&gt;[] graph = new List[N+1]; int[] distance = new int[N+1]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); Arrays.fill(distance, Integer.MAX_VALUE); distance[K] = 0; queue.offer(K); for (int i = 0; i &lt;= N; i++) graph[i] = new ArrayList&lt;&gt;(); for (int[] time : times) graph[time[0]].add(new int[] &#123;time[1], time[2]&#125;); while (!queue.isEmpty()) &#123; int u = queue.poll(); Set&lt;Integer&gt; visit = new HashSet&lt;&gt;(); for (int[] edge : graph[u]) &#123; int v = edge[0]; int w = edge[1]; if (distance[u] != Integer.MAX_VALUE &amp;&amp; distance[v] &gt; distance[u] + w) &#123; distance[v] = distance[u] + w; if (visit.contains(v)) continue; queue.offer(v); visit.add(v); &#125; &#125; &#125; for (int i = 1; i &lt;= N; i++) &#123; if (distance[i] == Integer.MAX_VALUE) return -1; result = Math.max(result, distance[i]); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 690 - Employee Importance]]></title>
    <url>%2F2019%2F06%2F29%2FLeetCode-Problem-690-Employee-Importance%2F</url>
    <content type="text"><![CDATA[You are given a data structure of employee information, which includes the employee’s unique id, his importance value and his direct subordinates’ id. For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct. Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates. ExampleInput: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 Output: 11 Explanation:Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11. Note One employee has at most one direct leader and may have several subordinates. The maximum number of employees won’t exceed 2000. Code12345public class Employee &#123; public int id; public int importance; public List&lt;Integer&gt; subordinates;&#125; 1234567891011121314151617181920public int getImportance(List&lt;Employee&gt; employees, int id) &#123; int result = 0; Map&lt;Integer, Employee&gt; map = new HashMap&lt;&gt;(); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.offer(id); for (Employee employee : employees) map.put(employee.id, employee); while (!queue.isEmpty()) &#123; Integer employeeId = queue.poll(); Employee employee = map.get(employeeId); result += employee.importance; for (Integer subordinate : employee.subordinates) queue.offer(subordinate); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 542 - 01 Matrix]]></title>
    <url>%2F2019%2F06%2F28%2FLeetCode-Problem-542-01-Matrix%2F</url>
    <content type="text"><![CDATA[Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1. ExampleNo.1Input: 123[[0,0,0], [0,1,0], [0,0,0]] Output: 123[[0,0,0], [0,1,0], [0,0,0]] No.2Input: 123[[0,0,0], [0,1,0], [1,1,1]] Output: 123[[0,0,0], [0,1,0], [1,2,1]] Note The number of elements of the given matrix will not exceed 10,000. There are at least one 0 in the given matrix. The cells are adjacent in only four directions: up, down, left and right. BFS123456789101112131415161718192021222324252627282930313233343536public int[][] updateMatrix(int[][] matrix) &#123; int m = matrix.length; int n = matrix[0].length; int[][] directions = new int[][] &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (matrix[i][j] == 0) queue.offer(new int[] &#123;i, j&#125;); else matrix[i][j] = Integer.MAX_VALUE; &#125; &#125; while (!queue.isEmpty()) &#123; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; int[] pos = queue.poll(); for (int[] direction : directions) &#123; int x = pos[0] + direction[0]; int y = pos[1] + direction[1]; if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n || matrix[x][y] &lt;= matrix[pos[0]][pos[1]] + 1) continue; matrix[x][y] = matrix[pos[0]][pos[1]] + 1; queue.offer(new int[] &#123;x, y&#125;); &#125; &#125; &#125; return matrix;&#125; Other123456789101112131415161718192021222324252627282930313233public int[][] updateMatrix(int[][] matrix) &#123; int m = matrix.length; int n = matrix[0].length; int[][] result = new int[m][n]; for (int i = 0; i &lt; m; i++) &#123; Arrays.fill(result[i], 10000); for (int j = 0; j &lt; n; j++) &#123; if (matrix[i][j] == 0) result[i][j] = 0; else &#123; if (i &gt; 0) result[i][j] = Math.min(result[i][j], result[i - 1][j] + 1); if (j &gt; 0) result[i][j] = Math.min(result[i][j], result[i][j - 1] + 1); &#125; &#125; &#125; for (int i = m - 1; i &gt;= 0; i--) &#123; for (int j = n - 1; j &gt;= 0; j--) &#123; if (result[i][j] &gt; 1) &#123; if (i + 1 &lt; m) result[i][j] = Math.min(result[i][j], result[i + 1][j] + 1); if (j + 1 &lt; n) result[i][j] = Math.min(result[i][j], result[i][j + 1] + 1); &#125; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 663 - Walls and Gates]]></title>
    <url>%2F2019%2F06%2F28%2FLintCode-Problem-663-Walls-and-Gates%2F</url>
    <content type="text"><![CDATA[You are given a m x n 2D grid initialized with these three possible values. -1 - A wall or an obstacle. 0 - A gate. INF - Infinity means an empty room. We use the value 2^31 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a ROOM, that room should remain filled with INF ExampleNo.1Input:[[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]] Output:[[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]] Explanation:the 2D grid is: 1234INF -1 0 INFINF INF INF -1INF -1 INF -1 0 -1 INF INF the answer is: 12343 -1 0 12 2 1 -11 -1 2 -10 -1 3 4 No.2Input:[[0,-1],[2147483647,2147483647]] Output:[[0,-1],[1,2]] Code1234567891011121314151617181920212223242526272829303132333435public void wallsAndGates(int[][] rooms) &#123; if (rooms == null || rooms.length == 0 || rooms[0].length == 0) return; int m = rooms.length; int n = rooms[0].length; int[][] directions = new int[][] &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (rooms[i][j] == 0) queue.offer(new int[] &#123;i, j&#125;); &#125; &#125; while (!queue.isEmpty()) &#123; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; int[] pos = queue.poll(); for (int[] direction : directions) &#123; int x = direction[0] + pos[0]; int y = direction[1] + pos[1]; if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n || rooms[x][y] != Integer.MAX_VALUE) continue; rooms[x][y] = rooms[pos[0]][pos[1]] + 1; queue.offer(new int[] &#123;x, y&#125;); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 130 - Surrounded Regions]]></title>
    <url>%2F2019%2F06%2F28%2FLeetCode-Problem-130-Surrounded-Regions%2F</url>
    <content type="text"><![CDATA[Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’. A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region. Example1234X X X XX O O XX X O XX O X X After running your function, the board should be: 1234X X X XX X X XX X X XX O X X ExplanationSurrounded regions shouldn’t be on the border, which means that any ‘O’ on the border of the board are not flipped to ‘X’. Any ‘O’ that is not on the border and it is not connected to an ‘O’ on the border will be flipped to ‘X’. Two cells are connected if they are adjacent cells connected horizontally or vertically. Code1234567891011121314151617181920212223242526272829303132333435363738394041public void solve(char[][] board) &#123; if (board == null || board.length == 0 || board[0].length == 0) return; int m = board.length; int n = board[0].length; for (int i = 0; i &lt; n; i++) &#123; dfs(board, m, n, 0, i); dfs(board, m, n, m - 1, i); &#125; for (int i = 0; i &lt; m; i++) &#123; dfs(board, m, n, i, 0); dfs(board, m, n, i, n - 1); &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (board[i][j] == 'O') board[i][j] = 'X'; if (board[i][j] == 'T') board[i][j] = 'O'; &#125; &#125;&#125;private void dfs(char[][] board, int m, int n, int x, int y) &#123; if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n) return; if (board[x][y] != 'O') return; board[x][y] = 'T'; dfs(board, m, n, x + 1, y); dfs(board, m, n, x - 1, y); dfs(board, m, n, x, y + 1); dfs(board, m, n, x, y - 1);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 417 - Pacific Atlantic Water Flow]]></title>
    <url>%2F2019%2F06%2F28%2FLeetCode-Problem-417-Pacific-Atlantic-Water-Flow%2F</url>
    <content type="text"><![CDATA[Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges. Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower. Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean. Note The order of returned grid coordinates does not matter. Both m and n are less than 150. ExampleGiven the following 5x5 matrix: 1234567Pacific ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) * ~ 3 2 3 (4) (4) * ~ 2 4 (5) 3 1 * ~ (6) (7) 1 4 5 * ~ (5) 1 1 2 4 * * * * * * Atlantic Return: [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix). Code1234567891011121314151617181920212223242526272829303132333435363738394041424344public List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(int[][] matrix) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return result; int m = matrix.length; int n = matrix[0].length; boolean[][] toPacific = new boolean[m][n]; boolean[][] toAtlantic = new boolean[m][n]; for (int i = 0; i &lt; n; i++) &#123; dfs(matrix, toAtlantic, m, n, 0, i, -1); dfs(matrix, toPacific, m, n, m - 1, i, -1); &#125; for (int i = 0; i &lt; m; i++) &#123; dfs(matrix, toAtlantic, m, n, i, 0, -1); dfs(matrix, toPacific, m, n, i, n - 1, -1); &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (toAtlantic[i][j] &amp;&amp; toPacific[i][j]) result.add(Arrays.asList(i, j)); &#125; &#125; return result;&#125;private void dfs(int[][] matrix, boolean[][] visit, int m, int n, int x, int y, int pre)&#123; if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n || visit[x][y]) return; if (matrix[x][y] &lt; pre) return; visit[x][y] = true; dfs(matrix, visit, m, n, x + 1, y, matrix[x][y]); dfs(matrix, visit, m, n, x - 1, y, matrix[x][y]); dfs(matrix, visit, m, n, x, y + 1, matrix[x][y]); dfs(matrix, visit, m, n, x, y - 1, matrix[x][y]);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 331 - Verify Preorder Serialization of a Binary Tree]]></title>
    <url>%2F2019%2F06%2F28%2FLeetCode-Problem-331-Verify-Preorder-Serialization-of-a-Binary-Tree%2F</url>
    <content type="text"><![CDATA[One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as #. 1234567 _9_ / \ 3 2 / \ / \ 4 1 # 6/ \ / \ / \# # # # # # For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where # represents a null node. Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree. Each comma separated value in the string must be either an integer or a character ‘#’ representing null pointer. You may assume that the input format is always valid, for example it could never contain two consecutive commas such as “1,,3”. ExampleNo.1Input: “9,3,4,#,#,1,#,#,2,#,6,#,#” Output: true No.2Input: “1,#” Output: false No.3Input: “9,#,#,1” Output: false Stack123456789101112131415161718public boolean isValidSerialization(String preorder) &#123; String[] str = preorder.split(","); Stack&lt;String&gt; stack = new Stack&lt;&gt;(); for (int i = str.length - 1; i &gt;= 0; i--) &#123; if (!str[i].equals("#")) &#123; if (stack.size() &lt; 2) return false; stack.pop(); stack.pop(); &#125; stack.push(str[i]); &#125; return stack.size() == 1;&#125; Other12345678910111213141516public boolean isValidSerialization(String preorder) &#123; String[] str = preorder.split(","); int degree = 1; for (int i = 0; i &lt; str.length; i++) &#123; degree--; if (degree &lt; 0) return false; if (!str[i].equals("#")) degree += 2; &#125; return degree == 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 515 - Find Largest Value in Each Tree Row]]></title>
    <url>%2F2019%2F06%2F27%2FLeetCode-Problem-515-Find-Largest-Value-in-Each-Tree-Row%2F</url>
    <content type="text"><![CDATA[You need to find the largest value in each row of a binary tree. ExampleInput: 12345 1 / \ 3 2 / \ \ 5 3 9 Output: [1, 3, 9] Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516171819202122232425262728public List&lt;Integer&gt; largestValues(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; int size = queue.size(); int max = Integer.MIN_VALUE; for (int i = 0; i &lt; size; i++) &#123; TreeNode node = queue.poll(); max = Math.max(max, node.val); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); &#125; result.add(max); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 513 - Find Bottom Left Tree Value]]></title>
    <url>%2F2019%2F06%2F27%2FLeetCode-Problem-513-Find-Bottom-Left-Tree-Value%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find the leftmost value in the last row of the tree. ExampleNo.1Input: 123 2 / \1 3 Output:1 No.2Input: 1234567 1 / \ 2 3 / / \4 5 6 / 7 Output:7 NoteYou may assume the tree (i.e., the given root node) is not NULL. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021public int findBottomLeftValue(TreeNode root) &#123; int result = 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode node = queue.poll(); result = node.val; if (node.right != null) queue.offer(node.right); if (node.left != null) queue.offer(node.left); &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 103 - Binary Tree Zigzag Level Order Traversal]]></title>
    <url>%2F2019%2F06%2F27%2FLeetCode-Problem-103-Binary-Tree-Zigzag-Level-Order-Traversal%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its zigzag level order traversal as: 12345[ [3], [20,9], [15,7]] Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; Deque&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); boolean isOdd = true; while (!queue.isEmpty()) &#123; int size = queue.size(); List&lt;Integer&gt; level = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; size; i++) &#123; TreeNode node; if (isOdd) &#123; node = queue.pollFirst(); if (node.left != null) queue.offerLast(node.left); if (node.right != null) queue.offerLast(node.right); &#125; else &#123; node = queue.pollLast(); if (node.right != null) queue.offerFirst(node.right); if (node.left != null) queue.offerFirst(node.left); &#125; level.add(node.val); &#125; result.add(level); isOdd = !isOdd; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 518 - Coin Change 2]]></title>
    <url>%2F2019%2F06%2F26%2FLeetCode-Problem-518-Coin-Change-2%2F</url>
    <content type="text"><![CDATA[You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin. ExampleNo.1Input: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount:5=55=2+2+15=2+1+1+15=1+1+1+1+1 No.2Input: amount = 3, coins = [2] Output: 0 Explanation: the amount of 3 cannot be made up just with coins of 2. No.3Input: amount = 10, coins = [10] Output: 1 NoteYou can assume that 0 &lt;= amount &lt;= 5000 1 &lt;= coin &lt;= 5000 the number of coins is less than 500 the answer is guaranteed to fit into signed 32-bit integer Code123456789101112// dp[i] = dp[i] + dp[i - coins[j]]public int change(int amount, int[] coins) &#123; int[] dp = new int[amount + 1]; dp[0] = 1; for (int j = 0; j &lt; coins.length; j++) &#123; for (int i = coins[j]; i &lt;= amount; i++) dp[i] += dp[i - coins[j]]; &#125; return dp[amount];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 322 - Coin Change]]></title>
    <url>%2F2019%2F06%2F26%2FLeetCode-Problem-322-Coin-Change%2F</url>
    <content type="text"><![CDATA[You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. ExampleNo.1Input: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 No.2Input: coins = [2], amount = 3 Output: -1 NoteYou may assume that you have an infinite number of each kind of coin. Code123456789101112131415// dp[i] = min&#123;dp[i - coins[j]] + 1&#125;public int coinChange(int[] coins, int amount) &#123; int[] dp = new int[amount + 1]; Arrays.fill(dp, amount + 1); dp[0] = 0; for (int i = 1; i &lt;= amount; i++) &#123; for (int j = 0; j &lt; coins.length; j++) &#123; if (i - coins[j] &gt;= 0) dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1); &#125; &#125; return dp[amount] &gt; amount ? -1 : dp[amount];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 441 - Arranging Coins]]></title>
    <url>%2F2019%2F06%2F26%2FLeetCode-Problem-441-Arranging-Coins%2F</url>
    <content type="text"><![CDATA[You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins. Given n, find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer. ExampleNo.1n = 5 The coins can form the following rows: 123¤¤ ¤¤ ¤ Because the 3rd row is incomplete, we return 2. No.2n = 8 The coins can form the following rows: 1234¤¤ ¤¤ ¤ ¤¤ ¤ Because the 4th row is incomplete, we return 3. Code123456789101112131415161718public int arrangeCoins(int n) &#123; if (n &lt;= 1) return n; long left = 1; long right = n; while (left &lt; right) &#123; long mid = left + (right - left) / 2; if (mid * (mid + 1) / 2 &gt; n) right = mid; else left = mid + 1; &#125; return (int) left - 1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 448 - Find All Numbers Disappeared in an Array]]></title>
    <url>%2F2019%2F06%2F25%2FLeetCode-Problem-448-Find-All-Numbers-Disappeared-in-an-Array%2F</url>
    <content type="text"><![CDATA[Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. ExampleInput:[4,3,2,7,8,2,3,1] Output:[5,6] Code1234567891011121314151617public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int idx = Math.abs(nums[i]) - 1; if (nums[idx] &gt; 0) nums[idx] *= -1; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt; 0) result.add(i + 1); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 442 - Find All Duplicates in an Array]]></title>
    <url>%2F2019%2F06%2F25%2FLeetCode-Problem-442-Find-All-Duplicates-in-an-Array%2F</url>
    <content type="text"><![CDATA[Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime? ExampleInput:[4,3,2,7,8,2,3,1] Output:[2,3] Code1234567891011121314public List&lt;Integer&gt; findDuplicates(int[] nums) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int idx = Math.abs(nums[i]) - 1; if (nums[idx] &lt; 0) result.add(Math.abs(nums[i])); else nums[idx] *= -1; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 268 - Missing Number]]></title>
    <url>%2F2019%2F06%2F24%2FLeetCode-Problem-268-Missing-Number%2F</url>
    <content type="text"><![CDATA[Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array. ExampleNo.1Input: [3,0,1] Output: 2 No.2Input: [9,6,4,2,3,5,7,0,1] Output: 8 NoteYour algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? Code12345678public int missingNumber(int[] nums) &#123; int result = 0; for (int i = 0; i &lt; nums.length; i++) result ^= nums[i] ^ (i + 1); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 287 - Find the Duplicate Number]]></title>
    <url>%2F2019%2F06%2F24%2FLeetCode-Problem-287-Find-the-Duplicate-Number%2F</url>
    <content type="text"><![CDATA[Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. ExampleNo.1Input: [1,3,4,2,2] Output: 2 No.2Input: [3,1,3,4,2] Output: 3 Note You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n^2). There is only one duplicate number in the array, but it could be repeated more than once. Code123456789101112131415161718public int findDuplicate(int[] nums) &#123; int slow = nums[0]; int fast = nums[nums[0]]; while (slow != fast) &#123; slow = nums[slow]; fast = nums[nums[fast]]; &#125; int result = 0; while (slow != result) &#123; slow = nums[slow]; result = nums[result]; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 220 - Contains Duplicate III]]></title>
    <url>%2F2019%2F06%2F22%2FLeetCode-Problem-220-Contains-Duplicate-III%2F</url>
    <content type="text"><![CDATA[Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k. ExampleNo.1Input: nums = [1,2,3,1], k = 3, t = 0 Output: true No.2Input: nums = [1,0,1,1], k = 1, t = 2 Output: true No.3Input: nums = [1,5,9,1,5,9], k = 2, t = 3 Output: false Code123456789101112131415161718192021public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (i &gt; k) set.remove(nums[i - k - 1]); Integer floor = set.floor(nums[i]); Integer ceiling = set.ceiling(nums[i]); if (floor != null &amp;&amp; (long) nums[i] - (long) floor &lt;= t) return true; if (ceiling != null &amp;&amp; (long) ceiling - (long) nums[i] &lt;= t) return true; set.add(nums[i]); &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 219 - Contains Duplicate II]]></title>
    <url>%2F2019%2F06%2F22%2FLeetCode-Problem-219-Contains-Duplicate-II%2F</url>
    <content type="text"><![CDATA[Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. ExampleNo.1Input: nums = [1,2,3,1], k = 3 Output: true No.2Input: nums = [1,0,1,1], k = 1 Output: true No.3Input: nums = [1,2,3,1,2,3], k = 2 Output: false Code123456789101112public boolean containsNearbyDuplicate(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (map.containsKey(nums[i]) &amp;&amp; i - map.get(nums[i]) &lt;= k) return true; map.put(nums[i], i); &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 217 - Contains Duplicate]]></title>
    <url>%2F2019%2F06%2F22%2FLeetCode-Problem-217-Contains-Duplicate%2F</url>
    <content type="text"><![CDATA[Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. ExampleNo.1Input: [1,2,3,1] Output: true No.2Input: [1,2,3,4] Output: false No.3Input: [1,1,1,3,3,4,3,2,4,2] Output: true Code123456789101112public boolean containsDuplicate(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int num : nums) &#123; if (set.contains(num)) return true; set.add(num); &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 162 - Find Peak Element]]></title>
    <url>%2F2019%2F06%2F20%2FLeetCode-Problem-162-Find-Peak-Element%2F</url>
    <content type="text"><![CDATA[A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. ExampleNo.1Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. No.2Input: nums = [1,2,1,3,5,6,4] Output: 1 or 5 Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6. NoteYour solution should be in logarithmic complexity. Code123456789101112131415public int findPeakElement(int[] nums) &#123; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &gt; nums[mid + 1]) right = mid; else left = mid + 1; &#125; return right;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 632 - Smallest Range]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-Problem-632-Smallest-Range%2F</url>
    <content type="text"><![CDATA[You have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the k lists. We define the range [a,b] is smaller than range [c,d] if b-a &lt; d-c or a &lt; c if b-a == d-c. ExampleInput:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] Output: [20,24] Explanation:List 1: [4, 10, 15, 24,26], 24 is in range [20,24].List 2: [0, 9, 12, 20], 20 is in range [20,24].List 3: [5, 18, 22, 30], 22 is in range [20,24]. Note The given list may contain duplicates, so ascending order means &gt;= here. 1 &lt;= k &lt;= 3500 -105 &lt;= value of elements &lt;= 105. Code12345678910111213141516171819202122232425262728293031323334public int[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123; int max = Integer.MAX_VALUE; int min = Integer.MIN_VALUE; int curMax = Integer.MIN_VALUE; PriorityQueue&lt;int[]&gt; minHeap = new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;() &#123; @Override public int compare(int[] o1, int[] o2) &#123; return nums.get(o1[0]).get(o1[1]) - nums.get(o2[0]).get(o2[1]); &#125; &#125;); for (int i = 0; i &lt; nums.size(); i++) &#123; minHeap.offer(new int[] &#123;i, 0&#125;); curMax = Math.max(curMax, nums.get(i).get(0)); &#125; while (minHeap.size() == nums.size()) &#123; int[] pos = minHeap.poll(); int curMin = nums.get(pos[0]).get(pos[1]); if (curMax - curMin &lt; max - min) &#123; min = curMin; max = curMax; &#125; if (pos[1] &lt; nums.get(pos[0]).size() - 1) &#123; minHeap.offer(new int[] &#123;pos[0], pos[1] + 1&#125;); curMax = Math.max(curMax, nums.get(pos[0]).get(pos[1] + 1)); &#125; &#125; return new int[] &#123;min, max&#125;;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 910 - Smallest Range II]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-Problem-910-Smallest-Range-II%2F</url>
    <content type="text"><![CDATA[Given an array A of integers, for each integer A[i] we need to choose either x = -K or x = K, and add x to A[i] (only once). After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B. ExampleNo.1Input: A = [1], K = 0 Output: 0 Explanation: B = [1] No.2Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8] No.3Input: A = [1,3,6], K = 3 Output: 3 Explanation: B = [4,6,3] Note 1 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 10000 0 &lt;= K &lt;= 10000 Code1234567891011121314public int smallestRangeII(int[] A, int K) &#123; Arrays.sort(A); int min = A[0]; int max = A[A.length - 1]; int result = max - min; for (int i = 0; i &lt; A.length - 1; i++) &#123; max = Math.max(max, A[i] + 2 * K); min = Math.min(A[0] + 2 * K, A[i + 1]); result = Math.min(result, max - min); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 908 - Smallest Range I]]></title>
    <url>%2F2019%2F06%2F09%2FLeetCode-Problem-908-Smallest-Range-I%2F</url>
    <content type="text"><![CDATA[Given an array A of integers, for each integer A[i] we may choose any x with -K &lt;= x &lt;= K, and add x to A[i]. After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B. ExampleNo.1Input: A = [1], K = 0 Output: 0 Explanation: B = [1] No.2Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8] No.3Input: A = [1,3,6], K = 3 Output: 0 Explanation: B = [3,3,3] or B = [4,4,4] Note 1 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 10000 0 &lt;= K &lt;= 10000 Code1234567891011public int smallestRangeI(int[] A, int K) &#123; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for (int a : A) &#123; min = Math.min(min, a); max = Math.max(max, a); &#125; return Math.max(max - min - 2 * K, 0);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 560 - Subarray Sum Equals K]]></title>
    <url>%2F2019%2F06%2F08%2FLeetCode-Problem-560-Subarray-Sum-Equals-K%2F</url>
    <content type="text"><![CDATA[Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. ExampleInput:nums = [1,1,1], k = 2 Output: 2 Note The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7]. Code1234567891011121314151617public int subarraySum(int[] nums, int k) &#123; int result = 0; int sum = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, 1); for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; if (map.containsKey(sum - k)) result += map.get(sum - k); map.put(sum, map.getOrDefault(sum, 0) + 1); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 523 - Continuous Subarray Sum]]></title>
    <url>%2F2019%2F06%2F08%2FLeetCode-Problem-523-Continuous-Subarray-Sum%2F</url>
    <content type="text"><![CDATA[Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of k, that is, sums up to n*k where n is also an integer. ExampleNo.1Input: [23, 2, 4, 6, 7], k=6 Output: True Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6. No.2Input: [23, 2, 6, 4, 7], k=6 Output: True Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42. Note The length of the array won’t exceed 10,000. You may assume the sum of all the numbers is in the range of a signed 32-bit integer. Code123456789101112131415161718// 若数字a和b分别除以数字c，若得到的余数相同，那么(a-b)必定能够整除cpublic boolean checkSubarraySum(int[] nums, int k) &#123; int sum = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, -1); for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; int mod = (k == 0) ? sum : sum % k; if (map.containsKey(mod) &amp;&amp; i - map.get(mod) &gt; 1) return true; else if (!map.containsKey(mod)) map.put(mod, i); &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 698 - Partition to K Equal Sum Subsets]]></title>
    <url>%2F2019%2F06%2F07%2FLeetCode-Problem-698-Partition-to-K-Equal-Sum-Subsets%2F</url>
    <content type="text"><![CDATA[Given an array of integers nums and a positive integer k, find whether it’s possible to divide this array into k non-empty subsets whose sums are all equal. ExampleInput: nums = [4, 3, 2, 3, 5, 2, 1], k = 4 Output: True Explanation: It’s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums. Note 1 &lt;= k &lt;= len(nums) &lt;= 16. 0 &lt; nums[i] &lt; 10000. Code123456789101112131415161718192021222324252627282930313233343536373839public boolean canPartitionKSubsets(int[] nums, int k) &#123; int sum = 0; for (int num : nums) sum += num; if (sum % k != 0) return false; boolean[] visit = new boolean[nums.length]; Arrays.sort(nums); return dfs(nums, k, sum / k, 0, nums.length - 1, visit);&#125;private boolean dfs(int[] nums, int k, int target, int sum, int idx, boolean[] visit) &#123; if (k == 1) return true; if (sum &gt; target) return false; if (sum == target) return dfs(nums, k - 1, target, 0, nums.length - 1, visit); for (int i = idx; i &gt;= 0; i--) &#123; if (visit[i]) continue; visit[i] = true; if (dfs(nums, k, target, sum + nums[i], i - 1, visit)) return true; visit[i] = false; &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 416 - Partition Equal Subset Sum]]></title>
    <url>%2F2019%2F06%2F07%2FLeetCode-Problem-416-Partition-Equal-Subset-Sum%2F</url>
    <content type="text"><![CDATA[Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note Each of the array element will not exceed 100. The array size will not exceed 200. ExampleNo.1Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. No.2Input: [1, 2, 3, 5] Output: false Explanation: The array cannot be partitioned into equal sum subsets. Code123456789101112131415161718192021// dp[i] = dp[i] || dp[i - nums[j]], nums[j] &lt;= i &lt;= targetpublic boolean canPartition(int[] nums) &#123; int sum = 0; for (int num : nums) sum += num; if (sum % 2 == 1) return false; int target = sum / 2; boolean[] dp = new boolean[target + 1]; dp[0] = true; for (int num : nums) &#123; for (int i = target; i &gt;= num; i--) dp[i] |= dp[i - num]; &#125; return dp[target];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 388 - Longest Absolute File Path]]></title>
    <url>%2F2019%2F06%2F07%2FLeetCode-Problem-388-Longest-Absolute-File-Path%2F</url>
    <content type="text"><![CDATA[Suppose we abstract our file system by a string in the following manner: The string “dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext” represents: 1234dir subdir1 subdir2 file.ext The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext. The string “dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext” represents: 1234567dir subdir1 file1.ext subsubdir1 subdir2 subsubdir2 file2.ext The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext. We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is “dir/subdir2/subsubdir2/file2.ext”, and its length is 32 (not including the double quotes). Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0. Note The name of a file contains at least a . and an extension. The name of a directory or sub-directory will not contain a .. Time complexity required: O(n) where n is the size of the input string. Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png. Code1234567891011121314151617public int lengthLongestPath(String input) &#123; int result = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(-1, 0); for (String str : input.split("\n")) &#123; int level = str.lastIndexOf("\t") + 1; int length = str.substring(level).length(); if (str.contains(".")) result = Math.max(result, map.get(level - 1) + length); else map.put(level, map.get(level - 1) + length + 1); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 84 - Largest Rectangle in Histogram]]></title>
    <url>%2F2019%2F06%2F06%2FLeetCode-Problem-84-Largest-Rectangle-in-Histogram%2F</url>
    <content type="text"><![CDATA[Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. ExampleInput: [2,1,5,6,2,3] Output: 10 Code123456789101112131415161718public int largestRectangleArea(int[] heights) &#123; int result = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt;= heights.length; i++) &#123; int next = (i == heights.length ? -1 : heights[i]); while (!stack.isEmpty() &amp;&amp; next &lt;= heights[stack.peek()]) &#123; int h = heights[stack.pop()]; int w = stack.isEmpty() ? i : i - stack.peek() - 1; result = Math.max(result, h * w); &#125; stack.push(i); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 907 - Sum of Subarray Minimums]]></title>
    <url>%2F2019%2F06%2F06%2FLeetCode-Problem-907-Sum-of-Subarray-Minimums%2F</url>
    <content type="text"><![CDATA[Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A. Since the answer may be large, return the answer modulo 10^9 + 7. ExampleInput: [3,1,2,4] Output: 17 Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4].Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1. Sum is 17. Note 1 &lt;= A.length &lt;= 30000 1 &lt;= A[i] &lt;= 30000 Code1234567891011121314151617181920212223// res = sum(A[i] * f(i))，其中f(i)是子数组的数量，A[i]是最小值。// f(i) = (left[i] + 1) * (right[i] + 1)// left[i]，能在A[i]左侧取得的最长宽度，使得在这个范围内A[i]是最小值,且都大于A[i]// right[i], 能在A[i]右侧取得的最长宽度，使得在这个范围内A[i]是最小值，且都大于等于A[i]public int sumSubarrayMins(int[] A) &#123; int result = 0; int mod = (int) 1e9 + 7; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt;= A.length; i++) &#123; int next = (i == A.length) ? -1 : A[i]; while (!stack.isEmpty() &amp;&amp; next &lt; A[stack.peek()]) &#123; int j = stack.pop(); int k = stack.isEmpty() ? -1 : stack.peek(); result = (result + A[j] * (j - k) * (i - j)) % mod; &#125; stack.push(i); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 209 - Minimum Size Subarray Sum]]></title>
    <url>%2F2019%2F06%2F06%2FLeetCode-Problem-209-Minimum-Size-Subarray-Sum%2F</url>
    <content type="text"><![CDATA[Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. ExampleInput: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow upIf you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n). Code12345678910111213141516public int minSubArrayLen(int s, int[] nums) &#123; int min = Integer.MAX_VALUE; int sum = 0; for (int left = 0, right = 0; right &lt; nums.length; right++) &#123; sum += nums[right]; while (sum &gt;= s) &#123; min = Math.min(min, right - left + 1); sum -= nums[left]; left++; &#125; &#125; return min == Integer.MAX_VALUE ? 0 : min;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 983 - Minimum Cost For Tickets]]></title>
    <url>%2F2019%2F06%2F06%2FLeetCode-Problem-983-Minimum-Cost-For-Tickets%2F</url>
    <content type="text"><![CDATA[In a country popular for train travel, you have planned some train travelling one year in advance. The days of the year that you will travel is given as an array days. Each day is an integer from 1 to 365. Train tickets are sold in 3 different ways: a 1-day pass is sold for costs[0] dollars; a 7-day pass is sold for costs[1] dollars; a 30-day pass is sold for costs[2] dollars. The passes allow that many days of consecutive travel. For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8. Return the minimum number of dollars you need to travel every day in the given list of days. ExampleNo.1Input: days = [1,4,6,7,8,20], costs = [2,7,15] Output: 11 Explanation:For example, here is one way to buy passes that lets you travel your travel plan:On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, …, 9.On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.In total you spent $11 and covered all the days of your travel. No.2Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15] Output: 17 Explanation:For example, here is one way to buy passes that lets you travel your travel plan:On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, …, 30.On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.In total you spent $17 and covered all the days of your travel. Note 1 &lt;= days.length &lt;= 365 1 &lt;= days[i] &lt;= 365 days is in strictly increasing order. costs.length == 3 1 &lt;= costs[i] &lt;= 1000 Code123456789101112131415161718192021// dp[i] = min&#123;dp[i - 1] + cost[0], dp[i - 7] + cost[1], dp[i - 30] + cost[2]&#125;public int mincostTickets(int[] days, int[] costs) &#123; int lastDay = days[days.length - 1]; int[] dp = new int[lastDay + 1]; dp[0] = 0; for (int i = 0; i &lt; days.length; i++) &#123; int day = days[i]; int price1 = dp[day - 1] + costs[0]; int price2 = dp[Math.max(0, day - 7)] + costs[1]; int price3 = dp[Math.max(0, day - 30)] + costs[2]; dp[day] = Math.min(Math.min(price1, price2), price3); if (i &lt; days.length - 1) &#123; for (int j = day + 1; j &lt; days[i + 1]; j++) dp[j] = dp[day]; &#125; &#125; return dp[lastDay];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 659 - Encode and Decode Strings]]></title>
    <url>%2F2019%2F06%2F06%2FLintCode-Problem-659-Encode-and-Decode-Strings%2F</url>
    <content type="text"><![CDATA[Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. Please implement encode and decode ExampleNo.1Input: [“lint”,”code”,”love”,”you”] Output: [“lint”,”code”,”love”,”you”] Explanation:One possible encode method is: “lint:;code:;love:;you” No.2Input: [“we”, “say”, “:”, “yes”] Output: [“we”, “say”, “:”, “yes”] Explanation:One possible encode method is: “we:;say:;:::;yes” Code1234567891011121314151617181920212223242526272829303132333435363738394041public String encode(List&lt;String&gt; strs) &#123; StringBuilder sb = new StringBuilder(); for (String str : strs) &#123; for (char ch : str.toCharArray()) &#123; if (ch == ':') sb.append("::"); else sb.append(ch); &#125; sb.append(":;"); &#125; return sb.toString();&#125;public List&lt;String&gt; decode(String str) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; str.length();) &#123; char ch = str.charAt(i); if (ch == ':') &#123; result.add(sb.toString()); if (str.charAt(i + 1) != ';') result.add(":"); sb.setLength(0); i += 2; &#125; else &#123; sb.append(ch); i++; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 648 - Replace Words]]></title>
    <url>%2F2019%2F06%2F05%2FLeetCode-Problem-648-Replace-Words%2F</url>
    <content type="text"><![CDATA[In English, we have a concept called root, which can be followed by some other words to form another longer word - let’s call this word successor. For example, the root an, followed by other, which can form another word another. Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length. You need to output the sentence after the replacement. ExampleInput: dict = [“cat”, “bat”, “rat”] sentence = “the cattle was rattled by the battery” Output: “the cat was rat by the bat” Note The input will only have lower-case letters. 1 &lt;= dict words number &lt;= 1000 1 &lt;= sentence words number &lt;= 1000 1 &lt;= root length &lt;= 100 1 &lt;= sentence words length &lt;= 1000 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class TrieNode &#123; private String word; private Map&lt;Character, TrieNode&gt; children = new HashMap&lt;&gt;();&#125;public class TrieTree &#123; private TrieNode root; public TrieTree(TrieNode root) &#123; this.root = root; &#125; public void insert(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char ch = word.charAt(i); node.children.putIfAbsent(ch, new TrieNode()); node = node.children.get(ch); &#125; node.word = word; &#125; public String find(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char ch = word.charAt(i); if (!node.children.containsKey(ch)) break; node = node.children.get(ch); if (node.word != null) return node.word; &#125; return word; &#125;&#125;public String replaceWords(List&lt;String&gt; dict, String sentence) &#123; StringBuilder sb = new StringBuilder(); TrieTree trieTree = new TrieTree(new TrieNode()); for (String word : dict) trieTree.insert(word); String[] words = sentence.split(" "); for (String word : words) sb.append(trieTree.find(word)).append(" "); return sb.toString().trim();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 299 - Bulls and Cows]]></title>
    <url>%2F2019%2F06%2F05%2FLeetCode-Problem-299-Bulls-and-Cows%2F</url>
    <content type="text"><![CDATA[You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number. Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. Please note that both secret number and friend’s guess may contain duplicate digits. ExampleNo.1Input: secret = “1807”, guess = “7810” Output: “1A3B” Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7. No.2Input: secret = “1123”, guess = “0111” Output: “1A1B” Explanation: The 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow. NoteYou may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal. Code12345678910111213141516171819202122232425public String getHint(String secret, String guess) &#123; int[] count = new int[10]; int bulls = 0; int cows = 0; for (int i = 0; i &lt; secret.length(); i++) &#123; char s = secret.charAt(i); char g = guess.charAt(i); if (s == g) bulls++; else &#123; if (count[s - '0'] &lt; 0) cows++; if (count[g - '0'] &gt; 0) cows++; count[s - '0']++; count[g - '0']--; &#125; &#125; return String.valueOf(bulls) + "A" + String.valueOf(cows) + "B";&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 833 - Find And Replace in String]]></title>
    <url>%2F2019%2F06%2F04%2FLeetCode-Problem-833-Find-And-Replace-in-String%2F</url>
    <content type="text"><![CDATA[To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size). Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y. The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y. If not, we do nothing. For example, if we have S = “abcd” and we have some replacement operation i = 2, x = “cd”, y = “ffff”, then because “cd” starts at position 2 in the original string S, we will replace it with “ffff”. Using another example on S = “abcd”, if we have both the replacement operation i = 0, x = “ab”, y = “eee”, as well as another replacement operation i = 2, x = “ec”, y = “ffff”, this second operation does nothing because in the original string S[2] = ‘c’, which doesn’t match x[0] = ‘e’. All these operations occur simultaneously. It’s guaranteed that there won’t be any overlap in replacement: for example, S = “abc”, indexes = [0, 1], sources = [“ab”,”bc”] is not a valid test case. ExampleNo.1Input: S = “abcd”, indexes = [0,2], sources = [“a”,”cd”], targets = [“eee”,”ffff”] Output: “eeebffff” Explanation: “a” starts at index 0 in S, so it’s replaced by “eee”.“cd” starts at index 2 in S, so it’s replaced by “ffff”. No.2Input: S = “abcd”, indexes = [0,2], sources = [“ab”,”ec”], targets = [“eee”,”ffff”] Output: “eeecd” Explanation: “ab” starts at index 0 in S, so it’s replaced by “eee”.“ec” doesn’t starts at index 2 in the original S, so we do nothing. Notes 0 &lt;= indexes.length = sources.length = targets.length &lt;= 100 0 &lt; indexes[i] &lt; S.length &lt;= 1000 All characters in given inputs are lowercase letters. Code1234567891011121314151617181920212223242526public String findReplaceString(String S, int[] indexes, String[] sources, String[] targets) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; indexes.length; i++) &#123; int idx = indexes[i]; String str = S.substring(idx, idx + sources[i].length()); if (str.equals(sources[i])) map.put(idx, i); &#125; for (int i = 0; i &lt; S.length();) &#123; if (map.containsKey(i)) &#123; int idx = map.get(i); sb.append(targets[idx]); i += sources[idx].length(); &#125; else &#123; sb.append(S.charAt(i)); i++; &#125; &#125; return sb.toString();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 692 - Top K Frequent Words]]></title>
    <url>%2F2019%2F06%2F04%2FLeetCode-Problem-692-Top-K-Frequent-Words%2F</url>
    <content type="text"><![CDATA[Given a non-empty list of words, return the k most frequent elements. Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first. ExampleNo.1Input: [“i”, “love”, “leetcode”, “i”, “love”, “coding”], k = 2 Output: [“i”, “love”] Explanation: “i” and “love” are the two most frequent words. Note that “i” comes before “love” due to a lower alphabetical order. No.2Input: [“the”, “day”, “is”, “sunny”, “the”, “the”, “the”, “sunny”, “is”, “is”], k = 4 Output: [“the”, “is”, “sunny”, “day”] Explanation: “the”, “is”, “sunny” and “day” are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively. Note You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Input words contain only lowercase letters. Follow up Try to solve it in O(n log k) time and O(n) extra space. Code1234567891011121314151617181920212223242526272829public List&lt;String&gt; topKFrequent(String[] words, int k) &#123; List&lt;String&gt; result = new LinkedList&lt;&gt;(); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (String word : words) map.put(word, map.getOrDefault(word, 0) + 1); PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; heap = new PriorityQueue&lt;&gt;(new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123; @Override public int compare(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) &#123; if (o1.getValue() != o2.getValue()) return o1.getValue() - o2.getValue(); else return o2.getKey().compareTo(o1.getKey()); &#125; &#125;); for (Map.Entry entry : map.entrySet()) &#123; heap.offer(entry); if (heap.size() &gt; k) heap.poll(); &#125; while (!heap.isEmpty()) result.add(0, heap.poll().getKey()); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 916 - Word Subsets]]></title>
    <url>%2F2019%2F06%2F04%2FLeetCode-Problem-916-Word-Subsets%2F</url>
    <content type="text"><![CDATA[We are given two arrays A and B of words. Each word is a string of lowercase letters. Now, say that word b is a subset of word a if every letter in b occurs in a, including multiplicity. For example, “wrr” is a subset of “warrior”, but is not a subset of “world”. Now say a word a from A is universal if for every b in B, b is a subset of a. Return a list of all universal words in A. You can return the words in any order. ExampleNo.1Input: A = [“amazon”,”apple”,”facebook”,”google”,”leetcode”], B = [“e”,”o”] Output: [“facebook”,”google”,”leetcode”] No.2Input: A = [“amazon”,”apple”,”facebook”,”google”,”leetcode”], B = [“l”,”e”] Output: [“apple”,”google”,”leetcode”] No.3Input: A = [“amazon”,”apple”,”facebook”,”google”,”leetcode”], B = [“e”,”oo”] Output: [“facebook”,”google”] No.4Input: A = [“amazon”,”apple”,”facebook”,”google”,”leetcode”], B = [“lo”,”eo”] Output: [“google”,”leetcode”] No.5Input: A = [“amazon”,”apple”,”facebook”,”google”,”leetcode”], B = [“ec”,”oc”,”ceo”] Output: [“facebook”,”leetcode”] Note 1 &lt;= A.length, B.length &lt;= 10000 1 &lt;= A[i].length, B[i].length &lt;= 10 A[i] and B[i] consist only of lowercase letters. All words in A[i] are unique: there isn’t i != j with A[i] == A[j]. Code123456789101112131415161718192021222324252627282930313233343536373839public List&lt;String&gt; wordSubsets(String[] A, String[] B) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); int[] maxCount = new int[26]; for (String b : B) &#123; int[] count = count(b); for (int i = 0; i &lt; 26; i++) maxCount[i] = Math.max(maxCount[i], count[i]); &#125; for (String a : A) &#123; int[] count = count(a); boolean isSubset = true; for (int i = 0; i &lt; 26; i++) &#123; if (count[i] &lt; maxCount[i]) &#123; isSubset = false; break; &#125; &#125; if (isSubset) result.add(a); &#125; return result;&#125;private int[] count(String str) &#123; int[] count = new int[26]; for (int i = 0; i &lt; str.length(); i++) &#123; int idx = str.charAt(i) - 'a'; count[idx]++; &#125; return count;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 829 - Word Pattern II]]></title>
    <url>%2F2019%2F06%2F04%2FLintCode-Problem-829-Word-Pattern-II%2F</url>
    <content type="text"><![CDATA[Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty substring in str.(i.e if a corresponds to s, then b cannot correspond to s. For example, given pattern = “ab”, str = “ss”, return false.) NoteYou may assume both pattern and str contains only lowercase letters. ExampleNo.1Input:pattern = “abab”str = “redblueredblue” Output: true Explanation: “a”-&gt;”red”,”b”-&gt;”blue” No.2Input:pattern = “aaaa”str = “asdasdasdasd” Output: true Explanation: “a”-&gt;”asd” No.3Input:pattern = “aabb”str = “xyzabcxzyabc” Output: false Code1234567891011121314151617181920212223242526272829303132333435public boolean wordPatternMatch(String pattern, String str) &#123; Map&lt;String, Character&gt; map = new HashMap&lt;&gt;(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); return dfs(map, set, pattern, 0, str, 0);&#125;private boolean dfs(Map&lt;String, Character&gt; map, Set&lt;Character&gt; set, String pattern, int p, String str, int s) &#123; if (p == pattern.length() &amp;&amp; s == str.length()) return true; else if (p == pattern.length() || s == str.length()) return false; char ch = pattern.charAt(p); for (int i = s; i &lt; str.length(); i++) &#123; String word = str.substring(s, i + 1); if (!map.containsKey(word) &amp;&amp; !set.contains(ch)) &#123; map.put(word, ch); set.add(ch); if (dfs(map, set, pattern, p + 1, str, i + 1)) return true; map.remove(word); set.remove(ch); &#125; else if (map.containsKey(word) &amp;&amp; map.get(word) == ch) &#123; if (dfs(map, set, pattern, p + 1, str, i + 1)) return true; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 290 - Word Pattern]]></title>
    <url>%2F2019%2F06%2F04%2FLeetCode-Problem-290-Word-Pattern%2F</url>
    <content type="text"><![CDATA[Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. ExampleNo.1Input: pattern = “abba”, str = “dog cat cat dog” Output: true No.2Input:pattern = “abba”, str = “dog cat cat fish” Output: false No.3Input: pattern = “aaaa”, str = “dog cat cat dog” Output: false No.4Input: pattern = “abba”, str = “dog dog dog dog” Output: false NotesYou may assume pattern contains only lowercase letters, and str contains lowercase letters that may be separated by a single space. Code123456789101112131415161718192021222324public boolean wordPattern(String pattern, String str) &#123; Map&lt;String, Character&gt; map = new HashMap&lt;&gt;(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); String[] words = str.split(" "); if (words.length != pattern.length()) return false; for (int i = 0; i &lt; words.length; i++) &#123; char p = pattern.charAt(i); if (!map.containsKey(words[i])) &#123; if (set.contains(p)) return false; map.put(words[i], p); set.add(p); &#125; else if (map.get(words[i]) != p) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 140 - Word Break II]]></title>
    <url>%2F2019%2F06%2F03%2FLeetCode-Problem-140-Word-Break-II%2F</url>
    <content type="text"><![CDATA[Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. ExampleNo.1Input:s = “catsanddog”wordDict = [“cat”, “cats”, “and”, “sand”, “dog”] Output:[ “cats and dog”, “cat sand dog”] No.2Input:s = “pineapplepenapple”wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”] Output:[ “pine apple pen apple”, “pineapple pen apple”, “pine applepen apple”] Explanation: Note that you are allowed to reuse a dictionary word. No.3Input:s = “catsandog”wordDict = [“cats”, “dog”, “sand”, “and”, “cat”] Output:[] Code123456789101112131415161718192021222324252627282930313233343536private Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) &#123; Set&lt;String&gt; dict = new HashSet&lt;&gt;(); for (String word : wordDict) dict.add(word); return dfs(s, dict);&#125;private List&lt;String&gt; dfs(String s, Set&lt;String&gt; dict) &#123; if (map.containsKey(s)) return map.get(s); List&lt;String&gt; result = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= s.length(); i++) &#123; String word = s.substring(0, i); if (!dict.contains(word)) continue; if (i == s.length()) result.add(s); else &#123; List&lt;String&gt; segList = dfs(s.substring(i), dict); for (String seg : segList) result.add(word + " " + seg); &#125; &#125; map.put(s, result); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 139 - Word Break]]></title>
    <url>%2F2019%2F06%2F02%2FLeetCode-Problem-139-Word-Break%2F</url>
    <content type="text"><![CDATA[Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. ExampleNo.1Input: s = “leetcode”, wordDict = [“leet”, “code”] Output: true Explanation: Return true because “leetcode” can be segmented as “leet code”. No.2Input: s = “applepenapple”, wordDict = [“apple”, “pen”] Output: true Explanation: Return true because “applepenapple” can be segmented as “apple pen apple”. Note that you are allowed to reuse a dictionary word. No.3Input: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”] Output: false Code123456789101112131415161718192021// dp[i] = dp[j] &amp;&amp; S(j, i-1)public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; Set&lt;String&gt; dict = new HashSet&lt;&gt;(); boolean[] dp = new boolean[s.length() + 1]; for (String word : wordDict) dict.add(word); dp[0] = true; for (int i = 0; i &lt; dp.length; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (dp[j] &amp;&amp; dict.contains(s.substring(j, i))) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[dp.length - 1];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 126 - Word Ladder II]]></title>
    <url>%2F2019%2F06%2F01%2FLeetCode-Problem-126-Word-Ladder-II%2F</url>
    <content type="text"><![CDATA[Given two words (beginWord and endWord), and a dictionary’s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that: Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. ExampleNo.1Input:beginWord = “hit”,endWord = “cog”,wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”] Output:[ [“hit”,”hot”,”dot”,”dog”,”cog”], [“hit”,”hot”,”lot”,”log”,”cog”]] No.2Input:beginWord = “hit”endWord = “cog”wordList = [“hot”,”dot”,”dog”,”lot”,”log”] Output: [] Explanation: The endWord “cog” is not in wordList, therefore no possible transformation. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; List&lt;List&lt;String&gt;&gt; results = new ArrayList&lt;&gt;(); List&lt;String&gt; result = new ArrayList&lt;&gt;(); if (!wordList.contains(endWord)) return results; Map&lt;String, List&lt;String&gt;&gt; prev = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; count = new HashMap&lt;&gt;(); Set&lt;String&gt; dict = new HashSet&lt;&gt;(); dict.add(beginWord); dict.add(endWord); prev.putIfAbsent(beginWord, new ArrayList&lt;&gt;()); prev.putIfAbsent(endWord, new ArrayList&lt;&gt;()); count.put(endWord, 0); for (String word : wordList) dict.add(word); // end -&gt; start bfs(prev, count, dict, endWord); // start -&gt; end dfs(results, result, prev, count, beginWord, endWord); return results;&#125;private void bfs(Map&lt;String, List&lt;String&gt;&gt; prev, Map&lt;String, Integer&gt; count, Set&lt;String&gt; dict, String start) &#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.offer(start); while (!queue.isEmpty()) &#123; String current = queue.poll(); List&lt;String&gt; nexts = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; current.length(); i++) &#123; char[] newWord = current.toCharArray(); for (char ch = 'a'; ch &lt;= 'z'; ch++) &#123; if (newWord[i] == ch) continue; newWord[i] = ch; String str = String.valueOf(newWord); if (dict.contains(str)) nexts.add(str); &#125; &#125; for (String next : nexts) &#123; prev.putIfAbsent(next, new ArrayList&lt;&gt;()); prev.get(next).add(current); if (!count.containsKey(next)) &#123; count.put(next, count.get(current) + 1); queue.offer(next); &#125; &#125; &#125;&#125;private void dfs(List&lt;List&lt;String&gt;&gt; results, List&lt;String&gt; result, Map&lt;String, List&lt;String&gt;&gt; prev, Map&lt;String, Integer&gt; count, String start, String end) &#123; result.add(start); if (start == end) results.add(new ArrayList&lt;&gt;(result)); else &#123; List&lt;String&gt; nexts = prev.get(start); for (String next : nexts) &#123; if (count.get(start) == count.get(next) + 1) dfs(results, result, prev, count, next, end); &#125; &#125; result.remove(result.size() - 1);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 127 - Word Ladder]]></title>
    <url>%2F2019%2F06%2F01%2FLeetCode-Problem-127-Word-Ladder%2F</url>
    <content type="text"><![CDATA[Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. ExampleNo.1Input:beginWord = “hit”,endWord = “cog”,wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”] Output: 5 Explanation: As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,return its length 5. No.2Input:beginWord = “hit”endWord = “cog”wordList = [“hot”,”dot”,”dog”,”lot”,”log”] Output: 0 Explanation: The endWord “cog” is not in wordList, therefore no possible transformation. Code12345678910111213141516171819202122232425262728293031323334353637public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; int count = 1; Set&lt;String&gt; set = new HashSet&lt;&gt;(); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.offer(beginWord); for (String word : wordList) set.add(word); while (!queue.isEmpty()) &#123; int size = queue.size(); count++; for (int i = 0; i &lt; size; i++) &#123; String word = queue.poll(); for (int idx = 0; idx &lt; word.length(); idx++) &#123; char[] newWord = word.toCharArray(); for (char ch = 'a'; ch &lt;= 'z'; ch++) &#123; newWord[idx] = ch; String str = String.valueOf(newWord); if (set.contains(str)) &#123; if (endWord.equals(str)) return count; queue.offer(str); set.remove(str); &#125; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 212 - Word Search II]]></title>
    <url>%2F2019%2F05%2F31%2FLeetCode-Problem-212-Word-Search-II%2F</url>
    <content type="text"><![CDATA[Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. ExampleInput: 123456board = [ ['o','a','a','n'], ['e','t','a','e'], ['i','h','k','r'], ['i','f','l','v']] words = [“oath”,”pea”,”eat”,”rain”] Output: [“eat”,”oath”] Note All inputs are consist of lowercase letters a-z. The values of words are distinct. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class TrieNode &#123; private String word; private Map&lt;Character, TrieNode&gt; children = new HashMap&lt;&gt;();&#125;public class TrieTree &#123; private TrieNode root; public TrieTree(TrieNode root) &#123; this.root = root; &#125; public void insert(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char ch = word.charAt(i); node.children.putIfAbsent(ch, new TrieNode()); node = node.children.get(ch); &#125; node.word = word; &#125;&#125;public List&lt;String&gt; findWords(char[][] board, String[] words) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); TrieTree trieTree = new TrieTree(new TrieNode()); for (String word : words) trieTree.insert(word); int n = board.length; int m = board[0].length; boolean[][] visit = new boolean[n][m]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) dfs(result, board, visit, trieTree.root, n, m, i, j); &#125; return result;&#125;private void dfs(List&lt;String&gt; result, char[][] board, boolean[][] visit, TrieNode trieNode, int n, int m, int x, int y) &#123; char ch = board[x][y]; if (!trieNode.children.containsKey(ch) || visit[x][y]) return; TrieNode child = trieNode.children.get(ch); String word = child.word; if (word != null &amp;&amp; !result.contains(word)) result.add(word); visit[x][y] = true; if (x + 1 &lt; n) dfs(result, board, visit, child, n, m, x + 1, y); if (x - 1 &gt;= 0) dfs(result, board, visit, child, n, m, x - 1, y); if (y + 1 &lt; m) dfs(result, board, visit, child, n, m, x, y + 1); if (y - 1 &gt;= 0) dfs(result, board, visit, child, n, m, x, y - 1); visit[x][y] = false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 79 - Word Search]]></title>
    <url>%2F2019%2F05%2F31%2FLeetCode-Problem-79-Word-Search%2F</url>
    <content type="text"><![CDATA[Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example123456board =[ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']] Given word = “ABCCED”, return true.Given word = “SEE”, return true.Given word = “ABCB”, return false. Code1234567891011121314151617181920212223242526272829303132public boolean exist(char[][] board, String word) &#123; int n = board.length; int m = board[0].length; boolean[][] visited = new boolean[n][m]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (search(board, visited, word, 0, i, j, n, m)) return true; &#125; &#125; return false;&#125;private boolean search(char[][] board, boolean[][] visited, String word, int idx, int x, int y, int n, int m) &#123; if (idx == word.length()) return true; if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || visited[x][y] || board[x][y] != word.charAt(idx)) return false; visited[x][y] = true; boolean exist = search(board, visited, word, idx + 1, x + 1, y, n, m) || search(board, visited, word, idx + 1, x - 1, y, n, m) || search(board, visited, word, idx + 1, x, y + 1, n, m) || search(board, visited, word, idx + 1, x, y - 1, n, m); visited[x][y] = false; return exist;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 557 - Reverse Words in a String III]]></title>
    <url>%2F2019%2F05%2F31%2FLeetCode-Problem-557-Reverse-Words-in-a-String-III%2F</url>
    <content type="text"><![CDATA[Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. ExampleInput: “Let’s take LeetCode contest” Output: “s’teL ekat edoCteeL tsetnoc” NoteIn the string, each word is separated by single space and there will not be any extra space in the string. Code1234567891011121314151617181920212223242526272829public String reverseWords(String s) &#123; char[] str = s.toCharArray(); for (int i = 0; i &lt; str.length;) &#123; int j = i + 1; for (; j &lt; str.length; j++) &#123; if (str[j] == ' ') break; &#125; reverse(str, i, j - 1); i = j + 1; &#125; return String.valueOf(str);&#125;private void reverse(char[] str, int start, int end) &#123; while (start &lt; end) &#123; char temp = str[end]; str[end] = str[start]; str[start] = temp; start++; end--; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 927 - Reverse Words in a String II]]></title>
    <url>%2F2019%2F05%2F31%2FLintCode-Problem-927-Reverse-Words-in-a-String-II%2F</url>
    <content type="text"><![CDATA[Given an input character array, reverse the array word by word. A word is defined as a sequence of non-space characters. The input character array does not contain leading or trailing spaces and the words are always separated by a single space. ExampleInput: [“t”,”h”,”e”,” “,”s”,”k”,”y”,” “,”i”,”s”,” “,”b”,”l”,”u”,”e”] Output: [“b”,”l”,”u”,”e”,” “,”i”,”s”,” “,”s”,”k”,”y”,” “,”t”,”h”,”e”] ChallengeCould you do it in-place without allocating extra space? Code1234567891011121314151617181920212223242526272829public char[] reverseWords(char[] str) &#123; reverse(str, 0, str.length - 1); for (int i = 0; i &lt; str.length;) &#123; int j = i + 1; for (; j &lt; str.length; j++) &#123; if (str[j] == ' ') break; &#125; reverse(str, i, j - 1); i = j + 1; &#125; return str;&#125;private void reverse(char[] str, int start, int end) &#123; while (start &lt; end) &#123; char temp = str[end]; str[end] = str[start]; str[start] = temp; start++; end--; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 151 - Reverse Words in a String]]></title>
    <url>%2F2019%2F05%2F31%2FLeetCode-Problem-151-Reverse-Words-in-a-String%2F</url>
    <content type="text"><![CDATA[Given an input string, reverse the string word by word. ExampleNo.1Input: “the sky is blue” Output: “blue is sky the” No.2Input: “ hello world! “ Output: “world! hello” Explanation: Your reversed string should not contain leading or trailing spaces. No.3Input: “a good example” Output: “example good a” Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string. Note A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string. Code1234567891011121314public String reverseWords(String s) &#123; StringBuilder sb = new StringBuilder(); String[] str = s.trim().split(" "); int index = str.length - 1; while (index &gt;= 0) &#123; if (str[index].length() &gt; 0) sb.append(str[index]).append(" "); index--; &#125; return sb.toString().trim();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 541 - Reverse String II]]></title>
    <url>%2F2019%2F05%2F31%2FLeetCode-Problem-541-Reverse-String-II%2F</url>
    <content type="text"><![CDATA[Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original. ExampleInput: s = “abcdefg”, k = 2 Output: “bacdfeg” Restrictions The string consists of lower English letters only. Length of the given string and k will in the range [1, 10000] Code12345678910111213141516171819public String reverseStr(String s, int k) &#123; char[] str = s.toCharArray(); for (int i = 0; i &lt; s.length(); i += 2 * k) &#123; int start = i; int end = Math.min(i + k - 1, s.length() - 1); while (start &lt; end) &#123; char temp = str[end]; str[end] = str[start]; str[start] = temp; start++; end--; &#125; &#125; return String.valueOf(str);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 344 - Reverse String]]></title>
    <url>%2F2019%2F05%2F31%2FLeetCode-Problem-344-Reverse-String%2F</url>
    <content type="text"><![CDATA[Write a function that reverses a string. The input string is given as an array of characters char[]. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. You may assume all the characters consist of printable ascii characters. ExampleNo.1Input: [“h”,”e”,”l”,”l”,”o”] Output: [“o”,”l”,”l”,”e”,”h”] No.2Input: [“H”,”a”,”n”,”n”,”a”,”h”] Output: [“h”,”a”,”n”,”n”,”a”,”H”] Code12345678910111213public void reverseString(char[] s) &#123; int start = 0; int end = s.length - 1; while (start &lt; end) &#123; char temp = s[end]; s[end] = s[start]; s[start] = temp; start++; end--; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 872 - Leaf-Similar Trees]]></title>
    <url>%2F2019%2F05%2F30%2FLeetCode-Problem-872-Leaf-Similar-Trees%2F</url>
    <content type="text"><![CDATA[Consider all the leaves of a binary tree. From left to right order, the values of those leaves form a leaf value sequence. For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary trees are considered leaf-similar if their leaf value sequence is the same. Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar. Note Both of the given trees will have between 1 and 100 nodes. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718public boolean leafSimilar(TreeNode root1, TreeNode root2) &#123; List&lt;Integer&gt; leaves1 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; leaves2 = new ArrayList&lt;&gt;(); dfs(leaves1, root1); dfs(leaves2, root2); return leaves1.equals(leaves2);&#125;private void dfs(List&lt;Integer&gt; leaves, TreeNode root) &#123; if (root == null) return; if (root.left == null &amp;&amp; root.right == null) leaves.add(root.val); dfs(leaves, root.left); dfs(leaves, root.right);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 543 - Diameter of Binary Tree]]></title>
    <url>%2F2019%2F05%2F30%2FLeetCode-Problem-543-Diameter-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. ExampleGiven a binary tree 12345 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. NoteThe length of path between two nodes is represented by the number of edges between them. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718private int max = 1;public int diameterOfBinaryTree(TreeNode root) &#123; dfs(root); return max - 1;&#125;private int dfs(TreeNode root) &#123; if (root == null) return 0; int left = dfs(root.left); int right = dfs(root.right); max = Math.max(max, left + right + 1); return Math.max(left, right) + 1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 979 - Distribute Coins in Binary Tree]]></title>
    <url>%2F2019%2F05%2F30%2FLeetCode-Problem-979-Distribute-Coins-in-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given the root of a binary tree with N nodes, each node in the tree has node.val coins, and there are N coins total. In one move, we may choose two adjacent nodes and move one coin from one node to another. (The move may be from parent to child, or from child to parent.) Return the number of moves required to make every node have exactly one coin. ExampleNo.1 Input: [3,0,0] Output: 2 Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child. No.2 Input: [0,3,0] Output: 3 Explanation: From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child. No.3 Input: [1,0,2] Output: 2 No.4 Input: [1,0,0,null,3] Output: 4 Note 1&lt;= N &lt;= 100 0 &lt;= node.val &lt;= N Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718private int result = 0;public int distributeCoins(TreeNode root) &#123; dfs(root); return result;&#125;private int dfs(TreeNode root) &#123; if (root == null) return 0; int left = dfs(root.left); int right = dfs(root.right); result += Math.abs(left) + Math.abs(right); return left + right + root.val - 1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 394 - Decode String]]></title>
    <url>%2F2019%2F05%2F24%2FLeetCode-Problem-394-Decode-String%2F</url>
    <content type="text"><![CDATA[Given an encoded string, return it’s decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4]. Exampless = “3[a]2[bc]”, return “aaabcbc”.s = “3[a2[c]]”, return “accaccacc”.s = “2[abc]3[cd]ef”, return “abcabccdcdcdef”. Code123456789101112131415161718192021222324252627282930public String decodeString(String s) &#123; Stack&lt;String&gt; strStack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; intStack = new Stack&lt;&gt;(); StringBuilder sb = new StringBuilder(); int number = 0; for (char ch : s.toCharArray()) &#123; if (Character.isDigit(ch)) number = 10 * number + ch - '0'; else if (ch == '[') &#123; intStack.push(number); strStack.push(sb.toString()); number = 0; sb.setLength(0); &#125; else if (ch == ']') &#123; int count = intStack.pop(); StringBuilder temp = new StringBuilder(strStack.pop()); for (int i = 0; i &lt; count; i++) temp.append(sb); sb = temp; &#125; else sb.append(String.valueOf(ch)); &#125; return sb.toString();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 809 - Expressive Words]]></title>
    <url>%2F2019%2F05%2F24%2FLeetCode-Problem-809-Expressive-Words%2F</url>
    <content type="text"><![CDATA[Sometimes people repeat letters to represent extra feeling, such as “hello” -&gt; “heeellooo”, “hi” -&gt; “hiiii”. In these strings like “heeellooo”, we have groups of adjacent letters that are all the same: “h”, “eee”, “ll”, “ooo”. For some given string S, a query word is stretchy if it can be made to be equal to S by any number of applications of the following extension operation: choose a group consisting of characters c, and add some number of characters c to the group so that the size of the group is 3 or more. For example, starting with “hello”, we could do an extension on the group “o” to get “hellooo”, but we cannot get “helloo” since the group “oo” has size less than 3. Also, we could do another extension like “ll” -&gt; “lllll” to get “helllllooo”. If S = “helllllooo”, then the query word “hello” would be stretchy because of these two extension operations: query = “hello” -&gt; “hellooo” -&gt; “helllllooo” = S. Given a list of query words, return the number of words that are stretchy. ExampleInput:S = “heeellooo”words = [“hello”, “hi”, “helo”] Output: 1 Explanation:We can extend “e” and “o” in the word “hello” to get “heeellooo”.We can’t extend “helo” to get “heeellooo” because the group “ll” is not size 3 or more. Notes 0 &lt;= len(S) &lt;= 100. 0 &lt;= len(words) &lt;= 100. 0 &lt;= len(words[i]) &lt;= 100. S and all words in words consist only of lowercase letters Code12345678910111213141516171819202122232425public int expressiveWords(String S, String[] words) &#123; int result = 0; for (String word : words) &#123; int i = 0; int j = 0; int m = S.length(); int n = word.length(); for (; i &lt; m; i++) &#123; if (j &lt; n &amp;&amp; word.charAt(j) == S.charAt(i)) j++; else if (i &gt; 0 &amp;&amp; S.charAt(i) == S.charAt(i - 1) &amp;&amp; i &lt; S.length() - 1 &amp;&amp; S.charAt(i) == S.charAt(i + 1)) i++; else if (i &lt;= 1 || S.charAt(i) != S.charAt(i - 1) || S.charAt(i) != S.charAt(i - 2)) break; &#125; if (i == m &amp;&amp; j == n) result++; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 341 - Flatten Nested List Iterator]]></title>
    <url>%2F2019%2F05%2F24%2FLeetCode-Problem-341-Flatten-Nested-List-Iterator%2F</url>
    <content type="text"><![CDATA[Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list – whose elements may also be integers or other lists. ExampleNo.1Input: [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. No.2Input: [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. Code12345public interface NestedInteger &#123; public boolean isInteger(); public Integer getInteger(); public List&lt;NestedInteger&gt; getList();&#125; 12345678910111213141516171819202122232425private Stack&lt;NestedInteger&gt; stack = new Stack&lt;&gt;();public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123; push(nestedList);&#125;@Overridepublic Integer next() &#123; return hasNext() ? stack.pop().getInteger() : null;&#125;@Overridepublic boolean hasNext() &#123; while (!stack.isEmpty() &amp;&amp; !stack.peek().isInteger()) &#123; NestedInteger nestedInteger = stack.pop(); push(nestedInteger.getList()); &#125; return !stack.isEmpty();&#125;private void push(List&lt;NestedInteger&gt; list) &#123; for (int i = list.size() - 1; i &gt;= 0; i--) stack.push(list.get(i));&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 900 - RLE Iterator]]></title>
    <url>%2F2019%2F05%2F24%2FLeetCode-Problem-900-RLE-Iterator%2F</url>
    <content type="text"><![CDATA[Write an iterator that iterates through a run-length encoded sequence. The iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some sequence. More specifically, for all even i, A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence. The iterator supports one function: next(int n), which exhausts the next n elements (n &gt;= 1) and returns the last element exhausted in this way. If there is no element left to exhaust, next returns -1 instead. For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5]. This is because the sequence can be read as “three eights, zero nines, two fives”. ExampleInput: [“RLEIterator”,”next”,”next”,”next”,”next”], [[[3,8,0,9,2,5]],[2],[1],[1],[2]] Output: [null,8,8,5,-1] Explanation:RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]).This maps to the sequence [8,8,8,5,5].RLEIterator.next is then called 4 times: .next(2) exhausts 2 terms of the sequence, returning 8. The remaining sequence is now [8, 5, 5]. .next(1) exhausts 1 term of the sequence, returning 8. The remaining sequence is now [5, 5]. .next(1) exhausts 1 term of the sequence, returning 5. The remaining sequence is now [5]. .next(2) exhausts 2 terms, returning -1. This is because the first term exhausted was 5,but the second term did not exist. Since the last term exhausted does not exist, we return -1. Note 0 &lt;= A.length &lt;= 1000 A.length is an even integer. 0 &lt;= A[i] &lt;= 10^9 There are at most 1000 calls to RLEIterator.next(int n) per test case. Each call to RLEIterator.next(int n) will have 1 &lt;= n &lt;= 10^9. Code12345678910111213141516171819private int curPos = 0;private int[] A;public RLEIterator(int[] A) &#123; this.A = A;&#125;public int next(int n) &#123; while (curPos &lt; A.length - 1 &amp;&amp; n &gt; A[curPos]) &#123; n -= A[curPos]; curPos += 2; &#125; if (curPos &gt; A.length - 1) return -1; A[curPos] -= n; return A[curPos + 1];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 284 - Peeking Iterator]]></title>
    <url>%2F2019%2F05%2F23%2FLeetCode-Problem-284-Peeking-Iterator%2F</url>
    <content type="text"><![CDATA[Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation – it essentially peek() at the element that will be returned by the next call to next(). ExampleAssume that the iterator is initialized to the beginning of the list: [1,2,3]. Call next() gets you 1, the first element in the list.Now you call peek() and it returns 2, the next element. Calling next() after that still return 2.You call next() the final time and it returns 3, the last element.Calling hasNext() after that should return false. Follow upHow would you extend your design to be generic and work with all types, not just integer? Code1234567891011121314151617181920212223private Iterator&lt;Integer&gt; iterator;private Integer next;public PeekingIterator(Iterator&lt;Integer&gt; iterator) &#123; this.iterator = iterator; next = iterator.next();&#125;public Integer peek() &#123; return next;&#125;@Overridepublic Integer next() &#123; int result = next; next = iterator.hasNext() ? iterator.next() : null; return result;&#125;@Overridepublic boolean hasNext() &#123; return next != null;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 601 - Flatten 2D Vector]]></title>
    <url>%2F2019%2F05%2F23%2FLintCode-Problem-601-Flatten-2D-Vector%2F</url>
    <content type="text"><![CDATA[Implement an iterator to flatten a 2d vector. ExampleNo.1Input:[[1,2],[3],[4,5,6]] Output:[1,2,3,4,5,6] No.2Input:[[7,9],[5]] Output:[7,9,5] Code12345678910111213141516171819202122private Iterator&lt;List&lt;Integer&gt;&gt; row;private Iterator&lt;Integer&gt; col;public Vector2D(List&lt;List&lt;Integer&gt;&gt; vec2d) &#123; row = vec2d.iterator();&#125;@Overridepublic Integer next() &#123; if (!hasNext()) return null; return col.next();&#125;@Overridepublic boolean hasNext() &#123; while ((col == null || !col.hasNext()) &amp;&amp; row.hasNext()) col = row.next().iterator(); return col != null &amp;&amp; col.hasNext();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 535 - Encode and Decode TinyURL]]></title>
    <url>%2F2019%2F05%2F23%2FLeetCode-Problem-535-Encode-and-Decode-TinyURL%2F</url>
    <content type="text"><![CDATA[TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL. Code1234567891011121314151617181920212223242526272829303132private final String ALPHA_NUMERIC_STRING = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";private Map&lt;String, String&gt; shortToLong = new HashMap&lt;&gt;();private Map&lt;String, String&gt; longToShort = new HashMap&lt;&gt;();private String URL = "http://tinyurl.com/";private int SIZE = 6;public String encode(String longUrl) &#123; if (longToShort.containsKey(longUrl)) return URL + longToShort.get(longUrl); int hash = 0; StringBuilder shortUrl = new StringBuilder(); int length = ALPHA_NUMERIC_STRING.length(); for (int i = 0; i &lt; SIZE; i++) hash += (int) Math.random(); while (hash != 0 &amp;&amp; shortUrl.length() &lt; SIZE) &#123; shortUrl.append(ALPHA_NUMERIC_STRING.charAt(hash % length)); hash /= length; &#125; longToShort.put(longUrl, shortUrl.toString()); shortToLong.put(shortUrl.toString(), longUrl); return URL + shortUrl.toString();&#125;public String decode(String shortUrl) &#123; String hash = shortUrl.substring(shortUrl.lastIndexOf("/") + 1); return shortToLong.get(hash);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 919 - Complete Binary Tree Inserter]]></title>
    <url>%2F2019%2F05%2F21%2FLeetCode-Problem-919-Complete-Binary-Tree-Inserter%2F</url>
    <content type="text"><![CDATA[A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Write a data structure CBTInserter that is initialized with a complete binary tree and supports the following operations: CBTInserter(TreeNode root) initializes the data structure on a given tree with head node root; CBTInserter.insert(int v) will insert a TreeNode into the tree with value node.val = v so that the tree remains complete, and returns the value of the parent of the inserted TreeNode; CBTInserter.get_root() will return the head node of the tree. ExampleNo.1Input: inputs = [“CBTInserter”,”insert”,”get_root”], inputs = [[[1]],[2],[]] Output: [null,1,[1,2]] No.2Input: inputs = [“CBTInserter”,”insert”,”insert”,”get_root”], inputs = [[[1,2,3,4,5,6]],[7],[8],[]] Output: [null,3,4,[1,2,3,4,5,6,7,8]] Note The initial given tree is complete and contains between 1 and 1000 nodes. CBTInserter.insert is called at most 10000 times per test case. Every value of a given or inserted node is between 0 and 5000. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445private TreeNode root;private Queue&lt;TreeNode&gt; leaves;public CBTInserter(TreeNode root) &#123; this.root = root; leaves = new LinkedList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode node = queue.poll(); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); if (node.left == null || node.right == null) leaves.offer(node); &#125; &#125;&#125;public int insert(int v) &#123; TreeNode leaf = new TreeNode(v); TreeNode parent = leaves.peek(); if (parent.left == null) parent.left = leaf; else &#123; parent.right = leaf; leaves.poll(); &#125; leaves.offer(leaf); return parent.val;&#125;public TreeNode get_root() &#123; return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 614 - Binary Tree Longest Consecutive Sequence II]]></title>
    <url>%2F2019%2F05%2F21%2FLintCode-Problem-614-Binary-Tree-Longest-Consecutive-Sequence-II%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find the length(number of nodes) of the longest consecutive sequence(Monotonic and adjacent node values differ by 1) path.The path could be start and end at any node in the tree ExampleNo.1Input:{1,2,0,3} Output:4 Explanation: 12345 1 / \ 2 0 /3 0-1-2-3 No.2Input:{3,2,2} Output:2 Explanation: 123 3 / \2 2 2-3 Code12345678public class TreeNode &#123; public int val; public TreeNode left, right; public TreeNode(int val) &#123; this.val = val; this.left = this.right = null; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536public class ResultType &#123; private int increase; private int decrease; public ResultType(int increase, int decrease) &#123; this.increase = increase; this.decrease = decrease; &#125;&#125;private int max = 0;public int longestConsecutive2(TreeNode root) &#123; dfs(root, null); return max;&#125;private ResultType dfs(TreeNode root, TreeNode parent) &#123; if (root == null) return new ResultType(0, 0); ResultType left = dfs(root.left, root); ResultType right = dfs(root.right, root); max = Math.max(max, left.increase + right.decrease + 1); max = Math.max(max, left.decrease + right.increase + 1); int increase = 0; int decrease = 0; if (parent == null || root.val + 1 == parent.val) decrease = Math.max(left.decrease, right.decrease) + 1; else if (parent == null || root.val - 1 == parent.val) increase = Math.max(left.increase, right.increase) + 1; return new ResultType(increase, decrease);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 595 - Binary Tree Longest Consecutive Sequence]]></title>
    <url>%2F2019%2F05%2F21%2FLintCode-Problem-595-Binary-Tree-Longest-Consecutive-Sequence%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find the length of the longest consecutive sequence path. The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path need to be from parent to child (cannot be the reverse). ExampleNo.1Input: 12345671 \ 3 / \2 4 \ 5 Output:3 Explanation:Longest consecutive sequence path is 3-4-5, so return 3. No.2Input: 1234567 2 \ 3 / 2 / 1 Output:2 Explanation:Longest consecutive sequence path is 2-3, not 3-2-1, so return 2. Code12345678public class TreeNode &#123; public int val; public TreeNode left, right; public TreeNode(int val) &#123; this.val = val; this.left = this.right = null; &#125;&#125; 1234567891011121314151617private int max = 0;public int longestConsecutive(TreeNode root) &#123; dfs(root, null, 0); return max;&#125;private void dfs(TreeNode root, TreeNode parent, int count) &#123; if (root == null) return; count = (parent == null) || (root.val - parent.val == 1) ? count + 1 : 1; max = Math.max(max, count); dfs(root.left, root, count); dfs(root.right, root, count);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 878 - Boundary of Binary Tree]]></title>
    <url>%2F2019%2F05%2F20%2FLintCode-Problem-878-Boundary-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the values of its boundary in anti-clockwise direction starting from root. Boundary includes left boundary, leaves, and right boundary in order without duplicate nodes. Left boundary is defined as the path from root to the left-most node. Right boundary is defined as the path from root to the right-most node. If the root doesn’t have left subtree or right subtree, then the root itself is left boundary or right boundary. Note this definition only applies to the input binary tree, and not applies to any subtrees. The left-most node is defined as a leaf node you could reach when you always firstly travel to the left subtree if exists. If not, travel to the right subtree. Repeat until you reach a leaf node. The right-most node is also defined by the same way with left and right exchanged. ExampleNo.1Input: {1,#,2,3,4} Output: [1,3,4,2] Explanation: 123451 \ 2 / \3 4 The root doesn’t have left subtree, so the root itself is left boundary. The leaves are node 3 and 4. The right boundary are node 1,2,4. Note the anti-clockwise direction means you should output reversed right boundary. So order them in anti-clockwise without duplicates and we have [1,3,4,2]. No.2nput: {1,2,3,4,5,6,#,#,#,7,8,9,10} Output: [1,2,4,7,8,9,10,6,3] Explanation: 1234567 1 / \ 2 3 / \ / 4 5 6 / \ / \ 7 8 9 10 The left boundary are node 1,2,4. (4 is the left-most node according to definition) The leaves are node 4,7,8,9,10. The right boundary are node 1,3,6,10. (10 is the right-most node). So order them in anti-clockwise without duplicate nodes we have [1,2,4,7,8,9,10,6,3]. Code12345678public class TreeNode &#123; public int val; public TreeNode left, right; public TreeNode(int val) &#123; this.val = val; this.left = this.right = null; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public List&lt;Integer&gt; boundaryOfBinaryTree(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; result.add(root.val); traverseLeft(result, root.left); traverseLeaf(result, root); traverseRight(result, root.right); return result;&#125;private void traverseLeft(List&lt;Integer&gt; result, TreeNode root) &#123; if (root == null) return; if (root.left == null &amp;&amp; root.right == null) return; result.add(root.val); if (root.left != null) traverseLeft(result, root.left); else traverseLeft(result, root.right);&#125;private void traverseLeaf(List&lt;Integer&gt; result, TreeNode root) &#123; if (root == null) return; if (root.left == null &amp;&amp; root.right == null) &#123; result.add(root.val); return; &#125; traverseLeaf(result, root.left); traverseLeaf(result, root.right);&#125;private void traverseRight(List&lt;Integer&gt; result, TreeNode root) &#123; if (root == null) return; if (root.left == null &amp;&amp; root.right == null) return; if (root.right != null) traverseRight(result, root.right); else traverseRight(result, root.left); result.add(root.val);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 864 - Equal Tree Partition]]></title>
    <url>%2F2019%2F05%2F20%2FLintCode-Problem-864-Equal-Tree-Partition%2F</url>
    <content type="text"><![CDATA[Given a binary tree with n nodes, your task is to check if it’s possible to partition the tree to two trees which have the equal sum of values after removing exactly one edge on the original tree. Note The range of tree node value is in the range of [-100000, 100000]. 1 &lt;= n &lt;= 10000 You can assume that the tree is not null ExampleNo.1Input: {5,10,10,#,#,2,3} Output: true Explanation: origin: 12345 5 / \10 10 / \ 2 3 two subtrees: 123 5 10 / / \10 2 3 No.2Input: {1,2,10,#,#,2,20} Output: false Explanation: origin: 12345 1 / \2 10 / \ 2 20 Code12345678public class TreeNode &#123; public int val; public TreeNode left, right; public TreeNode(int val) &#123; this.val = val; this.left = this.right = null; &#125;&#125; 1234567891011121314151617181920212223242526private Set&lt;Integer&gt; set = new HashSet&lt;&gt;();private int countZero = 0;public boolean checkEqualTree(TreeNode root) &#123; int sum = helper(root); if (countZero != 0) return countZero % 2 == 0; return set.contains(sum &gt;&gt; 1);&#125;private int helper(TreeNode root) &#123; if (root == null) return 0; int left = helper(root.left); int right = helper(root.right); int sum = left + right + root.val; if (sum == 0) countZero++; set.add(sum); return sum;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 114 - Flatten Binary Tree to Linked List]]></title>
    <url>%2F2019%2F05%2F18%2FLeetCode-Problem-114-Flatten-Binary-Tree-to-Linked-List%2F</url>
    <content type="text"><![CDATA[Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 12345 1 / \ 2 5 / \ \3 4 6 The flattened tree should look like: 12345678910111 \ 2 \ 3 \ 4 \ 5 \ 6 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516171819202122232425public void flatten(TreeNode root) &#123; helper(root);&#125;private TreeNode helper(TreeNode root) &#123; if (root == null) return null; TreeNode leftTail = helper(root.left); TreeNode rightTail = helper(root.right); if (root.left != null) &#123; TreeNode temp = root.right; root.right = root.left; root.left = null; leftTail.right = temp; &#125; if (rightTail != null) return rightTail; else if (leftTail != null) return leftTail; else return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 897 - Increasing Order Search Tree]]></title>
    <url>%2F2019%2F05%2F18%2FLeetCode-Problem-897-Increasing-Order-Search-Tree%2F</url>
    <content type="text"><![CDATA[Given a tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child. ExampleNo.1Input: [5,3,6,2,4,null,8,1,null,null,null,7,9] 1234567 5 / \ 3 6 / \ \ 2 4 8 / / \ 1 7 9 Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 12345678910111213141516171 \ 2 \ 3 \ 4 \ 5 \ 6 \ 7 \ 8 \ 9 Note The number of nodes in the given tree will be between 1 and 100. Each node will have a unique integer value from 0 to 1000. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021private TreeNode prev;public TreeNode increasingBST(TreeNode root) &#123; TreeNode dummy = new TreeNode(-1); prev = dummy; helper(root); return dummy.right;&#125;private void helper(TreeNode root) &#123; if (root == null) return; helper(root.left); prev.right = root; root.left = null; prev = root; helper(root.right);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 222 - Count Complete Tree Nodes]]></title>
    <url>%2F2019%2F05%2F17%2FLeetCode-Problem-222-Count-Complete-Tree-Nodes%2F</url>
    <content type="text"><![CDATA[Given a complete binary tree, count the number of nodes. NoteDefinition of a complete binary tree from Wikipedia:In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2^h nodes inclusive at the last level h. ExampleInput: 12345 1 / \ 2 3 / \ /4 5 6 Output: 6 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516171819202122232425262728293031public int countNodes(TreeNode root) &#123; int leftHeight = getLeftHeight(root); int rightHeight = getRightHeight(root); if (leftHeight == rightHeight) return (int) Math.pow(2, leftHeight) - 1; else return countNodes(root.left) + countNodes(root.right) + 1;&#125;private int getLeftHeight(TreeNode root) &#123; int height = 0; while (root != null) &#123; height++; root = root.left; &#125; return height;&#125;private int getRightHeight(TreeNode root) &#123; int height = 0; while (root != null) &#123; height++; root = root.right; &#125; return height;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 993 - Cousins in Binary Tree]]></title>
    <url>%2F2019%2F05%2F17%2FLeetCode-Problem-993-Cousins-in-Binary-Tree%2F</url>
    <content type="text"><![CDATA[In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1. Two nodes of a binary tree are cousins if they have the same depth, but have different parents. We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree. Return true if and only if the nodes corresponding to the values x and y are cousins. ExampleNo.1 Input: root = [1,2,3,4], x = 4, y = 3 Output: false No.2 Input: root = [1,2,3,null,4,null,5], x = 5, y = 4 Output: true No.3 Input: root = [1,2,3,null,4], x = 2, y = 3 Output: false Note The number of nodes in the tree will be between 2 and 100. Each node has a unique integer value from 1 to 100. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839public boolean isCousins(TreeNode root, int x, int y) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; int size = queue.size(); int xParent = 0; int yParent = 0; for (int i = 0; i &lt; size; i++) &#123; TreeNode node = queue.poll(); if (node.left != null) &#123; queue.offer(node.left); if (node.left.val == x) xParent = node.val; if (node.left.val == y) yParent = node.val; &#125; if (node.right != null) &#123; queue.offer(node.right); if (node.right.val == x) xParent = node.val; if (node.right.val == y) yParent = node.val; &#125; &#125; if (xParent != 0 &amp;&amp; yParent != 0) return xParent != yParent; else if (xParent != 0 || yParent != 0) return false; &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 507 - Perfect Number]]></title>
    <url>%2F2019%2F05%2F17%2FLeetCode-Problem-507-Perfect-Number%2F</url>
    <content type="text"><![CDATA[We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself. Now, given an integer n, write a function that returns true when it is a perfect number and false when it is not. ExampleInput: 28 Output: True Explanation: 28 = 1 + 2 + 4 + 7 + 14 NoteThe input number n will not exceed 100,000,000. (1e8) Code12345678910111213public boolean checkPerfectNumber(int num) &#123; if (num == 1) return false; int sum = 1; for (int i = 2; i &lt;= num / i; i++) &#123; if (num % i == 0) sum += (i == num / i) ? i : i + num / i; &#125; return sum == num;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 367 - Valid Perfect Square]]></title>
    <url>%2F2019%2F05%2F17%2FLeetCode-Problem-367-Valid-Perfect-Square%2F</url>
    <content type="text"><![CDATA[Given a positive integer num, write a function which returns True if num is a perfect square else False. NoteDo not use any built-in library function such as sqrt. ExampleNo.1Input: 16 Output: true No.2Input: 14 Output: false Code123456789101112131415161718public boolean isPerfectSquare(int num) &#123; int start = 1; int end = num; while (start &lt;= end) &#123; int mid = start + (end - start) / 2; float divide = num / (float) mid; if (mid == divide) return true; else if (mid &gt; divide) end = mid - 1; else start = mid + 1; &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 279 - Perfect Squares]]></title>
    <url>%2F2019%2F05%2F16%2FLeetCode-Problem-279-Perfect-Squares%2F</url>
    <content type="text"><![CDATA[Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n. ExampleNo.1Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. No.2Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. Code12345678910111213// dp[n] = min&#123;dp[n-i*i] + 1&#125;, n-i*i &gt;= 0, i &gt;= 1public int numSquares(int n) &#123; int[] dp = new int[n + 1]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j * j &lt;= i; j++) dp[i] = Math.min(dp[i], dp[i - j * j] + 1); &#125; return dp[n];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 204 - Count Primes]]></title>
    <url>%2F2019%2F05%2F16%2FLeetCode-Problem-204-Count-Primes%2F</url>
    <content type="text"><![CDATA[Count the number of prime numbers less than a non-negative number, n. ExampleInput: 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7. Code123456789101112131415public int countPrimes(int n) &#123; boolean[] notPrime = new boolean[n + 1]; int count = 0; for (int i = 2; i &lt; n; i++) &#123; if (!notPrime[i]) &#123; count++; for (int j = i; j &lt;= n / i; j++) notPrime[i * j] = true; &#125; &#125; return count;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 558 - Quad Tree Intersection]]></title>
    <url>%2F2019%2F05%2F15%2FLeetCode-Problem-558-Quad-Tree-Intersection%2F</url>
    <content type="text"><![CDATA[A quadtree is a tree data in which each internal node has exactly four children: topLeft, topRight, bottomLeft and bottomRight. Quad trees are often used to partition a two-dimensional space by recursively subdividing it into four quadrants or regions. We want to store True/False information in our quad tree. The quad tree is used to represent a N * N boolean grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same. Each node has another two boolean attributes : isLeaf and val. isLeaf is true if and only if the node is a leaf node. The val attribute for a leaf node contains the value of the region it represents. For example, below are two quad trees A and B: 123456789101112131415161718192021222324252627282930313233A:+-------+-------+ T: true| | | F: false| T | T || | |+-------+-------+| | || F | F || | |+-------+-------+topLeft: TtopRight: TbottomLeft: FbottomRight: FB: +-------+---+---+| | F | F || T +---+---+| | T | T |+-------+---+---+| | || T | F || | |+-------+-------+topLeft: TtopRight: topLeft: F topRight: F bottomLeft: T bottomRight: TbottomLeft: TbottomRight: F Your task is to implement a function that will take two quadtrees and return a quadtree that represents the logical OR (or union) of the two trees. 12345678910A: B: C (A or B):+-------+-------+ +-------+---+---+ +-------+-------+| | | | | F | F | | | || T | T | | T +---+---+ | T | T || | | | | T | T | | | |+-------+-------+ +-------+---+---+ +-------+-------+| | | | | | | | || F | F | | T | F | | T | F || | | | | | | | |+-------+-------+ +-------+-------+ +-------+-------+ Note Both A and B represent grids of size N * N. N is guaranteed to be a power of 2. If you want to know more about the quad tree, you can refer to its wiki. The logic OR operation is defined as this: “A or B” is true if A is true, or if B is true, or if both A and B are true. Code123456789101112131415161718public class Node &#123; public boolean val; public boolean isLeaf; public Node topLeft; public Node topRight; public Node bottomLeft; public Node bottomRight; public Node(boolean _val, boolean _isLeaf, Node _topLeft, Node _topRight, Node _bottomLeft, Node _bottomRight) &#123; val = _val; isLeaf = _isLeaf; topLeft = _topLeft; topRight = _topRight; bottomLeft = _bottomLeft; bottomRight = _bottomRight; &#125;&#125; 123456789101112131415161718public Node intersect(Node quadTree1, Node quadTree2) &#123; if (quadTree1.isLeaf) return quadTree1.val ? quadTree1 : quadTree2; if (quadTree2.isLeaf) return quadTree2.val ? quadTree2 : quadTree1; Node topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft); Node topRight = intersect(quadTree1.topRight, quadTree2.topRight); Node bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft); Node bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight); if (topLeft.isLeaf &amp;&amp; topRight.isLeaf &amp;&amp; bottomLeft.isLeaf &amp;&amp; bottomRight.isLeaf &amp;&amp; topLeft.val == topRight.val &amp;&amp; topLeft.val == bottomLeft.val &amp;&amp; topLeft.val == bottomRight.val) return new Node(topLeft.val, true, null, null, null, null); else return new Node(false, false, topLeft, topRight, bottomLeft, bottomRight);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 427 - Construct Quad Tree]]></title>
    <url>%2F2019%2F05%2F15%2FLeetCode-Problem-427-Construct-Quad-Tree%2F</url>
    <content type="text"><![CDATA[We want to use quad trees to store an N x N boolean grid. Each cell in the grid can only be true or false. The root node represents the whole grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same. Each node has another two boolean attributes : isLeaf and val. isLeaf is true if and only if the node is a leaf node. The val attribute for a leaf node contains the value of the region it represents. Your task is to use a quad tree to represent a given grid. The following example may help you understand the problem better: Given the 8 x 8 grid below, we want to construct the corresponding quad tree: It can be divided according to the definition above: The corresponding quad tree should be as following, where each node is represented as a (isLeaf, val) pair. For the non-leaf nodes, val can be arbitrary, so it is represented as *. Note N is less than 1000 and guaranteened to be a power of 2. If you want to know more about the quad tree, you can refer to its wiki. Code123456789101112131415161718public class Node &#123; public boolean val; public boolean isLeaf; public Node topLeft; public Node topRight; public Node bottomLeft; public Node bottomRight; public Node(boolean _val, boolean _isLeaf, Node _topLeft, Node _topRight, Node _bottomLeft, Node _bottomRight) &#123; val = _val; isLeaf = _isLeaf; topLeft = _topLeft; topRight = _topRight; bottomLeft = _bottomLeft; bottomRight = _bottomRight; &#125;&#125; 123456789101112131415161718192021222324252627282930313233public Node construct(int[][] grid) &#123; return helper(grid, 0, 0, grid.length - 1, grid.length - 1);&#125;private Node helper(int[][] grid, int x1, int y1, int x2, int y2) &#123; if (x1 &gt; x2 || y1 &gt; y2) return null; boolean isLeaf = true; for (int i = x1; i &lt;= x2; i++) &#123; for (int j = y1; j &lt;= y2; j++) &#123; if (grid[i][j] != grid[x1][y1]) &#123; isLeaf = false; break; &#125; &#125; &#125; if (isLeaf) &#123; return new Node(grid[x1][y1] == 1, isLeaf, null, null, null, null); &#125; int midX = (x1 + x2) &gt;&gt; 1; int midY = (y1 + y2) &gt;&gt; 1; return new Node(false, isLeaf, helper(grid, x1, y1, midX, midY), helper(grid, x1, midY + 1, midX, y2), helper(grid, midX + 1, y1, x2, midY), helper(grid, midX + 1, midY + 1, x2, y2));&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 696 - Count Binary Substrings]]></title>
    <url>%2F2019%2F05%2F14%2FLeetCode-Problem-696-Count-Binary-Substrings%2F</url>
    <content type="text"><![CDATA[Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0’s and 1’s, and all the 0’s and all the 1’s in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur. ExampleNo.1Input: “00110011” Output: 6 Explanation: There are 6 substrings that have equal number of consecutive 1’s and 0’s: “0011”, “01”, “1100”, “10”, “0011”, and “01”. Notice that some of these substrings repeat and are counted the number of times they occur. Also, “00110011” is not a valid substring because all the 0’s (and 1’s) are not grouped together. No.2Input: “10101” Output: 4 Explanation: There are 4 substrings: “10”, “01”, “10”, “01” that have equal number of consecutive 1’s and 0’s. Note s.length will be between 1 and 50,000. s will only consist of “0” or “1” characters. Code12345678910111213141516171819public int countBinarySubstrings(String s) &#123; int result = 0; int prev = 0; int current = 1; for (int i = 1; i &lt; s.length(); i++) &#123; if (s.charAt(i) != s.charAt(i - 1)) &#123; prev = current; current = 1; &#125; else current++; if (current &lt;= prev) result++; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 714 - Best Time to Buy and Sell Stock with Transaction Fee]]></title>
    <url>%2F2019%2F05%2F14%2FLeetCode-Problem-714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee%2F</url>
    <content type="text"><![CDATA[Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make. ExampleInput: prices = [1, 3, 2, 8, 4, 9], fee = 2 Output: 8 Explanation: The maximum profit can be achieved by:Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8. Note 0 &lt; prices.length &lt;= 50000. 0 &lt; prices[i] &lt; 50000. 0 &lt;= fee &lt; 50000. Code123456789101112131415161718192021// buy[i]: Max profit till index i. The series of transaction is ending with a buy.// sell[i]: Max profit till index i. The series of transaction is ending with a sell.// buy[i] = max(buy[i - 1], sell[i - 1] - prices[i])// sell[i] = max(sell[i - 1], buy[i - 1] + prices[i] - fee)public int maxProfit(int[] prices, int fee) &#123; if (prices == null || prices.length &lt;= 1) return 0; int b0, b1 = -prices[0]; int s0 = 0, s1 = 0; for (int i = 1; i &lt; prices.length; i++) &#123; b0 = Math.max(b1, s1 - prices[i]); s0 = Math.max(s1, b1 + prices[i] - fee); b1 = b0; s1 = s0; &#125; return s0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 309 - Best Time to Buy and Sell Stock with Cooldown]]></title>
    <url>%2F2019%2F05%2F14%2FLeetCode-Problem-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown%2F</url>
    <content type="text"><![CDATA[Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) ExampleInput: [1,2,3,0,2] Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell] Code12345678910111213141516171819202122// buy[i]: Max profit till index i. The series of transaction is ending with a buy.// sell[i]: Max profit till index i. The series of transaction is ending with a sell.// buy[i] = max(buy[i - 1], sell[i - 2] - prices[i])// sell[i] = max(sell[i - 1], buy[i - 1] + prices[i])public int maxProfit(int[] prices) &#123; if (prices == null || prices.length &lt;= 1) return 0; int b0, b1 = -prices[0]; int s0 = 0, s1 = 0, s2 = 0; for (int i = 1; i &lt; prices.length; i++) &#123; b0 = Math.max(b1, s2 - prices[i]); s0 = Math.max(s1, b1 + prices[i]); b1 = b0; s2 = s1; s1 = s0; &#125; return s0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 122 - Best Time to Buy and Sell Stock II]]></title>
    <url>%2F2019%2F05%2F13%2FLeetCode-Problem-122-Best-Time-to-Buy-and-Sell-Stock-II%2F</url>
    <content type="text"><![CDATA[Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). NoteYou may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). ExampleNo.1Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. No.2Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. No.3Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. Code12345678910public int maxProfit(int[] prices) &#123; int result = 0; for (int i = 1; i &lt; prices.length; i++) &#123; if (prices[i] &gt; prices[i - 1]) result += prices[i] - prices[i - 1]; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 121 - Best Time to Buy and Sell Stock]]></title>
    <url>%2F2019%2F05%2F13%2FLeetCode-Problem-121-Best-Time-to-Buy-and-Sell-Stock%2F</url>
    <content type="text"><![CDATA[Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. ExampleNo.1Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. No.2Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. Code12345678910111213public int maxProfit(int[] prices) &#123; int min = Integer.MAX_VALUE; int max = 0; for (int i = 0; i &lt; prices.length; i++) &#123; if (prices[i] &lt; min) min = prices[i]; else max = Math.max(max, prices[i] - min); &#125; return max;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 958 - Check Completeness of a Binary Tree]]></title>
    <url>%2F2019%2F05%2F11%2FLeetCode-Problem-958-Check-Completeness-of-a-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, determine if it is a complete binary tree. Definition of a complete binary tree from Wikipedia:In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2^h nodes inclusive at the last level h. ExampleNo.1 Input: [1,2,3,4,5,6] Output: true Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible. No.2 Input: [1,2,3,4,5,null,7] Output: false Explanation: The node with value 7 isn’t as far left as possible. Note The tree will have between 1 and 100 nodes. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021public boolean isCompleteTree(TreeNode root) &#123; boolean isNull = false; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); if (node == null) isNull = true; else &#123; if (isNull) return false; queue.offer(node.left); queue.offer(node.right); &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 572 - Subtree of Another Tree]]></title>
    <url>%2F2019%2F05%2F11%2FLeetCode-Problem-572-Subtree-of-Another-Tree%2F</url>
    <content type="text"><![CDATA[Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node’s descendants. The tree s could also be considered as a subtree of itself. ExampleNo.1Given tree s: 12345 3 / \ 4 5 / \1 2 Given tree t: 123 4 / \1 2 Return true, because t has the same structure and node values with a subtree of s. No.2Given tree s: 1234567 3 / \ 4 5 / \1 2 / 0 Given tree t: 123 4 / \1 2 Return false. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516171819public boolean isSubtree(TreeNode s, TreeNode t) &#123; if (s == null) return false; if (isSameTree(s, t)) return true; return isSubtree(s.left, t) || isSubtree(s.right, t);&#125;private boolean isSameTree(TreeNode s, TreeNode t) &#123; if (s == null &amp;&amp; t == null) return true; if (s == null || t == null || s.val != t.val) return false; return isSameTree(s.left, t.left) &amp;&amp; isSameTree(s.right, t.right);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 226 - Invert Binary Tree]]></title>
    <url>%2F2019%2F05%2F09%2FLeetCode-Problem-226-Invert-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Invert a binary tree. ExampleInput: 12345 4 / \ 2 7 / \ / \1 3 6 9 Output: 12345 4 / \ 7 2 / \ / \9 6 3 1 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910public TreeNode invertTree(TreeNode root) &#123; if (root == null) return null; TreeNode temp = invertTree(root.right); root.right = invertTree(root.left); root.left = temp; return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 814 - Binary Tree Pruning]]></title>
    <url>%2F2019%2F05%2F09%2FLeetCode-Problem-814-Binary-Tree-Pruning%2F</url>
    <content type="text"><![CDATA[We are given the head node root of a binary tree, where additionally every node’s value is either a 0 or a 1. Return the same tree where every subtree (of the given tree) not containing a 1 has been removed. (Recall that the subtree of a node X is X, plus every node that is a descendant of X.) ExampleNo.1Input: [1,null,0,0,1] Output: [1,null,0,null,1] Explanation:Only the red nodes satisfy the property “every subtree not containing a 1”.The diagram on the right represents the answer. No.2Input: [1,0,1,0,0,0,1] Output: [1,null,1,null,1] No.3Input: [1,1,0,1,1,0,1,0] Output: [1,1,0,1,1,null,1] Note The binary tree will have at most 100 nodes. The value of each node will only be 0 or 1. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789public TreeNode pruneTree(TreeNode root) &#123; if (root == null) return null; root.left = pruneTree(root.left); root.right = pruneTree(root.right); return (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == 0) ? null : root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 199 - Binary Tree Right Side View]]></title>
    <url>%2F2019%2F05%2F09%2FLeetCode-Problem-199-Binary-Tree-Right-Side-View%2F</url>
    <content type="text"><![CDATA[Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. ExampleInput: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 12345 1 &lt;--- / \2 3 &lt;--- \ \ 5 4 &lt;--- Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617181920212223242526public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; int size = queue.size(); result.add(queue.peekLast().val); for (int i = 0; i &lt; size; i++) &#123; TreeNode node = queue.poll(); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 590 - N-ary Tree Postorder Traversal]]></title>
    <url>%2F2019%2F05%2F08%2FLeetCode-Problem-590-N-ary-Tree-Postorder-Traversal%2F</url>
    <content type="text"><![CDATA[Given an n-ary tree, return the postorder traversal of its nodes’ values. For example, given a 3-ary tree: Return its postorder traversal as: [5,6,3,2,4,1]. NoteRecursive solution is trivial, could you do it iteratively? Code12345678public class Node &#123; public int val; public List&lt;Node&gt; children; public Node(int _val, List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125; 1234567891011121314151617181920public List&lt;Integer&gt; postorder(Node root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; Node node = stack.pop(); result.add(0, node.val); List&lt;Node&gt; children = node.children; for (Node child : children) stack.push(child); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 589 - N-ary Tree Preorder Traversal]]></title>
    <url>%2F2019%2F05%2F08%2FLeetCode-Problem-589-N-ary-Tree-Preorder-Traversal%2F</url>
    <content type="text"><![CDATA[Given an n-ary tree, return the preorder traversal of its nodes’ values. For example, given a 3-ary tree: Return its preorder traversal as: [1,3,5,6,2,4]. NoteRecursive solution is trivial, could you do it iteratively? Code12345678public class Node &#123; public int val; public List&lt;Node&gt; children; public Node(int _val, List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125; 1234567891011121314151617181920public List&lt;Integer&gt; preorder(Node root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; Node node = stack.pop(); result.add(node.val); List&lt;Node&gt; children = node.children; for (int i = children.size() - 1; i &gt;= 0; i--) stack.push(children.get(i)); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 429 - N-ary Tree Level Order Traversal]]></title>
    <url>%2F2019%2F05%2F08%2FLeetCode-Problem-429-N-ary-Tree-Level-Order-Traversal%2F</url>
    <content type="text"><![CDATA[Given an n-ary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example, given a 3-ary tree: We should return its level order traversal: 12345[ [1], [3,2,4], [5,6]] Note The depth of the tree is at most 1000. The total number of nodes is at most 5000. Code12345678public class Node &#123; public int val; public List&lt;Node&gt; children; public Node(int _val, List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125; 1234567891011121314151617181920212223242526272829public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; int size = queue.size(); List&lt;Integer&gt; nodes = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; size; i++) &#123; Node node = queue.poll(); nodes.add(node.val); List&lt;Node&gt; children = node.children; if (children != null) &#123; for (Node child : children) queue.offer(child); &#125; &#125; result.add(nodes); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 662 - Maximum Width of Binary Tree]]></title>
    <url>%2F2019%2F05%2F08%2FLeetCode-Problem-662-Maximum-Width-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a full binary tree, but some nodes are null. The width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the null nodes between the end-nodes are also counted into the length calculation. ExampleNo.1Input: 12345 1 / \ 3 2 / \ \ 5 3 9 Output: 4 Explanation: The maximum width existing in the third level with the length 4 (5,3,null,9). No.2Input: 123456789101112131415161718192021222324252627282930313233343536373839 1 / 3 / \ 5 3 ``` Output: 2Explanation: The maximum width existing in the third level with the length 2 (5,3).### No.3Input: ```bash 1 / \ 3 2 / 5 ``` Output: 2Explanation: The maximum width existing in the second level with the length 2 (3,2).### No.4Input: ```bash 1 / \ 3 2 / \ 5 9 / \ 6 7 Output: 8 Explanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7). NoteAnswer will in the range of 32-bit signed integer. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324252627282930public int widthOfBinaryTree(TreeNode root) &#123; if (root == null) return 0; int max = 0; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); root.val = 0; queue.offer(root); while (!queue.isEmpty()) &#123; int size = queue.size(); max = Math.max(max, queue.peekLast().val - queue.peekFirst().val + 1); for (int i = 0; i &lt; size; i++) &#123; TreeNode node = queue.poll(); if (node.left != null) &#123; node.left.val = node.val * 2; queue.offer(node.left); &#125; if (node.right != null) &#123; node.right.val = node.val * 2 + 1; queue.offer(node.right); &#125; &#125; &#125; return max;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 146 - LRU Cache]]></title>
    <url>%2F2019%2F05%2F08%2FLeetCode-Problem-146-LRU-Cache%2F</url>
    <content type="text"><![CDATA[Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow upCould you do both operations in O(1) time complexity? Example1234567891011LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 Code123456789101112131415161718private Map&lt;Integer, Integer&gt; map;public LRUCache(int capacity) &#123; map = new LinkedHashMap&lt;Integer, Integer&gt;(capacity, 0.75f, true) &#123; @Override protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) &#123; return map.size() &gt; capacity; &#125; &#125;;&#125;public int get(int key) &#123; return map.getOrDefault(key, -1);&#125;public void put(int key, int value) &#123; map.put(key, value);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 655 - Print Binary Tree]]></title>
    <url>%2F2019%2F05%2F04%2FLeetCode-Problem-655-Print-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Print a binary tree in an m*n 2D string array following these rules: The row number m should be equal to the height of the given binary tree. The column number n should always be an odd number. The root node’s value (in string format) should be put in the exactly middle of the first row it can be put. The column and the row where the root node belongs will separate the rest space into two parts (left-bottom part and right-bottom part). You should print the left subtree in the left-bottom part and print the right subtree in the right-bottom part. The left-bottom part and the right-bottom part should have the same size. Even if one subtree is none while the other is not, you don’t need to print anything for the none subtree but still need to leave the space as large as that for the other subtree. However, if two subtrees are none, then you don’t need to leave space for both of them. Each unused space should contain an empty string “”. Print the subtrees following the same rules. ExampleNo.1Input: 123 1 /2 Output:[[“”, “1”, “”], [“2”, “”, “”]] No.2Input: 12345 1 / \2 3 \ 4 Output:[[“”, “”, “”, “1”, “”, “”, “”], [“”, “2”, “”, “”, “”, “3”, “”], [“”, “”, “4”, “”, “”, “”, “”]] No.3Input: 1234567 1 / \ 2 5 / 3 / 4 Output:[[“”, “”, “”, “”, “”, “”, “”, “1”, “”, “”, “”, “”, “”, “”, “”] [“”, “”, “”, “2”, “”, “”, “”, “”, “”, “”, “”, “5”, “”, “”, “”] [“”, “3”, “”, “”, “”, “”, “”, “”, “”, “”, “”, “”, “”, “”, “”] [“4”, “”, “”, “”, “”, “”, “”, “”, “”, “”, “”, “”, “”, “”, “”]] NoteThe height of binary tree is in the range of [1, 10]. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536public List&lt;List&lt;String&gt;&gt; printTree(TreeNode root) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); int m = (root == null) ? 1 : getHeight(root); int n = (int) Math.pow(2, m) - 1; for (int i = 0; i &lt; m; i++) &#123; List&lt;String&gt; list = Arrays.asList(new String[n]); Collections.fill(list, ""); result.add(list); &#125; helper(result, root, 0, 0, n - 1); return result;&#125;private int getHeight(TreeNode root) &#123; if (root == null) return 0; return 1 + Math.max(getHeight(root.left), getHeight(root.right));&#125;private void helper(List&lt;List&lt;String&gt;&gt; result, TreeNode root, int currentHeight, int start, int end) &#123; if (root == null) return; int mid = start + (end - start) / 2; List&lt;String&gt; list = result.get(currentHeight); list.set(mid, String.valueOf(root.val)); helper(result, root.left, currentHeight + 1, start, mid - 1); helper(result, root.right, currentHeight + 1, mid + 1, end);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 563 - Binary Tree Tilt]]></title>
    <url>%2F2019%2F05%2F04%2FLeetCode-Problem-563-Binary-Tree-Tilt%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the tilt of the whole tree. The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0. The tilt of the whole tree is defined as the sum of all nodes’ tilt. ExampleInput: 123 1 / \2 3 Output: 1 Explanation:Tilt of node 2 : 0Tilt of node 3 : 0Tilt of node 1 : |2-3| = 1Tilt of binary tree : 0 + 0 + 1 = 1 Note The sum of node values in any subtree won’t exceed the range of 32-bit integer. All the tilt values won’t exceed the range of 32-bit integer. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718private int tilt = 0;public int findTilt(TreeNode root) &#123; postorder(root); return tilt;&#125;private int postorder(TreeNode root) &#123; if (root == null) return 0; int left = postorder(root.left); int right = postorder(root.right); tilt += Math.abs(left - right); return left + right + root.val;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 654 - Maximum Binary Tree]]></title>
    <url>%2F2019%2F05%2F04%2FLeetCode-Problem-654-Maximum-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given an integer array with no duplicates. A maximum tree building on this array is defined as follow: The root is the maximum number in the array. The left subtree is the maximum tree constructed from left part subarray divided by the maximum number. The right subtree is the maximum tree constructed from right part subarray divided by the maximum number. Construct the maximum tree by the given array and output the root node of this tree. ExampleInput: [3,2,1,6,0,5] Output: return the tree root node representing the following tree: 1234567 6 / \3 5 \ / 2 0 \ 1 Note The size of the given array will be in the range [1,1000]. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617181920212223public TreeNode constructMaximumBinaryTree(int[] nums) &#123; return construct(nums, 0, nums.length - 1);&#125;private TreeNode construct(int[] nums, int start, int end) &#123; if (start &gt; end) return null; int max = nums[start]; int idx = start; for (int i = start + 1; i &lt;= end; i++) &#123; if (nums[i] &gt; max) &#123; max = nums[i]; idx = i; &#125; &#125; TreeNode root = new TreeNode(nums[idx]); root.left = construct(nums, start, idx - 1); root.right = construct(nums, idx + 1, end); return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 310 - Minimum Height Trees]]></title>
    <url>%2F2019%2F05%2F03%2FLeetCode-Problem-310-Minimum-Height-Trees%2F</url>
    <content type="text"><![CDATA[For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels. FormatThe graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels). You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. ExampleNo.1Input: n = 4, edges = [[1, 0], [1, 2], [1, 3]] 12345 0 | 1 / \2 3 Output: [1] No.2Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]] 12345670 1 2 \ | / 3 | 4 | 5 Output: [3, 4] Note According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.” The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (n == 1) &#123; result.add(0); return result; &#125; List[] adj = new ArrayList[n]; for (int i = 0; i &lt; n; i++) adj[i] = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; edges.length; i++) &#123; int v1 = edges[i][0]; int v2 = edges[i][1]; adj[v1].add(v2); adj[v2].add(v1); &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; if (adj[i].size() == 1) queue.offer(i); &#125; while (n &gt; 2) &#123; int size = queue.size(); n -= size; for (int i = 0; i &lt; size; i++) &#123; int node = queue.poll(); List&lt;Integer&gt; adjNodes = adj[node]; for (Integer adjNode : adjNodes) &#123; adj[adjNode].remove(Integer.valueOf(node)); if (adj[adjNode].size() == 1) queue.offer(adjNode); &#125; &#125; &#125; while (!queue.isEmpty()) result.add(queue.poll()); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 448 - Inorder Successor in BST]]></title>
    <url>%2F2019%2F05%2F03%2FLintCode-Problem-448-Inorder-Successor-in-BST%2F</url>
    <content type="text"><![CDATA[Given a binary search tree and a node in it, find the in-order successor of that node in the BST. If the given node has no in-order successor in the tree, return null. NoteIt’s guaranteed p is one node in the given tree. (You can directly compare the memory address to find p) ExampleNo.1Input: {1,#,2}, node with value 1 Output: 2 Explanation: 1231 \ 2 No.2Input: {2,1,3}, node with value 1 Output: 2 Explanation: 123 2 / \1 3 ChallengeO(h), where h is the height of the BST. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011public TreeNode inorderSuccessor(TreeNode root, TreeNode p) &#123; if (root == null) return null; if (root.val &lt;= p.val) return inorderSuccessor(root.right, p); else &#123; TreeNode node = inorderSuccessor(root.left, p); return node == null ? root : node; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 938 - Range Sum of BST]]></title>
    <url>%2F2019%2F05%2F02%2FLeetCode-Problem-938-Range-Sum-of-BST%2F</url>
    <content type="text"><![CDATA[Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive). The binary search tree is guaranteed to have unique values. ExampleNo.1Input: root = [10,5,15,3,7,null,18], L = 7, R = 15 Output: 32 No.2Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 Output: 23 Note The number of nodes in the tree is at most 10000. The final answer is guaranteed to be less than 2^31. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617181920private int sum = 0;public int rangeSumBST(TreeNode root, int L, int R) &#123; preorder(root, L, R); return sum;&#125;private void preorder(TreeNode root, int L, int R) &#123; if (root == null) return; if (root.val &gt;= L &amp;&amp; root.val &lt;= R) sum += root.val; if (root.val &gt; L) preorder(root.left, L, R); if (root.val &lt; R) preorder(root.right, L, R);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 501 - Find Mode in Binary Search Tree]]></title>
    <url>%2F2019%2F05%2F02%2FLeetCode-Problem-501-Find-Mode-in-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. For example: Given BST [1,null,2,2], 123451 \ 2 /2 return [2]. NoteIf a tree has more than one mode, you can return them in any order. Follow upCould you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count). Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142private int max = 0;private int count = 1;private TreeNode prev = null;public int[] findMode(TreeNode root) &#123; List&lt;Integer&gt; modes = new ArrayList&lt;&gt;(); inorder(root, modes); int[] result = new int[modes.size()]; for (int i = 0; i &lt; modes.size(); i++) result[i] = modes.get(i); return result;&#125;private void inorder(TreeNode root, List&lt;Integer&gt; modes) &#123; if (root == null) return; inorder(root.left, modes); if (prev != null) &#123; if (root.val == prev.val) count++; else &#123; count = 1; &#125; &#125; if (count &gt;= max) &#123; if (count &gt; max) modes.clear(); modes.add(root.val); max = count; &#125; prev = root; inorder(root.right, modes);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 236 - Lowest Common Ancestor of a Binary Tree]]></title>
    <url>%2F2019%2F05%2F01%2FLeetCode-Problem-236-Lowest-Common-Ancestor-of-a-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] ExampleNo.1Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. No.2Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Note All of the nodes’ values will be unique. p and q are different and both values will exist in the binary tree. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || p.val == root.val || q.val == root.val) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null &amp;&amp; right != null) return root; return left == null ? right : left;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 235 - Lowest Common Ancestor of a Binary Search Tree]]></title>
    <url>%2F2019%2F05%2F01%2FLeetCode-Problem-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5] ExampleNo.1Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6. No.2Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Note All of the nodes’ values will be unique. p and q are different and both values will exist in the BST. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null) return null; if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) return lowestCommonAncestor(root.left, p, q); else if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) return lowestCommonAncestor(root.right, p, q); else return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 297 - Serialize and Deserialize Binary Tree]]></title>
    <url>%2F2019%2F05%2F01%2FLeetCode-Problem-297-Serialize-and-Deserialize-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. ExampleYou may serialize the following tree: 12345 1 / \2 3 / \ 4 5 as “[1,2,3,null,null,4,5]” ClarificationThe above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. NoteDo not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536private int index = 0;public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); preorder(root, sb); return sb.toString();&#125;public TreeNode deserialize(String data) &#123; String[] str = data.split(","); return construct(str);&#125;private void preorder(TreeNode root, StringBuilder sb) &#123; if (root == null) &#123; sb.append("#,"); return; &#125; sb.append(root.val).append(","); preorder(root.left, sb); preorder(root.right, sb);&#125;private TreeNode construct(String[] str) &#123; if (str[index].equals("#")) &#123; index++; return null; &#125; TreeNode root = new TreeNode(Integer.parseInt(str[index++])); root.left = construct(str); root.right = construct(str); return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 449 - Serialize and Deserialize BST]]></title>
    <url>%2F2019%2F04%2F30%2FLeetCode-Problem-449-Serialize-and-Deserialize-BST%2F</url>
    <content type="text"><![CDATA[Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible. NoteDo not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); preorder(root, sb); return sb.length() &lt; 1 ? "" : sb.deleteCharAt(sb.length() - 1).toString();&#125;public TreeNode deserialize(String data) &#123; if (data.length() &lt; 1) return null; String[] str = data.split(" "); return construct(str, 0, str.length - 1);&#125;private void preorder(TreeNode root, StringBuilder sb) &#123; if (root == null) return; sb.append(root.val + " "); preorder(root.left, sb); preorder(root.right, sb);&#125;private TreeNode construct(String[] str, int start, int end) &#123; if (start &gt; end) return null; TreeNode root = new TreeNode(Integer.parseInt(str[start])); int i = start + 1; for (; i &lt;= end; i++) &#123; if (Integer.parseInt(str[i]) &gt; root.val) break; &#125; root.left = construct(str, start + 1, i - 1); root.right = construct(str, i, end); return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 450 - Delete Node in a BST]]></title>
    <url>%2F2019%2F04%2F30%2FLeetCode-Problem-450-Delete-Node-in-a-BST%2F</url>
    <content type="text"><![CDATA[Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages: Search for a node to remove. If the node is found, delete the node. NoteTime complexity should be O(height of tree). Exampleroot = [5,3,6,2,4,null,7]key = 3 12345 5 / \ 3 6 / \ \2 4 7 Given key to delete is 3. So we find the node with value 3 and delete it. One valid answer is [5,4,6,2,null,null,7], shown in the following BST. 12345 5 / \ 4 6 / \2 7 Another valid answer is [5,2,6,null,4,null,7]. 12345 5 / \2 6 \ \ 4 7 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324public TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) return null; if (root.val &gt; key) root.left = deleteNode(root.left, key); else if (root.val &lt; key) root.right = deleteNode(root.right, key); else &#123; if (root.left == null || root.right == null) root = (root.left != null) ? root.left : root.right; else &#123; TreeNode node = root.right; while (node.left != null) node = node.left; root.val = node.val; root.right = deleteNode(root.right, node.val); &#125; &#125; return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 530 - Minimum Absolute Difference in BST]]></title>
    <url>%2F2019%2F04%2F30%2FLeetCode-Problem-530-Minimum-Absolute-Difference-in-BST%2F</url>
    <content type="text"><![CDATA[Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes. ExampleInput: 123451 \ 3 /2 Output:1 Explanation:The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3). NoteThere are at least two nodes in this BST. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021private int min = Integer.MAX_VALUE;private int prev = -1;public int getMinimumDifference(TreeNode root) &#123; inorder(root); return min;&#125;private void inorder(TreeNode root) &#123; if (root == null) return; inorder(root.left); if (prev != -1) min = Math.min(min, root.val - prev); prev = root.val; inorder(root.right);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 783 - Minimum Distance Between BST Nodes]]></title>
    <url>%2F2019%2F04%2F30%2FLeetCode-Problem-783-Minimum-Distance-Between-BST-Nodes%2F</url>
    <content type="text"><![CDATA[Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree. ExampleInput: root = [4,2,6,1,3,null,null] Output: 1 Explanation:Note that root is a TreeNode object, not an array. The given tree [4,2,6,1,3,null,null] is represented by the following diagram: 12345 4 / \ 2 6 / \ 1 3 while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2. Note The size of the BST will be between 2 and 100. The BST is always valid, each node’s value is an integer, and each node’s value is different. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021private int min = Integer.MAX_VALUE;private int prev = -1;public int minDiffInBST(TreeNode root) &#123; inorder(root); return min;&#125;private void inorder(TreeNode root) &#123; if (root == null) return; inorder(root.left); if (prev != -1) min = Math.min(min, root.val - prev); prev = root.val; inorder(root.right);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 173 - Binary Search Tree Iterator]]></title>
    <url>%2F2019%2F04%2F29%2FLeetCode-Problem-173-Binary-Search-Tree-Iterator%2F</url>
    <content type="text"><![CDATA[Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Example 12345678910BSTIterator iterator = new BSTIterator(root);iterator.next(); // return 3iterator.next(); // return 7iterator.hasNext(); // return trueiterator.next(); // return 9iterator.hasNext(); // return trueiterator.next(); // return 15iterator.hasNext(); // return trueiterator.next(); // return 20iterator.hasNext(); // return false Note next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516171819202122232425262728private Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();public BSTIterator(TreeNode root) &#123; while (root != null) &#123; stack.push(root); root = root.left; &#125;&#125;public int next() &#123; TreeNode node = stack.pop(); int val = node.val; if (node.right != null) &#123; node = node.right; while (node != null) &#123; stack.push(node); node = node.left; &#125; &#125; return val;&#125;public boolean hasNext() &#123; return !stack.isEmpty();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 230 - Kth Smallest Element in a BST]]></title>
    <url>%2F2019%2F04%2F29%2FLeetCode-Problem-230-Kth-Smallest-Element-in-a-BST%2F</url>
    <content type="text"><![CDATA[Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. NoteYou may assume k is always valid, 1 ≤ k ≤ BST’s total elements. ExampleNo.1Input: root = [3,1,4,null,2], k = 1 12345 3 / \1 4 \ 2 Output: 1 No.2Input: root = [5,3,6,2,4,null,null,1], k = 3 1234567 5 / \ 3 6 / \ 2 4 /1 Output: 3 Follow upWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617181920private int count = 0;private int num = 0;public int kthSmallest(TreeNode root, int k) &#123; inorder(root, k); return num;&#125;private void inorder(TreeNode root, int k) &#123; if (root.left != null) inorder(root.left, k); if (++count == k) &#123; num = root.val; return; &#125; if (root.right != null) inorder(root.right, k);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 863 - Binary Tree Path Sum IV]]></title>
    <url>%2F2019%2F04%2F29%2FLintCode-Problem-863-Binary-Tree-Path-Sum-IV%2F</url>
    <content type="text"><![CDATA[If the depth of a tree is smaller than 5, this tree can be represented by a list of three-digits integers. For each integer in this list: The hundreds digit represents the depth D of this node, 1 &lt;= D &lt;= 4. The tens digit represents the position P of this node in the level it belongs to, 1 &lt;= P &lt;= 8. The position is the same as that in a full binary tree. The units digit represents the value V of this node, 0 &lt;= V &lt;= 9. Given a list of ascending three-digits integers representing a binary with the depth smaller than 5. You need to return the sum of all paths from the root towards the leaves. ExampleNo.1Input: [113, 215, 221] Output: 12 Explanation: The tree that the list represents is: 123 3 / \5 1 The path sum is (3 + 5) + (3 + 1) = 12. No.2Input: [113, 221] Output: 4 Code12345678910111213141516171819202122232425262728293031private int sum = 0;public int pathSum(int[] nums) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums) map.put(num / 10, num % 10); traverse(nums[0] / 10, map, 0); return sum;&#125;private void traverse(int root, Map&lt;Integer, Integer&gt; map, int prevSum) &#123; int level = root / 10; int pos = root % 10; int left = (level + 1) * 10 + pos * 2 - 1; int right = (level + 1) * 10 + pos * 2; int curSum = prevSum + map.get(root); if (!map.containsKey(left) &amp;&amp; !map.containsKey(right)) &#123; sum += curSum; return; &#125; if (map.containsKey(left)) traverse(left, map, curSum); if (map.containsKey(right)) traverse(right, map, curSum);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 80 - Remove Duplicates from Sorted Array II]]></title>
    <url>%2F2019%2F04%2F28%2FLeetCode-Problem-80-Remove-Duplicates-from-Sorted-Array-II%2F</url>
    <content type="text"><![CDATA[Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. ExampleNo.1Given nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It doesn’t matter what you leave beyond the returned length. No.2Given nums = [0,0,1,1,1,1,2,3,3], Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively. It doesn’t matter what values are set beyond the returned length. ClarificationConfused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; Code12345678910111213public int removeDuplicates(int[] nums) &#123; if (nums.length &lt; 3) return nums.length; int length = 1; for (int i = 2; i &lt; nums.length; i++) &#123; if (nums[i] != nums[length] || nums[i] != nums[length - 1]) nums[++length] = nums[i]; &#125; return length + 1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 889 - Construct Binary Tree from Preorder and Postorder Traversal]]></title>
    <url>%2F2019%2F04%2F26%2FLeetCode-Problem-889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal%2F</url>
    <content type="text"><![CDATA[Return any binary tree that matches the given preorder and postorder traversals. Values in the traversals pre and post are distinct positive integers. ExampleInput: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1] Output: [1,2,3,4,5,6,7] Note 1 &lt;= pre.length == post.length &lt;= 30 pre[] and post[] are both permutations of 1, 2, …, pre.length. It is guaranteed an answer exists. If there exists multiple answers, you can return any of them. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516171819202122232425public TreeNode constructFromPrePost(int[] pre, int[] post) &#123; return helper(pre, post, 0, pre.length - 1, 0, post.length - 1);&#125;private TreeNode helper(int[] pre, int[] post, int preStart, int preEnd, int postStart, int postEnd) &#123; if (preStart &gt; preEnd) return null; TreeNode root = new TreeNode(pre[preStart]); if (preStart == preEnd) return root; int i = postEnd - 1; for (; i &gt;= postStart; i--) &#123; if (post[i] == pre[preStart + 1]) break; &#125; root.left = helper(pre, post, preStart + 1, preEnd - postEnd + i + 1, postStart, i); root.right = helper(pre, post, preEnd - postEnd + i + 2, preEnd, i + 1, postEnd - 1); return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 106 - Construct Binary Tree from Inorder and Postorder Traversal]]></title>
    <url>%2F2019%2F04%2F26%2FLeetCode-Problem-106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal%2F</url>
    <content type="text"><![CDATA[Given inorder and postorder traversal of a tree, construct the binary tree. NoteYou may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7]postorder = [9,15,7,20,3] Return the following binary tree: 12345 3 / \9 20 / \ 15 7 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021public TreeNode buildTree(int[] inorder, int[] postorder) &#123; return helper(inorder, postorder, 0, inorder.length - 1, 0, postorder.length - 1);&#125;private TreeNode helper(int[] inorder, int[] postorder, int inStart, int inEnd, int postStart, int postEnd) &#123; if (inStart &gt; inEnd || postStart &gt; postEnd) return null; int i = inStart; for (; i &lt;= inEnd; i++) &#123; if (inorder[i] == postorder[postEnd]) break; &#125; TreeNode root = new TreeNode(postorder[postEnd]); root.left = helper(inorder, postorder, inStart, i - 1, postStart, postEnd - inEnd + i - 1); root.right = helper(inorder, postorder, i + 1, inEnd, postEnd - inEnd + i, postEnd - 1); return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 105 - Construct Binary Tree from Preorder and Inorder Traversal]]></title>
    <url>%2F2019%2F04%2F26%2FLeetCode-Problem-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal%2F</url>
    <content type="text"><![CDATA[Given preorder and inorder traversal of a tree, construct the binary tree. NoteYou may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7]inorder = [9,3,15,20,7] Return the following binary tree: 12345 3 / \9 20 / \ 15 7 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return helper(preorder, inorder, 0, preorder.length - 1, 0, inorder.length - 1);&#125;private TreeNode helper(int[] preorder, int[] inorder, int preStart, int preEnd, int inStart, int inEnd) &#123; if (preStart &gt; preEnd || inStart &gt; inEnd) return null; int i = inStart; for (; i &lt;= inEnd; i++) &#123; if (inorder[i] == preorder[preStart]) break; &#125; TreeNode root = new TreeNode(preorder[preStart]); root.left = helper(preorder, inorder, preStart + 1, preStart + i - inStart, inStart, i - 1); root.right = helper(preorder, inorder, preStart + i - inStart + 1, preEnd, i + 1, inEnd); return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 695 - Max Area of Island]]></title>
    <url>%2F2019%2F04%2F26%2FLeetCode-Problem-695-Max-Area-of-Island%2F</url>
    <content type="text"><![CDATA[Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.) ExampleNo.112345678[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally. No.21[[0,0,0,0,0,0,0,0]] Given the above grid, return 0. NoteThe length of each dimension in the given grid does not exceed 50. Code1234567891011121314151617181920212223242526272829303132333435363738394041public int maxAreaOfIsland(int[][] grid) &#123; int max = 0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if (grid[i][j] == 1) &#123; int count = bfs(grid, i, j); max = Math.max(count, max); &#125; &#125; &#125; return max;&#125;private int bfs(int[][] grid, int i, int j) &#123; int count = 0; int n = grid.length; int m = grid[0].length; int[][] directions = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[]&#123;i, j&#125;); grid[i][j] = 0; while (!queue.isEmpty()) &#123; int[] pos = queue.poll(); count++; for (int[] direction : directions) &#123; int x = direction[0] + pos[0]; int y = direction[1] + pos[1]; if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; grid[x][y] == 1) &#123; queue.offer(new int[] &#123;x, y&#125;); grid[x][y] = 0; &#125; &#125; &#125; return count;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 921 - Count Univalue Subtrees]]></title>
    <url>%2F2019%2F04%2F26%2FLintCode-Problem-921-Count-Univalue-Subtrees%2F</url>
    <content type="text"><![CDATA[Given a binary tree, count the number of uni-value subtrees. A Uni-value subtree means all nodes of the subtree have the same value. ExampleNo.1Input: root = {5,1,5,5,5,#,5} Output: 4 Explanation: 12345 5 / \ 1 5 / \ \5 5 5 No.2Input: root = {1,3,2,4,5,#,6} Output: 3 Explanation: 12345 1 / \ 3 2 / \ \4 5 6 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021private int count = 0;public int countUnivalSubtrees(TreeNode root) &#123; countHelper(root, -1); return count;&#125;private boolean countHelper(TreeNode root, int parent) &#123; if (root == null) return true; boolean left = countHelper(root.left, root.val); boolean right = countHelper(root.right, root.val); if (!left || !right) &#123; return false; &#125; count++; return root.val == parent;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 687 - Longest Univalue Path]]></title>
    <url>%2F2019%2F04%2F26%2FLeetCode-Problem-687-Longest-Univalue-Path%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. The length of path between two nodes is represented by the number of edges between them. ExampleNo.1Input: 12345 5 / \ 4 5 / \ \1 1 5 Output: 2 No.2Input: 12345 1 / \ 4 5 / \ \4 4 5 Output: 2 NoteThe given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718private int max = 0;public int longestUnivaluePath(TreeNode root) &#123; pathHelper(root, -1); return max;&#125;private int pathHelper(TreeNode root, int parent) &#123; if (root == null) return 0; int left = pathHelper(root.left, root.val); int right = pathHelper(root.right, root.val); max = Math.max(max, left + right); return root.val == parent ? Math.max(left, right) + 1 : 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 463 - Island Perimeter]]></title>
    <url>%2F2019%2F04%2F25%2FLeetCode-Problem-463-Island-Perimeter%2F</url>
    <content type="text"><![CDATA[You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. ExampleInput: 1234[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]] Output: 16 Explanation: The perimeter is the 16 yellow stripes in the image below: Code12345678910111213141516171819202122public int islandPerimeter(int[][] grid) &#123; int result = 0; int n = grid.length; int m = grid[0].length; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (grid[i][j] == 0) continue; result += 4; if (j - 1 &gt;= 0 &amp;&amp; grid[i][j - 1] == 1) result -= 2; if (i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == 1) result -= 2; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 733 - Flood Fill]]></title>
    <url>%2F2019%2F04%2F25%2FLeetCode-Problem-733-Flood-Fill%2F</url>
    <content type="text"><![CDATA[An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535). Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, “flood fill” the image. To perform a “flood fill”, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor. At the end, return the modified image. ExampleNo.1Input:image = [[1,1,1],[1,1,0],[1,0,1]]sr = 1, sc = 1, newColor = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation:From the center of the image (with position (sr, sc) = (1, 1)), all pixels connectedby a path of the same color as the starting pixel are colored with the new color.Note the bottom corner is not colored 2, because it is not 4-directionally connectedto the starting pixel. Note The length of image and image[0] will be in the range [1, 50]. The given starting pixel will satisfy 0 &lt;= sr &lt; image.length and 0 &lt;= sc &lt; image[0].length. The value of each color in image[i][j] and newColor will be an integer in [0, 65535]. Code123456789101112131415161718public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123; if (newColor == image[sr][sc]) return image; dfs(image, sr, sc, newColor, image[sr][sc]); return image;&#125;private void dfs(int[][] image, int sr, int sc, int newColor, int oldColor) &#123; if (sr &gt;= 0 &amp;&amp; sr &lt;image.length &amp;&amp; sc &gt;= 0 &amp;&amp; sc &lt; image[0].length &amp;&amp; oldColor == image[sr][sc]) &#123; image[sr][sc] = newColor; dfs(image, sr + 1, sc, newColor, oldColor); dfs(image, sr - 1, sc, newColor, oldColor); dfs(image, sr, sc + 1, newColor, oldColor); dfs(image, sr, sc - 1, newColor, oldColor); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 437 - Path Sum III]]></title>
    <url>%2F2019%2F04%2F24%2FLeetCode-Problem-437-Path-Sum-III%2F</url>
    <content type="text"><![CDATA[You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000. Exampleroot = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 1234567 10 / \ 5 -3 / \ \ 3 2 11 / \ \3 -2 1 Return 3. The paths that sum to 8 are: 5 -&gt; 3 5 -&gt; 2 -&gt; 1 -3 -&gt; 11 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324// “当前节点值” + “某一中间路径和” = “目标值”// “当前节点累加的根路径和” = “之前某一节点中累加的根路径和” + “某一中间路径和” + “当前节点值”// 可得“当前节点累加的根路径和” - “之前某一节点中累加的根路径和” = “目标值”private int count = 0;public int pathSum(TreeNode root, int sum) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, 1); traverse(root, map, sum, 0); return count;&#125;private void traverse(TreeNode root, Map&lt;Integer, Integer&gt; map, int target, int currentSum) &#123; if (root == null) return; currentSum += root.val; count += map.getOrDefault(currentSum - target, 0); map.put(currentSum, map.getOrDefault(currentSum, 0) + 1); traverse(root.left, map, target, currentSum); traverse(root.right, map, target, currentSum); map.put(currentSum, map.get(currentSum) - 1);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 113 - Path Sum II]]></title>
    <url>%2F2019%2F04%2F24%2FLeetCode-Problem-113-Path-Sum-II%2F</url>
    <content type="text"><![CDATA[Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. NoteA leaf is a node with no children. ExampleGiven the below binary tree and sum = 22, 1234567 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1 Return: 1234[ [5,4,11,2], [5,8,4,5]] Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617181920212223public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); pathSumHelper(result, new ArrayList&lt;&gt;(), root, sum); return result;&#125;private void pathSumHelper(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; path, TreeNode root, int sum) &#123; if (root == null) return; path.add(root.val); if (root.left == null &amp;&amp; root.right == null) &#123; if (root.val == sum) result.add(new ArrayList&lt;&gt;(path)); &#125; pathSumHelper(result, path, root.left, sum - root.val); pathSumHelper(result, path, root.right, sum - root.val); path.remove(path.size() - 1);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 112 - Path Sum]]></title>
    <url>%2F2019%2F04%2F24%2FLeetCode-Problem-112-Path-Sum%2F</url>
    <content type="text"><![CDATA[Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. NoteA leaf is a node with no children. ExampleGiven the below binary tree and sum = 22, 1234567 5 / \ 4 8 / / \ 11 13 4 / \ \7 2 1 return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910public boolean hasPathSum(TreeNode root, int sum) &#123; if (root == null) return false; if (root.left == null &amp;&amp; root.right == null) return sum == root.val; return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 64 - Minimum Path Sum]]></title>
    <url>%2F2019%2F04%2F24%2FLeetCode-Problem-64-Minimum-Path-Sum%2F</url>
    <content type="text"><![CDATA[Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. NoteYou can only move either down or right at any point in time. ExampleInput: 12345[ [1,3,1], [1,5,1], [4,2,1]] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum. Code12345678910111213141516171819public int minPathSum(int[][] grid) &#123; int n = grid.length; int m = grid[0].length; int[][] dp = new int[n][m]; dp[0][0] = grid[0][0]; for (int i = 1; i &lt; m; i++) dp[0][i] = grid[0][i] + dp[0][i - 1]; for (int i = 1; i &lt; n; i++) dp[i][0] = grid[i][0] + dp[i - 1][0]; for (int i = 1; i &lt; n; i++) &#123; for (int j = 1; j &lt; m; j++) dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]); &#125; return dp[n - 1][m - 1];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 77 - Combinations]]></title>
    <url>%2F2019%2F04%2F24%2FLeetCode-Problem-77-Combinations%2F</url>
    <content type="text"><![CDATA[Given two integers n and k, return all possible combinations of k numbers out of 1 … n. ExampleInput: n = 4, k = 2 Output: 12345678[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] Code1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); combineHelper(result, new ArrayList&lt;&gt;(), n, k, 1); return result;&#125;private void combineHelper(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; combination, int n, int k, int idx) &#123; if (combination.size() == k) &#123; result.add(new ArrayList&lt;&gt;(combination)); return; &#125; for (int i = idx; i &lt;= n; i++) &#123; combination.add(i); combineHelper(result, combination, n, k, i + 1); combination.remove(combination.size() - 1); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 717 - 1-bit and 2-bit Characters]]></title>
    <url>%2F2019%2F04%2F24%2FLeetCode-Problem-717-1-bit-and-2-bit-Characters%2F</url>
    <content type="text"><![CDATA[We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11). Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero. ExampleNo.1Input:bits = [1, 0, 0] Output: True Explanation:The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character. No.2Input:bits = [1, 1, 1, 0] Output: False Explanation:The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character. Note 1 &lt;= len(bits) &lt;= 1000. bits[i] is always 0 or 1. Code123456789public boolean isOneBitCharacter(int[] bits) &#123; int n = bits.length; int i = 0; while (i &lt; n - 1) i += bits[i] + 1; return i == n - 1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 89 - Gray Code]]></title>
    <url>%2F2019%2F04%2F24%2FLeetCode-Problem-89-Gray-Code%2F</url>
    <content type="text"><![CDATA[The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. ExampleNo.1Input: 2 Output: [0,1,3,2] Explanation:00 - 001 - 111 - 310 - 2 For a given n, a gray code sequence may not be uniquely defined.For example, [0,2,3,1] is also a valid gray code sequence. 00 - 010 - 211 - 301 - 1 No.2Input: 0 Output: [0] Explanation: We define the gray code sequence to begin with 0. A gray code sequence of n has size = 2^n, which for n = 0 the size is 2^0 = 1. Therefore, for n = 0 the gray code sequence is [0]. Code12345678public List&lt;Integer&gt; grayCode(int n) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; (1 &lt;&lt; n); i++) result.add((i &gt;&gt; 1) ^ i); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 49 - Group Anagrams]]></title>
    <url>%2F2019%2F04%2F23%2FLeetCode-Problem-49-Group-Anagrams%2F</url>
    <content type="text"><![CDATA[Given an array of strings, group anagrams together. ExampleInput: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”], Output: 12345[ ["ate","eat","tea"], ["nat","tan"], ["bat"]] Note All inputs will be in lowercase. The order of your output does not matter. Code12345678910111213141516171819public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (String str: strs) &#123; int[] dic = new int[26]; StringBuilder sb = new StringBuilder(); for (char ch : str.toCharArray()) dic[ch - 'a']++; for (int i = 0; i &lt; dic.length; i++) sb.append(dic[i]); map.putIfAbsent(sb.toString(), new ArrayList&lt;&gt;()); map.get(sb.toString()).add(str); &#125; return new ArrayList&lt;&gt;(map.values());&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 43 - Multiply Strings]]></title>
    <url>%2F2019%2F04%2F23%2FLeetCode-Problem-43-Multiply-Strings%2F</url>
    <content type="text"><![CDATA[Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. ExampleNo.1Input: num1 = “2”, num2 = “3” Output: “6” No.2Input: num1 = “123”, num2 = “456” Output: “56088” Note The length of both num1 and num2 is &lt; 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly. Code12345678910111213141516171819202122public String multiply(String num1, String num2) &#123; int n = num1.length(); int m = num2.length(); int[] result = new int[m + n]; StringBuilder sb = new StringBuilder(); for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = m - 1; j &gt;= 0; j--) &#123; int multiply = (num1.charAt(i) - '0') * (num2.charAt(j) - '0'); int sum = result[i + j + 1] + multiply; result[i + j + 1] = sum % 10; result[i + j] += sum / 10; &#125; &#125; for (int val : result) &#123; if (sb.length() &gt; 0 || val != 0) sb.append(val); &#125; return sb.length() &gt; 0 ? sb.toString() : "0";&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 415 - Add Strings]]></title>
    <url>%2F2019%2F04%2F23%2FLeetCode-Problem-415-Add-Strings%2F</url>
    <content type="text"><![CDATA[Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2. Note The length of both num1 and num2 is &lt; 5100. Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly. Code1234567891011121314151617181920public String addStrings(String num1, String num2) &#123; StringBuilder sb = new StringBuilder(); int i = num1.length() - 1; int j = num2.length() - 1; int carry = 0; while (i &gt;= 0 || j &gt;= 0) &#123; int a = i &gt;= 0 ? num1.charAt(i--) - '0' : 0; int b = j &gt;= 0 ? num2.charAt(j--) - '0' : 0; int sum = a + b + carry; carry = sum / 10; sb.append(sum % 10); &#125; if (carry != 0) sb.append(carry); return sb.reverse().toString();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 48 - Rotate Image]]></title>
    <url>%2F2019%2F04%2F23%2FLeetCode-Problem-48-Rotate-Image%2F</url>
    <content type="text"><![CDATA[You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. ExampleNo.1Given input matrix = 12345[ [1,2,3], [4,5,6], [7,8,9]], rotate the input matrix in-place such that it becomes: 12345[ [7,4,1], [8,5,2], [9,6,3]] No.2Given input matrix = 123456[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], rotate the input matrix in-place such that it becomes: 123456[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] Code12345678910111213141516171819public void rotate(int[][] matrix) &#123; int n = matrix.length; for (int row = 0; row &lt; n - 1; row++) &#123; for (int col = 0; col &lt; n - 1 - row; col++) swap(matrix, row, col, n - 1 - col, n - 1 - row); &#125; for (int i = 0; i &lt; n / 2 ; i++) &#123; for (int j = 0; j &lt; n; j++) swap(matrix, i, j, n - 1 - i, j); &#125;&#125;private void swap(int[][] matrix, int x1, int y1, int x2, int y2) &#123; int tmp = matrix[x1][y1]; matrix[x1][y1] = matrix[x2][y2]; matrix[x2][y2] = tmp;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 34 - Find First and Last Position of Element in Sorted Array]]></title>
    <url>%2F2019%2F04%2F22%2FLeetCode-Problem-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array%2F</url>
    <content type="text"><![CDATA[Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. ExampleNo.1Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] No.2Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] Code1234567891011121314151617181920212223242526272829303132public int[] searchRange(int[] nums, int target) &#123; int[] result = &#123;-1, -1&#125;; if (nums == null || nums.length &lt; 1) return result; int left = binarySearch(nums, target, 0, nums.length - 1, true); if (nums[left] != target) return result; result[0] = left; int right = binarySearch(nums, target, left, nums.length, false) - 1; result[1] = right; return result;&#125;private int binarySearch(int[] nums, int target, int left, int right, boolean isLeft) &#123; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if ((isLeft &amp;&amp; nums[mid] &lt; target) || (!isLeft &amp;&amp; nums[mid] &lt;= target)) left = mid + 1; else right = mid; &#125; return right;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 95 - Unique Binary Search Trees II]]></title>
    <url>%2F2019%2F04%2F20%2FLeetCode-Problem-95-Unique-Binary-Search-Trees-II%2F</url>
    <content type="text"><![CDATA[Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n. ExampleInput: 3 Output: 1234567[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]] Explanation:The above output corresponds to the 5 unique BST’s shown below: 123451 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \2 1 2 3 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516171819202122232425262728293031public List&lt;TreeNode&gt; generateTrees(int n) &#123; if (n == 0) return new ArrayList&lt;&gt;(); return generate(1, n);&#125;private List&lt;TreeNode&gt; generate(int start, int end) &#123; List&lt;TreeNode&gt; result = new ArrayList&lt;&gt;(); if (start &gt; end) &#123; result.add(null); return result; &#125; for (int i = start; i &lt;= end; i++) &#123; List&lt;TreeNode&gt; leftList = generate(start, i - 1); List&lt;TreeNode&gt; rightList = generate(i + 1, end); for (TreeNode left : leftList) &#123; for (TreeNode right : rightList) &#123; TreeNode root = new TreeNode(i); root.left = left; root.right = right; result.add(root); &#125; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 96 - Unique Binary Search Trees]]></title>
    <url>%2F2019%2F04%2F20%2FLeetCode-Problem-96-Unique-Binary-Search-Trees%2F</url>
    <content type="text"><![CDATA[Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n? ExampleInput: 3 Output: 5 Explanation:Given n = 3, there are a total of 5 unique BST’s: 123451 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \2 1 2 3 Code123456789101112public int numTrees(int n) &#123; int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 0; j &lt; i; j++) dp[i] += dp[j] * dp[i - j - 1]; &#125; return dp[n];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 119 - Pascal's Triangle II]]></title>
    <url>%2F2019%2F04%2F19%2FLeetCode-Problem-119-Pascal-s-Triangle-II%2F</url>
    <content type="text"><![CDATA[Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle. Note that the row index starts from 0. In Pascal’s triangle, each number is the sum of the two numbers directly above it. ExampleInput: 3 Output: [1,3,3,1] Follow upCould you optimize your algorithm to use only O(k) extra space? Code123456789101112public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; triangle = new ArrayList&lt;&gt;(); for (int idx = 0; idx &lt;= rowIndex; idx++) &#123; triangle.add(1); for (int num = idx - 1; num &gt; 0; num--) triangle.set(num, triangle.get(num) + triangle.get(num - 1)); &#125; return triangle;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 118 - Pascal's Triangle]]></title>
    <url>%2F2019%2F04%2F19%2FLeetCode-Problem-118-Pascal-s-Triangle%2F</url>
    <content type="text"><![CDATA[Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it. ExampleInput: 5 Output: 1234567[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] Code1234567891011121314151617181920212223public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; triangle = new ArrayList&lt;&gt;(); if (numRows == 0) return triangle; triangle.add(new ArrayList&lt;&gt;()); triangle.get(0).add(1); for (int num = 1; num &lt; numRows; num++) &#123; List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); List&lt;Integer&gt; prev = triangle.get(num - 1); row.add(1); for (int i = 1; i &lt; num; i++) row.add(prev.get(i - 1) + prev.get(i)); row.add(1); triangle.add(row); &#125; return triangle;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 700 - Search in a Binary Search Tree]]></title>
    <url>%2F2019%2F04%2F18%2FLeetCode-Problem-700-Search-in-a-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node’s value equals the given value. Return the subtree rooted with that node. If such node doesn’t exist, you should return NULL. For example, Given the tree: 12345 4 / \ 2 7 / \1 3 And the value to search: 2 You should return this subtree: 123 2 / \ 1 3 In the example above, if we want to search the value 5, since there is no node with value 5, we should return NULL. Note that an empty tree is represented by NULL, therefore you would see the expected output (serialized tree format) as [], not null. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112public TreeNode searchBST(TreeNode root, int val) &#123; if (root == null) return null; if (root.val == val) return root; if (root.val &lt; val) return searchBST(root.right, val); else return searchBST(root.left, val);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 701 - Insert into a Binary Search Tree]]></title>
    <url>%2F2019%2F04%2F18%2FLeetCode-Problem-701-Insert-into-a-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. For example, Given the tree: 12345 4 / \ 2 7 / \1 3 And the value to insert: 5 You can return this binary search tree: 12345 4 / \ 2 7 / \ /1 3 5 This tree is also valid: 1234567 5 / \ 2 7 / \ 1 3 \ 4 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011public TreeNode insertIntoBST(TreeNode root, int val) &#123; if (root == null) return new TreeNode(val); if (root.val &lt; val) root.right = insertIntoBST(root.right, val); else root.left = insertIntoBST(root.left, val); return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 168 - Excel Sheet Column Title]]></title>
    <url>%2F2019%2F04%2F18%2FLeetCode-Problem-168-Excel-Sheet-Column-Title%2F</url>
    <content type="text"><![CDATA[Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example: 1 -&gt; A 2 -&gt; B 3 -&gt; C ... 26 -&gt; Z 27 -&gt; AA 28 -&gt; AB ...ExampleNo.1Input: 1 Output: “A” No.2Input: 28 Output: “AB” No.3Input: 701 Output: “ZY” Code12345678910public String convertToTitle(int n) &#123; StringBuilder sb = new StringBuilder(); while (n &gt; 0) &#123; sb.append((char) (--n % 26 + 'A')); n /= 26; &#125; return sb.reverse().toString();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 171 - Excel Sheet Column Number]]></title>
    <url>%2F2019%2F04%2F18%2FLeetCode-Problem-171-Excel-Sheet-Column-Number%2F</url>
    <content type="text"><![CDATA[Given a column title as appear in an Excel sheet, return its corresponding column number. For example: A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 ...ExampleNo.1Input: “A” Output: 1 No.2Input: “AB” Output: 28 No.3Input: “ZY” Output: 701 Code123456789public int titleToNumber(String s) &#123; int n = s.length() - 1; int sum = 0; for (char ch : s.toCharArray()) sum += (ch - 'A' + 1) * Math.pow(26, n--); return sum;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 860 - Number of Distinct Islands]]></title>
    <url>%2F2019%2F04%2F17%2FLintCode-Problem-860-Number-of-Distinct-Islands%2F</url>
    <content type="text"><![CDATA[Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Count the number of distinct islands. An island is considered to be the same as another if and only if one island has the same shape as another island (and not rotated or reflected). Notice that: 12111 and 12 111 are considered different island, because we do not consider reflection / rotation. NoteThe length of each dimension in the given grid does not exceed 50. ExampleNo.1Input: 123456[ [1,1,0,0,1], [1,0,0,0,0], [1,1,0,0,1], [0,1,0,1,1]] Output: 3 Explanation: 123411 1 11 11 11 1 No.2Input: 123456[ [1,1,0,0,0], [1,1,0,0,0], [0,0,0,1,1], [0,0,0,1,1]] Output: 1 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public int numberofDistinctIslands(int[][] grid) &#123; int n = grid.length; int m = grid[0].length; boolean[][] visit = new boolean[n][m]; Set&lt;List&lt;List&lt;Integer&gt;&gt;&gt; count = new HashSet&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (grid[i][j] == 1 &amp;&amp; !visit[i][j]) &#123; List&lt;List&lt;Integer&gt;&gt; island = bfs(grid, visit, i, j); count.add(island); &#125; &#125; &#125; return count.size();&#125;private List&lt;List&lt;Integer&gt;&gt; bfs(int[][] grid, boolean[][] visit, int i, int j) &#123; int n = grid.length; int m = grid[0].length; int[][] directions = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; List&lt;List&lt;Integer&gt;&gt; island = new ArrayList&lt;&gt;(); Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[] &#123;i, j&#125;); visit[i][j] = true; while (!queue.isEmpty()) &#123; int[] pos = queue.poll(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(pos[0] - i); list.add(pos[1] - j); island.add(list); for (int[] direction : directions) &#123; int x = pos[0] + direction[0]; int y = pos[1] + direction[1]; if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; grid[x][y] == 1 &amp;&amp; !visit[x][y]) &#123; queue.offer(new int[] &#123;x, y&#125;); visit[x][y] = true; &#125; &#125; &#125; return island;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 1017 - Similar RGB Color]]></title>
    <url>%2F2019%2F04%2F16%2FLintCode-Problem-1017-Similar-RGB-Color%2F</url>
    <content type="text"><![CDATA[In the following, every capital letter represents some hexadecimal digit from 0 to f. The red-green-blue color “#AABBCC” can be written as “#ABC” in shorthand. For example, “#15c” is shorthand for the color “#1155cc”. Now, say the similarity between two colors “#ABCDEF” and “#UVWXYZ” is -(AB - UV)^2 - (CD - WX)^2 - (EF - YZ)^2. Given the color “#ABCDEF”, return a 7 character color that is most similar to #ABCDEF, and has a shorthand (that is, it can be represented as some “#XYZ”) Note color is a string of length 7. color is a valid RGB color: for i &gt; 0, color[i] is a hexadecimal digit from 0 to f Any answer which has the same (highest) similarity as the best answer will be accepted. All inputs and outputs should use lowercase letters, and the output is 7 characters. ExampleNo.1Input: color = “#09f166” Output: “#11ee66” Explanation:The similarity is -(0x09 - 0x11)^2 -(0xf1 - 0xee)^2 - (0x66 - 0x66)^2 = -64 -9 -0 = -73.This is the highest among any shorthand color. No.2Input: color = “#010000” Output: “#000000” Explanation:The similarity is -(0x01 - 0x10)^2 -(0x00 - 0x00)^2 - (0x00 - 0x00)^2 = -1 -0 -0 = -1.This is the highest among any shorthand color. Code1234567891011121314public String similarRGB(String color) &#123; StringBuilder sb = new StringBuilder("#"); for (int i = 1; i &lt; color.length(); i += 2) sb.append(helper(color.substring(i, i + 2))); return sb.toString();&#125;private String helper(String str) &#123; int num = Integer.parseInt(str, 16); num = num / 17 + (num % 17 &gt; 8 ? 1 : 0); return String.format("%02x", num * 17);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 75 - Sort Colors]]></title>
    <url>%2F2019%2F04%2F15%2FLeetCode-Problem-75-Sort-Colors%2F</url>
    <content type="text"><![CDATA[Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. NoteYou are not suppose to use the library’s sort function for this problem. ExampleInput: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s. Could you come up with a one-pass algorithm using only constant space? Code12345678910111213141516171819public void sortColors(int[] nums) &#123; int lo = 0; int hi = nums.length - 1; for (int i = 0; i &lt;= hi; ) &#123; if (nums[i] == 0) swap(nums, i++, lo++); else if (nums[i] == 2) swap(nums, i, hi--); else i++; &#125;&#125;private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 922 - Sort Array By Parity II]]></title>
    <url>%2F2019%2F04%2F13%2FLeetCode-Problem-922-Sort-Array-By-Parity-II%2F</url>
    <content type="text"><![CDATA[Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even. Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even. You may return any answer array that satisfies this condition. ExampleInput: [4,2,5,7] Output: [4,5,2,7] Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted. Note 2 &lt;= A.length &lt;= 20000 A.length % 2 == 0 0 &lt;= A[i] &lt;= 1000 Code1234567891011121314151617public int[] sortArrayByParityII(int[] A) &#123; int left = 0; int right = A.length - 1; for (; left &lt; A.length - 1 ; left += 2) &#123; if (A[left] % 2 != 0) &#123; while (right &gt; 0 &amp;&amp; A[right] % 2 != 0) right -= 2; int temp = A[left]; A[left] = A[right]; A[right] = temp; &#125; &#125; return A;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 324 - Wiggle Sort II]]></title>
    <url>%2F2019%2F04%2F10%2FLeetCode-Problem-324-Wiggle-Sort-II%2F</url>
    <content type="text"><![CDATA[Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]…. ExampleNo.1Input: nums = [1, 5, 1, 1, 6, 4] Output: One possible answer is [1, 4, 1, 5, 1, 6]. No.2Input: nums = [1, 3, 2, 2, 3, 1] Output: One possible answer is [2, 3, 1, 3, 1, 2]. NoteYou may assume all input has valid answer. Follow UpCan you do it in O(n) time and/or in-place with O(1) extra space? O(nlogn) runtime, O(n) space123456789101112131415public void wiggleSort(int[] nums) &#123; int[] copy = nums.clone(); Arrays.sort(copy); int left = (copy.length - 1) &gt;&gt; 1; int right = copy.length - 1; int idx = 0; while (left &gt;= 0 &amp;&amp; right &gt;= (copy.length + 1) &gt;&gt; 1) &#123; nums[idx++] = copy[left--]; nums[idx++] = copy[right--]; &#125; if (left == 0) nums[idx] = copy[0];&#125; O(n) runtime, O(1) space1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void wiggleSort(int[] nums) &#123; int n = nums.length; int lo = 0; int hi = n - 1; int midNum = partition(nums, lo, hi, (n - 1) &gt;&gt; 1); for (int i = 0; i &lt;= hi;) &#123; if (nums[getMapIdx(i, n)] &gt; midNum) swap(nums, getMapIdx(i++, n) , getMapIdx(lo++, n)); else if (nums[getMapIdx(i, n)] &lt; midNum) swap(nums, getMapIdx(i, n), getMapIdx(hi--, n)); else i++; &#125;&#125;private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125;private int getMapIdx(int i, int n) &#123; return (2 * i + 1) % (n | 1);&#125;private int partition(int[] nums, int lo, int hi, int k) &#123; int left = lo; int right = hi; int num = nums[lo]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; nums[right] &gt;= num) right--; while (left &lt; right &amp;&amp; nums[left] &lt;= num) left++; swap(nums, left, right); &#125; swap(nums, lo, left); if (left - lo == k) return num; else if (left - lo &lt; k) return partition(nums, left + 1, hi, k - (left - lo + 1)); else return partition(nums, lo, right - 1, k);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 508 - Wiggle Sort]]></title>
    <url>%2F2019%2F04%2F10%2FLintCode-Problem-508-Wiggle-Sort%2F</url>
    <content type="text"><![CDATA[Given an unsorted array nums, reorder it in-place such that nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]…. ExampleInput: nums = [3,5,2,1,6,4] Output: One possible answer is [3,5,1,6,2,4] Code1234567891011121314// 假如原来是 nums[i - 2] &lt;= nums[i - 1]，那么 nums[i - 1] 和 nums[i] 交换的条件是，nums[i - 1] &lt;= nums[i]。// 推导出此时 nums[i] &gt;= nums[i - 2]，因此交换之后，不会让 nums[i] 和 nums[i - 2] 的大小关系出现变化。public void wiggleSort(int[] nums) &#123; for (int i = 0; i &lt; nums.length - 1 ; i++) &#123; if ((i % 2 == 0 &amp;&amp; nums[i] &gt; nums[i + 1]) || (i % 2 != 0 &amp;&amp; nums[i] &lt; nums[i + 1])) swap(nums, i, i + 1); &#125;&#125;private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 732 - My Calendar III]]></title>
    <url>%2F2019%2F04%2F10%2FLeetCode-Problem-732-My-Calendar-III%2F</url>
    <content type="text"><![CDATA[Implement a MyCalendarThree class to store your events. A new event can always be added. Your class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start &lt;= x &lt; end. A K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.) For each call to the method MyCalendar.book, return an integer K representing the largest integer such that there exists a K-booking in the calendar. Your class will be called like this: MyCalendarThree cal = new MyCalendarThree(); MyCalendarThree.book(start, end) ExampleNo.11234567MyCalendarThree();MyCalendarThree.book(10, 20); // returns 1MyCalendarThree.book(50, 60); // returns 1MyCalendarThree.book(10, 40); // returns 2MyCalendarThree.book(5, 15); // returns 3MyCalendarThree.book(5, 10); // returns 3MyCalendarThree.book(25, 55); // returns 3 Explanation:The first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking.The third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking.The remaining events cause the maximum K-booking to be only a 3-booking.Note that the last event locally causes a 2-booking, but the answer is still 3 becauseeg. [10, 20), [10, 40), and [5, 15) are still triple booked. Note The number of calls to MyCalendarThree.book per test case will be at most 400. In calls to MyCalendarThree.book(start, end), start and end are integers in the range [0, 10^9]. Code1234567891011121314151617181920private TreeMap&lt;Integer, Integer&gt; map;public MyCalendarThree() &#123; map = new TreeMap&lt;&gt;();&#125;public int book(int start, int end) &#123; map.put(start, map.getOrDefault(start, 0) + 1); map.put(end, map.getOrDefault(end, 0) - 1); int count = 0; int max = 0; for (int key : map.keySet()) &#123; count += map.get(key); max = count &gt; max ? count : max; &#125; return max;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 731 - My Calendar II]]></title>
    <url>%2F2019%2F04%2F08%2FLeetCode-Problem-731-My-Calendar-II%2F</url>
    <content type="text"><![CDATA[Implement a MyCalendarTwo class to store your events. A new event can be added if adding the event will not cause a triple booking. Your class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start &lt;= x &lt; end. A triple booking happens when three events have some non-empty intersection (ie., there is some time that is common to all 3 events.) For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a triple booking. Otherwise, return false and do not add the event to the calendar. Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) ExampleNo.11234567MyCalendar();MyCalendar.book(10, 20); // returns trueMyCalendar.book(50, 60); // returns trueMyCalendar.book(10, 40); // returns trueMyCalendar.book(5, 15); // returns falseMyCalendar.book(5, 10); // returns trueMyCalendar.book(25, 55); // returns true Explanation:The first two events can be booked. The third event can be double booked.The fourth event (5, 15) can’t be booked, because it would result in a triple booking.The fifth event (5, 10) can be booked, as it does not use time 10 which is already double booked.The sixth event (25, 55) can be booked, as the time in [25, 40) will be double booked with the third event;the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event. Note The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9]. Code12345678910111213141516171819202122private List&lt;int[]&gt; singles;private List&lt;int[]&gt; doubles;public MyCalendarTwo() &#123; singles = new ArrayList&lt;&gt;(); doubles = new ArrayList&lt;&gt;();&#125;public boolean book(int start, int end) &#123; for (int[] d : doubles) &#123; if (end &gt; d[0] &amp;&amp; start &lt; d[1]) return false; &#125; for (int[] s : singles) &#123; if (end &gt; s[0] &amp;&amp; start &lt; s[1]) doubles.add(new int[] &#123;Math.max(start, s[0]), Math.min(end, s[1])&#125;); &#125; singles.add(new int[] &#123;start, end&#125;); return true;&#125; TreeMap123456789101112131415161718192021222324private TreeMap&lt;Integer, Integer&gt; map;public MyCalendarTwo() &#123; map = new TreeMap&lt;&gt;();&#125;public boolean book(int start, int end) &#123; map.put(start, map.getOrDefault(start, 0) + 1); map.put(end, map.getOrDefault(end, 0) - 1); int count = 0; for (int key : map.keySet()) &#123; count += map.get(key); if (count == 3) &#123; map.put(start, map.get(start) - 1); map.put(end, map.get(end) + 1); return false; &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 729 - My Calendar I]]></title>
    <url>%2F2019%2F04%2F08%2FLeetCode-Problem-729-My-Calendar-I%2F</url>
    <content type="text"><![CDATA[Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking. Your class will have the method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start &lt;= x &lt; end. A double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.) For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar. Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) ExampleNo.11234MyCalendar();MyCalendar.book(10, 20); // returns trueMyCalendar.book(15, 25); // returns falseMyCalendar.book(20, 30); // returns true Explanation:The first event can be booked. The second can’t because time 15 is already booked by another event.The third event can be booked, as the first event takes every time less than 20, but not including 20. Note The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9]. Code123456789101112131415private List&lt;int[]&gt; list;public MyCalendar() &#123; list = new ArrayList&lt;&gt;();&#125;public boolean book(int start, int end) &#123; for (int[] event : list) &#123; if (Math.max(start, event[0]) &lt; Math.min(end, event[1])) return false; &#125; list.add(new int[] &#123;start, end&#125;); return true;&#125; TreeMap1234567891011121314151617private TreeMap&lt;Integer, Integer&gt; map;public MyCalendar() &#123; map = new TreeMap&lt;&gt;();&#125;public boolean book(int start, int end) &#123; Integer prev = map.floorKey(start); Integer next = map.ceilingKey(start); if ((prev == null || map.get(prev) &lt;= start) &amp;&amp; (next == null || end &lt;= next)) &#123; map.put(start, end); return true; &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 849 - Basic Calculator III]]></title>
    <url>%2F2019%2F04%2F08%2FLintCode-Problem-849-Basic-Calculator-III%2F</url>
    <content type="text"><![CDATA[Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces . The expression string contains only non-negative integers, +, -, *, / operators , open ( and closing parentheses ) and empty spaces . The integer division should truncate toward zero. You may assume that the given expression is always valid. All intermediate results will be in the range of [-2147483648, 2147483647] Example1234"1 + 1" = 2" 6-4 / 2 " = 4"2*(5+5*2)/3+(6/2+8)" = 21"(2+6* 3+5- (3*14/7+2)*5)+3"=-12 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public int calculate(String s) &#123; int result = 0; int curResult = 0; int num = 0; char lastSign = '+'; for (int i = 0; i &lt; s.length(); i++) &#123; char ch = s.charAt(i); if (Character.isDigit(ch)) &#123; num = 10 * num + (ch - '0'); &#125; else if (ch == '(') &#123; int count = 0; int j = i; for (; i &lt; s.length(); i++) &#123; if (s.charAt(i) == '(') count++; else if (s.charAt(i) == ')') count--; if (count == 0) break; &#125; num = calculate(s.substring(j + 1, i)); &#125; if (ch == '+' || ch == '-' || ch == '*' || ch == '/' || i == s.length() - 1) &#123; switch (lastSign) &#123; case '+': curResult += num; break; case '-': curResult -= num; break; case '*': curResult *= num; break; case '/': curResult /= num; break; &#125; if (ch == '+' || ch == '-' || i == s.length() - 1) &#123; result += curResult; curResult = 0; &#125; lastSign = ch; num = 0; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 227 - Basic Calculator II]]></title>
    <url>%2F2019%2F04%2F08%2FLeetCode-Problem-227-Basic-Calculator-II%2F</url>
    <content type="text"><![CDATA[Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero. ExampleNo.1Input: “3+2*2” Output: 7 No.2Input: “ 3/2 “ Output: 1 No.3Input: “ 3+5 / 2 “ Output: 5 Note You may assume that the given expression is always valid. Do not use the eval built-in library function. Code123456789101112131415161718192021222324252627282930313233public int calculate(String s) &#123; int result = 0; int curResult = 0; int num = 0; char lastSign = '+'; for (int i = 0; i &lt; s.length(); i++) &#123; char ch = s.charAt(i); if (Character.isDigit(ch)) &#123; num = 10 * num + (ch - '0'); &#125; if (ch == '+' || ch == '-' || ch == '*' || ch == '/' || i == s.length() - 1) &#123; switch (lastSign) &#123; case '+': curResult += num; break; case '-': curResult -= num; break; case '*': curResult *= num; break; case '/': curResult /= num; break; &#125; if (ch == '+' || ch == '-' || i == s.length() - 1) &#123; result += curResult; curResult = 0; &#125; lastSign = ch; num = 0; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 224 - Basic Calculator]]></title>
    <url>%2F2019%2F04%2F08%2FLeetCode-Problem-224-Basic-Calculator%2F</url>
    <content type="text"><![CDATA[Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces . ExampleNo.1Input: “1 + 1” Output: 2 No.2Input: “ 2-1 + 2 “ Output: 3 No.3Input: “(1+(4+5+2)-3)+(6+8)” Output: 23 Note You may assume that the given expression is always valid. Do not use the eval built-in library function. Code12345678910111213141516171819202122232425262728293031323334public int calculate(String s) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int result = 0; int num = 0; int sign = 1; for (int i = 0; i &lt; s.length(); i++) &#123; char ch = s.charAt(i); if (Character.isDigit(ch)) &#123; num = 10 * num + (ch - '0'); &#125; else if (ch == '+' || ch == '-') &#123; result += sign * num; num = 0; sign = ch == '+' ? 1 : -1; &#125; else if (ch == '(') &#123; stack.push(result); stack.push(sign); sign = 1; result = 0; &#125; else if (ch == ')') &#123; result += sign * num; num = 0; result *= stack.pop(); result += stack.pop(); &#125; &#125; result += sign * num; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 913 - Flip Game II]]></title>
    <url>%2F2019%2F04%2F07%2FLintCode-Problem-913-Flip-Game-II%2F</url>
    <content type="text"><![CDATA[You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive “++” into “–”. The game ends when a person can no longer make a move and therefore the other person will be the winner. Write a function to determine if the starting player can guarantee a win. ExampleNo.1Input: s = “++++” Output: true Explanation:The starting player can guarantee a win by flipping the middle “++” to become “+–+”. No.2Input: s = “+++++” Output: false Explanation:The starting player can not win“+++–” –&gt; “+—-““++–+” –&gt; “—-+” ChallengeDerive your algorithm’s runtime complexity. Code12345678910111213141516171819202122private Map&lt;String, Boolean&gt; map = new HashMap&lt;&gt;();public boolean canWin(String s) &#123; if (map.containsKey(s)) return map.get(s); int idx = s.indexOf("++", 0); while (idx != -1) &#123; String str = s.substring(0, idx) + "--" + s.substring(idx + 2); if (!canWin(str)) &#123; map.put(str, false); return true; &#125; map.put(str, true); idx = s.indexOf("++", idx + 1); &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 914 - Flip Game]]></title>
    <url>%2F2019%2F04%2F07%2FLintCode-Problem-914-Flip-Game%2F</url>
    <content type="text"><![CDATA[You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive “++” into “–”. The game ends when a person can no longer make a move and therefore the other person will be the winner. Write a function to compute all possible states of the string after one valid move. ExampleNo.1Input: s = “++++” Output: 12345[ "--++", "+--+", "++--"] No.2Input: s = “—+++-+++-+” Output: 123456[ "---+++-+---+", "---+++---+-+", "---+---+++-+", "-----+-+++-+"] Code123456789101112public List&lt;String&gt; generatePossibleNextMoves(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); int idx = s.indexOf("++", 0); while (idx != -1) &#123; result.add(s.substring(0, idx) + "--" + s.substring(idx + 2)); idx = s.indexOf("++", idx + 1); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 203 - Remove Linked List Elements]]></title>
    <url>%2F2019%2F04%2F07%2FLeetCode-Problem-203-Remove-Linked-List-Elements%2F</url>
    <content type="text"><![CDATA[Remove all elements from a linked list of integers that have value val. ExampleInput: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6 Output: 1-&gt;2-&gt;3-&gt;4-&gt;5 Code12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314public ListNode removeElements(ListNode head, int val) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode current = dummy; while (current.next != null) &#123; if (current.next.val == val) current.next = current.next.next; else current = current.next; &#125; return dummy.next;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 237 - Delete Node in a Linked List]]></title>
    <url>%2F2019%2F04%2F07%2FLeetCode-Problem-237-Delete-Node-in-a-Linked-List%2F</url>
    <content type="text"><![CDATA[Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list – head = [4,5,1,9], which looks like following: ExampleNo.1Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function. No.2Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function. Note The linked list will have at least two elements. All of the nodes’ values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function. Code12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 1234public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 240 - Search a 2D Matrix II]]></title>
    <url>%2F2019%2F04%2F07%2FLeetCode-Problem-240-Search-a-2D-Matrix-II%2F</url>
    <content type="text"><![CDATA[Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. ExampleConsider the following matrix: 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] Given target = 5, return true. Given target = 20, return false. Code123456789101112131415public boolean searchMatrix(int[][] matrix, int target) &#123; int i = matrix.length - 1; int j = 0; while (i &gt;= 0 &amp;&amp; j &lt; matrix[0].length) &#123; if (matrix[i][j] &lt; target) j++; else if (matrix[i][j] &gt; target) i--; else return true; &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 74 - Search a 2D Matrix]]></title>
    <url>%2F2019%2F04%2F07%2FLeetCode-Problem-74-Search-a-2D-Matrix%2F</url>
    <content type="text"><![CDATA[Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. ExampleNo.1Input: 12345matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]] target = 3 Output: true No.2Input: 12345matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]] target = 13 Output: false Code1234567891011121314151617181920212223public boolean searchMatrix(int[][] matrix, int target) &#123; if (matrix.length &lt; 1) return false; int m = matrix.length; int n = matrix[0].length; int left = 0; int right = m * n - 1; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; int num = matrix[mid / n][mid % n]; if (num &lt; target) left = mid + 1; else if (num &gt; target) right = mid - 1; else return true; &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 373 - Find K Pairs with Smallest Sums]]></title>
    <url>%2F2019%2F04%2F05%2FLeetCode-Problem-373-Find-K-Pairs-with-Smallest-Sums%2F</url>
    <content type="text"><![CDATA[You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u,v) which consists of one element from the first array and one element from the second array. Find the k pairs (u1,v1),(u2,v2) …(uk,vk) with the smallest sums. ExampleNo.1Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]] Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] No.2Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 Output: [1,1],[1,1] Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] No.3Input: nums1 = [1,2], nums2 = [3], k = 3 Output: [1,3],[2,3] Explanation: All possible pairs are returned from the sequence: [1,3],[2,3] Code123456789101112131415161718192021222324252627public List&lt;int[]&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) &#123; List&lt;int[]&gt; result = new ArrayList&lt;&gt;(); if (nums1.length == 0 || nums2.length == 0) return result; PriorityQueue&lt;int[]&gt; minHeap = new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;() &#123; @Override public int compare(int[] o1, int[] o2) &#123; return (o1[0] + o1[1]) - (o2[0] + o2[1]); &#125; &#125;); for (int i = 0; i &lt; Math.min(k, nums1.length); i++) minHeap.offer(new int[] &#123;nums1[i], nums2[0], 0&#125;); while (!minHeap.isEmpty() &amp;&amp; k &gt; 0) &#123; int[] pair = minHeap.poll(); result.add(new int[] &#123;pair[0], pair[1]&#125;); k--; if (pair[2] &lt; nums2.length - 1) minHeap.offer(new int[] &#123;pair[0], nums2[pair[2] + 1], pair[2] + 1&#125;); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 378 - Kth Smallest Element in a Sorted Matrix]]></title>
    <url>%2F2019%2F04%2F05%2FLeetCode-Problem-378-Kth-Smallest-Element-in-a-Sorted-Matrix%2F</url>
    <content type="text"><![CDATA[Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example12345matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]], k = 8, return 13. NoteYou may assume k is always valid, 1 ≤ k ≤ n^2. Code1234567891011121314151617181920212223242526272829303132333435363738// 第k小的数一定在left和right之间：即 left&lt;= answer &lt;= right// 循环结束的条件必定是：left &gt;= right// 所以：left == answer == rightpublic int kthSmallest(int[][] matrix, int k) &#123; int m = matrix.length; int n = matrix[0].length; int left = matrix[0][0]; int right = matrix[m - 1][n - 1]; while (left &lt; right) &#123; int mid = (left + right) &gt;&gt; 1; int count = count(matrix, mid, m, n); if (count &lt; k) left = mid + 1; else right = mid; &#125; return right;&#125;private int count(int[][] matrix, int mid, int m, int n) &#123; int i = m - 1; int j = 0; int count = 0; while (i &gt;= 0 &amp;&amp; j &lt; n) &#123; if (matrix[i][j] &lt;= mid) &#123; j++; count += i + 1; &#125; else i--; &#125; return count;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 93 - Restore IP Addresses]]></title>
    <url>%2F2019%2F04%2F05%2FLeetCode-Problem-93-Restore-IP-Addresses%2F</url>
    <content type="text"><![CDATA[Given a string containing only digits, restore it by returning all possible valid IP address combinations. ExampleInput: “25525511135” Output: [“255.255.11.135”, “255.255.111.35”] Code12345678910111213141516171819202122232425262728293031323334public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); restoreIpAddressesHelper(result, new ArrayList&lt;&gt;(), s, 0, 0); return result;&#125;private void restoreIpAddressesHelper(List&lt;String&gt; result, List&lt;String&gt; ip, String s, int idx, int level) &#123; if (level == 4 &amp;&amp; idx == s.length()) &#123; result.add(ip.get(0) + "." + ip.get(1) + "." + ip.get(2) + "." + ip.get(3)); return; &#125; if (level == 4 || idx == s.length()) return; for (int i = 1; i &lt;= 3 &amp;&amp; idx + i &lt;= s.length(); i++) &#123; String str = s.substring(idx, idx + i); if (!isValid(str)) break; ip.add(str); restoreIpAddressesHelper(result, ip, s, idx + i, level + 1); ip.remove(ip.size() - 1); &#125;&#125;private boolean isValid(String s) &#123; if (s.length() &gt; 1 &amp;&amp; s.charAt(0) == '0') return false; int i = Integer.parseInt(s); return i &lt;= 255 &amp;&amp; i &gt;= 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 556 - Next Greater Element III]]></title>
    <url>%2F2019%2F04%2F05%2FLeetCode-Problem-556-Next-Greater-Element-III%2F</url>
    <content type="text"><![CDATA[Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1. ExampleNo.1Input: 12 Output: 21 No.2Input: 21 Output: -1 Code123456789101112131415161718192021222324252627282930313233343536public int nextGreaterElement(int n) &#123; char[] ch = String.valueOf(n).toCharArray(); int i = ch.length - 2; while (i &gt;= 0 &amp;&amp; ch[i] &gt;= ch[i + 1]) i--; if (i &lt; 0) return -1; int j = ch.length - 1; while (j &gt;= i &amp;&amp; ch[j] &lt;= ch[i]) j--; swap(ch, i, j); reverse(ch, i + 1, ch.length - 1); long result = Long.parseLong(String.valueOf(ch)); return result &gt; Integer.MAX_VALUE ? -1 : (int) result;&#125;private void swap(char[] ch, int i, int j) &#123; char temp = ch[i]; ch[i] = ch[j]; ch[j] = temp;&#125;private void reverse(char[] ch, int i, int j) &#123; while (i &lt; j) &#123; swap(ch, i, j); i++; j--; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 503 - Next Greater Element II]]></title>
    <url>%2F2019%2F04%2F04%2FLeetCode-Problem-503-Next-Greater-Element-II%2F</url>
    <content type="text"><![CDATA[Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, output -1 for this number. ExampleInput: [1,2,1] Output: [2,-1,2] Explanation: The first 1’s next greater number is 2;The number 2 can’t find next greater number;The second 1’s next greater number needs to search circularly, which is also 2. NoteThe length of given array won’t exceed 10000. Code123456789101112131415161718public int[] nextGreaterElements(int[] nums) &#123; int[] result = new int[nums.length]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Arrays.fill(result, -1); for (int i = 0; i &lt; 2 * nums.length; i++) &#123; int idx = i % nums.length; while (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[idx]) result[stack.pop()] = nums[idx]; if (i &lt; nums.length) stack.push(i); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 496 - Next Greater Element I]]></title>
    <url>%2F2019%2F04%2F04%2FLeetCode-Problem-496-Next-Greater-Element-I%2F</url>
    <content type="text"><![CDATA[You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2. The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number. ExampleNo.1Input: nums1 = [4,1,2], nums2 = [1,3,4,2]. Output: [-1,3,-1] Explanation: For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1. For number 1 in the first array, the next greater number for it in the second array is 3. For number 2 in the first array, there is no next greater number for it in the second array, so output -1. No.2Input: nums1 = [2,4], nums2 = [1,2,3,4]. Output: [3,-1] Explanation: For number 2 in the first array, the next greater number for it in the second array is 3. For number 4 in the first array, there is no next greater number for it in the second array, so output -1. Note All elements in nums1 and nums2 are unique. The length of both nums1 and nums2 would not exceed 1000. Code1234567891011121314151617public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123; int[] result = new int[nums1.length]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int num : nums2) &#123; while (!stack.isEmpty() &amp;&amp; stack.peek() &lt; num) map.put(stack.pop(), num); stack.push(num); &#125; for (int i = 0; i &lt; nums1.length; i++) result[i] = map.getOrDefault(nums1[i], -1); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 176 - Route Between Two Nodes in Graph]]></title>
    <url>%2F2019%2F04%2F02%2FLintCode-Problem-176-Route-Between-Two-Nodes-in-Graph%2F</url>
    <content type="text"><![CDATA[Given a directed graph, design an algorithm to find out whether there is a route between two nodes. ExampleGiven graph: 123456 A-----&gt;B-----&gt;C\ | \ | \ | \ v -&gt;D-----&gt;E No.1Input:s = B and t = E, Output:true No.2Input:s = D and t = C, Output:false Code12345678public class DirectedGraphNode &#123; int label; ArrayList&lt;DirectedGraphNode&gt; neighbors; DirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;DirectedGraphNode&gt;(); &#125;&#125; 123456789101112131415161718192021public boolean hasRoute(ArrayList&lt;DirectedGraphNode&gt; graph, DirectedGraphNode s, DirectedGraphNode t) &#123; Set&lt;DirectedGraphNode&gt; set = new HashSet&lt;&gt;(); Queue&lt;DirectedGraphNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(s); set.add(s); while (!queue.isEmpty()) &#123; DirectedGraphNode node = queue.poll(); for (DirectedGraphNode neighbor : node.neighbors) &#123; if (set.contains(neighbor)) continue; set.add(neighbor); queue.offer(neighbor); &#125; &#125; return set.contains(t);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 165 - Compare Version Numbers]]></title>
    <url>%2F2019%2F04%2F02%2FLeetCode-Problem-165-Compare-Version-Numbers%2F</url>
    <content type="text"><![CDATA[Compare two version numbers version1 and version2.If version1 &gt; version2 return 1; if version1 &lt; version2 return -1;otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision. You may assume the default revision number for each level of a version number to be 0. For example, version number 3.4 has a revision number of 3 and 4 for its first and second level revision number. Its third and fourth level revision number are both 0. ExampleNo.1Input: version1 = “0.1”, version2 = “1.1” Output: -1 No.2Input: version1 = “1.0.1”, version2 = “1” Output: 1 No.3Input: version1 = “7.5.2.4”, version2 = “7.5.3” Output: -1 No.4Input: version1 = “1.01”, version2 = “1.001” Output: 0 Explanation: Ignoring leading zeroes, both “01” and “001” represent the same number “1” No.5Input: version1 = “1.0”, version2 = “1.0.0” Output: 0 Explanation: The first version number does not have a third level revision number, which means its third level revision number is default to “0” Note Version strings are composed of numeric strings separated by dots . and this numeric strings may have leading zeroes. Version strings do not start or end with dots, and they will not be two consecutive dots. Code1234567891011121314151617public int compareVersion(String version1, String version2) &#123; String[] str1 = version1.split("\\."); String[] str2 = version2.split("\\."); int length = Math.max(str1.length, str2.length); for (int i = 0; i &lt; length; i++) &#123; int v1 = i &gt; str1.length - 1 ? 0 : Integer.parseInt(str1[i]); int v2 = i &gt; str2.length - 1 ? 0 : Integer.parseInt(str2[i]); if (v1 &gt; v2) return 1; else if (v1 &lt; v2) return -1; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 445 - Add Two Numbers II]]></title>
    <url>%2F2019%2F04%2F01%2FLeetCode-Problem-445-Add-Two-Numbers-II%2F</url>
    <content type="text"><![CDATA[You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow upWhat if you cannot modify the input lists? In other words, reversing the lists is not allowed. ExampleInput: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 Code12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324252627282930public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;(); ListNode dummy = new ListNode(0); while (l1 != null) &#123; stack1.push(l1.val); l1 = l1.next; &#125; while (l2 != null) &#123; stack2.push(l2.val); l2 = l2.next; &#125; int carry = 0; while (!stack1.isEmpty() || !stack2.isEmpty() || carry != 0) &#123; int val1 = stack1.isEmpty() ? 0 : stack1.pop(); int val2 = stack2.isEmpty() ? 0 : stack2.pop(); int sum = val1 + val2 + carry; carry = sum / 10; ListNode node = new ListNode(sum % 10); node.next = dummy.next; dummy.next = node; &#125; return dummy.next;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 347 - Top K Frequent Elements]]></title>
    <url>%2F2019%2F04%2F01%2FLeetCode-Problem-347-Top-K-Frequent-Elements%2F</url>
    <content type="text"><![CDATA[Given a non-empty array of integers, return the k most frequent elements. ExampleNo.1Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] No.2Input: nums = [1], k = 1 Output: [1] Note You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size. Code123456789101112131415161718192021222324252627public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; minHeap = new PriorityQueue&lt;&gt;(new Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123; @Override public int compare(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2) &#123; return o1.getValue() - o2.getValue(); &#125; &#125;); for (int num : nums) map.put(num, map.getOrDefault(num, 0) + 1); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; if (minHeap.size() &lt; k) minHeap.offer(entry); else if (entry.getValue() &gt; minHeap.peek().getValue()) &#123; minHeap.poll(); minHeap.offer(entry); &#125; &#125; while (!minHeap.isEmpty()) result.add(minHeap.poll().getKey()); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 31 - Next Permutation]]></title>
    <url>%2F2019%2F03%2F31%2FLeetCode-Problem-31-Next-Permutation%2F</url>
    <content type="text"><![CDATA[Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 Code12345678910111213141516171819202122232425262728293031public void nextPermutation(int[] nums) &#123; int i = nums.length - 2; while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) i--; if (i &gt;= 0) &#123; int j = nums.length - 1; while (j &gt;= i &amp;&amp; nums[j] &lt;= nums[i]) j--; swap(nums, i, j); &#125; reverse(nums, i + 1, nums.length - 1);&#125;private void reverse(int[] nums, int i, int j) &#123; while (i &lt; j) &#123; swap(nums, i, j); i++; j--; &#125;&#125;private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 131 - Palindrome Partitioning]]></title>
    <url>%2F2019%2F03%2F31%2FLeetCode-Problem-131-Palindrome-Partitioning%2F</url>
    <content type="text"><![CDATA[Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example:Input: “aab” Output: 1234[ ["aa","b"], ["a","a","b"]] Code12345678910111213141516171819202122232425262728293031323334public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); partitionHelper(result, new ArrayList&lt;&gt;(), s, 0); return result;&#125;private void partitionHelper(List&lt;List&lt;String&gt;&gt; result, List&lt;String&gt; palindrome, String s, int idx) &#123; if (idx == s.length()) &#123; result.add(new ArrayList&lt;&gt;(palindrome)); return; &#125; for (int i = idx; i &lt; s.length(); i++) &#123; if (isPalindrome(s, idx, i)) &#123; palindrome.add(s.substring(idx, i + 1)); partitionHelper(result, palindrome, s, i + 1); palindrome.remove(palindrome.size() - 1); &#125; &#125;&#125;private boolean isPalindrome(String s, int start, int end) &#123; while (start &lt; end) &#123; if (s.charAt(start) != s.charAt(end)) return false; start++; end--; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 90 - Subsets II]]></title>
    <url>%2F2019%2F03%2F31%2FLeetCode-Problem-90-Subsets-II%2F</url>
    <content type="text"><![CDATA[Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). NoteThe solution set must not contain duplicate subsets. ExampleInput: [1,2,2] Output: 12345678[ [2], [1], [1,2,2], [2,2], [1,2], []] Code1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); subsetsWithDupHelper(result, new ArrayList&lt;&gt;(), nums, 0); return result;&#125;private void subsetsWithDupHelper(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; subset, int[] nums, int idx) &#123; result.add(new ArrayList&lt;&gt;(subset)); for (int i = idx; i &lt; nums.length; i++) &#123; if (i &gt; idx &amp;&amp; nums[i] == nums[i - 1]) continue; subset.add(nums[i]); subsetsWithDupHelper(result, subset, nums, i + 1); subset.remove(subset.size() - 1); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 78 - Subsets]]></title>
    <url>%2F2019%2F03%2F31%2FLeetCode-Problem-78-Subsets%2F</url>
    <content type="text"><![CDATA[Given a set of distinct integers, nums, return all possible subsets (the power set). NoteThe solution set must not contain duplicate subsets. ExampleInput: nums = [1,2,3] Output: 12345678910[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] Code12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); subsetsHelper(result, new ArrayList&lt;&gt;(), nums, 0); return result;&#125;private void subsetsHelper(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; subset, int[] nums, int idx) &#123; result.add(new ArrayList&lt;&gt;(subset)); for (int i = idx; i &lt; nums.length; i++) &#123; subset.add(nums[i]); subsetsHelper(result, subset, nums, i + 1); subset.remove(subset.size() - 1); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 47 - Permutations II]]></title>
    <url>%2F2019%2F03%2F31%2FLeetCode-Problem-47-Permutations-II%2F</url>
    <content type="text"><![CDATA[Given a collection of numbers that might contain duplicates, return all possible unique permutations. ExampleInput: [1,1,2] Output: 12345[ [1,1,2], [1,2,1], [2,1,1]] Code1234567891011121314151617181920212223242526public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); permuteUniqueHelper(result, new ArrayList&lt;&gt;(), new boolean[nums.length], nums); return result;&#125;private void permuteUniqueHelper(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; permute, boolean[] visit, int[] nums) &#123; if (permute.size() == nums.length) &#123; result.add(new ArrayList&lt;&gt;(permute)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (visit[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visit[i - 1])) continue; permute.add(nums[i]); visit[i] = true; permuteUniqueHelper(result, permute, visit, nums); permute.remove(permute.size() - 1); visit[i] = false; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 46 - Permutations]]></title>
    <url>%2F2019%2F03%2F31%2FLeetCode-Problem-46-Permutations%2F</url>
    <content type="text"><![CDATA[Given a collection of distinct integers, return all possible permutations. ExampleInput: [1,2,3] Output: 12345678[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] Code1234567891011121314151617181920212223public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); permuteHelper(result, new ArrayList&lt;&gt;(), nums); return result;&#125;private void permuteHelper(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; permute, int[] nums) &#123; if (permute.size() == nums.length) &#123; result.add(new ArrayList&lt;&gt;(permute)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (permute.contains(nums[i])) continue; permute.add(nums[i]); permuteHelper(result, permute, nums); permute.remove(permute.size() - 1); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 641 - Design Circular Deque]]></title>
    <url>%2F2019%2F03%2F31%2FLeetCode-Problem-641-Design-Circular-Deque%2F</url>
    <content type="text"><![CDATA[Design your implementation of the circular double-ended queue (deque). Your implementation should support following operations: MyCircularDeque(k): Constructor, set the size of the deque to be k. insertFront(): Adds an item at the front of Deque. Return true if the operation is successful. insertLast(): Adds an item at the rear of Deque. Return true if the operation is successful. deleteFront(): Deletes an item from the front of Deque. Return true if the operation is successful. deleteLast(): Deletes an item from the rear of Deque. Return true if the operation is successful. getFront(): Gets the front item from the Deque. If the deque is empty, return -1. getRear(): Gets the last item from Deque. If the deque is empty, return -1. isEmpty(): Checks whether Deque is empty or not. isFull(): Checks whether Deque is full or not. Example12345678910MyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be 3circularDeque.insertLast(1); // return truecircularDeque.insertLast(2); // return truecircularDeque.insertFront(3); // return truecircularDeque.insertFront(4); // return false, the queue is fullcircularDeque.getRear(); // return 2circularDeque.isFull(); // return truecircularDeque.deleteLast(); // return truecircularDeque.insertFront(4); // return truecircularDeque.getFront(); // return 4 Note All values will be in the range of [0, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in Deque library. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private int[] queue;private int front;private int rear;private int size;public MyCircularDeque(int k) &#123; queue = new int[k]; front = 0; rear = -1; size = 0;&#125;public boolean insertFront(int value) &#123; if (!isFull()) &#123; if (isEmpty()) &#123; front = 0; rear = 0; &#125; else front = (front - 1 + queue.length) % queue.length; queue[front] = value; size++; return true; &#125; return false;&#125;public boolean insertLast(int value) &#123; if (!isFull()) &#123; rear = (++rear) % queue.length; queue[rear] = value; size++; return true; &#125; return false;&#125;public boolean deleteFront() &#123; if (!isEmpty()) &#123; front = (++front) % queue.length; size--; return true; &#125; return false;&#125;public boolean deleteLast() &#123; if (!isEmpty()) &#123; rear = (rear - 1 + queue.length) % queue.length; size--; return true; &#125; return false;&#125;public int getFront() &#123; if (isEmpty()) return -1; return queue[front];&#125;public int getRear() &#123; if (isEmpty()) return -1; return queue[rear];&#125;public boolean isEmpty() &#123; return size == 0;&#125;public boolean isFull() &#123; return size == queue.length;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 622 - Design Circular Queue]]></title>
    <url>%2F2019%2F03%2F30%2FLeetCode-Problem-622-Design-Circular-Queue%2F</url>
    <content type="text"><![CDATA[Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called “Ring Buffer”. One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values. Your implementation should support following operations: MyCircularQueue(k): Constructor, set the size of the queue to be k. Front: Get the front item from the queue. If the queue is empty, return -1. Rear: Get the last item from the queue. If the queue is empty, return -1. enQueue(value): Insert an element into the circular queue. Return true if the operation is successful. deQueue(): Delete an element from the circular queue. Return true if the operation is successful. isEmpty(): Checks whether the circular queue is empty or not. isFull(): Checks whether the circular queue is full or not. Example12345678910MyCircularQueue circularQueue = new MyCircularQueue(3); // set the size to be 3circularQueue.enQueue(1); // return truecircularQueue.enQueue(2); // return truecircularQueue.enQueue(3); // return truecircularQueue.enQueue(4); // return false, the queue is fullcircularQueue.Rear(); // return 3circularQueue.isFull(); // return truecircularQueue.deQueue(); // return truecircularQueue.enQueue(4); // return truecircularQueue.Rear(); // return 4 Note All values will be in the range of [0, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in Queue library. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private int[] queue;private int front;private int rear;private int size;public MyCircularQueue(int k) &#123; queue = new int[k]; front = 0; rear = -1; size = 0;&#125;public boolean enQueue(int value) &#123; if (!isFull()) &#123; rear = (++rear) % queue.length; queue[rear] = value; size++; return true; &#125; return false;&#125;public boolean deQueue() &#123; if (!isEmpty()) &#123; front = (++front) % queue.length; size--; return true; &#125; return false;&#125;public int Front() &#123; if (isEmpty()) return -1; return queue[front];&#125;public int Rear() &#123; if (isEmpty()) return -1; return queue[rear];&#125;public boolean isEmpty() &#123; return size == 0;&#125;public boolean isFull() &#123; return size == queue.length;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 707 - Design Linked List]]></title>
    <url>%2F2019%2F03%2F30%2FLeetCode-Problem-707-Design-Linked-List%2F</url>
    <content type="text"><![CDATA[Design your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed. Implement these functions in your linked list class: get(index) : Get the value of the index-th node in the linked list. If the index is invalid, return -1. addAtHead(val) : Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. addAtTail(val) : Append a node of value val to the last element of the linked list. addAtIndex(index, val) : Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. deleteAtIndex(index) : Delete the index-th node in the linked list, if the index is valid. Example1234567MyLinkedList linkedList = new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1, 2); // linked list becomes 1-&gt;2-&gt;3linkedList.get(1); // returns 2linkedList.deleteAtIndex(1); // now the linked list is 1-&gt;3linkedList.get(1); // returns 3 Note All values will be in the range of [1, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in LinkedList library. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899private int size;private Node head;private Node tail;private class Node &#123; int val; Node next; public Node(int val) &#123; this.val = val; &#125;&#125;public MyLinkedList() &#123; size = 0;&#125;public int get(int index) &#123; if (size == 0 || index &gt;= size) return -1; Node node = head; for (int i = 1; i &lt;= index; i++) node = node.next; return node.val;&#125;public void addAtHead(int val) &#123; Node node = new Node(val); node.next = head; head = node; if (size == 0) tail = head; size++;&#125;public void addAtTail(int val) &#123; Node node = new Node(val); if (size == 0) head = node; else tail.next = node; tail = node; size++;&#125;public void addAtIndex(int index, int val) &#123; if (index &gt; size) return; if (index == size) &#123; addAtTail(val); return; &#125; if (index == 0) &#123; addAtHead(val); return; &#125; Node node = new Node(val); Node current = head; for (int i = 1; i &lt; index; i++) &#123; current = current.next; &#125; node.next = current.next; current.next = node; size++;&#125;public void deleteAtIndex(int index) &#123; if (size == 0 || index &gt;= size) return; if (index == 0) &#123; head = head.next; size--; return; &#125; Node current = head; for (int i = 1; i &lt; index; i++) &#123; current = current.next; &#125; current.next = current.next.next; if (index == size - 1) tail = current; size--;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 705 - Design HashSet]]></title>
    <url>%2F2019%2F03%2F30%2FLeetCode-Problem-705-Design-HashSet%2F</url>
    <content type="text"><![CDATA[Design a HashSet without using any built-in hash table libraries. To be specific, your design should include these functions: add(value): Insert a value into the HashSet. contains(value) : Return whether the value exists in the HashSet or not. remove(value): Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing. Example123456789MyHashSet hashSet = new MyHashSet();hashSet.add(1); hashSet.add(2); hashSet.contains(1); // returns truehashSet.contains(3); // returns false (not found)hashSet.add(2); hashSet.contains(2); // returns truehashSet.remove(2); hashSet.contains(2); // returns false (already removed) Note All values will be in the range of [0, 1000000]. The number of operations will be in the range of [1, 10000]. Please do not use the built-in HashSet library. Code123456789101112131415161718192021222324252627282930313233private int size = 1000;private LinkedList[] map;public MyHashSet() &#123; map = new LinkedList[size]; for (int i = 0; i &lt; size; i++) map[i] = new LinkedList&lt;Integer&gt;();&#125;public void add(int key) &#123; if (!contains(key)) &#123; int hash = hash(key); map[hash].add(key); &#125;&#125;public void remove(int key) &#123; if (contains(key)) &#123; int hash = hash(key); int idx = map[hash].indexOf(key); map[hash].remove(idx); &#125;&#125;public boolean contains(int key) &#123; int hash = hash(key); return map[hash].contains(key);&#125;private int hash(Integer x)&#123; return x.hashCode() % size;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 706 - Design HashMap]]></title>
    <url>%2F2019%2F03%2F30%2FLeetCode-Problem-706-Design-HashMap%2F</url>
    <content type="text"><![CDATA[Design a HashMap without using any built-in hash table libraries. To be specific, your design should include these functions: put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value. get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. remove(key) : Remove the mapping for the value key if this map contains the mapping for the key. Example123456789MyHashMap hashMap = new MyHashMap();hashMap.put(1, 1); hashMap.put(2, 2); hashMap.get(1); // returns 1hashMap.get(3); // returns -1 (not found)hashMap.put(2, 1); // update the existing valuehashMap.get(2); // returns 1 hashMap.remove(2); // remove the mapping for 2hashMap.get(2); // returns -1 (not found) Note All keys and values will be in the range of [0, 1000000]. The number of operations will be in the range of [1, 10000]. Please do not use the built-in HashMap library. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private int size = 1000;private Node[] map;private class Node&#123; int key; int value; Node next; public Node (int key, int value)&#123; this.key = key; this.value = value; &#125;&#125;public MyHashMap() &#123; map = new Node[size]; for (int i = 0; i &lt; size; i++) map[i] = new Node(-1, -1);&#125;public void put(int key, int value) &#123; int hash = hash(key); Node p = find(map[hash], key); if (p.next == null) p.next = new Node(key, value); else p.next.value = value;&#125;public int get(int key) &#123; int hash = hash(key); Node p = find(map[hash], key); return p.next == null ? -1 : p.next.value;&#125;public void remove(int key) &#123; int hash = hash(key); Node p = find(map[hash], key); if (p.next != null) p.next = p.next.next;&#125;private int hash(Integer x)&#123; return x.hashCode() % size;&#125;private Node find(Node n, int key) &#123; Node p = null; while (n != null &amp;&amp; n.key != key) &#123; p = n; n = n.next; &#125; return p;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 232 - Implement Queue using Stacks]]></title>
    <url>%2F2019%2F03%2F29%2FLeetCode-Problem-232-Implement-Queue-using-Stacks%2F</url>
    <content type="text"><![CDATA[Implement the following operations of a queue using stacks. push(x) – Push element x to the back of queue.pop() – Removes the element from in front of queue.peek() – Get the front element.empty() – Return whether the queue is empty. Example1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2); queue.peek(); // returns 1queue.pop(); // returns 1queue.empty(); // returns false Notes You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). Code1234567891011121314151617181920212223242526272829303132333435private Stack&lt;Integer&gt; stack1;private Stack&lt;Integer&gt; stack2;private int top;public MyQueue() &#123; stack1 = new Stack&lt;&gt;(); stack2 = new Stack&lt;&gt;();&#125;public void push(int x) &#123; if (stack1.isEmpty()) top = x; stack1.push(x);&#125;public int pop() &#123; if (stack2.isEmpty()) &#123; while (!stack1.isEmpty()) stack2.push(stack1.pop()); &#125; return stack2.pop();&#125;public int peek() &#123; if (stack2.isEmpty()) return top; return stack2.peek();&#125;public boolean empty() &#123; return stack1.isEmpty() &amp;&amp; stack2.isEmpty();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 225 - Implement Stack using Queues]]></title>
    <url>%2F2019%2F03%2F29%2FLeetCode-Problem-225-Implement-Stack-using-Queues%2F</url>
    <content type="text"><![CDATA[Implement the following operations of a stack using queues. push(x) – Push element x onto stack.pop() – Removes the element on top of the stack.top() – Get the top element.empty() – Return whether the stack is empty. Example1234567MyStack stack = new MyStack();stack.push(1);stack.push(2); stack.top(); // returns 2stack.pop(); // returns 2stack.empty(); // returns false Notes You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). Code1234567891011121314151617181920212223242526272829303132333435private Queue&lt;Integer&gt; queue1;private Queue&lt;Integer&gt; queue2;private int top;public MyStack() &#123; queue1 = new LinkedList&lt;&gt;(); queue2 = new LinkedList&lt;&gt;();&#125;public void push(int x) &#123; queue1.offer(x); top = x;&#125;public int pop() &#123; while (queue1.size() &gt; 1) &#123; top = queue1.remove(); queue2.offer(top); &#125; int num = queue1.poll(); while (!queue2.isEmpty()) queue1.offer(queue2.remove()); return num;&#125;public int top() &#123; return top;&#125;public boolean empty() &#123; return queue1.isEmpty();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 377 - Combination Sum IV]]></title>
    <url>%2F2019%2F03%2F29%2FLeetCode-Problem-377-Combination-Sum-IV%2F</url>
    <content type="text"><![CDATA[Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Examplenums = [1, 2, 3]target = 4 The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1) Note that different sequences are counted as different combinations. Therefore the output is 7. Follow upWhat if negative numbers are allowed in the given array?How does it change the problem?What limitation we need to add to the question to allow negative numbers? Code1234567891011121314public int combinationSum4(int[] nums, int target) &#123; int[] dp = new int[target + 1]; dp[0] = 1; // dp[i] += dp[i - num[j]] for (int i = 1; i &lt;= target; i++) &#123; for (int num : nums) &#123; if (i &gt;= num) dp[i] += dp[i - num]; &#125; &#125; return dp[target];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 538 - Convert BST to Greater Tree]]></title>
    <url>%2F2019%2F03%2F29%2FLeetCode-Problem-538-Convert-BST-to-Greater-Tree%2F</url>
    <content type="text"><![CDATA[Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. ExampleInput: The root of a Binary Search Tree like this: 123 5 / \2 13 Output: The root of a Greater Tree like this: 123 18 / \20 13 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617private int sum = 0;public TreeNode convertBST(TreeNode root) &#123; if (root == null) return null; if (root.right != null) convertBST(root.right); sum += root.val; root.val = sum; if (root.left != null) convertBST(root.left); return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 216 - Combination Sum III]]></title>
    <url>%2F2019%2F03%2F28%2FLeetCode-Problem-216-Combination-Sum-III%2F</url>
    <content type="text"><![CDATA[Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note All numbers will be positive integers. The solution set must not contain duplicate combinations. ExampleNo.1Input: k = 3, n = 7 Output: [[1,2,4]] No.2Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]] Code123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; combination = new ArrayList&lt;&gt;(); combinationSum3Helper(result, combination, k, n, 1); return result;&#125;private void combinationSum3Helper(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; combination, int k, int n, int idx) &#123; if (n == 0 &amp;&amp; combination.size() == k) &#123; result.add(new ArrayList&lt;&gt;(combination)); return; &#125; for (int i = idx; i &lt;= 9 &amp;&amp; combination.size() &lt; k &amp;&amp; n &gt; 0; i++) &#123; combination.add(i); combinationSum3Helper(result, combination, k, n - i, i + 1); combination.remove(combination.size() - 1); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 40 - Combination Sum II]]></title>
    <url>%2F2019%2F03%2F28%2FLeetCode-Problem-40-Combination-Sum-II%2F</url>
    <content type="text"><![CDATA[Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. ExampleNo.1Input: candidates = [10,1,2,7,6,1,5], target = 8,A solution set is: 123456[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] No.2Input: candidates = [2,5,2,1,2], target = 5, 12345A solution set is:[ [1,2,2], [5]] Code12345678910111213141516171819202122232425262728public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; combination = new ArrayList&lt;&gt;(); Arrays.sort(candidates); combinationSum2Helper(result, combination, candidates, target, 0); return result;&#125;private void combinationSum2Helper(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; combination, int[] candidates, int target, int idx) &#123; if (target &lt; 0) return; if (target == 0) &#123; result.add(new ArrayList&lt;&gt;(combination)); return; &#125; for (int i = idx; i &lt; candidates.length; i++) &#123; if (i &gt; idx &amp;&amp; candidates[i] == candidates[i - 1]) continue; combination.add(candidates[i]); combinationSum2Helper(result, combination, candidates, target - candidates[i], i + 1); combination.remove(combination.size() - 1); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 39 - Combination Sum]]></title>
    <url>%2F2019%2F03%2F28%2FLeetCode-Problem-39-Combination-Sum%2F</url>
    <content type="text"><![CDATA[Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. ExampleNo.1Input: candidates = [2,3,6,7], target = 7,A solution set is: 1234[ [7], [2,2,3]] No.2Input: candidates = [2,3,5], target = 8,A solution set is: 12345[ [2,2,2,2], [2,3,3], [3,5]] Code12345678910111213141516171819202122232425public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; combination = new ArrayList&lt;&gt;(); Arrays.sort(candidates); combinationSumHelper(result, combination, candidates, target, 0); return result;&#125;private void combinationSumHelper(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; combination, int[] candidates, int target, int idx) &#123; if (target &lt; 0) return; if (target == 0) &#123; result.add(new ArrayList&lt;&gt;(combination)); return; &#125; for (int i = idx; i &lt; candidates.length; i++) &#123; combination.add(candidates[i]); combinationSumHelper(result, combination, candidates, target - candidates[i], i); combination.remove(combination.size() - 1); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 107 - Binary Tree Level Order Traversal II]]></title>
    <url>%2F2019%2F03%2F27%2FLeetCode-Problem-107-Binary-Tree-Level-Order-Traversal-II%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). ExampleGiven binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its bottom-up level order traversal as: 12345[ [15,7], [9,20], [3]] Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516171819202122232425262728293031public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; int size = queue.size(); List&lt;Integer&gt; level = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; size; i++) &#123; TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); &#125; result.add(level); &#125; Collections.reverse(result); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 102 - Binary Tree Level Order Traversal]]></title>
    <url>%2F2019%2F03%2F27%2FLeetCode-Problem-102-Binary-Tree-Level-Order-Traversal%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). ExampleGiven binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617181920212223242526272829public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; int size = queue.size(); List&lt;Integer&gt; level = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; size; i++) &#123; TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); &#125; result.add(level); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 145 - Binary Tree Postorder Traversal]]></title>
    <url>%2F2019%2F03%2F27%2FLeetCode-Problem-145-Binary-Tree-Postorder-Traversal%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the postorder traversal of its nodes’ values. ExampleInput: [1,null,2,3] 123451 \ 2 /3 Output: [3,2,1] Follow upRecursive solution is trivial, could you do it iteratively? Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516171819202122public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if (root == null) return result; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); result.add(0, node.val); if (node.left != null) stack.push(node.left); if (node.right != null) stack.push(node.right); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 94 - Binary Tree Inorder Traversal]]></title>
    <url>%2F2019%2F03%2F27%2FLeetCode-Problem-94-Binary-Tree-Inorder-Traversal%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the inorder traversal of its nodes’ values. ExampleInput: [1,null,2,3] 123451 \ 2 /3 Output: [1,3,2] Follow upRecursive solution is trivial, could you do it iteratively? Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode current = root; while (current != null || !stack.isEmpty()) &#123; while (current != null) &#123; stack.push(current); current = current.left; &#125; TreeNode node = stack.pop(); result.add(node.val); current = node.right; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 144 - Binary Tree Preorder Traversal]]></title>
    <url>%2F2019%2F03%2F27%2FLeetCode-Problem-144-Binary-Tree-Preorder-Traversal%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the preorder traversal of its nodes’ values. ExampleInput: [1,null,2,3] 123451 \ 2 /3 Output: [1,2,3] Follow upRecursive solution is trivial, could you do it iteratively? Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516171819202122public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); result.add(node.val); if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 92 - Reverse Linked List II]]></title>
    <url>%2F2019%2F03%2F27%2FLeetCode-Problem-92-Reverse-Linked-List-II%2F</url>
    <content type="text"><![CDATA[Reverse a linked list from position m to n. Do it in one-pass. Note1 ≤ m ≤ n ≤ length of list. ExampleInput: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL Code12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324public ListNode reverseBetween(ListNode head, int m, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode mPrevNode = dummy; for (int i = 1; i &lt; m; i++) mPrevNode = mPrevNode.next; ListNode mNode = mPrevNode.next; ListNode nNode = mNode; ListNode nPostNode = nNode.next; for (int i = m; i &lt; n; i++) &#123; ListNode next = nPostNode.next; nPostNode.next = nNode; nNode = nPostNode; nPostNode = next; &#125; mNode.next = nPostNode; mPrevNode.next = nNode; return dummy.next;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 206 - Reverse Linked List]]></title>
    <url>%2F2019%2F03%2F27%2FLeetCode-Problem-206-Reverse-Linked-List%2F</url>
    <content type="text"><![CDATA[Reverse a singly linked list. ExampleInput: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL Follow upA linked list can be reversed either iteratively or recursively. Could you implement both? Code12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 12345678910111213public ListNode reverseList(ListNode head) &#123; ListNode prev = null; ListNode cur = head; while (cur != null) &#123; ListNode next = cur.next; cur.next = prev; prev = cur; cur = next; &#125; return prev;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 142 - Linked List Cycle II]]></title>
    <url>%2F2019%2F03%2F27%2FLeetCode-Problem-142-Linked-List-Cycle-II%2F</url>
    <content type="text"><![CDATA[Given a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. NoteDo not modify the linked list. ExampleNo.1Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node. No.2Input: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where tail connects to the first node. No.3Input: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list. Follow upCan you solve it without using extra space? Code12345678public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; next = null; &#125;&#125; 12345678910111213141516171819202122232425262728293031public ListNode detectCycle(ListNode head) &#123; ListNode result = hasCycle(head); if (result == null) return null; while (head != result) &#123; head = head.next; result = result.next; &#125; return result;&#125;private ListNode hasCycle(ListNode head) &#123; if (head == null) return null; ListNode fast = head; ListNode slow = head; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) return slow; &#125; return null;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 141 - Linked List Cycle]]></title>
    <url>%2F2019%2F03%2F27%2FLeetCode-Problem-141-Linked-List-Cycle%2F</url>
    <content type="text"><![CDATA[Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. ExampleNo.1Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node. No.2Input: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where tail connects to the first node. No.3Input: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list. Follow upCan you solve it using O(1) (i.e. constant) memory? Code12345678public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; next = null; &#125;&#125; 1234567891011121314151617public boolean hasCycle(ListNode head) &#123; if (head == null) return false; ListNode fast = head; ListNode slow = head; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) return true; &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 260 - Single Number III]]></title>
    <url>%2F2019%2F03%2F25%2FLeetCode-Problem-260-Single-Number-III%2F</url>
    <content type="text"><![CDATA[Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. ExampleInput: [1,2,1,3,2,5] Output: [3,5] Note The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity? Code1234567891011121314151617181920212223public int[] singleNumber(int[] nums) &#123; int[] result = new int[2]; int xor = 0; int num1 = 0; int num2 = 0; for (int num : nums) xor ^= num; int last = xor - (xor &amp; (xor - 1)); for (int i = 0; i &lt; nums.length; i++) &#123; if ((last &amp; nums[i]) == 0) num1 ^= nums[i]; else num2 ^= nums[i]; &#125; result[0] = num1; result[1] = num2; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 703 - Kth Largest Element in a Stream]]></title>
    <url>%2F2019%2F03%2F25%2FLeetCode-Problem-703-Kth-Largest-Element-in-a-Stream%2F</url>
    <content type="text"><![CDATA[Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Your KthLargest class will have a constructor which accepts an integer k and an integer array nums, which contains initial elements from the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream. Exampleint k = 3;int[] arr = [4,5,8,2];KthLargest kthLargest = new KthLargest(3, arr);kthLargest.add(3); // returns 4kthLargest.add(5); // returns 5kthLargest.add(10); // returns 5kthLargest.add(9); // returns 8kthLargest.add(4); // returns 8 NoteYou may assume that nums’ length ≥ k-1 and k ≥ 1. Code123456789101112131415161718private PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();private int size;public KthLargest(int k, int[] nums) &#123; size = k; for (int num : nums) add(num);&#125;public int add(int val) &#123; minHeap.offer(val); if (minHeap.size() &gt; size) minHeap.poll(); return minHeap.peek();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 215 - Kth Largest Element in an Array]]></title>
    <url>%2F2019%2F03%2F24%2FLeetCode-Problem-215-Kth-Largest-Element-in-an-Array%2F</url>
    <content type="text"><![CDATA[Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. ExampleNo.1Input: [3,2,1,5,6,4] and k = 2 Output: 5 No.2Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 NoteYou may assume k is always valid, 1 ≤ k ≤ array’s length. Code1234567891011121314151617181920212223242526272829303132333435363738394041public int findKthLargest(int[] nums, int k) &#123; return sort(nums, k, 0, nums.length - 1);&#125;private int sort(int[] nums, int k, int left, int right) &#123; int pivot = partition(nums, left, right); if (pivot == nums.length - k) return nums[pivot]; else if (pivot &lt; nums.length - k) return sort(nums, k, pivot + 1, right); else return sort(nums, k, left, pivot - 1);&#125;private int partition(int[] nums, int left, int right) &#123; int pivot = left; while (true) &#123; while (left &lt;= right &amp;&amp; nums[left] &lt;= nums[pivot]) left++; while (left &lt;= right &amp;&amp; nums[right] &gt; nums[pivot]) right--; if (left &gt; right) break; swap(nums, left, right); &#125; swap(nums, pivot, right); return right;&#125;private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 541 - Zigzag Iterator II]]></title>
    <url>%2F2019%2F03%2F24%2FLintCode-Problem-541-Zigzag-Iterator-II%2F</url>
    <content type="text"><![CDATA[Follow up Zigzag Iterator: What if you are given k 1d vectors? How well can your code be extended to such cases? The “Zigzag” order is not clearly defined and is ambiguous for k &gt; 2 cases. If “Zigzag” does not look right to you, replace “Zigzag” with “Cyclic”. ExampleNo.1Input: k = 3 12345vecs = [ [1,2,3], [4,5,6,7], [8,9],] Output: [1,4,8,2,5,9,3,6,7] No.2Input: k = 3 12345vecs = [ [1,1,1] [2,2,2] [3,3,3]] Output: [1,2,3,1,2,3,1,2,3] code12345678910111213141516171819202122private Queue&lt;Iterator&gt; queue = new LinkedList&lt;&gt;();public ZigzagIterator2(List&lt;List&lt;Integer&gt;&gt; vecs) &#123; for (List&lt;Integer&gt; vec : vecs) &#123; if (!vec.isEmpty()) queue.offer(vec.iterator()); &#125;&#125;public int next() &#123; Iterator iterator = queue.poll(); int next = (int) iterator.next(); if (iterator.hasNext()) queue.offer(iterator); return next;&#125;public boolean hasNext() &#123; return !queue.isEmpty();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 540 - Zigzag Iterator]]></title>
    <url>%2F2019%2F03%2F24%2FLintCode-Problem-540-Zigzag-Iterator%2F</url>
    <content type="text"><![CDATA[Given two 1d vectors, implement an iterator to return their elements alternately. ExampleNo.1Input: v1 = [1, 2] and v2 = [3, 4, 5, 6] Output: [1, 3, 2, 4, 5, 6] Explanation:By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1, 3, 2, 4, 5, 6]. No.2Input: v1 = [1, 1, 1, 1] and v2 = [3, 4, 5, 6] Output: [1, 3, 1, 4, 1, 5, 1, 6] Code1234567891011121314151617181920212223private Queue&lt;Iterator&gt; queue = new LinkedList&lt;&gt;();public ZigzagIterator(List&lt;Integer&gt; v1, List&lt;Integer&gt; v2) &#123; if (!v1.isEmpty()) queue.offer(v1.iterator()); if (!v2.isEmpty()) queue.offer(v2.iterator());&#125;public int next() &#123; Iterator iterator = queue.poll(); int next = (int) iterator.next(); if (iterator.hasNext()) queue.offer(iterator); return next;&#125;public boolean hasNext() &#123; return !queue.isEmpty();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 904 - Plus One Linked List]]></title>
    <url>%2F2019%2F03%2F24%2FLintCode-Problem-904-Plus-One-Linked-List%2F</url>
    <content type="text"><![CDATA[Given a non-negative integer represented as non-empty a singly linked list of digits, plus one to the integer. You may assume the integer do not contain any leading zero, except the number 0 itself. The digits are stored such that the most significant digit is at the head of the list. ExampleNo.1Input: 1 -&gt; 2 -&gt; 3 -&gt; null Output: 1 -&gt; 2 -&gt; 4 -&gt; null Explanation:123 + 1 = 124 No.2Input: 9 -&gt; 9 -&gt; null Output: 1 -&gt; 0 -&gt; 0 -&gt; null Explanation:99 + 1 = 100 Code12345678public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; next = null; &#125;&#125; 12345678910111213141516171819202122232425262728public ListNode plusOne(ListNode head) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode slow = dummy; ListNode fast = dummy; while (fast.next != null) &#123; fast = fast.next; if (fast.val != 9) slow = fast; &#125; if (fast.val != 9) &#123; fast.val++; &#125; else &#123; slow.val++; slow = slow.next; while (slow != null) &#123; slow.val = 0; slow = slow.next; &#125; &#125; return dummy.val == 0 ? head : dummy;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 872 - Kill Process]]></title>
    <url>%2F2019%2F03%2F23%2FLintCode-Problem-872-Kill-Process%2F</url>
    <content type="text"><![CDATA[In this problem, each process has a unique PID (process id) and PPID (parent process id). Each process only has one parent process, but may have one or more children processes. This is just like a tree structure. Only one process has PPID that is 0, which means this process has no parent process. All the PIDs will be distinct positive integers. We use two list of integers to represent a list of processes, where the first list contains PID for each process and the second list contains the corresponding PPID. Now given the two lists, and a PID representing a process you want to kill, return a list of PIDs of processes that will be killed in the end. You should assume that when a process is killed, all its children processes will be killed. No order is required for the final answer. Note The given kill id is guaranteed to be one of the given PIDs. There is at least one PID in the list. ExampleNo.1Input: PID = [1, 3, 10, 5], PPID = [3, 0, 5, 3], killID = 5 Output: [5, 10] Explanation: Kill 5 will also kill 10. 12345 3 / \1 5 / 10 No.2Input: PID = [1, 2, 3], PPID = [0, 1, 1], killID = 2 Output: [2] Code1234567891011121314151617181920212223public List&lt;Integer&gt; killProcess(List&lt;Integer&gt; pid, List&lt;Integer&gt; ppid, int kill) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; ppid.size(); i++) &#123; map.putIfAbsent(ppid.get(i), new ArrayList&lt;&gt;()); map.get(ppid.get(i)).add(pid.get(i)); &#125; dfs(result, map, kill); return result;&#125;private void dfs(List&lt;Integer&gt; result, Map&lt;Integer, List&lt;Integer&gt;&gt; map, int pid) &#123; result.add(pid); if (!map.containsKey(pid)) return; for (Integer i : map.get(pid)) dfs(result, map, i);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 879 - Output Contest Matches]]></title>
    <url>%2F2019%2F03%2F23%2FLintCode-Problem-879-Output-Contest-Matches%2F</url>
    <content type="text"><![CDATA[During the NBA playoffs, we always arrange the rather strong team to play with the rather weak team, like make the rank 1 team play with the rank nth team, which is a good strategy to make the contest more interesting. Now, you’re given n teams, and you need to output their final contest matches in the form of a string. The n teams are given in the form of positive integers from 1 to n, which represents their initial rank. (Rank 1 is the strongest team and Rank n is the weakest team.) We’ll use parentheses () and commas , to represent the contest team pairing - parentheses () for pairing and commas , for partition. During the pairing process in each round, you always need to follow the strategy of making the rather strong one pair with the rather weak one. Note The n is in range [2, 2^12]. We ensure that the input n can be converted into the form 2^k, where k is a positive integer. ExampleNo.1Input: 2 Output: “(1,2)” No.2Input: 4 Output: “((1,4),(2,3))” Explanation:In the first round, we pair the team 1 and 4, the team 2 and 3 together, as we need to make the strong team and weak team together.And we got (1,4),(2,3).In the second round, the winners of (1,4) and (2,3) need to play again to generate the final winner, so you need to add the paratheses outside them.And we got the final answer ((1,4),(2,3)). No.3Input: 8 Output: “(((1,8),(4,5)),((2,7),(3,6)))” Explanation:First round: (1,8),(2,7),(3,6),(4,5)Second round: ((1,8),(4,5)),((2,7),(3,6))Third round: (((1,8),(4,5)),((2,7),(3,6))) Code123456789101112131415public String findContestMatch(int n) &#123; String[] result = new String[n]; for (int i = 1; i &lt;= n; i++) result[i - 1] = String.valueOf(i); while (n &gt; 1) &#123; for (int i = 1; i &lt;= n / 2; i++) result[i - 1] = "(" + result[i - 1] + ","+ result[n - i] + ")"; n &gt;&gt;= 1; &#125; return result[0];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 200 - Number of Islands]]></title>
    <url>%2F2019%2F03%2F22%2FLeetCode-Problem-200-Number-of-Islands%2F</url>
    <content type="text"><![CDATA[Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. ExampleNo.1Input: 123411110110101100000000 Output: 1 No.2Input: 123411000110000010000011 Output: 3 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344public int numIslands(char[][] grid) &#123; int count = 0; if (grid == null || grid.length &lt; 1 || grid[0].length &lt; 1) return count; int n = grid.length; int m = grid[0].length; boolean[][] visit = new boolean[n][m]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (grid[i][j] == '1' &amp;&amp; !visit[i][j]) &#123; bfs(grid, visit, i, j); count++; &#125; &#125; &#125; return count;&#125;private void bfs(char[][] grid, boolean[][] visit, int i, int j) &#123; int n = grid.length; int m = grid[0].length; int[][] directions = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[] &#123;i, j&#125;); visit[i][j] = true; while (!queue.isEmpty()) &#123; int[] position = queue.poll(); for (int[] direction : directions) &#123; int x = position[0] + direction[0]; int y = position[1] + direction[1]; if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; grid[x][y] == '1' &amp;&amp; !visit[x][y]) &#123; visit[x][y] = true; queue.offer(new int[] &#123;x, y&#125;); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 650 - Find Leaves of Binary Tree]]></title>
    <url>%2F2019%2F03%2F22%2FLintCode-Problem-650-Find-Leaves-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, collect a tree’s nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty. ExampleNo.1Input: {1,2,3,4,5} Output: [[4, 5, 3], [2], [1]]. Explanation: 12345 1 / \ 2 3 / \ 4 5 No.2Input: {1,2,3,4} Output: [[4, 3], [2], [1]]. Explanation: 12345 1 / \ 2 3 /4 Code12345678public class TreeNode &#123; public int val; public TreeNode left, right; public TreeNode(int val) &#123; this.val = val; this.left = this.right = null; &#125;&#125; 12345678910111213141516171819202122232425public List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) &#123; Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); findLeavesHelper(root, map); for (List&lt;Integer&gt; values : map.values()) result.add(values); return result;&#125;private int findLeavesHelper(TreeNode root, Map&lt;Integer, List&lt;Integer&gt;&gt; map) &#123; if (root == null) return 0; int left = findLeavesHelper(root.left, map); int right = findLeavesHelper(root.right, map); int level = Math.max(left, right) + 1; map.putIfAbsent(level, new ArrayList&lt;&gt;()); map.get(level).add(root.val); return level;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 56 - Merge Intervals]]></title>
    <url>%2F2019%2F03%2F22%2FLeetCode-Problem-56-Merge-Intervals%2F</url>
    <content type="text"><![CDATA[Given a collection of intervals, merge all overlapping intervals. ExampleNo.1Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. No.2Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. Code123456public class Interval &#123; int start; int end; Interval() &#123; start = 0; end = 0; &#125; Interval(int s, int e) &#123; start = s; end = e; &#125;&#125; 1234567891011121314151617181920212223242526public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; List&lt;Interval&gt; result = new ArrayList&lt;&gt;(); Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval o1, Interval o2) &#123; return o1.start - o2.start; &#125; &#125;); for (Interval i : intervals) &#123; if (result.size() &lt; 1) &#123; result.add(i); continue; &#125; Interval last = result.get(result.size() - 1); if (i.start &gt; last.end) result.add(i); else last.end = Math.max(last.end, i.end); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 917 - Palindrome Permutation II]]></title>
    <url>%2F2019%2F03%2F21%2FLintCode-Problem-917-Palindrome-Permutation-II%2F</url>
    <content type="text"><![CDATA[Given a string s, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form. ExampleNo.1Input: s = “aabb” Output: [“abba”,”baab”] No.2Input: “abc” Output: [] Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public List&lt;String&gt; generatePalindromes(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int count = 0; String odd = ""; List&lt;Character&gt; half = new ArrayList&lt;&gt;(); for (Character ch : s.toCharArray()) map.put(ch, map.getOrDefault(ch, 0) + 1); for (Map.Entry&lt;Character, Integer&gt; entry : map.entrySet()) &#123; Character key = entry.getKey(); Integer value = entry.getValue(); if (value % 2 != 0) &#123; count++; if (count &gt; 1) return result; odd = String.valueOf(key); &#125; for (int i = 0; i &lt; value / 2; i++) half.add(key); &#125; permutation(result, half, odd, new StringBuilder(), new boolean[half.size()]); return result;&#125;private void permutation(List&lt;String&gt; result, List&lt;Character&gt; half, String odd, StringBuilder sb, boolean[] visit) &#123; if (sb.length() == half.size()) &#123; result.add(sb.toString() + odd + sb.reverse().toString()); sb.reverse(); return; &#125; for (int i = 0; i &lt; half.size(); i++) &#123; if (i &gt; 0 &amp;&amp; half.get(i) == half.get(i - 1) &amp;&amp; !visit[i - 1]) continue; if (!visit[i]) &#123; visit[i] = true; sb.append(half.get(i)); permutation(result, half, odd, sb, visit); sb.deleteCharAt(sb.length() - 1); visit[i] = false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 916 - Palindrome Permutation]]></title>
    <url>%2F2019%2F03%2F19%2FLintCode-Problem-916-Palindrome-Permutation%2F</url>
    <content type="text"><![CDATA[Given a string, determine if a permutation of the string could form a palindrome. ExampleNo.1Input: s = “code” Output: False Explanation:No solution No.2Input: s = “aab” Output: True Explanation:“aab” –&gt; “aba” No.3Input: s = “carerac” Output: True Explanation:“carerac” –&gt; “carerac” Code1234567891011121314151617public boolean canPermutePalindrome(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int count = 0; for (Character ch : s.toCharArray()) map.put(ch, map.getOrDefault(ch, 0) + 1); for (int i : map.values()) &#123; if (i % 2 != 0) count++; if (count &gt; 1) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 642 - Moving Average from Data Stream]]></title>
    <url>%2F2019%2F03%2F19%2FLintCode-Problem-642-Moving-Average-from-Data-Stream%2F</url>
    <content type="text"><![CDATA[Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window. ExampleMovingAverage m = new MovingAverage(3);m.next(1) = 1 // return 1.00000m.next(10) = (1 + 10) / 2 // return 5.50000m.next(3) = (1 + 10 + 3) / 3 // return 4.66667m.next(5) = (10 + 3 + 5) / 3 // return 6.00000 Code12345678910111213141516171819private Queue&lt;Integer&gt; queue;private double sum;private int size;public MovingAverage(int size) &#123; queue = new LinkedList&lt;&gt;(); sum = 0; this.size = size;&#125;public double next(int val) &#123; sum += val; if (queue.size() == size) sum -= queue.poll(); queue.offer(val); return sum / queue.size();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 813 - Find Anagram Mappings]]></title>
    <url>%2F2019%2F03%2F17%2FLintCode-Problem-813-Find-Anagram-Mappings%2F</url>
    <content type="text"><![CDATA[Given two lists A and B, and B is an anagram of A. B is an anagram of A means B is made by randomizing the order of the elements in A. We want to find an index mapping P, from A to B. A mapping P[i] = j means the ith element in A appears in B at index j. These lists A and B may contain duplicates. If there are multiple answers, output any of them. Note A, B have equal lengths in range [1, 100]. A[i], B[i] are integers in range [0, 10^5]. ExampleNo.1Input: A = [12, 28, 46, 32, 50] and B = [50, 12, 32, 46, 28] Output: [1, 4, 3, 2, 0] Explanation:As P[0] = 1 because the 0th element of A appears at B[1], and P[1] = 4 because the 1st element of A appears at B[4], and so on. No.2Input: A = [1, 2, 3, 4, 5] and B = [5, 4, 3, 2, 1] Output: [4, 3, 2, 1, 0] Explanation:As P[0] = 4 because the 0th element of A appears at B[4], and P[1] = 3 because the 1st element of A Code123456789101112public int[] anagramMappings(int[] A, int[] B) &#123; int[] result = new int[A.length]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; B.length; i++) map.put(B[i], i); for (int i = 0; i &lt; A.length; i++) result[i] = map.get(A[i]); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 629 - Minimum Spanning Tree]]></title>
    <url>%2F2019%2F03%2F16%2FLintCode-Problem-629-Minimum-Spanning-Tree%2F</url>
    <content type="text"><![CDATA[Given a list of Connections, which is the Connection class (the city name at both ends of the edge and a cost between them), find some edges, connect all the cities and spend the least amount. Return the connects if can connect all the cities, otherwise return empty list. NoteReturn the connections sorted by the cost, or sorted city1 name if their cost is same, or sorted city2 if their city1 name is also same. ExampleGievn the connections = [“Acity”,”Bcity”,1], [“Acity”,”Ccity”,2], [“Bcity”,”Ccity”,3] Return [“Acity”,”Bcity”,1], [“Acity”,”Ccity”,2] Code123456789public class Connection &#123; public String city1, city2; public int cost; public Connection(String city1, String city2, int cost) &#123; this.city1 = city1; this.city2 = city2; this.cost = cost; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class UnionFind&#123; private int[] id; public UnionFind(int n) &#123; id = new int[n]; for (int i = 0; i &lt; n; i++) id[i] = i; &#125; public int find(int p) &#123; if (id[p] == p) return p; return id[p] = find(id[p]); &#125; public void connect(int p, int q) &#123; int pId = id[p]; int qId = id[q]; if (pId != qId) id[pId] = qId; &#125;&#125;public List&lt;Connection&gt; lowestCost(List&lt;Connection&gt; connections) &#123; List&lt;Connection&gt; result = new ArrayList&lt;&gt;(); Collections.sort(connections, new Comparator&lt;Connection&gt;() &#123; @Override public int compare(Connection o1, Connection o2) &#123; if (o1.cost != o2.cost) return o1.cost - o2.cost; else if (!o1.city1.equals(o2.city1)) return o1.city1.compareTo(o2.city1); else return o1.city2.compareTo(o2.city2); &#125; &#125;); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); int index = 0; for (Connection c : connections) &#123; if (!map.containsKey(c.city1)) map.put(c.city1, index++); if (!map.containsKey(c.city2)) map.put(c.city2, index++); &#125; UnionFind uf = new UnionFind(index); for (Connection c : connections) &#123; int idx1 = map.get(c.city1); int idx2 = map.get(c.city2); if (uf.find(idx1) != uf.find(idx2)) &#123; result.add(c); uf.connect(idx1, idx2); &#125; &#125; return result.size() == index - 1 ? result : new ArrayList&lt;&gt;();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 919 - Meeting Rooms II]]></title>
    <url>%2F2019%2F03%2F16%2FLintCode-Problem-919-Meeting-Rooms-II%2F</url>
    <content type="text"><![CDATA[Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), find the minimum number of conference rooms required. ExampleNo.1Input: intervals = [(0,30),(5,10),(15,20)] Output: 2 Explanation:We need two meeting roomsroom1: (0,30)room2: (5,10),(15,20) No.2Input: intervals = [(2,7)] Output: 1 Explanation:Only need one meeting room Code12345678public class Interval &#123; int start, end; Interval(int start, int end) &#123; this.start = start; this.end = end; &#125;&#125; 1234567891011121314151617181920212223public int minMeetingRooms(List&lt;Interval&gt; intervals) &#123; if (intervals == null || intervals.size() &lt; 1) return 0; Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval o1, Interval o2) &#123; return o1.start - o2.start; &#125; &#125;); PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(); minHeap.offer(intervals.get(0).end); for (int i = 1; i &lt; intervals.size(); i++) &#123; if (intervals.get(i).start &gt; minHeap.peek()) minHeap.poll(); minHeap.offer(intervals.get(i).end); &#125; return minHeap.size();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 920 - Meeting Rooms]]></title>
    <url>%2F2019%2F03%2F15%2FLintCode-Problem-920-Meeting-Rooms%2F</url>
    <content type="text"><![CDATA[Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), determine if a person could attend all meetings. ExampleNo.1Input: intervals = [(0,30),(5,10),(15,20)] Output: false Explanation:(0,30), (5,10) and (0,30),(15,20) will conflict No.2Input: intervals = [(5,8),(9,15)] Output: true Explanation:Two times will not conflict Code12345678public class Interval &#123; int start, end; Interval(int start, int end) &#123; this.start = start; this.end = end; &#125;&#125; 12345678910111213141516171819202122public boolean canAttendMeetings(List&lt;Interval&gt; intervals) &#123; if (intervals == null || intervals.size() &lt; 1) return true; Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval o1, Interval o2) &#123; return o1.start - o2.start; &#125; &#125;); int end = intervals.get(0).end; for (int i = 1; i &lt; intervals.size(); i++) &#123; if (intervals.get(i).start &lt; end) return false; end = Math.max(end, intervals.get(i).end); &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 630 - Knight Shortest Path II]]></title>
    <url>%2F2019%2F03%2F14%2FLintCode-Problem-630-Knight-Shortest-Path-II%2F</url>
    <content type="text"><![CDATA[Given a knight in a chessboard n * m (a binary matrix with 0 as empty and 1 as barrier). the knight initialze position is (0, 0) and he wants to reach position (n - 1, m - 1), Knight can only be from left to right. Find the shortest path to the destination position, return the length of the route. Return -1 if knight can not reached. ClarificationIf the knight is at (x, y), he can get to the following positions in one step: (x + 1, y + 2)(x - 1, y + 2)(x + 2, y + 1)(x - 2, y + 1) ExampleNo.1Input:[[0,0,0,0],[0,0,0,0],[0,0,0,0]] Output:3 Explanation:[0,0]-&gt;[2,1]-&gt;[0,2]-&gt;[2,3] No.2Input:[[0,1,0],[0,0,1],[0,0,0]] Output:-1 Code12345678910111213141516171819202122232425262728293031public int shortestPath2(boolean[][] grid) &#123; int n = grid.length; int m = grid[0].length; int[][] visited = new int[n][m]; int[][] directions = &#123;&#123;1, 2&#125;, &#123;-1, 2&#125;, &#123;2, 1&#125;, &#123;-2, 1&#125;&#125;; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[] &#123;0, 0, 0&#125;); visited[0][0] = 1; while (!queue.isEmpty()) &#123; for (int i = 0; i &lt; queue.size(); i++) &#123; int[] position = queue.poll(); if (position[0] == n - 1 &amp;&amp; position[1] == m - 1) return position[2]; for (int[] direction : directions) &#123; int x = position[0] + direction[0]; int y = position[1] + direction[1]; if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; grid[x][y] == false &amp;&amp; visited[x][y] == 0) &#123; queue.offer(new int[] &#123;x, y, position[2] + 1&#125;); visited[x][y] = 1; &#125; &#125; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 611 - Knight Shortest Path]]></title>
    <url>%2F2019%2F03%2F14%2FLintCode-Problem-611-Knight-Shortest-Path%2F</url>
    <content type="text"><![CDATA[Given a knight in a chessboard (a binary matrix with 0 as empty and 1 as barrier) with a source position, find the shortest path to a destination position, return the length of the route. Return -1 if destination cannot be reached. Notesource and destination must be empty.Knight can not enter the barrier. ClarificationIf the knight is at (x, y), he can get to the following positions in one step: (x + 1, y + 2)(x + 1, y - 2)(x - 1, y + 2)(x - 1, y - 2)(x + 2, y + 1)(x + 2, y - 1)(x - 2, y + 1)(x - 2, y - 1) ExampleNo.1Input: 123[[0,0,0], [0,0,0], [0,0,0]] source = [2, 0] destination = [2, 2] Output: 2 Explanation:[2,0]-&gt;[0,1]-&gt;[2,2] No.2Input: 123[[0,1,0], [0,0,1], [0,0,0]] source = [2, 0] destination = [2, 2] Output: -1 Code123456public class Point &#123; int x; int y; Point() &#123; x = 0; y = 0; &#125; Point(int a, int b) &#123; x = a; y = b; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637public int shortestPath(boolean[][] grid, Point source, Point destination) &#123; int result = 0; int n = grid.length; int m = grid[0].length; int[][] visited = new int[n][m]; int[][] directions = &#123;&#123;1, 2&#125;, &#123;1, -2&#125;, &#123;-1, 2&#125;, &#123;-1, -2&#125;, &#123;2, 1&#125;, &#123;2, -1&#125;, &#123;-2, 1&#125;, &#123;-2, -1&#125;&#125;; Queue&lt;Point&gt; queue = new LinkedList&lt;&gt;(); queue.offer(source); visited[source.x][source.y] = 1; while (!queue.isEmpty()) &#123; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; Point position = queue.poll(); if (position.x == destination.x &amp;&amp; position.y == destination.y) return result; for (int[] direction : directions) &#123; int x = position.x + direction[0]; int y = position.y + direction[1]; if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; grid[x][y] == false &amp;&amp; visited[x][y] == 0) &#123; Point nextPos = new Point(x, y); queue.offer(nextPos); visited[x][y] = 1; &#125; &#125; &#125; result++; &#125; return -1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 387 - First Unique Character in a String]]></title>
    <url>%2F2019%2F03%2F14%2FLeetCode-Problem-387-First-Unique-Character-in-a-String%2F</url>
    <content type="text"><![CDATA[Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1. ExamplesNo.1s = “leetcode”return 0. No.2s = “loveleetcode”,return 2. NoteYou may assume the string contain only lowercase letters. Code1234567891011121314151617181920public int firstUniqChar(String s) &#123; if (s == null || s.length() &lt; 1) return -1; int[] index = new int[26]; for (int i = 0; i &lt; s.length(); i++) &#123; int idx = s.charAt(i) - 'a'; index[idx]++; &#125; for (int i = 0; i &lt; s.length(); i++) &#123; int idx = s.charAt(i) - 'a'; if (index[idx] == 1) return i; &#125; return -1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 210 - Course Schedule II]]></title>
    <url>%2F2019%2F03%2F14%2FLeetCode-Problem-210-Course-Schedule-II%2F</url>
    <content type="text"><![CDATA[There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. ExampleNo.1Input: 2, [[1,0]] Output: [0,1] Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] . No.2Input: 4, [[1,0],[2,0],[3,1],[3,2]] Output: [0,1,2,3] or [0,2,1,3] Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] . Note The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites. Code12345678910111213141516171819202122232425262728293031323334353637public int[] findOrder(int numCourses, int[][] prerequisites) &#123; int[] inDegree = new int[numCourses]; List[] adj = new ArrayList[numCourses]; int[] result = new int[numCourses]; int count = 0; for (int i = 0; i &lt; numCourses; i++) adj[i] = new ArrayList&lt;Integer&gt;(); for (int[] prerequisite : prerequisites) &#123; adj[prerequisite[1]].add(prerequisite[0]); inDegree[prerequisite[0]]++; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; numCourses; i++) &#123; if (inDegree[i] == 0) queue.offer(i); &#125; while (!queue.isEmpty()) &#123; int course = queue.poll(); result[count++] = course; for (int i = 0; i &lt; adj[course].size(); i++) &#123; int postrequisite = (int) adj[course].get(i); inDegree[postrequisite]--; if (inDegree[postrequisite] == 0) queue.offer(postrequisite); &#125; &#125; return count == numCourses ? result : new int[0];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 207 - Course Schedule]]></title>
    <url>%2F2019%2F03%2F13%2FLeetCode-Problem-207-Course-Schedule%2F</url>
    <content type="text"><![CDATA[There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? ExampleNo.1Input: 2, [[1,0]] Output: true Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. No.2Input: 2, [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Note The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites. Code1234567891011121314151617181920212223242526272829303132333435public boolean canFinish(int numCourses, int[][] prerequisites) &#123; int[] inDegree = new int[numCourses]; List[] adj = new ArrayList[numCourses]; int count = 0; for (int i = 0; i &lt; numCourses; i++) adj[i] = new ArrayList&lt;Integer&gt;(); for (int[] prerequisite : prerequisites) &#123; adj[prerequisite[1]].add(prerequisite[0]); inDegree[prerequisite[0]]++; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; numCourses; i++) &#123; if (inDegree[i] == 0) queue.offer(i); &#125; while (!queue.isEmpty()) &#123; int course = queue.poll(); count++; for (int i = 0; i &lt; adj[course].size(); i++) &#123; int postrequisite = (int) adj[course].get(i); inDegree[postrequisite]--; if (inDegree[postrequisite] == 0) queue.offer(postrequisite); &#125; &#125; return count == numCourses;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 604 - Window Sum]]></title>
    <url>%2F2019%2F03%2F13%2FLintCode-Problem-604-Window-Sum%2F</url>
    <content type="text"><![CDATA[Given an array of n integers, and a moving window(size k), move the window at each iteration from the start of the array, find the sum of the element inside the window at each moving. ExampleInput：array = [1,2,7,8,5], k = 3 Output：[10,17,20] Explanation：1 + 2 + 7 = 102 + 7 + 8 = 177 + 8 + 5 = 20 Code12345678910111213141516public int[] winSum(int[] nums, int k) &#123; if (nums == null || k &lt;= 0 || nums.length &lt; k) return new int[0]; int n = nums.length; int[] result = new int[n-k+1]; int sum = 0; for (int i = 0; i &lt; k; i++) result[0] += nums[i]; for (int i = 1; i &lt; n - k + 1; i++) result[i] = result[i-1] - nums[i-1] + nums[i+k-1]; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 836 - Rectangle Overlap]]></title>
    <url>%2F2019%2F03%2F13%2FLeetCode-Problem-836-Rectangle-Overlap%2F</url>
    <content type="text"><![CDATA[A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner. Two rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap. Given two (axis-aligned) rectangles, return whether they overlap. ExampleNo.1Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3] Output: true No.2Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1] Output: false NotesBoth rectangles rec1 and rec2 are lists of 4 integers.All coordinates in rectangles will be between -10^9 and 10^9. Code1234567891011public boolean isRectangleOverlap(int[] rec1, int[] rec2) &#123; int x1 = rec1[0], y1 = rec1[1]; int x2 = rec1[2], y2 = rec1[3]; int x3 = rec2[0], y3 = rec2[1]; int x4 = rec2[2], y4 = rec2[3]; if (x1 &gt;= x4 || x2 &lt;= x3 || y1 &gt;= y4 || y2 &lt;= y3) return false; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 533 - Two Sum - Closest to target]]></title>
    <url>%2F2019%2F03%2F13%2FLintCode-Problem-533-Two-Sum-Closest-to-target%2F</url>
    <content type="text"><![CDATA[Given an array nums of n integers, find two integers in nums such that the sum is closest to a given number, target. Return the absolute value of difference between the sum of the two integers and the target. ExampleNo.1Input: nums = [-1, 2, 1, -4] and target = 4 Output: 1 Explanation:The minimum difference is 1. (4 - (2 + 1) = 1). No.2Input: nums = [-1, -1, -1, -4] and target = 4 Output: 6 Explanation:The minimum difference is 6. (4 - (- 1 - 1) = 6). ChallengeDo it in O(nlogn) time complexity. Code12345678910111213141516171819202122232425public int twoSumClosest(int[] nums, int target) &#123; int result = Integer.MAX_VALUE; if (nums == null || nums.length &lt; 2) return result; int left = 0; int right = nums.length - 1; Arrays.sort(nums); while (left &lt; right) &#123; int sum = nums[left] + nums[right]; result = Math.min(result, Math.abs(sum - target)); if (sum &lt; target) left++; else if (sum &gt; target) right--; else return result; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 613 - High Five]]></title>
    <url>%2F2019%2F03%2F12%2FLintCode-Problem-613-High-Five%2F</url>
    <content type="text"><![CDATA[There are two properties in the node student id and scores, to ensure that each student will have at least 5 points, find the average of 5 highest scores for each person. ExampleNo.1Input:[[1,91],[1,92],[2,93],[2,99],[2,98],[2,97],[1,60],[1,58],[2,100],[1,61]] Output:1: 72.402: 97.40 No.2Input:[[1,90],[1,90],[1,90],[1,90],[1,90],[1,90]] Output:1: 90.00 Code1234567public class Record &#123; public int id, score; public Record(int id, int score)&#123; this.id = id; this.score = score; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637public Map&lt;Integer, Double&gt; highFive(Record[] results) &#123; Map&lt;Integer, Double&gt; avgHigh = new HashMap&lt;&gt;(); PriorityQueue&lt;Record&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;Record&gt;() &#123; @Override public int compare(Record o1, Record o2) &#123; if (o1.id != o2.id) return o1.id - o2.id; return o2.score - o1.score; &#125; &#125;); for (Record record : results) queue.offer(record); int id = Integer.MIN_VALUE; int sum = 0; while (!queue.isEmpty()) &#123; if (queue.peek().id != id) &#123; id = queue.peek().id; for (int i = 0; i &lt; 5; i++) &#123; Record record = queue.poll(); sum += record.score; &#125; avgHigh.put(id, (double) sum / 5); sum = 0; &#125; while (!queue.isEmpty() &amp;&amp; queue.peek().id == id) queue.poll(); &#125; return avgHigh;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 409 - Longest Palindrome]]></title>
    <url>%2F2019%2F03%2F12%2FLeetCode-Problem-409-Longest-Palindrome%2F</url>
    <content type="text"><![CDATA[Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example “Aa” is not considered a palindrome here. NoteAssume the length of given string will not exceed 1,010. ExampleInput:“abccccdd” Output:7 Explanation:One longest palindrome that can be built is “dccaccd”, whose length is 7. Code12345678910111213141516171819public int longestPalindrome(String s) &#123; int[] count = new int[128]; int result = 0; boolean isOdd = false; for (char ch : s.toCharArray()) &#123; int idx = ch - '0'; count[idx]++; &#125; for (int chCount : count) &#123; if (chCount % 2 != 0) isOdd = true; result += (chCount &gt;&gt; 1) * 2; &#125; return isOdd ? result + 1 : result; &#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 612 - K Closest Points]]></title>
    <url>%2F2019%2F03%2F12%2FLintCode-Problem-612-K-Closest-Points%2F</url>
    <content type="text"><![CDATA[Given some points and an origin point in two-dimensional space, find k points which are nearest to the origin. Return these points sorted by distance, if they are same in distance, sorted by the x-axis, and if they are same in the x-axis, sorted by y-axis. ExampleNo.1Input: points = [[4,6],[4,7],[4,4],[2,5],[1,1]], origin = [0, 0], k = 3 Output: [[1,1],[2,5],[4,4]] No.2Input: points = [[0,0],[0,9]], origin = [3, 1], k = 1 Output: [[0,0]] Code123456public class Point &#123; int x; int y; Point() &#123; x = 0; y = 0; &#125; Point(int a, int b) &#123; x = a; y = b; &#125;&#125; 12345678910111213141516171819202122232425public Point[] kClosest(Point[] points, Point origin, int k) &#123; Point[] result = new Point[k]; PriorityQueue&lt;Point&gt; minHeap = new PriorityQueue&lt;&gt;(new Comparator&lt;Point&gt;() &#123; @Override public int compare(Point o1, Point o2) &#123; int distance1 = (o1.x - origin.x) * (o1.x - origin.x) + (o1.y - origin.y) * (o1.y - origin.y); int distance2 = (o2.x - origin.x) * (o2.x - origin.x) + (o2.y - origin.y) * (o2.y - origin.y); if (distance1 == distance2) return o1.x == o2.x ? (o1.y - o2.y) : o1.x - o2.x; return distance1 - distance2; &#125; &#125;); for (Point point : points) minHeap.offer(point); for (int i = 0; i &lt; k; i++) result[i] = minHeap.poll(); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 628 - Maximum Subtree]]></title>
    <url>%2F2019%2F03%2F12%2FLintCode-Problem-628-Maximum-Subtree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find the subtree with maximum sum. Return the root of the subtree. NoteIt’s guaranteed that there is only one subtree with maximum sum and the given binary tree is not an empty tree. ExampleInput : 12345 1 / \ -5 2 / \ / \0 3 -4 -5 Output : 3 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617181920212223private TreeNode maxTree;private int maxSum = Integer.MIN_VALUE;public TreeNode findSubtree(TreeNode root) &#123; findSubtreeHelper(root); return maxTree;&#125;private int findSubtreeHelper(TreeNode node) &#123; if (node == null) return 0; int left = findSubtreeHelper(node.left); int right = findSubtreeHelper(node.right); int sum = left + right + node.val; if (maxTree == null || sum &gt; maxSum) &#123; maxTree = node; maxSum = sum; &#125; return sum;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 937 - Reorder Log Files]]></title>
    <url>%2F2019%2F03%2F11%2FLeetCode-Problem-937-Reorder-Log-Files%2F</url>
    <content type="text"><![CDATA[You have an array of logs. Each log is a space delimited string of words. For each log, the first word in each log is an alphanumeric identifier. Then, either: Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits. We will call these two varieties of logs letter-logs and digit-logs. It is guaranteed that each log has at least one word after its identifier. Reorder the logs so that all of the letter-logs come before any digit-log. The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties. The digit-logs should be put in their original order. Return the final order of the logs. ExampleInput: [“a1 9 2 3 1”,”g1 act car”,”zo4 4 7”,”ab1 off key dog”,”a8 act zoo”] Output: [“g1 act car”,”a8 act zoo”,”ab1 off key dog”,”a1 9 2 3 1”,”zo4 4 7”] Note0 &lt;= logs.length &lt;= 1003 &lt;= logs[i].length &lt;= 100logs[i] is guaranteed to have an identifier, and a word after the identifier. Code12345678910111213141516171819202122public String[] reorderLogFiles(String[] logs) &#123; Arrays.sort(logs, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; String[] str1 = o1.split(" ", 2); String[] str2 = o2.split(" ", 2); char ch1 = str1[1].charAt(0); char ch2 = str2[1].charAt(0); if (Character.isLetter(ch1) &amp;&amp; Character.isLetter(ch2)) &#123; int compare = str1[1].compareTo(str2[1]); return compare != 0 ? compare : str1[0].compareTo(str2[0]); &#125; else if (Character.isDigit(ch1) &amp;&amp; Character.isDigit(ch2)) return 0; return Character.isLetter(ch1) ? -1 : 1; &#125; &#125;); return logs;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 763 - Partition Labels]]></title>
    <url>%2F2019%2F03%2F11%2FLeetCode-Problem-763-Partition-Labels%2F</url>
    <content type="text"><![CDATA[A string S of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts. ExampleInput: S = “ababcbacadefegdehijhklij” Output: [9,7,8] Explanation:The partition is “ababcbaca”, “defegde”, “hijhklij”.This is a partition so that each letter appears in at most one part.A partition like “ababcbacadefegde”, “hijhklij” is incorrect, because it splits S into less parts. NoteS will have length in range [1, 500].S will consist of lowercase letters (‘a’ to ‘z’) only. Code123456789101112131415161718192021222324public List&lt;Integer&gt; partitionLabels(String S) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int[] last = new int[26]; for (int i = 0; i &lt; S.length(); i++) &#123; int idx = S.charAt(i) - 'a'; last[idx] = i; &#125; int start = 0; int end = 0; for (int i = 0; i &lt; S.length(); i++) &#123; int idx = S.charAt(i) - 'a'; end = Math.max(end, last[idx]); if (i == end) &#123; result.add(end - start + 1); start = i + 1; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 386 - Longest Substring with At Most K Distinct Characters]]></title>
    <url>%2F2019%2F03%2F10%2FLintCode-Problem-386-Longest-Substring-with-At-Most-K-Distinct-Characters%2F</url>
    <content type="text"><![CDATA[Given a string S, find the length of the longest substring T that contains at most k distinct characters. ExampleNo.1Input: S = “eceba” and k = 3 Output: 4 Explanation: T = “eceb” No.2Input: S = “WORLD” and k = 4 Output: 4 Explanation: T = “WORL” or “ORLD” ChallengeO(n) time Code12345678910111213141516171819202122232425262728293031public int lengthOfLongestSubstringKDistinct(String s, int k) &#123; int result = 0; int[] count = new int[128]; int num = 0; int start = 0; int end = 0; while (end &lt; s.length()) &#123; int idxEnd = s.charAt(end) - '0'; if (count[idxEnd] == 0) num++; count[idxEnd]++; end++; while (num &gt; k) &#123; int idxStart = s.charAt(start) - '0'; count[idxStart]--; if (count[idxStart] == 0) num--; start++; &#125; result = Math.max(result, end - start); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 438 - Find All Anagrams in a String]]></title>
    <url>%2F2019%2F03%2F10%2FLeetCode-Problem-438-Find-All-Anagrams-in-a-String%2F</url>
    <content type="text"><![CDATA[Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. ExampleNo.1Input:s: “cbaebabacd” p: “abc” Output:[0, 6] Explanation:The substring with start index = 0 is “cba”, which is an anagram of “abc”.The substring with start index = 6 is “bac”, which is an anagram of “abc”. No.2Input:s: “abab” p: “ab” Output:[0, 1, 2] Explanation:The substring with start index = 0 is “ab”, which is an anagram of “ab”.The substring with start index = 1 is “ba”, which is an anagram of “ab”.The substring with start index = 2 is “ab”, which is an anagram of “ab”. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (s.length() &lt; p.length()) return result; int[] count = new int[26]; int num = 0; int start = 0; int end = 0; for (char ch : p.toCharArray()) &#123; int idx = ch - 'a'; if (count[idx] == 0) num++; count[idx]++; &#125; while (end &lt; s.length()) &#123; int idxEnd = s.charAt(end) - 'a'; count[idxEnd]--; if (count[idxEnd] == 0) num--; end++; while (num == 0) &#123; int idxStart = s.charAt(start) - 'a'; count[idxStart]++; if (count[idxStart] &gt; 0) num++; if (end - start == p.length()) result.add(start); start++; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 597 - Subtree with Maximum Average]]></title>
    <url>%2F2019%2F03%2F10%2FLintCode-Problem-597-Subtree-with-Maximum-Average%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find the subtree with maximum average. Return the root of the subtree. NoteIt’s guaranteed that there is only one subtree with maximum average. ExampleNo.1Input： 12345 1 / \ -5 11 / \ / \1 2 4 -2 Output：11(it’s a TreeNode) No.2Input： 123 1 / \-5 11 Output：11(it’s a TreeNode) Code123456789101112131415public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;private class ResultType&#123; int sum; int num; ResultType(int sum, int num) &#123; this.sum = sum; this.num = num; &#125;&#125; 1234567891011121314151617181920212223242526private TreeNode maxTree;private ResultType maxResult;public TreeNode findSubtree2(TreeNode root) &#123; findSubtreeHelper(root); return maxTree;&#125;private ResultType findSubtreeHelper(TreeNode node) &#123; if (node == null) return new ResultType(0, 0); ResultType left = findSubtreeHelper(node.left); ResultType right = findSubtreeHelper(node.right); int sum = left.sum + right.sum + node.val; int num = left.num + right.num + 1; ResultType root = new ResultType(sum, num); if (maxTree == null || maxResult.sum * root.num &lt; root.sum * maxResult.num) &#123; maxTree = node; maxResult = root; &#125; return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 819 - Most Common Word]]></title>
    <url>%2F2019%2F03%2F09%2FLeetCode-Problem-819-Most-Common-Word%2F</url>
    <content type="text"><![CDATA[Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn’t banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive. The answer is in lowercase. ExampleInput:paragraph = “Bob hit a ball, the hit BALL flew far after it was hit.”banned = [“hit”] Output: “ball” Explanation:“hit” occurs 3 times, but it is a banned word.“ball” occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.Note that words in the paragraph are not case sensitive,that punctuation is ignored (even if adjacent to words, such as “ball,”),and that “hit” isn’t the answer even though it occurs more because it is banned. Note1 &lt;= paragraph.length &lt;= 1000.1 &lt;= banned.length &lt;= 100.1 &lt;= banned[i].length &lt;= 10.The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and even if it is a proper noun.)paragraph only consists of letters, spaces, or the punctuation symbols !?’,;.There are no hyphens or hyphenated words.Words only consist of letters, never apostrophes or other punctuation symbols. Code1234567891011121314151617181920212223242526272829303132public String mostCommonWord(String paragraph, String[] banned) &#123; Map&lt;String, Integer&gt; count = new HashMap&lt;&gt;(); Set&lt;String&gt; ban = new HashSet(Arrays.asList(banned)); StringBuilder sb = new StringBuilder(); String result = ""; int max = Integer.MIN_VALUE; paragraph += "."; for (int i = 0; i &lt; paragraph.length(); i++) &#123; char ch = paragraph.charAt(i); if (Character.isLetter(ch)) sb.append(Character.toLowerCase(ch)); else if (sb.length() &gt; 0) &#123; String word = sb.toString(); if (!ban.contains(word)) &#123; count.put(word, count.getOrDefault(word, 0) + 1); if (count.get(word) &gt; max) &#123; result = word; max = count.get(word); &#125; &#125; sb.setLength(0); &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 973 - K Closest Points to Origin]]></title>
    <url>%2F2019%2F03%2F09%2FLeetCode-Problem-973-K-Closest-Points-to-Origin%2F</url>
    <content type="text"><![CDATA[We have a list of points on the plane. Find the K closest points to the origin (0, 0). (Here, the distance between two points on a plane is the Euclidean distance.) You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.) ExampleNo.1Input: points = [[1,3],[-2,2]], K = 1 Output: [[-2,2]] Explanation:The distance between (1, 3) and the origin is sqrt(10).The distance between (-2, 2) and the origin is sqrt(8).Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]]. No.2Input: points = [[3,3],[5,-1],[-2,4]], K = 2 Output: [[3,3],[-2,4]] (The answer [[-2,4],[3,3]] would also be accepted.) Note 1 &lt;= K &lt;= points.length &lt;= 10000 -10000 &lt; points[i][0] &lt; 10000 -10000 &lt; points[i][1] &lt; 10000 Code1234567891011121314151617public int[][] kClosest(int[][] points, int K) &#123; int[][] result = new int[K][2]; PriorityQueue&lt;int[]&gt; minHeap = new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;() &#123; @Override public int compare(int[] o1, int[] o2) &#123; return (o1[0] * o1[0] + o1[1] * o1[1]) - (o2[0] * o2[0] + o2[1] * o2[1]); &#125; &#125;); for (int[] point : points) minHeap.offer(point); for (int i = 0; i &lt; K; i++) result[i] = minHeap.poll(); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 788 - The Maze II]]></title>
    <url>%2F2019%2F03%2F09%2FLintCode-Problem-788-The-Maze-II%2F</url>
    <content type="text"><![CDATA[There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won’t stop rolling until hitting a wall. When the ball stops, it could choose the next direction. Given the ball’s start position, the destination and the maze, find the shortest distance for the ball to stop at the destination. The distance is defined by the number of empty spaces traveled by the ball from the start position (excluded) to the destination (included). If the ball cannot stop at the destination, return -1. The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes. Note There is only one ball and one destination in the maze. Both the ball and the destination exist on an empty space, and they will not be at the same position initially. The given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls. The maze contains at least 2 empty spaces, and both the width and height of the maze won’t exceed 100. ExampleNo.1Input:(rowStart, colStart) = (0,4)(rowDest, colDest)= (4,4) 123450 0 1 0 00 0 0 0 00 0 0 1 01 1 0 1 10 0 0 0 0 Output: 12 Explanation:(0,4)-&gt;(0,3)-&gt;(1,3)-&gt;(1,2)-&gt;(1,1)-&gt;(1,0)-&gt;(2,0)-&gt;(2,1)-&gt;(2,2)-&gt;(3,2)-&gt;(4,2)-&gt;(4,3)-&gt;(4,4) No.2Input:(rowStart, colStart) = (0,4)(rowDest, colDest)= (0,0) 123450 0 1 0 00 0 0 0 00 0 0 1 01 1 0 1 10 0 0 0 0 Output: 6 Explanation:(0,4)-&gt;(0,3)-&gt;(1,3)-&gt;(1,2)-&gt;(1,1)-&gt;(1,0)-&gt;(0,0) Code123456789101112131415161718192021222324252627282930313233343536373839404142public int shortestDistance(int[][] maze, int[] start, int[] destination) &#123; int n = maze.length; int m = maze[0].length; int minPath = Integer.MAX_VALUE; int[][] directions = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int[][] visit = new int[n][m]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); visit[start[0]][start[1]] = 1; queue.offer(new int[] &#123;start[0], start[1], 0&#125;); while (!queue.isEmpty()) &#123; int[] position = queue.poll(); if (destination[0] == position[0] &amp;&amp; destination[1] == position[1]) &#123; minPath = Math.min(minPath, position[2]); continue; &#125; for (int[] direction : directions) &#123; int x = position[0]; int y = position[1]; int path = position[2]; while (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; m &amp;&amp; maze[x][y] == 0) &#123; x += direction[0]; y += direction[1]; path++; &#125; x -= direction[0]; y -= direction[1]; path--; if (visit[x][y] == 0) &#123; visit[x][y] = 1; queue.offer(new int[] &#123;x, y, path&#125;); &#125; &#125; &#125; return minPath == Integer.MAX_VALUE ? -1 : minPath;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LintCode] Problem 787 - The Maze]]></title>
    <url>%2F2019%2F03%2F08%2FLintCode-Problem-787-The-Maze%2F</url>
    <content type="text"><![CDATA[There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won’t stop rolling until hitting a wall. When the ball stops, it could choose the next direction. Given the ball’s start position, the destination and the maze, determine whether the ball could stop at the destination. The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes. Note There is only one ball and one destination in the maze. Both the ball and the destination exist on an empty space, and they will not be at the same position initially. The given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls. The maze contains at least 2 empty spaces, and both the width and height of the maze won’t exceed 100. ExampleNo.1Input: 12345678map = [ [0,0,1,0,0], [0,0,0,0,0], [0,0,0,1,0], [1,1,0,1,1], [0,0,0,0,0]] start = [0,4]end = [3,2] Output:false No.2Input: 1234567map = [[0,0,1,0,0], [0,0,0,0,0], [0,0,0,1,0], [1,1,0,1,1], [0,0,0,0,0]] start = [0,4]end = [4,4] Output:true Code123456789101112131415161718192021222324252627282930313233343536public boolean hasPath(int[][] maze, int[] start, int[] destination) &#123; int n = maze.length; int m = maze[0].length; int[][] directions = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int[][] visit = new int[n][m]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); visit[start[0]][start[1]] = 1; queue.offer(start); while (!queue.isEmpty()) &#123; int[] position = queue.poll(); if (destination[0] == position[0] &amp;&amp; destination[1] == position[1]) return true; for (int[] direction : directions) &#123; int x = position[0]; int y = position[1]; while (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; m &amp;&amp; maze[x][y] == 0) &#123; x += direction[0]; y += direction[1]; &#125; x -= direction[0]; y -= direction[1]; if (visit[x][y] == 0) &#123; visit[x][y] = 1; queue.offer(new int[] &#123;x, y&#125;); &#125; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 516 - Longest Palindromic Subsequence]]></title>
    <url>%2F2019%2F03%2F08%2FLeetCode-Problem-516-Longest-Palindromic-Subsequence%2F</url>
    <content type="text"><![CDATA[Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000. ExampleNo.1Input:“bbbab” Output:4 One possible longest palindromic subsequence is “bbbb”. No. 2Input:“cbbd” Output:2 One possible longest palindromic subsequence is “bb”. Code12345678910111213141516171819public int longestPalindromeSubseq(String s) &#123; int n = s.length(); int[][] dp = new int[n][n]; // dp[i][j] = dp[i+1][j-1] + 2 (Si == Sj) // dp[i][j] = Max(dp[i+1][j], dp[i][j-1]) (Si != Sj) for (int i = n - 1; i &gt;= 0; i--) &#123; dp[i][i] = 1; for (int j = i + 1; j &lt; n; j++) &#123; if (s.charAt(i) == s.charAt(j)) dp[i][j] = dp[i+1][j-1] + 2; else dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]); &#125; &#125; return dp[0][n-1];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 653 - Two Sum IV - Input is a BST]]></title>
    <url>%2F2019%2F03%2F08%2FLeetCode-Problem-653-Two-Sum-IV-Input-is-a-BST%2F</url>
    <content type="text"><![CDATA[Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. ExampleNo.1Input: 12345 5 / \ 3 6 / \ \2 4 7 Target = 9 Output: True No.2Input: 12345 5 / \ 3 6 / \ \2 4 7 Target = 28 Output: False Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324252627public boolean findTarget(TreeNode root, int k) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); inorder(list, root); int left = 0; int right = list.size() - 1; while (left &lt; right) &#123; if (list.get(left) + list.get(right) &lt; k) left++; else if (list.get(left) + list.get(right) &gt; k) right--; else return true; &#125; return false;&#125;private void inorder(List&lt;Integer&gt; list, TreeNode root) &#123; if (root == null) return; inorder(list, root.left); list.add(root.val); inorder(list, root.right);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 81 - Search in Rotated Sorted Array II]]></title>
    <url>%2F2019%2F03%2F04%2FLeetCode-Problem-81-Search-in-Rotated-Sorted-Array-II%2F</url>
    <content type="text"><![CDATA[Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. ExampleNo.1Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true No.2Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false Follow upThis is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.Would this affect the run-time complexity? How and why? Code123456789// [1,1,1,1... 1]里有一个0public boolean search(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; if (target == nums[i]) return true; &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 33 - Search in Rotated Sorted Array]]></title>
    <url>%2F2019%2F03%2F04%2FLeetCode-Problem-33-Search-in-Rotated-Sorted-Array%2F</url>
    <content type="text"><![CDATA[Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n). ExampleNo.1Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 No.2Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1 Code12345678910111213141516171819202122232425public int search(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (nums[mid] == target) return mid; if (nums[mid] &lt; nums[left]) &#123; if (target &lt;= nums[right] &amp;&amp; target &gt; nums[mid]) left = mid + 1; else right = mid - 1; &#125; else &#123; if (target &lt; nums[mid] &amp;&amp; target &gt;= nums[left]) right = mid - 1; else left = mid + 1; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 32 - Longest Valid Parentheses]]></title>
    <url>%2F2019%2F03%2F04%2FLeetCode-Problem-32-Longest-Valid-Parentheses%2F</url>
    <content type="text"><![CDATA[Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring. ExampleNo.1Input: “(()” Output: 2 Explanation: The longest valid parentheses substring is “()” No.2Input: “)()())” Output: 4 Explanation: The longest valid parentheses substring is “()()” Code12345678910111213141516171819public int longestValidParentheses(String s) &#123; int result = 0; int[] d = new int[s.length()]; // "()": d[i] = d[i-2] + 2 // "(...))": d[i] = d[i-1] + d[i - d[i-1] - 2] + 2 for (int i = 1; i &lt; s.length(); i++) &#123; if (s.charAt(i) == ')') &#123; if (s.charAt(i - 1) == '(') d[i] = (i &gt;= 2 ? d[i - 2] : 0) + 2; else if (i - d[i - 1] &gt;= 1 &amp;&amp; s.charAt(i - d[i - 1] - 1) == '(') d[i] = d[i - 1] + (i - d[i - 1] &gt;= 2 ? d[i - d[i - 1] - 2] : 0) + 2; result = Math.max(result, d[i]); &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 22 - Generate Parentheses]]></title>
    <url>%2F2019%2F03%2F03%2FLeetCode-Problem-22-Generate-Parentheses%2F</url>
    <content type="text"><![CDATA[Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1234567[ "((()))", "(()())", "(())()", "()(())", "()()()"] Code1234567891011121314151617181920public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); generateParenthesisHelper(result, n, 0, 0, ""); return result;&#125;private void generateParenthesisHelper(List&lt;String&gt; result, int n, int open, int close, String str) &#123; if (str.length() == 2 * n) &#123; result.add(str); return; &#125; if (close &lt; open) generateParenthesisHelper(result, n, open, close + 1, str + ")"); if (open &lt; n) generateParenthesisHelper(result, n, open + 1, close, str + "(");&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 18 - 4Sum]]></title>
    <url>%2F2019%2F03%2F03%2FLeetCode-Problem-18-4Sum%2F</url>
    <content type="text"><![CDATA[Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. NoteThe solution set must not contain duplicate quadruplets. ExampleGiven array nums = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: 12345[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 3; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; threeSum(nums, target, nums[i], i + 1, result); &#125; return result;&#125;private void threeSum(int[] nums, int target, int num, int left, List&lt;List&lt;Integer&gt;&gt; result) &#123; for (int i = left; i &lt; nums.length - 2; i++) &#123; if (i &gt; left &amp;&amp; nums[i] == nums[i - 1]) continue; twoSum(nums, target, num, nums[i], i + 1, result); &#125;&#125;private void twoSum(int[] nums, int target, int num1, int num2, int left, List&lt;List&lt;Integer&gt;&gt; result) &#123; int sum = target - num1 - num2; int right = nums.length - 1; while (left &lt; right) &#123; if (nums[left] + nums[right] == sum) &#123; result.add(Arrays.asList(num1, num2, nums[left], nums[right])); left++; right--; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--; &#125; else if (nums[left] + nums[right] &lt; sum) left++; else right--; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 16 - 3Sum Closest]]></title>
    <url>%2F2019%2F03%2F03%2FLeetCode-Problem-16-3Sum-Closest%2F</url>
    <content type="text"><![CDATA[Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. ExampleGiven array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Code123456789101112131415161718192021public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int result = nums[0] + nums[1] + nums[2]; for (int i = 0; i &lt; nums.length - 2; i++) &#123; int left = i + 1; int right = nums.length - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; result = Math.abs(target - sum) &lt; Math.abs(target - result) ? sum : result; if (sum &lt; target) left++; else right--; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 15 - 3Sum]]></title>
    <url>%2F2019%2F03%2F03%2FLeetCode-Problem-15-3Sum%2F</url>
    <content type="text"><![CDATA[Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. NoteThe solution set must not contain duplicate triplets. ExampleGiven array nums = [-1, 0, 1, 2, -1, -4], A solution set is: 1234[ [-1, 0, 1], [-1, -1, 2]] Code123456789101112131415161718192021222324252627282930313233public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 2; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; twoSum(nums, -nums[i], i + 1, nums.length - 1, result); &#125; return result;&#125;private void twoSum(int[] nums, int target, int left, int right, List&lt;List&lt;Integer&gt;&gt; result) &#123; while (left &lt; right) &#123; if (nums[left] + nums[right] == target) &#123; result.add(Arrays.asList(-target, nums[left], nums[right])); left++; right--; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--; &#125; else if (nums[left] + nums[right] &lt; target) left++; else right--; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 11 - Container With Most Water]]></title>
    <url>%2F2019%2F03%2F03%2FLeetCode-Problem-11-Container-With-Most-Water%2F</url>
    <content type="text"><![CDATA[Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. NoteYou may not slant the container and n is at least 2. Example The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Input: [1,8,6,2,5,4,8,3,7] Output: 49 Code12345678910111213141516public int maxArea(int[] height) &#123; int left = 0; int right = height.length - 1; int result = 0; while (left &lt; right) &#123; result = Math.max(result, Math.min(height[left], height[right]) * (right - left)); if (height[left] &lt; height[right]) left++; else right--; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 38 - Count and Say]]></title>
    <url>%2F2019%2F03%2F03%2FLeetCode-Problem-38-Count-and-Say%2F</url>
    <content type="text"><![CDATA[The count-and-say sequence is the sequence of integers with the first five terms as following: 123451. 12. 113. 214. 12115. 111221 1 is read off as “one 1” or 11.11 is read off as “two 1s” or 21.21 is read off as “one 2, then one 1” or 1211. Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. NoteEach term of the sequence of integers will be represented as a string. ExampleNo.1Input: 1 Output: “1” No.2Input: 4 Output: “1211” Code1234567891011121314151617181920public String countAndSay(int n) &#123; if (n == 1) return "1"; String prev = countAndSay(n - 1); StringBuilder result = new StringBuilder(); for (int i = 0; i &lt; prev.length(); i++) &#123; int count = 1; while (i + 1 &lt; prev.length() &amp;&amp; prev.charAt(i) == prev.charAt(i + 1)) &#123; count++; i++; &#125; result.append(count).append(prev.charAt(i)); &#125; return result.toString();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 6 - ZigZag Conversion]]></title>
    <url>%2F2019%2F03%2F02%2FLeetCode-Problem-6-ZigZag-Conversion%2F</url>
    <content type="text"><![CDATA[The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) 123P A H NA P L S I I GY I R And then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows: 1string convert(string s, int numRows); ExampleNo.1Input: s = “PAYPALISHIRING”, numRows = 3 Output: “PAHNAPLSIIGYIR” No.2Input: s = “PAYPALISHIRING”, numRows = 4 Output: “PINALSIGYAHRPI” Explanation: 1234P I NA L S I GY A H RP I Code123456789101112131415161718public String convert(String s, int numRows) &#123; if (numRows == 1) return s; StringBuffer result = new StringBuffer(); int cycle = 2 * numRows - 2; for (int i = 0; i &lt; numRows; i++) &#123; for (int j = 0; i + j &lt; s.length(); j += cycle) &#123; result.append(s.charAt(i + j)); if (i != 0 &amp;&amp; i != numRows - 1 &amp;&amp; cycle - i + j &lt; s.length()) result.append(s.charAt(cycle - i + j)); &#125; &#125; return result.toString();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 14 - Longest Common Prefix]]></title>
    <url>%2F2019%2F03%2F02%2FLeetCode-Problem-14-Longest-Common-Prefix%2F</url>
    <content type="text"><![CDATA[Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”. ExampleNo.1Input: [“flower”,”flow”,”flight”] Output: “fl” No.2Input: [“dog”,”racecar”,”car”] Output: “” Explanation: There is no common prefix among the input strings. NoteAll given inputs are in lowercase letters a-z. Code12345678910111213public String longestCommonPrefix(String[] strs) &#123; if (strs == null || strs.length &lt; 1) return ""; for (int i = 0; i &lt; strs[0].length(); i++) &#123; for (int j = 1; j &lt; strs.length; j++) &#123; if (i == strs[j].length() || strs[j].charAt(i) != strs[0].charAt(i)) return strs[0].substring(0, i); &#125; &#125; return strs[0];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 58 - Length of Last Word]]></title>
    <url>%2F2019%2F03%2F02%2FLeetCode-Problem-58-Length-of-Last-Word%2F</url>
    <content type="text"><![CDATA[Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0. NoteA word is defined as a character sequence consists of non-space characters only. ExampleInput: “Hello World” Output: 5 Code1234567891011121314151617public int lengthOfLastWord(String s) &#123; if (s == null || s.length() &lt; 1) return 0; int result = 0; int i = s.length() - 1; while (i &gt;= 0 &amp;&amp; s.charAt(i) == ' ') i--; while (i &gt;= 0 &amp;&amp; s.charAt(i) != ' ') &#123; result++; i--; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 67 - Add Binary]]></title>
    <url>%2F2019%2F03%2F02%2FLeetCode-Problem-67-Add-Binary%2F</url>
    <content type="text"><![CDATA[Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. ExampleNo.1Input: a = “11”, b = “1” Output: “100” No.2Input: a = “1010”, b = “1011” Output: “10101” Code123456789101112131415161718192021public String addBinary(String a, String b) &#123; int carry = 0; StringBuffer result = new StringBuffer(); for (int i = a.length() - 1, j = b.length() - 1; i &gt;= 0 || j &gt;= 0; i--, j--) &#123; int sum = carry; if (i &gt;= 0) sum += a.charAt(i) - '0'; if (j &gt;= 0) sum += b.charAt(j) - '0'; carry = sum / 2; result.insert(0, sum % 2); &#125; if (carry &gt; 0) result.insert(0, carry); return result.toString();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 100 - Same Tree]]></title>
    <url>%2F2019%2F03%2F02%2FLeetCode-Problem-100-Same-Tree%2F</url>
    <content type="text"><![CDATA[Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. ExampleNo.1Input: 12345 1 1 / \ / \ 2 3 2 3[1,2,3], [1,2,3] Output: true No.2Input: 12345 1 1 / \ 2 2[1,2], [1,null,2] Output: false No.3Input: 12345 1 1 / \ / \ 2 1 1 2[1,2,1], [1,1,2] Output: false Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678public boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null &amp;&amp; q == null) return true; else if (p == null || q == null || p.val != q.val) return false; return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 101 - Symmetric Tree]]></title>
    <url>%2F2019%2F03%2F02%2FLeetCode-Problem-101-Symmetric-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 12345 1 / \ 2 2 / \ / \3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 12345 1 / \2 2 \ \ 3 3 NoteBonus points if you could solve it both recursively and iteratively. Recursive123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415public boolean isSymmetric(TreeNode root) &#123; if (root == null) return true; return isSymmetricHelper(root.left, root.right);&#125;private boolean isSymmetricHelper(TreeNode n1, TreeNode n2) &#123; if (n1 == null &amp;&amp; n2 == null) return true; else if (n1 == null || n2 == null || n1.val != n2.val) return false; return isSymmetricHelper(n1.left, n2.right) &amp;&amp; isSymmetricHelper(n1.right, n2.left);&#125; Iterative123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516171819202122232425public boolean isSymmetric(TreeNode root) &#123; if (root == null) return true; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root.left); queue.offer(root.right); while (!queue.isEmpty()) &#123; TreeNode n1 = queue.poll(); TreeNode n2 = queue.poll(); if (n1 == null &amp;&amp; n2 == null) continue; else if (n1 == null || n2 == null || n1.val != n2.val) return false; queue.offer(n1.left); queue.offer(n2.right); queue.offer(n1.right); queue.offer(n2.left); &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 965 - Univalued Binary Tree]]></title>
    <url>%2F2019%2F03%2F02%2FLeetCode-Problem-965-Univalued-Binary-Tree%2F</url>
    <content type="text"><![CDATA[A binary tree is univalued if every node in the tree has the same value. Return true if and only if the given tree is univalued. ExampleNo.1 Input: [1,1,1,1,1,null,1] Output: true No.2 Input: [2,2,2,5,2] Output: false NoteThe number of nodes in the given tree will be in the range [1, 100].Each node’s value will be an integer in the range [0, 99]. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011public boolean isUnivalTree(TreeNode root) &#123; if (root == null) return true; if (root.left != null &amp;&amp; root.val != root.left.val) return false; if (root.right != null &amp;&amp; root.val != root.right.val) return false; return isUnivalTree(root.left) &amp;&amp; isUnivalTree(root.right);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 985 - Sum of Even Numbers After Queries]]></title>
    <url>%2F2019%2F03%2F02%2FLeetCode-Problem-985-Sum-of-Even-Numbers-After-Queries%2F</url>
    <content type="text"><![CDATA[We have an array A of integers, and an array queries of queries. For the i-th query val = queries[i][0], index = queries[i][1], we add val to A[index]. Then, the answer to the i-th query is the sum of the even values of A. (Here, the given index = queries[i][1] is a 0-based index, and each query permanently modifies the array A.) Return the answer to all queries. Your answer array should have answer[i] as the answer to the i-th query. ExampleInput: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]] Output: [8,6,2,4] Explanation:At the beginning, the array is [1,2,3,4].After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4. Note1 &lt;= A.length &lt;= 10000-10000 &lt;= A[i] &lt;= 100001 &lt;= queries.length &lt;= 10000-10000 &lt;= queries[i][0] &lt;= 100000 &lt;= queries[i][1] &lt; A.length Code123456789101112131415161718192021222324252627public int[] sumEvenAfterQueries(int[] A, int[][] queries) &#123; int n = queries.length; int[] result = new int[n]; int sum = 0; for (int i = 0; i &lt; A.length; i++) &#123; if (A[i] % 2 == 0) sum += A[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; int val = queries[i][0]; int index = queries[i][1]; if (A[index] % 2 == 0) sum -= A[index]; A[index] += val; if (A[index] % 2 == 0) sum += A[index]; result[i] = sum; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 561 - Array Partition I]]></title>
    <url>%2F2019%2F03%2F01%2FLeetCode-Problem-561-Array-Partition-I%2F</url>
    <content type="text"><![CDATA[Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. ExampleInput: [1,4,3,2] Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4). Noten is a positive integer, which is in the range of [1, 10000].All the integers in the array will be in the range of [-10000, 10000]. Code123456789public int arrayPairSum(int[] nums) &#123; int sum = 0; Arrays.sort(nums); for (int i = 0; i &lt; nums.length; i += 2) sum += nums[i]; return sum;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 933 - Number of Recent Calls]]></title>
    <url>%2F2019%2F03%2F01%2FLeetCode-Problem-933-Number-of-Recent-Calls%2F</url>
    <content type="text"><![CDATA[Write a class RecentCounter to count recent requests. It has only one method: ping(int t), where t represents some time in milliseconds. Return the number of pings that have been made from 3000 milliseconds ago until now. Any ping with time in [t - 3000, t] will count, including the current ping. It is guaranteed that every call to ping uses a strictly larger value of t than before. ExampleInput: inputs = [“RecentCounter”,”ping”,”ping”,”ping”,”ping”], inputs = [[],[1],[100],[3001],[3002]] Output: [null,1,2,3,3] NoteEach test case will have at most 10000 calls to ping.Each test case will call ping with strictly increasing values of t.Each call to ping will have 1 &lt;= t &lt;= 10^9. Code1234567891011121314Queue&lt;Integer&gt; queue;public RecentCounter() &#123; queue = new LinkedList();&#125;public int ping(int t) &#123; queue.offer(t); while (queue.peek() &lt; t - 3000) queue.poll(); return queue.size();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 728 - Self Dividing Numbers]]></title>
    <url>%2F2019%2F03%2F01%2FLeetCode-Problem-728-Self-Dividing-Numbers%2F</url>
    <content type="text"><![CDATA[A self-dividing number is a number that is divisible by every digit it contains. For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0. Also, a self-dividing number is not allowed to contain the digit zero. Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible. ExampleInput:left = 1, right = 22 Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22] NoteThe boundaries of each input argument are 1 &lt;= left &lt;= right &lt;= 10000. Code123456789101112131415161718192021public List&lt;Integer&gt; selfDividingNumbers(int left, int right) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int ans = left; ans &lt;= right; ans++) &#123; int i = ans; while (i != 0) &#123; int d = i % 10; if (d == 0 || ans % d != 0) break; i /= 10; &#125; if (i == 0) result.add(ans); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 852 - Peak Index in a Mountain Array]]></title>
    <url>%2F2019%2F03%2F01%2FLeetCode-Problem-852-Peak-Index-in-a-Mountain-Array%2F</url>
    <content type="text"><![CDATA[Let’s call an array A a mountain if the following properties hold: A.length &gt;= 3There exists some 0 &lt; i &lt; A.length - 1 such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] Given an array that is definitely a mountain, return any i such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]. ExampleNo.1Input: [0,1,0] Output: 1 No.2Input: [0,2,1,0] Output: 1 Note3 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt;= 10^6A is a mountain, as defined above. Code123456789101112131415public int peakIndexInMountainArray(int[] A) &#123; int left = 0; int right = A.length - 1; while (left &lt; right) &#123; int mid = (left + right) &gt;&gt; 1; if (A[mid] &lt; A[mid + 1]) left = mid + 1; else right = mid; &#125; return left;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 617 - Merge Two Binary Trees]]></title>
    <url>%2F2019%2F02%2F28%2FLeetCode-Problem-617-Merge-Two-Binary-Trees%2F</url>
    <content type="text"><![CDATA[Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. ExampleInput: 123456Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 Output:Merged tree: 12345 3 / \ 4 5 / \ \ 5 4 7 NoteThe merging process must start from the root nodes of both trees. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if (t1 == null) return t2; if (t2 == null) &#123; return t1; &#125; TreeNode t = new TreeNode(t1.val + t2.val); t.left = mergeTrees(t1.left, t2.left); t.right = mergeTrees(t1.right, t2.right); return t;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 461 - Hamming Distance]]></title>
    <url>%2F2019%2F02%2F28%2FLeetCode-Problem-461-Hamming-Distance%2F</url>
    <content type="text"><![CDATA[The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note0 ≤ x, y &lt; 2^31. ExampleInput: x = 1, y = 4 Output: 2 1234Explanation:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different. Code1234567891011public int hammingDistance(int x, int y) &#123; int result = 0; int xor = x ^ y; while (xor != 0) &#123; result++; xor &amp;= xor - 1; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 944 - Delete Columns to Make Sorted]]></title>
    <url>%2F2019%2F02%2F28%2FLeetCode-Problem-944-Delete-Columns-to-Make-Sorted%2F</url>
    <content type="text"><![CDATA[We are given an array A of N lowercase letter strings, all of the same length. Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices. For example, if we have an array A = [“abcdef”,”uvwxyz”] and deletion indices {0, 2, 3}, then the final array after deletions is [“bef”, “vyz”], and the remaining columns of A are [“b”,”v”], [“e”,”y”], and [“f”,”z”]. (Formally, the c-th column is [A[0][c], A[1][c], …, A[A.length-1][c]].) Suppose we chose a set of deletion indices D such that after deletions, each remaining column in A is in non-decreasing sorted order. Return the minimum possible value of D.length. ExampleNo.1Input: [“cba”,”daf”,”ghi”] Output: 1 Explanation:After choosing D = {1}, each column [“c”,”d”,”g”] and [“a”,”f”,”i”] are in non-decreasing sorted order.If we chose D = {}, then a column [“b”,”a”,”h”] would not be in non-decreasing sorted order. No.2Input: [“a”,”b”] Output: 0 Explanation: D = {} No.3Input: [“zyx”,”wvu”,”tsr”] Output: 3 Explanation: D = {0, 1, 2} Note1 &lt;= A.length &lt;= 1001 &lt;= A[i].length &lt;= 1000 Code1234567891011121314public int minDeletionSize(String[] A) &#123; int result = 0; for (int i = 0; i &lt; A[0].length(); i++) &#123; for (int j = 0; j &lt; A.length - 1; j++) &#123; if (A[j].charAt(i) &gt; A[j + 1].charAt(i)) &#123; result++; break; &#125; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 942 - DI String Match]]></title>
    <url>%2F2019%2F02%2F28%2FLeetCode-Problem-942-DI-String-Match%2F</url>
    <content type="text"><![CDATA[Given a string S that only contains “I” (increase) or “D” (decrease), let N = S.length. Return any permutation A of [0, 1, …, N] such that for all i = 0, …, N-1: If S[i] == “I”, then A[i] &lt; A[i+1]If S[i] == “D”, then A[i] &gt; A[i+1] ExampleNo.1Input: “IDID” Output: [0,4,1,3,2] No.2Input: “III” Output: [0,1,2,3] No.3Input: “DDI” Output: [3,2,0,1] Note1 &lt;= S.length &lt;= 10000S only contains characters “I” or “D”. Code12345678910111213141516public int[] diStringMatch(String S) &#123; int n = S.length(); int left = 0; int right = n; int[] result = new int[n + 1]; for (int i = 0; i &lt; n; i++) &#123; if (S.charAt(i) == 'I') result[i] = left++; else result[i] = right--; &#125; result[n] = left; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 657 - Robot Return to Origin]]></title>
    <url>%2F2019%2F02%2F27%2FLeetCode-Problem-657-Robot-Return-to-Origin%2F</url>
    <content type="text"><![CDATA[There is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves. The move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false. NoteThe way that the robot is “facing” is irrelevant. “R” will always make the robot move to the right once, “L” will always make it move left, etc. Also, assume that the magnitude of the robot’s movement is the same for each move. ExampleNo.1Input: “UD” Output: true Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true. No.2Input: “LL” Output: false Explanation: The robot moves left twice. It ends up two “moves” to the left of the origin. We return false because it is not at the origin at the end of its moves. Code123456789101112131415161718public boolean judgeCircle(String moves) &#123; char[] chs = moves.toCharArray(); int x = 0; int y = 0; for (char ch : chs) &#123; if (ch == 'L') x--; else if (ch == 'R') x++; else if (ch == 'D') y--; else if (ch == 'U') y++; &#125; return x == 0 &amp;&amp; y == 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 832 - Flipping an Image]]></title>
    <url>%2F2019%2F02%2F27%2FLeetCode-Problem-832-Flipping-an-Image%2F</url>
    <content type="text"><![CDATA[Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed. For example, flipping [1, 1, 0] horizontally results in [0, 1, 1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0]. ExampleNo.1Input: [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] No.2Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Notes1 &lt;= A.length = A[0].length &lt;= 200 &lt;= A[i][j] &lt;= 1 Code1234567891011public int[][] flipAndInvertImage(int[][] A) &#123; for (int[] row : A) &#123; for (int i = 0; i &lt; (row.length + 1) / 2; i++) &#123; int temp = row[row.length - i - 1] ^ 1; row[row.length - i - 1] = row[i] ^ 1; row[i] = temp; &#125; &#125; return A;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 905 - Sort Array By Parity]]></title>
    <url>%2F2019%2F02%2F27%2FLeetCode-Problem-905-Sort-Array-By-Parity%2F</url>
    <content type="text"><![CDATA[Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A. You may return any answer array that satisfies this condition. ExampleNo.1Input: [3,1,2,4] Output: [2,4,3,1] The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Note1 &lt;= A.length &lt;= 50000 &lt;= A[i] &lt;= 5000 Code1234567891011121314151617181920public int[] sortArrayByParity(int[] A) &#123; int left = 0; int right = A.length - 1; while (left &lt; right) &#123; if (A[left] % 2 &gt; A[right] % 2) &#123; int temp = A[left]; A[left] = A[right]; A[right] = temp; &#125; if (A[left] % 2 == 0) left++; if (A[right] % 2 &gt; 0) right--; &#125; return A;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 977 - Squares of a Sorted Array]]></title>
    <url>%2F2019%2F02%2F27%2FLeetCode-Problem-977-Squares-of-a-Sorted-Array%2F</url>
    <content type="text"><![CDATA[Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order. ExampleNo.1Input: [-4,-1,0,3,10] Output: [0,1,9,16,100] No.2Input: [-7,-3,2,3,11] Output: [4,9,9,49,121] Note1 &lt;= A.length &lt;= 10000-10000 &lt;= A[i] &lt;= 10000A is sorted in non-decreasing order. Code123456789101112131415161718192021222324252627282930313233public int[] sortedSquares(int[] A) &#123; int n = A.length; int[] result = new int[n]; int right = 0; while (right &lt; n &amp;&amp; A[right] &lt; 0) right++; int left = right - 1; int i = 0; while (left &gt;= 0 &amp;&amp; right &lt; n) &#123; if (A[left] * A[left] &lt; A[right] * A[right]) &#123; result[i++] = A[left] * A[left]; left--; &#125; else &#123; result[i++] = A[right] * A[right]; right++; &#125; &#125; while (left &gt;= 0) &#123; result[i++] = A[left] * A[left]; left--; &#125; while (right &lt; n) &#123; result[i++] = A[right] * A[right]; right++; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 961 - N-Repeated Element in Size 2N Array]]></title>
    <url>%2F2019%2F02%2F27%2FLeetCode-Problem-961-N-Repeated-Element-in-Size-2N-Array%2F</url>
    <content type="text"><![CDATA[In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times. Return the element repeated N times. ExampleNo.1Input: [1,2,3,3] Output: 3 No.2Input: [2,1,2,5,3,2] Output: 2 No.3Input: [5,1,5,2,5,3,5,4] Output: 5 Note4 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt; 10000A.length is even Code12345678910public int repeatedNTimes(int[] A) &#123; for (int i = 1; i &lt;= 3; i++) &#123; for (int j = 0; j &lt; A.length - i; j++) &#123; if (A[j] == A[j + i]) return A[j]; &#125; &#125; throw null;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 804 - Unique Morse Code Words]]></title>
    <url>%2F2019%2F02%2F26%2FLeetCode-Problem-804-Unique-Morse-Code-Words%2F</url>
    <content type="text"><![CDATA[International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: “a” maps to “.-“, “b” maps to “-…”, “c” maps to “-.-.”, and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: [“.-“,”-…”,”-.-.”,”-..”,”.”,”..-.”,”–.”,”….”,”..”,”.—“,”-.-“,”.-..”,”–”,”-.”,”—“,”.–.”,”–.-“,”.-.”,”…”,”-“,”..-“,”…-“,”.–”,”-..-“,”-.–”,”–..”] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cba” can be written as “-.-..–…”, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. ExampleInput: words = [“gin”, “zen”, “gig”, “msg”] Output: 2 Explanation:The transformation of each word is: 1234"gin" -&gt; "--...-.""zen" -&gt; "--...-.""gig" -&gt; "--...--.""msg" -&gt; "--...--." There are 2 different transformations, “–…-.” and “–…–.”. NoteThe length of words will be at most 100.Each words[i] will have length in range [1, 12].words[i] will only consist of lowercase letters. Code1234567891011121314public int uniqueMorseRepresentations(String[] words) &#123; Set&lt;String&gt; result = new HashSet&lt;&gt;(); String[] morse = &#123;".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---", ".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."&#125;; for (String word : words) &#123; String str = ""; for (char ch : word.toCharArray()) str += morse[ch - 'a']; result.add(str); &#125; return result.size();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 709 - To Lower Case]]></title>
    <url>%2F2019%2F02%2F26%2FLeetCode-Problem-709-To-Lower-Case%2F</url>
    <content type="text"><![CDATA[Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase. ExampleNo.1Input: “Hello” Output: “hello” No.2Input: “here” Output: “here” No.3Input: “LOVELY” Output: “lovely” Code12345678910public String toLowerCase(String str) &#123; char[] ch = str.toCharArray(); for (int i = 0; i &lt; ch.length; i++) &#123; if (ch[i] &gt;= 'A' &amp;&amp; ch[i] &lt;= 'Z') ch[i] -= 'A' - 'a'; &#125; return String.valueOf(ch);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 929 - Unique Email Addresses]]></title>
    <url>%2F2019%2F02%2F26%2FLeetCode-Problem-929-Unique-Email-Addresses%2F</url>
    <content type="text"><![CDATA[Every email consists of a local name and a domain name, separated by the @ sign. For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name. Besides lowercase letters, these emails may contain ‘.’s or ‘+’s. If you add periods (‘.’) between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. For example, “alice.z@leetcode.com“ and “alicez@leetcode.com“ forward to the same email address. (Note that this rule does not apply for domain names.) If you add a plus (‘+’) in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com. (Again, this rule does not apply for domain names.) It is possible to use both of these rules at the same time. Given a list of emails, we send one email to each address in the list. How many different addresses actually receive mails? ExampleInput: [“test.email+alex@leetcode.com”,”test.e.mail+bob.cathy@leetcode.com“,”testemail+david@lee.tcode.com“] Output: 2 Explanation: “testemail@leetcode.com“ and “testemail@lee.tcode.com“ actually receive mails Note1 &lt;= emails[i].length &lt;= 1001 &lt;= emails.length &lt;= 100Each emails[i] contains exactly one ‘@’ character. Code1234567891011public int numUniqueEmails(String[] emails) &#123; Set&lt;String&gt; result = new HashSet&lt;&gt;(); for (String email : emails) &#123; String[] names = email.split("@"); String[] local = names[0].split("\\+"); result.add(local[0].replace(".", "") + "@" + names[1]); &#125; return result.size();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 295 - Find Median from Data Stream]]></title>
    <url>%2F2019%2F02%2F26%2FLeetCode-Problem-295-Find-Median-from-Data-Stream%2F</url>
    <content type="text"><![CDATA[Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example,[2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure.double findMedian() - Return the median of all elements so far. ExampleaddNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3)findMedian() -&gt; 2 Follow upIf all integer numbers from the stream are between 0 and 100, how would you optimize it?If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it? Code1234567891011121314151617181920212223242526private PriorityQueue&lt;Integer&gt; maxHeap, minHeap;public MedianFinder() &#123; minHeap = new PriorityQueue&lt;&gt;(); maxHeap = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2.compareTo(o1); &#125; &#125;);&#125;public void addNum(int num) &#123; maxHeap.add(num); minHeap.add(maxHeap.poll()); if (minHeap.size() &gt; maxHeap.size()) maxHeap.add(minHeap.poll());&#125;public double findMedian() &#123; if (minHeap.size() == maxHeap.size()) return (double) (minHeap.peek() + maxHeap.peek()) / 2; else return (double) maxHeap.peek();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 17 - Letter Combinations of a Phone Number]]></title>
    <url>%2F2019%2F02%2F25%2FLeetCode-Problem-17-Letter-Combinations-of-a-Phone-Number%2F</url>
    <content type="text"><![CDATA[Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. ExampleInput: “23” Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. NoteAlthough the above answer is in lexicographical order, your answer could be in any order you want. Code1234567891011121314151617181920212223242526272829303132333435Map&lt;Character, char[]&gt; map = new HashMap&lt;Character, char[]&gt;() &#123;&#123; put('2', new char[] &#123; 'a', 'b', 'c' &#125;); put('3', new char[] &#123; 'd', 'e', 'f' &#125;); put('4', new char[] &#123; 'g', 'h', 'i' &#125;); put('5', new char[] &#123; 'j', 'k', 'l' &#125;); put('6', new char[] &#123; 'm', 'n', 'o' &#125;); put('7', new char[] &#123; 'p', 'q', 'r', 's' &#125;); put('8', new char[] &#123; 't', 'u', 'v' &#125;); put('9', new char[] &#123; 'w', 'x', 'y', 'z' &#125;);&#125;&#125;;public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if (digits == null || digits.length() &lt; 1) return result; StringBuilder sb = new StringBuilder(); combinationHelper(result, digits, sb); return result;&#125;private void combinationHelper(List&lt;String&gt; result, String digits, StringBuilder sb) &#123; if (sb.length() == digits.length()) &#123; result.add(sb.toString()); return; &#125; for (char c : map.get(digits.charAt(sb.length()))) &#123; sb.append(c); combinationHelper(result, digits, sb); sb.deleteCharAt(sb.length() - 1); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 771 - Jewels and Stones]]></title>
    <url>%2F2019%2F02%2F21%2FLeetCode-Problem-771-Jewels-and-Stones%2F</url>
    <content type="text"><![CDATA[You’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”. ExampleNo.1Input: J = “aA”, S = “aAAbbbb” Output: 3 No.2Input: J = “z”, S = “ZZ” Output: 0 NoteS and J will consist of letters and have length at most 50. The characters in J are distinct. Code12345678910111213141516public int numJewelsInStones(String J, String S) &#123; int result = 0; Set set = new HashSet(); for (char j : J.toCharArray()) &#123; set.add(j); &#125; for (char s : S.toCharArray()) &#123; if (set.contains(s)) &#123; result++; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[clone方法和java.lang.Cloneable接口]]></title>
    <url>%2F2019%2F02%2F19%2Fclone%E6%96%B9%E6%B3%95%E5%92%8Cjava-lang-Cloneable%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Java语言准备了用于复制实例的clone方法。要想调用clone方法，被复制对象的类必须实现java.lang.Cloneable接口，不论是被复制对象的类实现java.lang.Cloneable接口还是其某个父类实现Cloneable接口，亦或是被复制对象的类实现了Cloneable接口的子接口都可以。 实现了Cloneable接口的类的实例可以调用clone方法进行复制，clone方法的返回值是复制出的新的实例（clone方法内部所进行的处理是分配与要复制的实例同样大小的内存空间，接着将要复制的实例中的字段的值复制到所分配的内存空间中去）。 如果没有实现Cloneable接口的类的实例调用了clone方法，则会在运行时抛出CloneNotSupportedException异常。 clone方法是在哪里定义的clone方法定义在java.lang.Object中。因为Object类是所有Java类的父类，因此所有的Java类都继承了clone方法。 需要实现Cloneable的哪些方法提到Cloneable接口，很容易让人误以为Cloneable接口中声明了clone方法。其实这是错误的。在Cloneable接口中并没有声明任何方法。它只是被用来标记“可以使用clone方法进行复制”的。这样的接口被称为标记接口。 clone方法进行的是浅复制clone方法所进行的复制只是将被复制实例的字段值直接复制到新的实例中。换言之，它并没有考虑字段中所保存的实例的内容。例如，当字段中保存的是数组时，如果使用clone方法进行复制，则只会复制该数组的引用，并不会一一复制数组中的元素。 像这样的字段对字段的复制被称为浅复制（shallow copy）。clone方法所进行的复制就是浅复制。 当使用clone方法进行浅复制无法满足需求时，类的设计者可以实现重写clone方法，实现自己需要的复制功能（重写clone方法时，别忘了使用super.clone()来调用父类的clone方法）。 需要注意的是，clone方法只会进行复制，并不会调用被复制实例的构造函数。此外，对于在生成实例时需要进行特殊的初始化处理的类，需要自己去实现clone方法，在其内部进行这些初始化处理。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Prototype模式]]></title>
    <url>%2F2019%2F02%2F18%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Prototype%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[不根据类来生成实例，而是根据实例来生成新实例。 在开发过程中，有时候也会有“在不指定类名的前提下生成实例”的需求。例如，在以下情况下，就不能根据类来生成实例，而要根据现有的实例来生成新的实例。 (1) 对象种类繁多，无法将它们整合到一个类中时(2) 难以根据类生成实例时(3) 想解耦框架与生成的实例时 在Java语言中，可以使用clone创建出实例的副本。 示例将字符串放入方框中显示出来或是加上下划线显示出来。 Product接口123456package framework;public interface Product extends Cloneable &#123; public abstract void use(String s); public abstract Product createClone();&#125; Manager类12345678910111213141516package framework;import java.util.HashMap;public class Manager &#123; private HashMap showcase = new HashMap(); public void register(String name, Product proto) &#123; showcase.put(name, proto); &#125; public Product create(String protoname) &#123; Product p = (Product) showcase.get(protoname); return p.createClone(); &#125;&#125; MessageBox类12345678910111213141516171819202122232425262728293031323334353637import framework.Product;public class MessageBox implements Product &#123; private char decochar; public MessageBox(char decochar) &#123; this.decochar = decochar; &#125; @Override public void use(String s) &#123; int length = s.getBytes().length; for (int i = 0; i &lt; length + 4; i++) &#123; System.out.print(decochar); &#125; System.out.println(""); System.out.println(decochar + " " + s + " " + decochar); for (int i = 0; i &lt; length + 4; i++) &#123; System.out.print(decochar); &#125; System.out.println(""); &#125; @Override public Product createClone() &#123; Product p = null; try &#123; p = (Product) clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return p; &#125;&#125; UnderlinePen类12345678910111213141516171819202122232425262728293031323334import framework.Product;public class UnderlinePen implements Product &#123; private char ulchar; public UnderlinePen(char ulchar) &#123; this.ulchar = ulchar; &#125; @Override public void use(String s) &#123; int length = s.getBytes().length; System.out.println("\"" + s + "\""); System.out.print(" "); for (int i = 0; i &lt; length; i++) &#123; System.out.print(ulchar); &#125; System.out.println(""); &#125; @Override public Product createClone() &#123; Product p = null; try &#123; p = (Product) clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return p; &#125;&#125; Main类12345678910111213141516171819202122import framework.Manager;import framework.Product;public class Main &#123; public static void main(String[] args) &#123; Manager manager = new Manager(); UnderlinePen upen = new UnderlinePen('~'); MessageBox mbox = new MessageBox('*'); MessageBox sbox = new MessageBox('/'); manager.register("strong message", upen); manager.register("warning box", mbox); manager.register("slash box", sbox); Product p1 = manager.create("strong message"); p1.use("Hello, world."); Product p2 = manager.create("warning box"); p2.use("Hello, world."); Product p3 = manager.create("slash box"); p3.use("Hello, world."); &#125;&#125; 运行结果12345678&quot;Hello, world.&quot; ~~~~~~~~~~~~~****************** Hello, world. ******************////////////////// Hello, world. ////////////////// 登场角色Prototype（原型）Prototype角色负责定义用于赋值现有实例来生成新实例的方法。在示例程序中，由Product接口扮演此角色。 ConcretePrototype（具体的原型）ConcretePrototype角色负责实现复制现有实例并生成新实例的方法。在示例程序中，由MessageBox类和UnderlinePen类扮演此角色。 Client（使用者）Client角色负责使用复制实例的方法生成新的实例。在示例程序中，由Manager类扮演此角色。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.util.concurrent包和Active Object模式]]></title>
    <url>%2F2019%2F02%2F17%2Fjava-util-concurrent%E5%8C%85%E5%92%8CActive-Object%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[类图 Main.java1234567891011121314151617181920import activeobject.ActiveObject;import activeobject.ActiveObjectFactory;public class Main &#123; public static void main(String[] args) &#123; ActiveObject activeObject = ActiveObjectFactory.createActiveObject(); try &#123; new MakerClientThread("Alice", activeObject).start(); new MakerClientThread("Bobby", activeObject).start(); new DisplayClientThread("Chris", activeObject).start(); Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; &#125; finally &#123; System.out.println("*** shutdown ***"); activeObject.shutdown(); &#125; &#125;&#125; MakerClientThread.java12345678910111213141516171819202122232425262728293031323334353637import activeobject.ActiveObject;import java.util.concurrent.CancellationException;import java.util.concurrent.ExecutionException;import java.util.concurrent.Future;import java.util.concurrent.RejectedExecutionException;public class MakerClientThread extends Thread &#123; private final ActiveObject activeObject; private final char fillchar; public MakerClientThread(String name, ActiveObject activeObject) &#123; super(name); this.activeObject = activeObject; this.fillchar = name.charAt(0); &#125; @Override public void run() &#123; try &#123; for (int i = 0; true; i++) &#123; Future&lt;String&gt; future = activeObject.makeString(i, fillchar); Thread.sleep(10); String value = future.get(); System.out.println(Thread.currentThread().getName() + ": value = " + value); &#125; &#125; catch (InterruptedException e) &#123; System.out.println(Thread.currentThread().getName() + ":" + e); &#125; catch (ExecutionException e) &#123; System.out.println(Thread.currentThread().getName() + ":" + e); &#125; catch (RejectedExecutionException e) &#123; System.out.println(Thread.currentThread().getName() + ":" + e); &#125; catch (CancellationException e) &#123; System.out.println(Thread.currentThread().getName() + ":" + e); &#125; &#125;&#125; DisplayClientThread.java123456789101112131415161718192021222324252627282930import activeobject.ActiveObject;import java.util.concurrent.CancellationException;import java.util.concurrent.RejectedExecutionException;public class DisplayClientThread extends Thread &#123; private final ActiveObject activeObject; public DisplayClientThread(String name, ActiveObject activeObject) &#123; super(name); this.activeObject = activeObject; &#125; @Override public void run() &#123; try &#123; for (int i = 0; true; i++) &#123; String string = Thread.currentThread().getName() + " " + i; activeObject.displayString(string); Thread.sleep(200); &#125; &#125; catch (InterruptedException e) &#123; System.out.println(Thread.currentThread().getName() + ":" + e); &#125; catch (RejectedExecutionException e) &#123; System.out.println(Thread.currentThread().getName() + ":" + e); &#125; catch (CancellationException e) &#123; System.out.println(Thread.currentThread().getName() + ":" + e); &#125; &#125;&#125; ActiveObject.java123456789package activeobject;import java.util.concurrent.Future;public interface ActiveObject &#123; public abstract Future&lt;String&gt; makeString(int count, char fillchar); public abstract void displayString(String string); public abstract void shutdown();&#125; ActiveObjectFactory.java1234567package activeobject;public class ActiveObjectFactory &#123; public static ActiveObject createActiveObject() &#123; return new ActiveObjectImpl(); &#125;&#125; ActiveObjectImpl.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package activeobject;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;class ActiveObjectImpl implements ActiveObject &#123; private final ExecutorService service = Executors.newSingleThreadExecutor(); @Override public Future&lt;String&gt; makeString(final int count, final char fillchar) &#123; class MakeStringRequest implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; char[] buffer = new char[count]; for (int i = 0; i &lt; count; i++) &#123; buffer[i] = fillchar; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; &#125; return new String(buffer); &#125; &#125; return service.submit(new MakeStringRequest()); &#125; @Override public void displayString(final String string) &#123; class DisplayStringRequest implements Runnable &#123; @Override public void run() &#123; try &#123; System.out.println("displayString: " + string); Thread.sleep(10); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; service.execute(new DisplayStringRequest()); &#125; @Override public void shutdown() &#123; service.shutdown(); &#125;&#125; 运行结果123456789101112131415161718192021222324252627282930313233343536373839404142434445displayString: Chris 0Alice: value = Bobby: value = Alice: value = ABobby: value = BdisplayString: Chris 1Alice: value = AAdisplayString: Chris 2Bobby: value = BBAlice: value = AAAdisplayString: Chris 3Bobby: value = BBBdisplayString: Chris 4displayString: Chris 5Alice: value = AAAAdisplayString: Chris 6Bobby: value = BBBBdisplayString: Chris 7displayString: Chris 8Alice: value = AAAAAdisplayString: Chris 9displayString: Chris 10Bobby: value = BBBBBdisplayString: Chris 11displayString: Chris 12displayString: Chris 13Alice: value = AAAAAAdisplayString: Chris 14displayString: Chris 15displayString: Chris 16Bobby: value = BBBBBBdisplayString: Chris 17displayString: Chris 18displayString: Chris 19*** shutdown ***Chris:java.util.concurrent.RejectedExecutionException: Task activeobject.ActiveObjectImpl$1DisplayStringRequest@16d7ece6 rejected from java.util.concurrent.ThreadPoolExecutor@1810004c[Shutting down, pool size = 1, active threads = 1, queued tasks = 6, completed tasks = 34]Alice: value = AAAAAAAdisplayString: Chris 20Alice:java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@5ddf2842 rejected from java.util.concurrent.ThreadPoolExecutor@1810004c[Shutting down, pool size = 1, active threads = 1, queued tasks = 5, completed tasks = 35]displayString: Chris 21displayString: Chris 22Bobby: value = BBBBBBBdisplayString: Chris 23Bobby:java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@5bfd5176 rejected from java.util.concurrent.ThreadPoolExecutor@1810004c[Shutting down, pool size = 1, active threads = 1, queued tasks = 1, completed tasks = 39]displayString: Chris 24]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解Java多线程设计模式】Active Object模式]]></title>
    <url>%2F2019%2F02%2F15%2F%E3%80%90%E5%9B%BE%E8%A7%A3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Active-Object%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[主动对象会通过自己特有的线程在合适的时机处理从外部接收到的异步消息。 示例实现具有“生成字符串”（makeString）和“显示字符串”（displayString）这两种功能（可以处理两种异步消息）的主动对象。 类图 时序图 Main.java123456789101112import activeobject.ActiveObject;import activeobject.ActiveObjectFactory;public class Main &#123; public static void main(String[] args) &#123; ActiveObject activeObject = ActiveObjectFactory.createActiveObject(); new MakerClientThread("Alice", activeObject).start(); new MakerClientThread("Bobby", activeObject).start(); new DisplayClientThread("Chris", activeObject).start(); &#125;&#125; MakerClientThread.java1234567891011121314151617181920212223242526import activeobject.ActiveObject;import activeobject.Result;public class MakerClientThread extends Thread &#123; private final ActiveObject activeObject; private final char fillchar; public MakerClientThread(String name, ActiveObject activeObject) &#123; super(name); this.activeObject = activeObject; this.fillchar = name.charAt(0); &#125; @Override public void run() &#123; try &#123; for (int i = 0; true; i++) &#123; Result&lt;String&gt; result = activeObject.makeString(i, fillchar); Thread.sleep(10); String value = result.getResultValue(); System.out.println(Thread.currentThread().getName() + ": value = " + value); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125; DisplayClientThread.java12345678910111213141516171819202122import activeobject.ActiveObject;public class DisplayClientThread extends Thread &#123; private final ActiveObject activeObject; public DisplayClientThread(String name, ActiveObject activeObject) &#123; super(name); this.activeObject = activeObject; &#125; @Override public void run() &#123; try &#123; for (int i = 0; true; i++) &#123; String string = Thread.currentThread().getName() + " " + i; activeObject.displayString(string); Thread.sleep(200); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125; ActiveObject.java123456package activeobject;public interface ActiveObject &#123; public abstract Result&lt;String&gt; makeString(int count, char fillchar); public abstract void displayString(String string);&#125; ActiveObjectFactory.java123456789101112package activeobject;public class ActiveObjectFactory &#123; public static ActiveObject createActiveObject() &#123; Servant servant = new Servant(); ActivationQueue queue = new ActivationQueue(); SchedulerThread scheduler = new SchedulerThread(queue); Proxy proxy = new Proxy(scheduler, servant); scheduler.start(); return proxy; &#125;&#125; Proxy.java1234567891011121314151617181920212223package activeobject;class Proxy implements ActiveObject &#123; private final SchedulerThread scheduler; private final Servant servant; public Proxy(SchedulerThread scheduler, Servant servant) &#123; this.scheduler = scheduler; this.servant = servant; &#125; @Override public Result&lt;String&gt; makeString(int count, char fillchar) &#123; FutureResult&lt;String&gt; future = new FutureResult&lt;String&gt;(); scheduler.invoke(new MakeStringRequest(servant, future, count, fillchar)); return future; &#125; @Override public void displayString(String string) &#123; scheduler.invoke(new DisplayStringRequest(servant, string)); &#125;&#125; SchedulerThread.java123456789101112131415161718192021package activeobject;class SchedulerThread extends Thread &#123; private final ActivationQueue queue; public SchedulerThread(ActivationQueue queue) &#123; this.queue = queue; &#125; public void invoke(MethodRequest request) &#123; queue.putRequest(request); &#125; @Override public void run() &#123; while (true) &#123; MethodRequest request = queue.takeRequest(); request.execute(); &#125; &#125;&#125; ActivationQueue.java123456789101112131415161718192021222324252627282930313233343536373839404142434445package activeobject;class ActivationQueue &#123; private static final int MAX_METHOD_REQUEST = 100; private final MethodRequest[] requestQueue; private int head; private int tail; private int count; public ActivationQueue() &#123; this.requestQueue = new MethodRequest[MAX_METHOD_REQUEST]; this.head = 0; this.tail = 0; this.count = 0; &#125; public synchronized void putRequest(MethodRequest request)&#123; while (count &gt;= requestQueue.length) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; requestQueue[tail] = request; tail = (tail + 1) % requestQueue.length; count++; notifyAll(); &#125; public synchronized MethodRequest takeRequest() &#123; while (count &lt;= 0) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; MethodRequest request = requestQueue[head]; head = (head + 1) % requestQueue.length; count--; notifyAll(); return request; &#125;&#125; MethodRequest.java12345678910111213package activeobject;abstract class MethodRequest&lt;T&gt; &#123; protected final Servant servant; protected final FutureResult&lt;T&gt; future; protected MethodRequest(Servant servant, FutureResult&lt;T&gt; future) &#123; this.servant = servant; this.future = future; &#125; public abstract void execute();&#125; MakeStringRequest.java123456789101112131415161718package activeobject;class MakeStringRequest extends MethodRequest&lt;String&gt; &#123; private final int count; private final char fillchar; public MakeStringRequest(Servant servant, FutureResult&lt;String&gt; future, int count, char fillchar) &#123; super(servant, future); this.count = count; this.fillchar = fillchar; &#125; @Override public void execute() &#123; Result&lt;String&gt; result = servant.makeString(count, fillchar); future.setResult(result); &#125;&#125; DisplayStringRequest.java123456789101112131415package activeobject;class DisplayStringRequest extends MethodRequest&lt;Object&gt; &#123; private final String string; public DisplayStringRequest(Servant servant, String string) &#123; super(servant, null); this.string = string; &#125; @Override public void execute() &#123; servant.displayString(string); &#125;&#125; Result.java12345package activeobject;public abstract class Result&lt;T&gt; &#123; public abstract T getResultValue();&#125; FutureResult.java123456789101112131415161718192021222324package activeobject;class FutureResult&lt;T&gt; extends Result&lt;T&gt; &#123; private Result&lt;T&gt; result; private boolean ready = false; public synchronized void setResult(Result&lt;T&gt; result) &#123; this.result = result; this.ready = true; notifyAll(); &#125; @Override public synchronized T getResultValue() &#123; while (!ready) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; return result.getResultValue(); &#125;&#125; RealResult.java1234567891011121314package activeobject;class RealResult&lt;T&gt; extends Result&lt;T&gt; &#123; private final T resultValue; public RealResult(T resultValue) &#123; this.resultValue = resultValue; &#125; @Override public T getResultValue() &#123; return resultValue; &#125;&#125; Servant.java1234567891011121314151617181920212223242526272829package activeobject;class Servant implements ActiveObject &#123; @Override public Result&lt;String&gt; makeString(int count, char fillchar) &#123; char[] buffer = new char[count]; for (int i = 0; i &lt; count; i++) &#123; buffer[i] = fillchar; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; &#125; return new RealResult&lt;String&gt;(new String(buffer)); &#125; @Override public void displayString(String string) &#123; try &#123; System.out.println("displayString: " + string); Thread.sleep(10); &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125; 运行结果1234567891011121314151617181920212223242526272829303132333435displayString: Chris 0Alice: value = Bobby: value = Alice: value = ABobby: value = BdisplayString: Chris 1Alice: value = AAdisplayString: Chris 2Bobby: value = BBdisplayString: Chris 3Alice: value = AAAdisplayString: Chris 4Bobby: value = BBBdisplayString: Chris 5Alice: value = AAAAdisplayString: Chris 6displayString: Chris 7Bobby: value = BBBBdisplayString: Chris 8displayString: Chris 9Alice: value = AAAAAdisplayString: Chris 10displayString: Chris 11Bobby: value = BBBBBdisplayString: Chris 12displayString: Chris 13displayString: Chris 14Alice: value = AAAAAAdisplayString: Chris 15displayString: Chris 16Bobby: value = BBBBBBdisplayString: Chris 17displayString: Chris 18displayString: Chris 19displayString: Chris 20 登场角色Client（委托者）Client角色调用ActiveObject角色的方法来委托处理，它能够调用的只有ActiveObject角色提供的方法。调用这些方法后，（如果ActivationQueue角色没有满）程序控制权会立即返回。虽然Client角色只知道ActiveObject角色，但它实际调用的是Proxy角色。Client角色在获取处理结果时，会调用VirtualResult角色的getResultValue方法。这里使用了Future模式。在示例程序中，由MakerClientThread类和DisplayClientThread类扮演此角色。 ActiveObject（主动对象）ActiveObject角色定义了主动对象向Client角色提供的接口。在示例程序中，由ActiveObject接口扮演此角色。 Proxy（代理人）Proxy角色负责将方法调用转换为MethodRequest角色的对象。转换后的MethodRequest角色会被传递给Scheduler角色。Proxy角色实现了ActiveObject角色提供的接口。调用Proxy角色的方法的是Client角色。将方法调用转换为MethodRequest角色，并传递给Scheduler角色的操作都是使用Client角色的线程进行的。在示例程序中，由Proxy类扮演此角色。 SchedulerScheduler角色负责将Proxy角色传递来的MethodRequest传递给ActivationQueue角色，以及从ActivationQueue角色取出并执行MethodRequest角色这两项工作。Client角色的线程负责将MethodRequest角色传递给ActivationQueue角色。而从ActivationQueue角色取出并执行MethodRequest角色这项工作则是使用Scheduler角色自己的线程进行的。在ActiveObject模式中，只有使用Client角色和Scheduler角色时才会启动新线程。Scheduler角色会把MethodRequest角色放入ActivationQueue角色或者从ActivationQueue角色取出MethodRequest角色。因此，Scheduler角色可以判断下次要执行哪个请求。在示例程序中，由SchedulerThread类扮演此角色。SchedulerThread并没有进行特殊的调度，而只是执行FIFO（First In First Out，先进先出）处理。 MethodRequestMethodRequest角色是与来自Client角色的请求对应的角色。MethodRequest定义了负责执行处理的Servant角色，以及负责设置返回值的Future角色和负责执行请求的方法（execute）。MethodRequest角色为主动对象的接口赋予了对象的表象形式。在示例程序中，由MethodRequest类扮演此角色。 ConcreteMethodRequestConcreteMethodRequest角色是使MethodRequest角色与具体的方法相对应的角色。对于ActiveObject角色中定义的每个方法，会有各个类与之对应，比如MethodAlphaRequest、MethodBetaRequest…。各个ConcreteMethodRequest角色中的字段分别与方法的参数相对应。在示例程序中，由MakeStringRequest类和DisplayStringRequest类扮演此角色。其中，MakeStringRequest类对应makeString方法（生成字符串），DisplayStringRequest类对应displayString方法（显示字符串）。 Servant（仆人）Servant角色负责实际地处理请求。调用Servant角色的是Scheduler角色的线程。Scheduler角色会从ActivationQueue角色取出一个MethodRequest角色（实际上是ConcreteMethodRequest角色）并执行它。此时，Scheduler角色调用的就是Servant角色的方法。Servant角色实现了ActiveObject角色定义的接口。Proxy角色会将请求转换为MethodRequest角色，而Servant角色则会实际地执行该请求。Scheduler角色介于Proxy角色和Servant角色之间，负责管理按照什么顺序执行请求。在示例程序中，由Servant类扮演此角色。 ActivationQueue（主动队列）ActivationQueue角色是保存MethodRequest角色的类。调用putRequest方法的是Client角色的线程，而调用takeRequest方法的是Scheduler角色的线程。这里使用了Producer-Consumer模式。在示例程序中，由ActivationQueue类扮演此角色。 VirtualResult（虚拟结果）VirtualResult角色与Future角色、RealResult角色共同构成了Future模式。Client角色在获取处理结果时会调用VirtualResult角色（实际上是Future角色）的getResultValue方法。在示例程序中，由Result类扮演此角色。 Future（期货）Future角色是Client角色在获取处理结果时实际调用的角色。当处理结果还没有出来的时候，它会使用Guarded Suspension模式让Client角色的线程等待结果出来。在示例程序中，由FutureResult类扮演此角色。 RealResult（真实结果）RealResult角色是表示处理结果的角色。Servant角色会创建一个RealResult角色作为处理结果，然后调用Future角色的setRealResult方法将其设置到Future角色中。在示例程序中，由RealResult类扮演此角色。 类图 时序图 Timethreads图]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解Java多线程设计模式】Thread-Specific Storage模式]]></title>
    <url>%2F2019%2F02%2F13%2F%E3%80%90%E5%9B%BE%E8%A7%A3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Thread-Specific-Storage%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[即使只有一个入口，也会在内部为每个线程分配特有的存储空间。在Java标准类库中，java.lang.ThreadLocal类实现了该模式。 关于java.lang.ThreadLocal类ThreadLocal的实例会管理多个对象由于一个ThreadLocal的实例可以管理多个对象，所以ThreadLocal定义了可以“存储”（set）和“获取”（get）对象的方法。 set方法 ThreadLocal类的set方法用于将通过参数接收的实例与调用该方法的线程（当前线程）对应并存储起来。这里存储的对象可以通过get方法获取。set方法中没有表示线程的参数。set方法会先查询当前线程（即表达式Thread.currentThread()的值），然后以它作为键来存储实例。 get方法 ThreadLocal类的get方法用于获取与调用get方法的线程（当前线程）对应的实例。该线程之前通过set方法存储的实例就是get方法的返回值。如果之前一次都还没有调用过set方法，则get方法的返回值为null。 与set方法一样，get方法中也没有表示线程的参数。这是因为，get方法也会去查询当前线程。即get方法会以当前线程自身作为健去获取对象。 java.lang.ThreadLocal与泛型java.lang.ThreadLocal是一个泛型类，可以通过参数的类型来指定要存储的对象的类型。ThreadLocal类的声明大致如下： 123456789public class ThreadLocal&lt;T&gt; &#123; public void set(T value) &#123; ... &#125; public T get() &#123; ... &#125;&#125; 即，通过ThreadLocal的T指定的类型就是set方法的参数的类型以及get方法的返回值的类型。 示例1：不使用Thread-Specific Storage模式使用Log类的静态方法将日志记录在文件中。 类图 Log.java123456789101112131415161718192021222324import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter;public class Log &#123; private static PrintWriter writer = null; static &#123; try &#123; writer = new PrintWriter(new FileWriter("log.txt")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void println(String s) &#123; writer.println(s); &#125; public static void close() &#123; writer.println("==== End of log ===="); writer.close(); &#125;&#125; Main.java123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; System.out.println("BEGIN"); for (int i = 0; i &lt; 10; i++) &#123; Log.println("main: i = " + i); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; &#125; Log.close(); System.out.println("END"); &#125;&#125; 运行结果123456789101112131415BEGINEND# log.txtmain: i = 0main: i = 1main: i = 2main: i = 3main: i = 4main: i = 5main: i = 6main: i = 7main: i = 8main: i = 9==== End of log ==== Timethreads图 示例2：使用了Thread-Specific Storage模式制作一种程序结构，在其中编写一个继承了Thread的类，但是并不在它的字段中保存PrintWriter的实例，而只是机械地在方法中调用Log.println。仅仅这样就可以实现自动地将字符串分配到各个线程的日志文件中。 类图 TSLog.java123456789101112131415161718192021222324import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter;public class TSLog &#123; private PrintWriter writer = null; public TSLog(String filename) &#123; try &#123; writer = new PrintWriter(new FileWriter(filename)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public void println(String s) &#123; writer.println(s); &#125; public void close() &#123; writer.println("==== End of log ===="); writer.close(); &#125;&#125; Log.java12345678910111213141516171819202122public class Log &#123; private static final ThreadLocal&lt;TSLog&gt; tsLogCollection = new ThreadLocal&lt;TSLog&gt;(); public static void println(String s) &#123; getTSLog().println(s); &#125; public static void close() &#123; getTSLog().close(); &#125; private static TSLog getTSLog() &#123; TSLog tsLog = tsLogCollection.get(); if (tsLog == null) &#123; tsLog = new TSLog(Thread.currentThread().getName() + "-log.txt"); tsLogCollection.set(tsLog); &#125; return tsLog; &#125;&#125; ClientThread.java12345678910111213141516171819202122public class ClientThread extends Thread &#123; public ClientThread(String name) &#123; super(name); &#125; @Override public void run() &#123; System.out.println(getName() + " BEGIN"); for (int i = 0; i &lt; 10; i++) &#123; Log.println("i = " + i); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; &#125; Log.close(); System.out.println(getName() + " END"); &#125;&#125; Main.java12345678public class Main &#123; public static void main(String[] args) &#123; new ClientThread("Alice").start(); new ClientThread("Bobby").start(); new ClientThread("Chris").start(); &#125;&#125; 运行结果12345678910111213141516171819Bobby BEGINChris BEGINAlice BEGINBobby ENDChris ENDAlice END# Alice-log.txt、Bobby-log.txt、Chris-log.txti = 0i = 1i = 2i = 3i = 4i = 5i = 6i = 7i = 8i = 9==== End of log ==== Timethreads图 登场角色Client（委托者）Client角色将处理委托给TSObjectProxy角色。一个TSObjectProxy角色会被多个Client角色使用。在示例程序中，由ClientThread类扮演此角色。 TSObjectProxy（线程特有的对象的代理人）TSObjectProxy角色会执行多个Client角色委托给它的处理。首先，TSObjectProxy角色使用TSObjectCollection角色获取与Client角色对应的TSObject角色。接着，它将处理委托给TSObject角色。在示例程序中，由Log类扮演此角色。 TSObjectCollection（线程特有的对象的集合）TSObjectCollection角色有一张Client角色与TSObject角色之间的对应表。当getTSObject方法被调用后，它会去查看对应表，返回与Client角色相对应的TSObject角色。另外，当setTSObject方法被调用后，它会将Client角色与TSObject角色之间的键值对应关系设置到对应表中。在示例程序中，由java.lang.ThreadLocal类扮演此角色。 TSObject（线程特有的对象）TSObject角色中保存着线程特有的信息。TSObject角色由TSObjectCollection角色管理。TSObject角色的方法只会被单线程调用。在示例程序中，由TSLog类扮演此角色。 类图 时序图新创建TSObject角色 多个Client角色访问各自的TSObject角色]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Double-Checked Locking模式的危险性]]></title>
    <url>%2F2019%2F02%2F13%2FDouble-Checked-Locking%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8D%B1%E9%99%A9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Double-Checked Locking模式原本是用于改善Single Threaded Execution模式的性能的方法之一。不过在Java中使用Double-Checked Locking模式是很危险的。 Single Threaded Execution模式getInstance是synchronized的，因此性能并不好。 1234567891011121314151617181920import java.util.Date;public class MySystem &#123; private static MySystem instance = null; private Date date = new Date(); private MySystem()&#123;&#125; public synchronized MySystem getInstance() &#123; if (instance == null) &#123; instance = new MySystem(); &#125; return instance; &#125; public Date getDate() &#123; return date; &#125;&#125; Double-Checked Locking模式getInstance方法不再是synchronized方法。取而代之的是if语句中编写的一段synchronized代码块。 123456789101112131415161718192021222324import java.util.Date;public class MySystem &#123; private static MySystem instance = null; private Date date = new Date(); private MySystem()&#123;&#125; public MySystem getInstance() &#123; if (instance == null) &#123; //(a) synchronized (MySystem.class) &#123; //(b) if (instance == null) &#123; //(c) instance = new MySystem(); //(d) &#125; &#125; //(e) &#125; return instance; //(f) &#125; public Date getDate() &#123; return date; &#125;&#125; 不能正确地运行的一个原因是，当调用getInstance的返回值的getDate方法时，date字段可能还没有被初始化。 这里创建了一个MySystem的实例。在创建MySystem的实例时，new Date()的值会被赋给实例字段date。如果线程A从synchronized代码块退出后，线程B才进入synchronized代码块，那么线程B也可以看见date的值。但是在(A-4)这个阶段，无法确保线程B可以看见A写入的date字段的值。 接下来，再假设线程B在(B-1)这个阶段的判断结果是instance != null。这样的话，线程B将不进入synchronized代码块，而是立即将instance的值作为返回值return出来。这之后，线程B会在(B-3)这个阶段调用getInstance的返回值的getDate方法。getDate方法的返回值就是date字段的值，因此线程B会引用date字段的值。但是，线程A还没有从synchronized代码块中退出，线程B也没有进入synchronized代码块。因此，无法确保date字段的值对线程B可见。 为什么能够看到instance字段由于重排序的存在，的确可能会在看到date字段的值之前先看到instance字段的值。 使用volatile会怎样将instance字段设置为volatile字段后，Double-Checked Locking模式就可以正常工作了。但是，volatile字段的读写性能开销与synchronized几乎相同。本来Double-Checked Locking模式就是用于避免synchronized引起的性能下降的，如果使用了volatile就无法改善性能了。 Initialization On Demand Holder模式Initialization On Demand Holder模式既不会像Single Threaded Execution模式那样降低性能，也不会带来像Double-Checked Locking模式那样的危险性。 这段程序会使用Holder的“类的初始化”来创建唯一的实例，并确保线程安全。这是因为在Java规范中，类的初始化是线程安全的。 在代码中，并没有使用synchronized和volatile来进行同步，因此性能不会下降。 而且，还使用了嵌套类的延迟初始化。Holder类的初始化在线程刚刚要使用该类时才会开始进行。也就是说，在调用MySystem.getInstance方法前，Holder类不会被初始化，甚至连MySystem的实例都不会创建。因此，使用Initialization On Demand Holder模式可以避免内存浪费。 12345678910111213141516171819import java.util.Date;public class MySystem &#123; private static class Holder &#123; public static MySystem instance = new MySystem(); &#125; private Date date = new Date(); private MySystem()&#123;&#125; public MySystem getInstance() &#123; return Holder.instance; &#125; public Date getDate() &#123; return date; &#125;&#125;]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final]]></title>
    <url>%2F2019%2F02%2F12%2Ffinal%2F</url>
    <content type="text"><![CDATA[final字段与构建线程安全的实例使用final关键字声明的字段只能被初始化一次。final字段在创建不允许被改变的对象时起到了非常重要的作用。 final字段的初始化只能在“字段声明时”或是“构造函数中”进行。那么，当final字段的初始化结束后，无论在任何时候，它的值对其他线程都是可见的。Java内存模型可以确保被初始化后的final字段在构造函数的处理结束后是可见的。也就是说，可以确保以下事情： 如果构造函数的处理结束了 final字段初始化后的值对所有线程都是可见的在final字段可以追溯到的所有范围内都可以看到正确的值 在构造函数的处理结束前 可能会看到final字段的值是默认的初始值（0、false或是null） java.util.concurrent.ConcurrentHashMap类使用final和volatile特性实现了无阻塞的Map。 将常量字段设置为finalJava内存模型可以确保final字段在构造函数执行结束后可以正确地被看到。这样就不再需要通过synchronized和volatile进行同步了。因此，将不希望被改变的字段设为final。 不要从构造函数中泄露this在构造函数执行结束前，可能会看到final字段的值发生变化。也就是说，存在首先看到“默认初始值”，然后看到“显示地初始化的值”的可能性。 1234567891011121314151617181920212223242526272829303132333435// 可能会显示出0public class Main &#123; public static void main(String[] args) &#123; new Thread() &#123; @Override public void run() &#123; new Something(); &#125; &#125;.start(); new Thread() &#123; @Override public void run() &#123; Something.print(); &#125; &#125;.start(); &#125;&#125;class Something &#123; private final int x; private static Something last = null; public Something() &#123; x = 123; last = this; &#125; public static void print() &#123; if (last != null) &#123; System.out.println(last.x); &#125; &#125;&#125; 根据Java内存模型，这时看到的last.x的值可能会是0。因为线程B在print方法中看到的last的值，是在构造函数处理结束前获取的this。 Java内存模型可以确保构造函数处理结束时final字段的值被正确地初始化，对其他线程是可见的。总而言之，如果使用通过new Something()获取的实例，final字段是不会发生可见性问题的。但是，如果在构造函数的处理过程中this还没有创建完毕，就无法确保final字段的正确的值对其他线程是可见的。 代码修改后，就不可能会显示出0了。这里进行的具体修改如下： 将构造函数修改为private，让外部无法调用 编写一个名为create的静态方法，在其中使用new关键字创建实例 将静态字段last赋值为上面使用new关键字创建的实例 这样修改后，只有当构造函数处理结束后静态字段last才会被赋值，因此可以确保final字段被正确地初始化。 123456789101112131415161718192021222324252627282930313233343536373839// 不会显示出0public class Main &#123; public static void main(String[] args) &#123; new Thread() &#123; @Override public void run() &#123; Something.create(); &#125; &#125;.start(); new Thread() &#123; @Override public void run() &#123; Something.print(); &#125; &#125;.start(); &#125;&#125;class Something &#123; private final int x; private static Something last = null; private Something() &#123; x = 123; &#125; public static Something create() &#123; last = new Something(); return last; &#125; public static void print() &#123; if (last != null) &#123; System.out.println(last.x); &#125; &#125;&#125; 在构造函数中将静态字段赋值为this是非常危险的。因为其他线程可能会通过这个静态字段访问正在创建中的实例。同样地，向静态字段中保存的数组和集合中保存this也是非常危险的。 另外，在构造函数中进行方法调用时，以this为参数的方法调用也是非常危险的。因为该方法可能会将this放在其他线程可以访问到的地方。]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile]]></title>
    <url>%2F2019%2F02%2F12%2Fvolatile%2F</url>
    <content type="text"><![CDATA[volatile具有“同步处理”和“对long和double的原子操作”这两种功能。 同步处理某个线程对volatile字段进行的写操作的结果对其他线程立即可见。换言之，对volatile字段的写入处理并不会被缓存起来。 123456789101112131415161718192021222324// 不可能出现无限while循环public class Main &#123; public static void main(String[] args) &#123; Runner runner = new Runner(); runner.start(); runner.shutdown(); &#125;&#125;class Runner extends Thread &#123; private volatile boolean quit = false; public void run() &#123; while (!quit) &#123; &#125; System.out.println("Done"); &#125; public void shutdown() &#123; quit = true; &#125;&#125; volatile字段并非只是不缓存读取和写入。如果线程A向volatile字段写入的值对线程B可见，那么之前向其他字段写入的所有值都对线程B可见。此外，在向volatile字段读取和写入前后不会发生重排序。 123456789101112131415161718192021222324252627282930313233343536public class Main &#123; public static void main(String[] args) &#123; final Something obj = new Something(); new Thread() &#123; @Override public void run() &#123; obj.write(); &#125; &#125;.start(); new Thread() &#123; @Override public void run() &#123; obj.read(); &#125; &#125;.start(); &#125;&#125;class Something &#123; private int x = 0; private volatile boolean valid = false; public void write() &#123; x = 123; valid = true; &#125; public void read() &#123; if (valid) &#123; System.out.println(x); &#125; &#125;&#125; 从volatile的使用目的来看，volatile阻止重排序是理所当然的。如代码所示，volatile字段多被用作判断实例是否变为了特定状态的标志。因此，当要确认volatile字段的值是否发生了变化时，必须先确保非volatile的其他字段的值已经被更新了。 在进行如下处理时，线程A向x以及valid写入的值对线程B是可见的。 线程A向字段x写值（normal write） 线程A向volatile字段valid写值（volatile write） 线程B读取volatile字段valid的值（volatile read） 线程B读取字段x的值（normal read） volatile不会进行线程的互斥处理关于重排序和可见性这两点，volatile的作用与synchronized的作用非常相似。但是，volatile不进行线程的互斥处理。也就是说，访问volatile字段的线程不会进入等待队列。 访问volatile字段会产生性能开销“向volatile字段写入的值如果对线程B可见，那么之前写入的所有值就都是可见的”是新增加的内容之一。由于增加了这项内容，向volatile字段读取和写入数据的性能开销就增大了很多。实际上，可以认为访问volatile字段与synchronized的处理耗费的时间几乎相同。 对long和double的原子操作Java规范无法确保对long和double的赋值操作的原子性。但是，即使是long和double的字段，只要它是volatile字段，就可以确保赋值操作的原子性。 java.util.concurrent.atomic包在java.util.concurrent.atomic包中有AtomicInteger和AtomicLong等用于进行原子操作的类。这些类可以确保值的比较和加减等操作的原子性。可以认为java.util.concurrent.atomic包是volatile字段的一种通用化形式。]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized]]></title>
    <url>%2F2019%2F02%2F12%2Fsynchronized%2F</url>
    <content type="text"><![CDATA[synchronized具有“线程的互斥处理”和“同步处理”两种功能。 线程的互斥处理如果程序中有synchronized关键字，线程就会进行lock/unlock操作。线程会在synchronized开始时获取锁（lock），在synchronized终止时释放锁（unlock）。 进行lock/unlock的部分并不仅仅是程序中写有synchronized的部分。当线程在wait方法内部等待的时候也会释放锁。此外，当线程从wait方法中出来的时候还必须先重新获取锁后才能继续运行。 只有一个线程能够获取某个实例的锁。因此，当线程A正准备获取锁时，如果其他线程已经获取了锁，那么线程A就会进入等待队列（或入口队列）。这样就实现了线程的互斥（mutal exclusion）。 synchronized的互斥处理如下图所示。这幅图展示了当线程A执行了unlock操作但是还没有从中出来时，线程B就无法执行lock操作的情形。图中的unlock M和lock M中都写了一个M，这表示unlock操作和lock操作是对同一个实例的监视器进行的操作。 同步处理synchronized（lock/unlock操作）并不仅仅进行线程的互斥处理。Java内存模型确保了某个线程在进行unlock M操作前进行的所有写入操作对进行lock M操作的线程都是可见的。 12345678910111213141516171819202122232425262728293031323334353637// 不可能显示出x&lt;ypublic class Main &#123; public static void main(String[] args) &#123; final Something obj = new Something(); new Thread() &#123; @Override public void run() &#123; obj.write(); &#125; &#125;.start(); new Thread() &#123; @Override public void run() &#123; obj.read(); &#125; &#125;.start(); &#125;&#125;class Something &#123; private int x = 0; private int y = 0; public synchronized void write() &#123; x = 100; y = 50; &#125; public synchronized void read() &#123; if (x &lt; y) &#123; System.out.println("x &lt; y"); &#125; &#125;&#125; 在进行如下处理时，线程A的写操作对线程B是可见的： 线程A对字段x和y写值（normal write操作） 线程A进行unlock操作 线程B对同一个监视器M进行lock操作 线程B读取字段x和y的值（normal read） 大体来说就是， 进行unlock操作后，写入缓存中的内容会被强制地写入共享内存中 进行lock操作后，缓存中的内容会先失效，然后共享内存中的最新内容会被强制重新读取到缓存中 代码不可能显示出x&lt;y的原因有以下两个： (1) 互斥处理可以防止read方法中断write方法的处理。虽然在write方法内部会发生重排序，但是该重排序不会对read方法产生任何影响。(2) 同步处理可以确保write方法向字段x、y写入的值对运行read方法的线程B是可见的。]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可见性]]></title>
    <url>%2F2019%2F02%2F12%2F%E5%8F%AF%E8%A7%81%E6%80%A7%2F</url>
    <content type="text"><![CDATA[假设线程A将某个值写入到了字段x中，而线程B读取到了该值。称其为“线程A向x的写值对线程B是可见的”。“是否是可见的”这个性质就称为可见性。在单线程程序中，无需在意可见性。这是因为，线程总是可以看见自己写入到字段中的值。但是，在多线程程序中必须注意可见性。这是因为，如果没有使用synchronized或volatile正确地进行同步，线程A写入到字段中的值可能并不会立即对线程B可见。 示例Java内存模型可能会导致Runner线程永远在while循环中不停地循环。也就是说，代码中的程序可能会失去生存性。 1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args) &#123; Runner runner = new Runner(); runner.start(); runner.shutdown(); &#125;&#125;class Runner extends Thread &#123; private boolean quit = false; public void run() &#123; while (!quit) &#123; &#125; System.out.println("Done"); &#125; public void shutdown() &#123; quit = true; &#125;&#125; 原因是，向字段quit写值的线程（主线程）与读取字段quit的线程（Runner）是不同的线程。主线程向quit写入的true这个值可能对Runner线程永远不可见。如果以“缓存”的思路来理解不可见的原因可能会有助于理解。主线程向quit写入的这个true值可能只是被保存在主线程的缓存中。而Runner线程从quit读取到的值，仍然是在Runner线程的缓存中保存着的值false，并没有任何变化。 代码是未正确同步的程序。不过如果将quit声明为volatile字段，就可以实现正确同步的程序。 共享内存与操作在Java内存模型中，线程A写入的值并不一定会立即对线程B可见。下图展示了线程A和线程B通过字段进行数据交互的情形。 共享内存（shared memory）是所有线程共享的存储空间，也被称为堆内存（heap memory）。因为实例会被全部保存在共享内存中，所以实例中的字段也存在于共享内存中。此外，数组的元素也被保存在共享内存中。也就是说，可以使用new在共享内存中分配存储空间。 局部变量不会被保存在共享内存中。通常，除局部变量外，方法的形参、catch语句块中编写的异常处理器的参数等也不会被保存在共享内存中，而是被保存在各个线程持有的栈中。正是由于它们没有被保存在共享内存中，所以其他线程不会访问它们。 在Java内存模型中，只有可以被多个线程访问的共享内存才会发生问题。 上图一共展示了以下6种操作： (1) normal read操作(2) normal write操作(3) volatile read操作(4) volatile write操作(5) lock操作(6) unlock操作 这里，(3)～(6)的操作是进行同步的同步操作。进行同步的操作具有防止重排序，控制可见性的效果。 normal read/normal write操作表示的是对普通字段（volatile以外的字段）的读写。这些操作是通过缓存来执行的。因此，通过normal read读取到的值并不一定是最新的值，通过normal write写入的值也不一定会立即对其他线程可见。 volatile read/volatile write操作表示的是对volatile字段的读写。由于这些操作并不是涌过缓存来执行的，所以通过volatile read读取到的值一定是最新的值，通过volatile write写入的值也会立即对其他线程可见。 lock/unlock操作是当程序中使用了synchronized关键字时进行互斥处理的操作，lock操作可以获取实例的锁，unlock操作可以释放实例的锁。 之所以在normal read/normal write操作中使用缓存，是为了提高性能。]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重排序]]></title>
    <url>%2F2019%2F02%2F12%2F%E9%87%8D%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[所谓重排序，是指编译器和Java虚拟机通过改变程序的处理顺序来优化程序。实际上，在运行单线程程序时无法判断是否进行了重排序。这是因为，虽然处理顺序改变了，但是规范上有很多限制可以避免程序出现运行错误。但是，在多线程程序中，有时就会发生明显是由重排序导致的运行错误。 示例在Java内存模型中，是有可能显示出x&lt;y的。 123456789101112131415161718192021222324252627282930313233343536public class Main &#123; public static void main(String[] args) &#123; final Something obj = new Something(); new Thread() &#123; @Override public void run() &#123; obj.write(); &#125; &#125;.start(); new Thread() &#123; @Override public void run() &#123; obj.read(); &#125; &#125;.start(); &#125;&#125;class Something &#123; private int x = 0; private int y = 0; public void write() &#123; x = 100; y = 50; &#125; public void read() &#123; if (x &lt; y) &#123; System.out.println("x &lt; y"); &#125; &#125;&#125; 原因就在于重排序。在write方法中，由于对x的赋值和对y的赋值之间不存在任何依赖关系，编译器可能会改变赋值顺序。而且，在线程A已经为y赋值，但是尚未为x赋值之前，线程B也可能会去查询x和y的值并执行if语句进行判断。这时，x&lt;y的关系成立。 虽然代码是未正确同步的程序，但是如果将write和read都声明为synchronized方法，就可以实现正确同步的程序。]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.util.concurrent包与线程同步]]></title>
    <url>%2F2019%2F02%2F03%2Fjava-util-concurrent%E5%8C%85%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[java.util.concurrent.CountDownLatch类当想让某个线程等待指定的线程终止时，可以使用java.lang.Thread类的join方法。但是，由于join方法可以等待的只是“线程终止”这个一次性的操作，所以无法使用它实现“等待指定次数的某种操作发生”。使用java.util.concurrent.CountDownLatch类可以实现“等待指定次数的CountDown方法被调用”这一功能。 Main.java1234567891011121314151617181920212223242526import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Main &#123; private static final int TASKS = 10; public static void main(String[] args) &#123; System.out.println("BEGIN"); ExecutorService service = Executors.newFixedThreadPool(5); CountDownLatch doneLatch = new CountDownLatch(TASKS); try &#123; for (int t = 0; t &lt; TASKS; t++) &#123; service.execute(new MyTask(doneLatch, t)); &#125; System.out.println("AWAIT"); doneLatch.await(); &#125; catch (InterruptedException e) &#123; &#125; finally &#123; service.shutdown(); System.out.println("END"); &#125; &#125;&#125; MyTask.java12345678910111213141516171819202122232425262728293031import java.util.Random;import java.util.concurrent.CountDownLatch;public class MyTask implements Runnable &#123; private final CountDownLatch doneLatch; private final int context; private static final Random random = new Random(314159); public MyTask(CountDownLatch doneLatch, int context) &#123; this.doneLatch = doneLatch; this.context = context; &#125; @Override public void run() &#123; doTask(); doneLatch.countDown(); &#125; protected void doTask() &#123; String name = Thread.currentThread().getName(); System.out.println(name + ":MyTask:BEGIN:context = " + context); try &#123; Thread.sleep(random.nextInt(3000)); &#125; catch (InterruptedException e) &#123; &#125; finally &#123; System.out.println(name + ":MyTask:END:context = " + context); &#125; &#125;&#125; 运行结果1234567891011121314151617181920212223BEGINpool-1-thread-2:MyTask:BEGIN:context = 1pool-1-thread-1:MyTask:BEGIN:context = 0pool-1-thread-3:MyTask:BEGIN:context = 2pool-1-thread-4:MyTask:BEGIN:context = 3AWAITpool-1-thread-5:MyTask:BEGIN:context = 4pool-1-thread-4:MyTask:END:context = 3pool-1-thread-4:MyTask:BEGIN:context = 5pool-1-thread-1:MyTask:END:context = 0pool-1-thread-1:MyTask:BEGIN:context = 6pool-1-thread-1:MyTask:END:context = 6pool-1-thread-1:MyTask:BEGIN:context = 7pool-1-thread-4:MyTask:END:context = 5pool-1-thread-4:MyTask:BEGIN:context = 8pool-1-thread-2:MyTask:END:context = 1pool-1-thread-2:MyTask:BEGIN:context = 9pool-1-thread-1:MyTask:END:context = 7pool-1-thread-5:MyTask:END:context = 4pool-1-thread-3:MyTask:END:context = 2pool-1-thread-4:MyTask:END:context = 8pool-1-thread-2:MyTask:END:context = 9END 时序图 java.util.concurrent.CyclicBarrier类CountDownLatch类只能进行倒数计数。也就是说，一旦计数值变为0后，即使调用await方法，主线程也会立即返回。当想多次重复进行线程同步时，使用java.util.concurrent.CyclicBarrier类会很方便。CyclicBarrier可以周期性地（cyclic）创建出屏障（barrier）。在屏障解除之前，碰到屏障的线程是无法继续前进的。屏障的解除条件是到达屏障处的线程个数达到了构造函数指定的个数。也就是说，当指定个数的线程到达屏障处后，屏障就会被解除，然后这些线程就会一起冲出去。 Main.java123456789101112131415161718192021222324252627282930313233343536import java.util.concurrent.CountDownLatch;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors;public class Main &#123; private static final int THREADS = 3; public static void main(String[] args) &#123; System.out.println("BEGIN"); ExecutorService service = Executors.newFixedThreadPool(THREADS); Runnable barrierAction = new Runnable() &#123; @Override public void run() &#123; System.out.println("Barrier Action!"); &#125; &#125;; CyclicBarrier phaseBarrier = new CyclicBarrier(THREADS, barrierAction); CountDownLatch doneLatch = new CountDownLatch(THREADS); try &#123; for (int t = 0; t &lt; THREADS; t++) &#123; service.execute(new MyTask(phaseBarrier, doneLatch, t)); &#125; System.out.println("AWAIT"); doneLatch.await(); &#125; catch (InterruptedException e) &#123; &#125; finally &#123; service.shutdown(); System.out.println("END"); &#125; &#125;&#125; MyTask.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Random;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CountDownLatch;import java.util.concurrent.CyclicBarrier;public class MyTask implements Runnable &#123; private static final int PHASE = 5; private final CyclicBarrier phaseBarrier; private final CountDownLatch doneLatch; private final int context; private static final Random random = new Random(314159); public MyTask(CyclicBarrier phaseBarrier, CountDownLatch doneLatch, int context) &#123; this.phaseBarrier = phaseBarrier; this.doneLatch = doneLatch; this.context = context; &#125; @Override public void run() &#123; try &#123; for (int phase = 0; phase &lt; PHASE; phase++) &#123; doPhase(phase); phaseBarrier.await(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; finally &#123; doneLatch.countDown(); &#125; &#125; protected void doPhase(int phase) &#123; String name = Thread.currentThread().getName(); System.out.println(name + ":MyTask:BEGIN:context = " + context + ", phase = " + phase); try &#123; Thread.sleep(random.nextInt(3000)); &#125; catch (InterruptedException e) &#123; &#125; finally &#123; System.out.println(name + ":MyTask:END:context = " + context + ", phase = " + phase); &#125; &#125;&#125; 运行结果1234567891011121314151617181920212223242526272829303132333435363738BEGINAWAITpool-1-thread-2:MyTask:BEGIN:context = 1, phase = 0pool-1-thread-1:MyTask:BEGIN:context = 0, phase = 0pool-1-thread-3:MyTask:BEGIN:context = 2, phase = 0pool-1-thread-1:MyTask:END:context = 0, phase = 0pool-1-thread-2:MyTask:END:context = 1, phase = 0pool-1-thread-3:MyTask:END:context = 2, phase = 0Barrier Action!pool-1-thread-3:MyTask:BEGIN:context = 2, phase = 1pool-1-thread-1:MyTask:BEGIN:context = 0, phase = 1pool-1-thread-2:MyTask:BEGIN:context = 1, phase = 1pool-1-thread-3:MyTask:END:context = 2, phase = 1pool-1-thread-2:MyTask:END:context = 1, phase = 1pool-1-thread-1:MyTask:END:context = 0, phase = 1Barrier Action!pool-1-thread-1:MyTask:BEGIN:context = 0, phase = 2pool-1-thread-3:MyTask:BEGIN:context = 2, phase = 2pool-1-thread-2:MyTask:BEGIN:context = 1, phase = 2pool-1-thread-1:MyTask:END:context = 0, phase = 2pool-1-thread-3:MyTask:END:context = 2, phase = 2pool-1-thread-2:MyTask:END:context = 1, phase = 2Barrier Action!pool-1-thread-2:MyTask:BEGIN:context = 1, phase = 3pool-1-thread-1:MyTask:BEGIN:context = 0, phase = 3pool-1-thread-3:MyTask:BEGIN:context = 2, phase = 3pool-1-thread-1:MyTask:END:context = 0, phase = 3pool-1-thread-3:MyTask:END:context = 2, phase = 3pool-1-thread-2:MyTask:END:context = 1, phase = 3Barrier Action!pool-1-thread-2:MyTask:BEGIN:context = 1, phase = 4pool-1-thread-1:MyTask:BEGIN:context = 0, phase = 4pool-1-thread-3:MyTask:BEGIN:context = 2, phase = 4pool-1-thread-3:MyTask:END:context = 2, phase = 4pool-1-thread-1:MyTask:END:context = 0, phase = 4pool-1-thread-2:MyTask:END:context = 1, phase = 4Barrier Action!END Timethreads图]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中断状态与InterruptedException异常的相互转换]]></title>
    <url>%2F2019%2F02%2F03%2F%E4%B8%AD%E6%96%AD%E7%8A%B6%E6%80%81%E4%B8%8EInterruptedException%E5%BC%82%E5%B8%B8%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[当interrupt方法被调用后，线程就可以被中断了。中断线程这个行为会带来一下结果之一。 (1) 线程变为“中断状态”：反映为“状态”(2) 抛出“InterruptedException异常”：反映为“控制” 通常情况下会是结果(1)；当线程正在sleep、wait、join时会是结果(2)（这时线程不会变为中断状态）。但是，上面的(1)和(2)是可以相互转换的。即，可以将(1)变为(2)，也可以将(2)变为(1)。可以根据程序需要——大多是为了防止代码忘记线程已经被中断的实施——进行转换。 中断状态-&gt;InterruptedException异常的转换可以像下面这样编写代码，以实现“如果线程处于中断状态就抛出异常InterruptedException”。其中的interrupted方法是java.lang.Thread类的静态方法。 123if (Thread.interrupted()) &#123; throw new InterruptedException();&#125; 将这段if语句写在长时间处理之前可以提高线程对中断的响应性。因为这样可以防止线程因没注意到自己被中断而进入长时间处理的情况发生， interrupt方法检查的是哪个线程Thread.interrupt方法会去检查Thread.currentThread()的中断状态。也就是说，无论上面的if语句写在哪个类的哪个方法中，它总是会去检查执行if语句的线程的中断状态。 不想清除中断状态时当Thread.interrupt方法被调用后，线程将不再处于中断状态。也就是说，一旦调用一次Thread.interrupt方法，中断状态将被清除。如果想在不清除中断状态的前提下检查当前线程的中断状态，可以使用isInterrupted这个实例方法。 123if (Thread.currentThread().isInterrupted()) &#123; //中断状态下的处理（中断状态不会被清除）&#125; InterruptedException异常-&gt;中断状态的转换要想只在指定的时间内让线程停止运行，可以使用Thread.sleep方法。由于Thread.sleep会抛出InterruptedException异常，因此有时会像下面这样编写代码。 1234try &#123; Thread.sleep(1000);&#125; catch (InterruptedException e) &#123;&#125; 但是，这样编写代码的话，被抛出的InterruptedException异常将会被忽略。如果某个线程正在sleep时被其他线程中断了，则“已经被中断”这个信息将会遗失。如果想要防止“已经被中断”这个信息遗失，线程可以像下面这样再次中断自己。 12345try &#123; Thread.sleep(1000);&#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt();&#125; 这就相当于将当前捕获到的InterruptedException转换为了中断状态。 InterruptedException异常-&gt;InterruptedException异常的转换还有不将捕获到的InterruptedException异常立即抛出，而是稍后再抛出的方法。 1234567891011InterruptedException savedException = null;...try &#123; Thread.sleep(1000)&#125; catch (InterruptedException e) &#123; savedException = e;&#125;...if (savedException != null) &#123; throw savedException;&#125; 这里，捕获到的InterruptedException异常会先保存在名为savedException的变量中，稍后再被throw出去。]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[捕获程序整体的终止时]]></title>
    <url>%2F2019%2F02%2F02%2F%E6%8D%95%E8%8E%B7%E7%A8%8B%E5%BA%8F%E6%95%B4%E4%BD%93%E7%9A%84%E7%BB%88%E6%AD%A2%E6%97%B6%2F</url>
    <content type="text"><![CDATA[未捕获的异常的处理器假设程序抛出异常时，并没有编写捕获该异常的catch语句块。通常情况下，这么做会导致程序在输出线程的调用堆栈信息后终止。如果使用Thread类的setDefaultUncaughtedExceptionHandler静态方法，可以设置未捕获的异常的处理器（Uncaught Exception Handler）。该处理器是Thread.UncaughtExceptionHandler接口类型的对象，实际的处理编写在uncaughtException方法中。设置了未捕获的异常的处理器后，程序将不会输出调用堆栈而是直接终止。 退出钩子退出钩子（Shutdown Hook）是指在Java虚拟机退出时启动的线程。“Java虚拟机退出时”指的是System.exit()被调用或是全部非守护线程终止时。这时可以使用退出钩子来编写程序完全终止时的终止处理。可以使用java.lang.Runtime类的实例方法addShutdownHook来设置退出钩子。 Main.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Main &#123; public static void main(String[] args) &#123; System.out.println("main:BEGIN"); Thread.setDefaultUncaughtExceptionHandler( new Thread.UncaughtExceptionHandler() &#123; @Override public void uncaughtException(Thread thread, Throwable exception) &#123; System.out.println("****"); System.out.println("UncaughtExceptionHandler:BEGIN"); System.out.println("currentThread = " + Thread.currentThread()); System.out.println("thread = " + thread); System.out.println("exception = " + exception); System.out.println("UncaughtExceptionHandler:END"); &#125; &#125;); Runtime.getRuntime().addShutdownHook( new Thread() &#123; @Override public void run() &#123; System.out.println("****"); System.out.println("shutdown hook:BEGIN"); System.out.println("currentThread = " + Thread.currentThread()); System.out.println("shutdown hook:END"); &#125; &#125; ); new Thread("MyThread") &#123; @Override public void run() &#123; System.out.println("MyThread:BEGIN"); System.out.println("MyThread:SLEEP..."); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; &#125; System.out.println("MyThread:DIVIDE"); int x = 1 / 0; System.out.println("MyThread:END"); &#125; &#125;.start(); System.out.println("main:END"); &#125;&#125; 运行结果123456789101112131415main:BEGINmain:ENDMyThread:BEGINMyThread:SLEEP...MyThread:DIVIDE****UncaughtExceptionHandler:BEGINcurrentThread = Thread[MyThread,5,main]thread = Thread[MyThread,5,main]exception = java.lang.ArithmeticException: / by zeroUncaughtExceptionHandler:END****shutdown hook:BEGINcurrentThread = Thread[Thread-0,5,main]shutdown hook:END]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.util.concurrent.ExecutorService接口与Two-Phase Termination模式]]></title>
    <url>%2F2019%2F02%2F02%2Fjava-util-concurrent-ExecutorService%E6%8E%A5%E5%8F%A3%E4%B8%8ETwo-Phase-Termination%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[通常，线程都会在ExecutorService接口背后运行。为了优雅地终止运行中的线程，ExecutorService接口准备了shutdown方法。 ExecutorService接口还提供了用于确认终止处理已执行到哪个阶段的方法。 isShutdown方法是用于确认shutdown方法是否已经被调用的方法。如果shutdown方法已经被调用，那么isShutdown会返回true。但是，即使isShutdown为true，也并不表示线程已经实际停止了。 isTerminated方法是用于确认线程是否已经实际停止了的方法。如果线程已经停止了，isTerminated会返回true。]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解Java多线程设计模式】Two-Phase Termination模式]]></title>
    <url>%2F2019%2F02%2F02%2F%E3%80%90%E5%9B%BE%E8%A7%A3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Two-Phase-Termination%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[先执行完终止处理再终止线程。 该模式的要点如下： 安全地终止线程（安全性） 必定会进行终止处理（生存性） 发出终止请求后尽快进行终止处理（响应性） 示例首先会启动一个线程，该线程每隔约500毫秒进行一次计数。接着，在大约10秒后程序就会终止该线程。 类图 时序图 CountupThread.java1234567891011121314151617181920212223242526272829303132333435public class CountupThread extends Thread &#123; private long counter = 0; private volatile boolean shutdownRequested = false; public void shutdownRequest() &#123; shutdownRequested = true; interrupt(); &#125; public boolean isShutdownRequested() &#123; return shutdownRequested; &#125; @Override public void run() &#123; try &#123; while (!isShutdownRequested()) &#123; doWork(); &#125; &#125; catch (InterruptedException e) &#123; &#125; finally &#123; doShutdown(); &#125; &#125; private void doWork() throws InterruptedException &#123; counter++; System.out.println("doWork: counter = " + counter); Thread.sleep(500); &#125; private void doShutdown() &#123; System.out.println("doShutdown: counter = " + counter); &#125;&#125; Main.java1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args) &#123; System.out.println("main: BEGIN"); try &#123; CountupThread t = new CountupThread(); t.start(); Thread.sleep(10000); System.out.println("main: shutdownRequest"); t.shutdownRequest(); System.out.println("main: join"); t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("main: END"); &#125;&#125; 运行结果12345678910111213141516171819202122232425main: BEGINdoWork: counter = 1doWork: counter = 2doWork: counter = 3doWork: counter = 4doWork: counter = 5doWork: counter = 6doWork: counter = 7doWork: counter = 8doWork: counter = 9doWork: counter = 10doWork: counter = 11doWork: counter = 12doWork: counter = 13doWork: counter = 14doWork: counter = 15doWork: counter = 16doWork: counter = 17doWork: counter = 18doWork: counter = 19doWork: counter = 20main: shutdownRequestmain: joindoShutdown: counter = 20main: END 登场角色TerminationRequester（终止请求发出者）TerminationRequester角色负责向Terminator角色发出终止请求。在示例程序中，由Main类扮演此角色。 Terminator（终止者）Terminator角色负责接收终止请求，并实际执行终止处理。它提供了表示终止请求的shutdownRequest方法。shutdownRequest方法不需要使用Single Threaded Execution模式。当shutdownRequest方法被调用后，Terminator角色会在考虑了安全性的基础上，自己进入“终止处理中”状态。接着当终止处理结束后，Terminator角色就会终止自己。Terminator角色带有一个表示自己是否已经接收到终止请求的标志，在需要安全地开始终止处理时，会检查这个标志。如果能够频繁地检查该标志，就可以缩短接收到终止请求后变为“终止处理中”状态所需的时间。在示例程序中，由CountupThread类扮演此角色。 类图]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.util.concurrent包和Future模式]]></title>
    <url>%2F2019%2F02%2F01%2Fjava-util-concurrent%E5%8C%85%E5%92%8CFuture%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[java.util.concurrent包java.util.concurrent包提供了用于支持Future模式的类和接口。 java.util.concurrent.Callable接口将“返回值的某种处理的调用”抽象化了。Callable接口声明了call方法。call方法与Runnable接口的run方法相似，不同的是call方法有返回值。 java.util.concurrent.Future接口相当于Future角色。Future接口声明了用于获取值的get方法，但并没有声明设置值的方法。设置值的方法需要在实现Future接口的类中声明。除了get方法外，Future接口还声明了用于中断运行的cancel方法。 java.util.concurrent.FutureTask类是实现了Future接口的标准类。FutureTask类声明了用于获取值的get方法、用于中断运行的cancel方法、用于设置值的set方法，以及用于设置异常的setException方法。此外，由于FutureTask类还实现了Runnable接口，所以它还声明了run方法。 在创建FutureTask类的实例时，Callable对象会被传递给构造函数的参数。之后，如果线程调用FutureTask的run方法，那么在构造函数中接收到的参数——Callable对象的call方法就会被执行。换言之，调用FutureTask的run方法的线程也会调用call方法。调用call方法的线程会同步地获取call方法的返回值，然后通过FutureTask的set方法来设置该返回值。如果call方法中发生了异常，则调用call方法的线程就会调用FutureTask的setException方法设置异常。再然后，只要根据需要，调用FutureTask的get方法去获取值，就可以获取call方法的返回值。其中，get方法无论由哪个线程调用都可以。 使用java.util.concurrent包Host.java123456789101112131415161718192021import java.util.concurrent.Callable;public class Host &#123; public Data request(final int count, final char c) &#123; System.out.println(" request(" + count + ", " + c + ") BEGIN"); FutureData future = new FutureData( new Callable&lt;RealData&gt;() &#123; @Override public RealData call() throws Exception &#123; return new RealData(count, c); &#125; &#125; ); new Thread(future).start(); System.out.println(" request(" + count + ", " + c + ") END"); return future; &#125;&#125; FutureData.java1234567891011121314151617181920212223242526import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class FutureData extends FutureTask&lt;RealData&gt; implements Data &#123; public FutureData(Callable&lt;RealData&gt; callable) &#123; super(callable); &#125; @Override public String getContent() &#123; String string = null; try &#123; string = get().getContent(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; return string; &#125;&#125; 时序图]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解Java多线程设计模式】Future模式]]></title>
    <url>%2F2019%2F01%2F29%2F%E3%80%90%E5%9B%BE%E8%A7%A3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Future%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[获取Future角色的线程会在稍后使用Future角色来获取运行结果。如果运行结果已经出来了，那么直接领取即可；如果运行结果还没有出来，那么需要等待结果出来。 示例在每次发出请求时都创建一个线程。程序一旦发出请求，就会立即获取返回值。也就是说，会有下面这样的返回值（data）。 Data data = host.request(10, ‘A’); 但是，这里的返回值data并非请求的运行结果。为了获取请求的运行结果，刚刚启动了其他线程去进行计算。 如下所示，过了一段时间后，线程会调用data的getContent方法去获取运行结果。 data.getContent 如果其他线程处理完了请求，那么调用getContent的线程会立即从该方法返回；而如果其他线程还没有处理完请求，那么调用getContent的线程会继续等待运行结果。 类图 时序图 Main.java1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args) &#123; System.out.println("main BEGIN"); Host host = new Host(); Data data1 = host.request(10, 'A'); Data data2 = host.request(20, 'B'); Data data3 = host.request(30, 'C'); System.out.println("main otherJob BEGIN"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; System.out.println("main otherJob END"); System.out.println("data1 = " + data1.getContent()); System.out.println("data2 = " + data2.getContent()); System.out.println("data3 = " + data3.getContent()); System.out.println("main END"); &#125;&#125; Host.java执行request的线程会做以下三件事情。 创建FutureData的实例 启动一个新线程，用于创建RealData的实例 将FutureData的实例作为返回值返回给调用者 123456789101112131415161718public class Host &#123; public Data request(final int count, final char c) &#123; System.out.println(" request(" + count + ", " + c + ") BEGIN"); final FutureData future = new FutureData(); new Thread() &#123; @Override public void run() &#123; RealData realdata = new RealData(count, c); future.setRealData(realdata); &#125; &#125;.start(); System.out.println(" request(" + count + ", " + c + ") END"); return future; &#125;&#125; Data.java123public interface Data &#123; public abstract String getContent();&#125; FutureData.java123456789101112131415161718192021222324public class FutureData implements Data &#123; private boolean ready = false; private RealData realdata = null; public synchronized void setRealData(RealData realdata) &#123; if (ready) return; this.ready = true; this.realdata = realdata; notifyAll(); &#125; @Override public synchronized String getContent() &#123; while(!ready) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; return realdata.getContent(); &#125;&#125; RealData.java123456789101112131415161718192021222324public class RealData implements Data &#123; private final String content; public RealData(int count, char c) &#123; System.out.println(" making RealData(" + count + ", " + c + ") BEGIN"); char[] buffer = new char[count]; for (int i = 0; i &lt; count; i++) &#123; buffer[i] = c; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; &#125; this.content = new String(buffer); System.out.println(" making RealData(" + count + ", " + c + ") END"); &#125; @Override public String getContent() &#123; return content; &#125;&#125; 运行结果12345678910111213141516171819main BEGIN request(10, A) BEGIN request(10, A) END request(20, B) BEGIN request(20, B) END request(30, C) BEGIN request(30, C) ENDmain otherJob BEGIN making RealData(30, C) BEGIN making RealData(10, A) BEGIN making RealData(20, B) BEGIN making RealData(10, A) ENDmain otherJob ENDdata1 = AAAAAAAAAA making RealData(20, B) ENDdata2 = BBBBBBBBBBBBBBBBBBBB making RealData(30, C) ENDdata3 = CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCmain END 登场角色Client（请求者）Client角色向Host角色发出请求（request），并会立即接收到请求的处理结果（返回值）——VirtualData角色。不过，这里接收到的VirtualData角色实际上是Future角色。Client角色没有必要知道返回值究竟是RealData角色还是Future角色。稍后，Client角色会通过VirtualData角色来进行操作。在示例程序中，由Main类扮演此角色。 HostHost角色会创建新的线程，并开始在新线程中创建RealData角色。同时，它会将Future角色（当作VirtualData角色）返回给Client角色。在示例程序中，由Host类扮演此角色。新线程在创建了RealData角色后，会将其设置到Future角色中。 VirtualData（虚拟数据）VirtualData角色是让Future角色与RealData角色具有一致性的角色。在示例程序中，由Data接口扮演此角色。 RealData（真实数据）RealData角色是表示真实数据的角色。创建该对象需要花费很多时间。在示例程序中，由RealData类扮演此角色。 Future（期货）Future角色由Host角色传递给Client角色。从程序行为上看，对Client角色而言，Future角色就是VirtualData角色。实际上，当Client角色操作Future角色时，线程会调用wait方法等待，直至RealData角色创建完成。但是，一旦RealData角色创建完成，线程就不会再继续等待。Future角色会将Client角色的操作委托给RealData角色。在示例程序中，由FutureData类扮演此角色。 类图]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.util.concurrent包和Worker Thread模式]]></title>
    <url>%2F2019%2F01%2F27%2Fjava-util-concurrent%E5%8C%85%E5%92%8CWorker-Thread%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[ThreadPoolExecutor类java.util.concurrent.ThreadPoolExecutor类是管理工人线程的类。ThreadPoolExecutor可以轻松地实现Worker Thread模式。ThreadPoolExecutor类可以对线程池（保存和管理工人线程的场所）进行以下设置。 指定线程池的大小 指定提前创建线程还是按需创建线程 指定创建线程的工厂（java.util.concurrent.ThreadFactory） 指定多长时间终止不需要的线程 指定传递要执行的工作时的排队方式 指定拒绝工作的方式 指定执行工作前和执行工作后的处理 通过java.util.concurrent包创建线程池java.util.concurrent.Executors类是用于创建线程池的工具类。 Executors.newFixedThreadPool方法Executors.newFixedThreadPool方法会创建一个线程池，该线程池会创建个数由参数指定的工人线程，而且创建出的线程会被重复利用。如果在这个方法的参数中加上ThreadFactory对象，则线程池会使用该ThreadFactory来创建新的工人线程。 Executors.newCachedThreadPool方法Executors.newCachedThreadPool方法会创建一个线程池，该线程池可以根据需要自动创建工人线程，而且工人线程会被重复利用。没有工作的工人线程会在缓存约60秒后自动终止。如果向这个方法的参数中传入ThreadFactory对象，则线程池会使用这个ThreadFactory来创建新的工人线程。 Executors.newScheduledThreadPool方法Executors.newScheduledThreadPool方法会创建一个线程池，该线程池可以在一定时间后执行请求或是反复执行请求。即使在没有请求时也需要保存的线程数量可以通过参数指定。此外，如果在这个方法的参数中加上ThreadFactory对象，则线程池会使用这个ThreadFactory来创建新的工人线程。 Main.java1234567891011121314151617181920import java.util.concurrent.Executors;import java.util.concurrent.ExecutorService;public class Main &#123; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newFixedThreadPool(5); try &#123; new ClientThread("Alice", executorService).start(); new ClientThread("Bobby", executorService).start(); new ClientThread("Chris", executorService).start(); Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; &#125; finally &#123; executorService.shutdown(); &#125; &#125;&#125; ClientThread.java1234567891011121314151617181920212223242526import java.util.Random;import java.util.concurrent.ExecutorService;import java.util.concurrent.RejectedExecutionException;public class ClientThread extends Thread &#123; private final ExecutorService executorService; private static final Random random = new Random(); public ClientThread(String name, ExecutorService executorService) &#123; super(name); this.executorService = executorService; &#125; public void run() &#123; try &#123; for (int i = 0; ; i++) &#123; Request request = new Request(getName(), i); executorService.execute(request); Thread.sleep(random.nextInt(1000)); &#125; &#125; catch (InterruptedException e) &#123; &#125; catch (RejectedExecutionException e) &#123; System.out.println(getName() + " : " + e); &#125; &#125;&#125; Request.java12345678910111213141516171819202122232425import java.util.Random;public class Request implements Runnable &#123; private final String name; private final int number; private static final Random random = new Random(); public Request(String name, int number) &#123; this.name = name; this.number = number; &#125; public void run() &#123; System.out.println(Thread.currentThread().getName() + " executes " + this); try &#123; Thread.sleep(random.nextInt(1000)); &#125; catch (InterruptedException e) &#123; &#125; &#125; public String toString() &#123; return "[ Request from " + name + " No." + number + " ]"; &#125;&#125; 运行结果12345678910111213141516171819202122pool-1-thread-1 executes [ Request from Chris No.0 ]pool-1-thread-2 executes [ Request from Bobby No.0 ]pool-1-thread-3 executes [ Request from Alice No.0 ]pool-1-thread-4 executes [ Request from Bobby No.1 ]pool-1-thread-5 executes [ Request from Chris No.1 ]pool-1-thread-3 executes [ Request from Bobby No.2 ]pool-1-thread-5 executes [ Request from Bobby No.3 ]pool-1-thread-2 executes [ Request from Alice No.1 ]pool-1-thread-1 executes [ Request from Chris No.2 ]pool-1-thread-3 executes [ Request from Chris No.3 ]pool-1-thread-4 executes [ Request from Alice No.2 ]...pool-1-thread-1 executes [ Request from Chris No.8 ]pool-1-thread-2 executes [ Request from Alice No.6 ]pool-1-thread-5 executes [ Request from Bobby No.8 ]pool-1-thread-4 executes [ Request from Alice No.7 ]pool-1-thread-3 executes [ Request from Alice No.8 ]pool-1-thread-1 executes [ Request from Chris No.9 ]pool-1-thread-4 executes [ Request from Bobby No.9 ]Bobby : java.util.concurrent.RejectedExecutionException: Task [ Request from Bobby No.10 ] rejected from java.util.concurrent.ThreadPoolExecutor@442f5c95[Shutting down, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 28]Alice : java.util.concurrent.RejectedExecutionException: Task [ Request from Alice No.9 ] rejected from java.util.concurrent.ThreadPoolExecutor@442f5c95[Shutting down, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 28]Chris : java.util.concurrent.RejectedExecutionException: Task [ Request from Chris No.10 ] rejected from java.util.concurrent.ThreadPoolExecutor@442f5c95[Shutting down, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 28]]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解Java多线程设计模式】Worker Thread模式]]></title>
    <url>%2F2019%2F01%2F13%2F%E3%80%90%E5%9B%BE%E8%A7%A3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Worker-Thread%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工人线程（worker thread）会逐个取回工作并进行处理。当所有工作全部完成后，工人线程会等待新的工作到来。 示例ClientThread类的线程会向Channel类发送工作请求（委托）。Channel类的实例雇用了五个工人线程（WorkerThread）进行工作。所有工人线程都在等待工作请求的到来。工作请求到来后，工人线程会从Channel那里获取一项工作请求并开始工作。工作完成后，工人线程会回到Channel那里等待下一项工作请求。 类图 时序图 Main.java12345678910public class Main &#123; public static void main(String[] args) &#123; Channel channel = new Channel(5); channel.startWorkers(); new ClientThread("Alice", channel).start(); new ClientThread("Bobby", channel).start(); new ClientThread("Chris", channel).start(); &#125;&#125; ClientThread.java 创建Request的实例 将该实例传递给Channel类的putRequest方法 12345678910111213141516171819202122import java.util.Random;public class ClientThread extends Thread &#123; private final Channel channel; private static final Random random = new Random(); public ClientThread(String name, Channel channel) &#123; super(name); this.channel = channel; &#125; public void run() &#123; try &#123; for (int i = 0; ; i++) &#123; Request request = new Request(getName(), i); channel.putRequest(request); Thread.sleep(random.nextInt(1000)); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125; Request.java12345678910111213141516171819202122232425import java.util.Random;public class Request &#123; private final String name; private final int number; private static final Random random = new Random(); public Request(String name, int number) &#123; this.name = name; this.number = number; &#125; public void execute() &#123; System.out.println(Thread.currentThread().getName() + " executes " + this); try &#123; Thread.sleep(random.nextInt(1000)); &#125; catch (InterruptedException e) &#123; &#125; &#125; public String toString() &#123; return "[ Request from " + name + " No." + number + " ]"; &#125;&#125; Channel.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Channel &#123; private static final int MAX_REQUEST = 100; private final Request[] requestQueue; private final WorkerThread[] threadPool; private int head; private int tail; private int count; public Channel(int threads) &#123; this.requestQueue = new Request[MAX_REQUEST]; this.threadPool = new WorkerThread[threads]; this.head = 0; this.tail = 0; this.count = 0; for (int i = 0; i &lt; threadPool.length; i++) &#123; threadPool[i] = new WorkerThread("Worker-" + i, this); &#125; &#125; public void startWorkers() &#123; for (int i = 0; i &lt; threadPool.length; i++) &#123; threadPool[i].start(); &#125; &#125; public synchronized void putRequest(Request request) &#123; while (count &gt;= requestQueue.length) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; requestQueue[tail] = request; tail = (tail + 1) % requestQueue.length; count++; notifyAll(); &#125; public synchronized Request takeRequest() &#123; while (count &lt;= 0) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; Request request = requestQueue[head]; head = (head + 1) % requestQueue.length; count--; notifyAll(); return request; &#125;&#125; WorkerThread.java 调用takeRequest方法从Channel的实例中获取一个Request的实例 调用Request的实例的execute方法 123456789101112131415public class WorkerThread extends Thread &#123; private final Channel channel; public WorkerThread(String name, Channel channel) &#123; super(name); this.channel = channel; &#125; public void run() &#123; while (true) &#123; Request request = channel.takeRequest(); request.execute(); &#125; &#125;&#125; 运行结果123456789Worker-3 executes [ Request from Bobby No.0 ]Worker-0 executes [ Request from Chris No.0 ]Worker-4 executes [ Request from Alice No.0 ]Worker-0 executes [ Request from Chris No.1 ]Worker-4 executes [ Request from Chris No.2 ]Worker-3 executes [ Request from Bobby No.1 ]Worker-1 executes [ Request from Alice No.1 ]Worker-1 executes [ Request from Bobby No.2 ]Worker-4 executes [ Request from Chris No.3 ] 登场角色Client（委托者）Client角色创建表示工作请求的Request角色并将其传递给Channel角色。在示例程序中，由ClientThread类扮演此角色。 Channel（通信线路）Channel角色接收来自于Client角色的Request角色，并将其传递给Worker角色。在示例程序中，由Channel类扮演此角色。 Worker（工人）Worker角色从Channel角色中获取Request角色，并进行工作。当一项工作完成后，它会继续去获取另外的Request角色。在示例程序中，由WorkerThread类扮演此角色。 Request（请求）Request角色是表示工作的角色。Request角色中保存了进行工作所必需的信息。在示例程序中，由Request类扮演此角色。 类图 Timethreads图]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.util.concurrent包和Thread-Per-Message模式]]></title>
    <url>%2F2019%2F01%2F03%2Fjava-util-concurrent%E5%8C%85%E5%92%8CThread-Per-Message%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Thread-Per-Message模式的七种实现方式 java.lang.Thread类 最基本的创建、启动线程的类 java.lang.Runnable接口 表示线程所执行的“工作”的接口 java.util.concurrent.ThreadFactory接口 将线程创建抽象化了的接口 java.util.concurrent.Executor接口 将线程执行抽象化了的接口 java.util.concurrent.ExecutorService接口 将被复用的线程抽象化了的接口 java.util.concurrent.ScheduledExecutorService接口 将被调度的线程的执行抽象化了的接口 java.util.concurrent.Executors类 用于创建实例的工具类 类图 java.lang.Thread类123456789101112131415public class Host &#123; private final Helper helper = new Helper(); public void request(final int count, final char c) &#123; System.out.println(" request(" + count + ", " + c + ") BEGIN"); new Thread() &#123; public void run() &#123; helper.handle(count, c); &#125; &#125;.start(); System.out.println(" request(" + count + ", " + c + ") END"); &#125;&#125; java.lang.Runnable接口1234567891011121314151617public class Host &#123; private final Helper helper = new Helper(); public void request(final int count, final char c) &#123; System.out.println(" request(" + count + ", " + c + ") BEGIN"); new Thread( new Runnable() &#123; public void run() &#123; helper.handle(count, c); &#125; &#125; ).start(); System.out.println(" request(" + count + ", " + c + ") END"); &#125;&#125; java.util.concurrent.ThreadFactory接口java.util.concurrent.ThreadFactory接口声明了如下所示的一个newThread方法。 1Thread newThread(Runnable r); ThreadFactory是将线程创建抽象化了的接口，参数中的Runnable对象表示线程执行的操作内容。 Host.java123456789101112131415161718192021222324import java.util.concurrent.ThreadFactory;public class Host &#123; private final Helper helper = new Helper(); private final ThreadFactory threadFactory; public Host(ThreadFactory threadFactory) &#123; this.threadFactory = threadFactory; &#125; public void request(final int count, final char c) &#123; System.out.println(" request(" + count + ", " + c + ") BEGIN"); threadFactory.newThread( new Runnable() &#123; public void run() &#123; helper.handle(count, c); &#125; &#125; ).start(); System.out.println(" request(" + count + ", " + c + ") END"); &#125;&#125; Main.java123456789101112131415161718192021import java.util.concurrent.ThreadFactory;public class Main &#123; public static void main(String[] args) &#123; System.out.println("main BEGIN"); Host host = new Host( new ThreadFactory() &#123; @Override public Thread newThread(Runnable r) &#123; return new Thread(r); &#125; &#125; ); host.request(10, 'A'); host.request(20, 'B'); host.request(30, 'C'); System.out.println("main END"); &#125;&#125; java.util.concurrent.Executors类获取的ThreadFactoryjava.util.concurrent.Executors类提供了许多的静态方法。Executors.defaultThreadFactory()表达式可以获取当前默认设置的ThreadFactory对象。 123456789101112131415import java.util.concurrent.Executors;public class Main &#123; public static void main(String[] args) &#123; System.out.println("main BEGIN"); Host host = new Host( Executors.defaultThreadFactory() ); host.request(10, 'A'); host.request(20, 'B'); host.request(30, 'C'); System.out.println("main END"); &#125;&#125; java.util.concurrent.Executor接口java.util.concurrent.Executor接口声明了如下所示的一个execute方法。 1void execute(Runnable r); Executor接口将某些“处理的执行”抽象化了，参数传入的Runnable对象表示“执行的处理”的内容。 Host.java1234567891011121314151617181920212223242526import java.util.concurrent.Executor;public class Host &#123; private final Helper helper = new Helper(); private final Executor executor; public Host(Executor executor) &#123; this.executor = executor; &#125; public void request(final int count, final char c) &#123; System.out.println(" request(" + count + ", " + c + ") BEGIN"); executor.execute( new Runnable()&#123; @Override public void run() &#123; helper.handle(count, c); &#125; &#125; ); System.out.println(" request(" + count + ", " + c + ") END"); &#125;&#125; Main.java12345678910111213141516171819import java.util.concurrent.Executor;public class Main &#123; public static void main(String[] args) &#123; System.out.println("main BEGIN"); Host host = new Host( new Executor() &#123; public void execute(Runnable r) &#123; new Thread(r).start(); &#125; &#125; ); host.request(10, 'A'); host.request(20, 'B'); host.request(30, 'C'); System.out.println("main END"); &#125;&#125; java.util.concurrent.ExecutorService接口java.util.concurrent.ExecutorService接口对可以反复execute的服务进行了抽象化。线程一直在后台运行着，每当调用execute方法时，线程就会执行Runnable对象。 123456789101112131415161718192021import java.util.concurrent.Executors;import java.util.concurrent.ExecutorService;public class Main &#123; public static void main(String[] args) &#123; System.out.println("main BEGIN"); ExecutorService executorService = Executors.newCachedThreadPool(); Host host = new Host(executorService); try &#123; host.request(10, 'A'); host.request(20, 'B'); host.request(30, 'C'); &#125; finally &#123; executorService.shutdown(); System.out.println("main END"); &#125; &#125;&#125; java.util.concurrent.ScheduledExecutorService接口java.util.concurrent.ScheduledExecutorService接口是ExecutorService的子接口，用于推迟操作的执行。schedule方法位于ScheduledExecutorService接口中，可以用于设置Runnable对象（r）和延迟时间（delay、unit）。 1schedule(Runnable r, long delay, TimeUnit unit); long类型的delay表示的是延迟时间，TimeUnit类型的unit表示的则是指定延迟时间的单位（NANOSECONDS、MICROSECONDS、MILLISECONDS或SECONDS）。 Host.java12345678910111213141516171819202122232425262728import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class Host &#123; private final Helper helper = new Helper(); private final ScheduledExecutorService scheduledExecutorService; public Host(ScheduledExecutorService scheduledExecutorService) &#123; this.scheduledExecutorService = scheduledExecutorService; &#125; public void request(final int count, final char c) &#123; System.out.println(" request(" + count + ", " + c + ") BEGIN"); scheduledExecutorService.schedule( new Runnable()&#123; @Override public void run() &#123; helper.handle(count, c); &#125; &#125; , 3L, TimeUnit.SECONDS ); System.out.println(" request(" + count + ", " + c + ") END"); &#125;&#125; Main.java123456789101112131415161718192021import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;public class Main &#123; public static void main(String[] args) &#123; System.out.println("main BEGIN"); ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(5); Host host = new Host(scheduledExecutorService); try &#123; host.request(10, 'A'); host.request(20, 'B'); host.request(30, 'C'); &#125; finally &#123; scheduledExecutorService.shutdown(); System.out.println("main END"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程与线程]]></title>
    <url>%2F2019%2F01%2F03%2F%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一般来说，一个进程可以包含多个线程。 线程之间共享内存进程与线程之间最大的区别就是内存是否共享。通常，每个进程都拥有彼此独立的内存空间。一个进程不可以擅自读取、写入其他进程的内存。由于进程的内存空间是彼此独立的，所以一个进程无须担心被其他进程破坏。线程之间共享内存。经常让一个线程向内存中写入内容，来供其他线程读取。所谓“共享内存”，在Java中就是“共享实例”的意思。Java的实例分配在内存上，可由多个线程进行读写。由于线程之间共享内存，所以线程之间的通信可以很自然、简单地实现。一个线程向实例中写入内容，其他线程就可以读取该实例的内容。而由于多个线程可以访问同一个实例，所以必须正确执行互斥处理。 线程的上下文切换快进程和线程之间的另一个区别就是上下文切换的繁重程度。当运行中的进程进行切换时，进程要暂时保存自身的当前状态（上下文信息）。而接着开始运行的进程需要恢复之前保存的自身的上下文信息。这种信息切换（context-switch）比较花费时间。当运行中的线程进行切换时，与进程一样，也会进行上下文切换。但由于线程管理的上下文信息比进程少，，所以一般来说，线程的上下文切换要比进程快。因此，当执行紧密关联的多项工作时，通常线程比进程更加合适。]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解Java多线程设计模式】Thread-Per-Message模式]]></title>
    <url>%2F2018%2F12%2F30%2F%E3%80%90%E5%9B%BE%E8%A7%A3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Thread-Per-Message%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[为每个命令或请求新分配一个线程，由这个线程来执行处理。在Thread-Per-Message模式中，消息的“委托端”和“执行端”是不同的线程。 示例Main类委托Host类来显示字符。Host类会创建并启动一个线程，来处理该委托。启动的线程使用Helper类来执行实际的显示。 类图 时序图 Timethreads图 Main.java1234567891011public class Main &#123; public static void main(String[] args) &#123; System.out.println("main BEGIN"); Host host = new Host(); host.request(10, 'A'); host.request(20, 'B'); host.request(30, 'C'); System.out.println("main END"); &#125;&#125; Host.java匿名内部类用于执行如下操作： 声明Thread的子类，并重写run方法 创建该类的实例 调用该实例的start方法启动线程 123456789101112131415public class Host &#123; private final Helper helper = new Helper(); public void request(final int count, final char c) &#123; System.out.println(" request(" + count + ", " + c + ") BEGIN"); new Thread() &#123; public void run() &#123; helper.handle(count, c); &#125; &#125;.start(); System.out.println(" request(" + count + ", " + c + ") END"); &#125;&#125; Helper.java1234567891011121314151617181920public class Helper &#123; public void handle(int count, char c) &#123; System.out.println(" handle(" + count + ", " + c + ") BEGIN"); for (int i = 0; i &lt; count; i++) &#123; slowly(); System.out.print(c); &#125; System.out.println(""); System.out.println(" handle(" + count + ", " + c + ") END"); &#125; private void slowly() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125; 运行结果1234567891011121314151617main BEGIN request(10, A) BEGIN request(10, A) END request(20, B) BEGIN handle(10, A) BEGIN request(20, B) END request(30, C) BEGIN handle(20, B) BEGIN request(30, C) ENDmain END handle(30, C) BEGINCABACBACBABCBCAACBACBACBABCCBA handle(10, A) ENDCBCBCBBCBCBCCBCBBCCB handle(20, B) ENDCCCCCCCCCC handle(30, C) END 登场角色Client（委托人）Client角色会向Host角色发出请求（request），但是并不知道Host角色是如何实现该请求的。在示例程序中，由Main类扮演此角色。 HostHost角色收到Client角色的请求（request）之后，会创建并启动一个线程。新创建的线程将使用Helper角色来“处理”（handle）请求。在示例程序中，由Host类扮演此角色。 Helper（助手）Helper角色为Host角色提供请求处理的功能。Host角色创建的新线程会利用Helper角色。在示例程序中，由Helper类扮演此角色。 类图]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.util.concurrent.locks包和Read-Write Lock模式]]></title>
    <url>%2F2018%2F12%2F28%2Fjava-util-concurrent-locks%E5%8C%85%E5%92%8CRead-Write-Lock%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[java.util.concurrent.locks包提供了已实现Read-Write Lock模式的ReadWriteLock接口和ReentrantReadWriteLock类。 java.util.concurrent.locks.ReadWriteLock接口的“用于读取的锁”和“用于写入的锁”是通过其他对象来实现的。获取锁和释放锁的方法： readLock.lock() readLock.unlock() writeLock.lock() writeLock.unlock() java.util.concurrent.locks.ReentrantReadWriteLock类实现了ReadWriteLock接口。ReentrantReadWriteLock类的主要特征如下： 公平性 当创建ReentrantReadWriteLock类的实例时，可以选择锁的获取顺序是否要设为公平（fair）的。如果创建的实例是公平的，那么等待时间久的线程将可以优先获取锁。 可重入性 ReentrantReadWriteLock类的锁是可重入的（reentrant）。也就是说，Reader角色的线程可以获取“用于写入的锁”，Writer角色的线程也可以获取“用于读取的锁”。 锁降级 ReentrantReadWriteLock类可以按如下顺序将“用于写入的锁”降级为“用于读取的锁”：获取用于写入的锁-&gt;获取用于读取的锁-&gt;释放用于写入的锁但是，“用于读取的锁”不可以升级为“用于写入的锁”。 便捷方法 ReentrantReadWriteLock类提供了获取等待中的线程的个数的方法getQueueLength，以及检查是否获取了用于写入的锁的方法isWriteLocked等便捷方法。 使用java.util.concurrent.locksData.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.concurrent.locks.ReentrantReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;public class Data &#123; private char[] buffer; private ReentrantReadWriteLock lock = new ReentrantReadWriteLock(true); private ReadLock readLock = lock.readLock(); private WriteLock writeLock = lock.writeLock(); public Data(int size) &#123; this.buffer = new char[size]; for (int i = 0; i &lt; buffer.length; i++) &#123; buffer[i] = '*'; &#125; &#125; public char[] read() throws InterruptedException &#123; readLock.lock(); try &#123; return doRead(); &#125; finally &#123; readLock.unlock(); &#125; &#125; public void write(char c) throws InterruptedException &#123; writeLock.lock(); try &#123; doWrite(c); &#125; finally &#123; writeLock.unlock(); &#125; &#125; private char[] doRead() &#123; char[] newbuf = new char[buffer.length]; for (int i = 0; i &lt; buffer.length; i++) &#123; newbuf[i] = buffer[i]; &#125; slowly(); return newbuf; &#125; private void doWrite(char c) &#123; for (int i = 0; i &lt; buffer.length; i++) &#123; buffer[i] = c; slowly(); &#125; &#125; private void slowly() &#123; try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解Java多线程设计模式】Read-Write Lock模式]]></title>
    <url>%2F2018%2F12%2F27%2F%E3%80%90%E5%9B%BE%E8%A7%A3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Read-Write-Lock%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在Read-Write Lock模式中，读取操作和写入操作是分开考虑的。在执行读取操作之前，线程必须获取用于读取的锁。而在执行写入操作之前，线程必须获取用于写入的锁。由于当线程执行读取操作时，实例的状态不会发生变化，所以多个线程可以同时读取。但在读取时，不可以写入。当线程执行写入操作时，实例的状态就会发生变化。因此，当有一个线程正在写入时，其他线程不可以读取或写入。一般来说，执行互斥处理会降低程序性能。但如果把针对写入的互斥处理和针对读取的互斥处理分开来考虑，则可以提高程序性能。 示例多个线程对Data类的实例执行读写操作。 类图 Main.java1234567891011121314public class Main &#123; public static void main(String[] args) &#123; Data data = new Data(10); new ReaderThread(data).start(); new ReaderThread(data).start(); new ReaderThread(data).start(); new ReaderThread(data).start(); new ReaderThread(data).start(); new ReaderThread(data).start(); new WriterThread(data, "ABCDEFGHIJKLMNOPQRSTUVWXYZ").start(); new WriterThread(data, "abcdefghijklmnopqrstuvwxyz").start(); &#125;&#125; Data.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Data &#123; private char[] buffer; private ReadWriteLock lock = new ReadWriteLock(); public Data(int size) &#123; this.buffer = new char[size]; for (int i = 0; i &lt; buffer.length; i++) &#123; buffer[i] = '*'; &#125; &#125; public char[] read() throws InterruptedException &#123; lock.readLock(); try &#123; return doRead(); &#125; finally &#123; lock.readUnlock(); &#125; &#125; public void write(char c) throws InterruptedException &#123; lock.writeLock(); try &#123; doWrite(c); &#125; finally &#123; lock.writeUnlock(); &#125; &#125; private char[] doRead() &#123; char[] newbuf = new char[buffer.length]; for (int i = 0; i &lt; buffer.length; i++) &#123; newbuf[i] = buffer[i]; &#125; slowly(); return newbuf; &#125; private void doWrite(char c) &#123; for (int i = 0; i &lt; buffer.length; i++) &#123; buffer[i] = c; slowly(); &#125; &#125; private void slowly() &#123; try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125; WriterThread.java1234567891011121314151617181920212223242526272829303132333435import java.util.Random;public class WriterThread extends Thread &#123; private final Data data; private final String filler; private int index = 0; private static final Random random = new Random(); public WriterThread(Data data, String filler) &#123; this.data = data; this.filler = filler; &#125; public void run() &#123; try &#123; while (true) &#123; char c = nextchar(); data.write(c); Thread.sleep(random.nextInt(3000)); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125; private char nextchar() &#123; char c = filler.charAt(index); index++; if (index &gt;= filler.length()) &#123; index = 0; &#125; return c; &#125;&#125; ReaderThread.java1234567891011121314151617public class ReaderThread extends Thread &#123; private final Data data; public ReaderThread(Data data) &#123; this.data = data; &#125; public void run() &#123; try &#123; while (true) &#123; char[] readbuf = data.read(); System.out.println(Thread.currentThread().getName() + " reads " + String.valueOf(readbuf)); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125; ReadWriteLock.java为了确保安全性，必须防止如下两种冲突。 “读取”和“写入”的冲突（read-write conflict） “写入”和“写入”的冲突（write-write conflict） 当线程想要获取用于读取的锁时： 如果有线程正在执行写入，则等待。否则，会引起read-write conflict。 如果有线程正在执行读取，则无需等待。read-read不会引起conflict。 当线程想要获取用于写入的锁时： 如果有线程正在执行写入，则等待。否则，会引起write-write conflict。 如果有线程正在执行读取，则等待。否则，会引起read-write conflict。 12345678910111213141516171819202122232425262728293031323334353637383940public final class ReadWriteLock &#123; private int readingReaders = 0; private int waitingWriters = 0; private int writingWriters = 0; private boolean preferWriter = true; public synchronized void readLock() throws InterruptedException &#123; while (writingWriters &gt; 0 || (preferWriter &amp;&amp; waitingWriters &gt; 0)) &#123; wait(); &#125; readingReaders++; &#125; public synchronized void readUnlock() &#123; readingReaders--; preferWriter = true; notifyAll(); &#125; public synchronized void writeLock() throws InterruptedException &#123; waitingWriters++; try &#123; while (readingReaders &gt; 0 || writingWriters &gt; 0) &#123; wait(); &#125; &#125; finally &#123; waitingWriters--; &#125; writingWriters++; &#125; public synchronized void writeUnlock() &#123; writingWriters--; preferWriter = false; notifyAll(); &#125;&#125; 运行结果12345678910111213141516171819202122232425262728293031323334353637Thread-0 reads **********Thread-4 reads **********Thread-5 reads **********Thread-2 reads **********Thread-1 reads **********Thread-3 reads **********Thread-2 reads AAAAAAAAAAThread-4 reads AAAAAAAAAAThread-3 reads AAAAAAAAAAThread-5 reads AAAAAAAAAAThread-0 reads AAAAAAAAAAThread-1 reads AAAAAAAAAAThread-0 reads aaaaaaaaaaThread-2 reads aaaaaaaaaaThread-1 reads aaaaaaaaaaThread-3 reads aaaaaaaaaaThread-5 reads aaaaaaaaaaThread-4 reads aaaaaaaaaaThread-0 reads aaaaaaaaaaThread-2 reads aaaaaaaaaaThread-5 reads aaaaaaaaaa...Thread-3 reads BBBBBBBBBBThread-5 reads BBBBBBBBBBThread-4 reads BBBBBBBBBBThread-2 reads BBBBBBBBBBThread-1 reads BBBBBBBBBBThread-0 reads BBBBBBBBBBThread-2 reads CCCCCCCCCCThread-0 reads CCCCCCCCCCThread-5 reads CCCCCCCCCCThread-1 reads CCCCCCCCCCThread-4 reads CCCCCCCCCCThread-3 reads CCCCCCCCCCThread-4 reads CCCCCCCCCCThread-2 reads CCCCCCCCCCThread-3 reads CCCCCCCCCC 登场角色Reader（读者）Reader角色对SharedResource角色执行read操作。在示例程序中，由ReaderThread类扮演此角色。 Writer（写者）Writer角色对SharedResource角色执行write操作。在示例程序中，由WriterThread类扮演此角色。 SharedResource（共享资源）SharedResource角色表示的是Reader角色和Writer角色二者共享的资源。SharedResource角色提供不修改内部状态的操作（read）和修改内部状态的操作（write）。在示例程序中，由Data类扮演此角色。 ReadWriteLock（读写锁）ReadWriteLock角色提供了SharedResource角色实现read操作和write操作时所需的锁。即实现read操作时所需的readLock和readUnlock，以及实现write操作时所需的writeLock和writeUnlock。在示例程序中，由ReadWriteLock类扮演此角色。 类图 Timethreads图Reader角色正在读取，Writer角色正在等待 一个Writer角色正在写入，Reader角色和其他Writer角色正在等待]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解Java多线程设计模式】总结]]></title>
    <url>%2F2018%2F12%2F23%2F%E3%80%90%E5%9B%BE%E8%A7%A3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Single Threaded Execution模式 语境多个线程共享实例时。 问题如果各个线程都随意地改变实例状态，实例会失去安全性。 解决方案首先，严格地规定实例的不稳定状态的范围（临界区）。接着，施加保护，确保临界区只能被一个线程执行。这样就可以确保实例的安全性。 实现Java可以使用synchronized来实现临界区。 Immutable模式 语境虽然多个线程共享了实例，但是实例的状态不会发生变化。 问题如果使用Single Threaded Execution模式，吞吐量会下降。 解决方案如果实例被创建后，状态不会发生变化，建议不要使用Single Threaded Execution模式。为了防止不小心编写出改变实例状态的代码，修改代码，让线程无法改变表示实例状态的字段。另外，如果代码中有改变实例状态的方法（setter），删除它们。获取实例状态的方法（getter）则没有影响，可以存在于代码中。使用Immutable模式可以提高吞吐量。但是，在整个项目周期内持续地保持类的不可变性（immutability）是非常困难的。 实现Java可以使用private来隐藏字段。另外，还可以使用final来确保字段无法改变。 Guarded Suspension模式 语境多个线程共享实例时。 问题如果各个线程都随意地访问实例，实例会失去安全性。 解决方案如果实例的状态不正确，就让线程等待实例恢复至正确的状态。首先，用“守护条件”表示实例的“正确状态”。接着，在执行可能会导致实例失去安全性的处理之前，检查是否满足守护条件。如果不满足守护条件，则让线程等待，直至满足守护条件为止。使用Guarded Suspension模式时，可以通过守护条件来控制方法的执行。但是，如果永远无法满足守护条件，那么线程会永远等待，所以可能会失去生存性。 实现在Java中，可以使用while语句来检查守护条件，调用wait方法来让线程等待。接着，调用notify/notifyAll方法来发送守护条件发生变化的通知。而检查和改变守护条件则可以使用Single Threaded Execution模式来实现。 Balking模式 语境多个线程共享实例时。 问题如果各个线程都随意地访问实例，实例会失去安全性。但是，如果要等待安全的时机，响应性又会下降。 解决方案当实例状态不正确时就中断处理。首先，用“守护条件”表示实例的“正确状态”。接着，在执行可能会导致实例失去安全性的处理之前，检查是否满足守护条件。只有满足守护条件时才让程序继续执行。如果不满足守护条件就中断执行，立即返回。 实现Java可以使用if语句来检查守护条件。这里可以使用return语句从方法中返回或是通过throw语句抛出异常来进行中断。而检查和改变守护条件则可以使用Single Threaded Execution模式来实现。 Producer-Consumer模式 语境想从某个线程（Producer角色）向其他线程（Consumer角色）传递数据时。 问题如果Producer角色和Consumer角色的处理速度不一致，那么处理速度快的角色会被处理速度慢的角色拖后腿，从而导致吞吐量的下降。 另外，如果在Producer角色写数据的同时，Consumer角色去读取数据，又会失去安全性。 解决方案在Producer角色和Consumer角色之间准备一个中转站——Channel角色。接着，让Channel角色持有多个数据。这样，就可以缓解Producer角色与Consumer角色之间的处理速度差异。另外，如果在Channel角色中进行线程互斥，就不会失去数据的安全性。这样就可以既不降低吞吐量，又可以在多个线程之间安全地传递数据。 Read-Write Lock模式 语境当多个线程共享了实例，且存在读取实例状态的线程（Reader角色）和改变实例状态的线程（Writer角色）时。 问题如果不进行线程的互斥处理将会失去安全性。但是，如果使用Single Threaded Execution模式，吞吐量又会下降。 解决方案首先将“控制Reader角色的锁”与“控制Writer角色的锁”分开，引入一个提供这两种锁的ReadWriteLock角色。ReadWriteLock角色会进行Writer角色之间的互斥处理，以及Reader角色与Writer角色之间的互斥处理。Reader角色之间即使发生冲突也不会有影响，因此无需进行互斥处理。这样，就可以既不失去安全性，又提高吞吐量。 实现Java可以使用finally语句块来防止忘记释放锁。 Thread-Per-Message模式 语境当线程（Client角色）要调用实例（Host角色）的方法时。 问题在方法的处理结束前，程序的控制权无法从Host角色中返回。如果方法的处理需要花费很长时间，响应性会下降。 解决方案在Host角色中启动一个新线程。接着，将方法需要执行的实际处理交给这个新启动的线程负责。这样，Client角色的线程就可以继续向前处理。这样修改后，可以在不改变Client角色的前提下提高响应性。 实现Java可以使用匿名内部类来轻松地启动新线程。 Worker Thread模式 语境当线程（Client角色）要调用实例（Host角色）的方法时。 问题如果方法的处理需要花费很长时间，响应性会下降。如果为了提高响应性而启动了一个新的线程并让它负责方法的处理，那么吞吐量会随线程的启动时间相应下降。另外，当要发出许多请求时，许多线程会启动，容量会因此下降。 解决方案首先，启动执行处理的线程（工人线程）。接着，将代表请求的实例传递给工人线程。这样，就无需每次都启动新线程了。 Future模式 语境当一个线程（Client角色）向其他线程委托了处理，而Client角色也想要获取处理结果时。 问题如果在委托处理时等待执行结果，响应性会下降。 解决方案首先，编写一个与处理结果具有相同接口（API）的Future角色。接着，在处理开始时返回Future角色，稍后再将处理结果设置到Future角色中。这样，Client角色就可以通过Future角色在自己觉得合适的时机获取（等待）处理结果。 Two-Phase Termination模式 语境当想要终止正在运行的线程时。 问题如果因为外部的原因紧急终止了线程，就会失去安全性。 解决方案首先，让即将被终止的线程自己去判断开始终止处理的时间点。为此，需要准备一个方法，来表示让该线程终止的“终止请求”。该方法执行的处理仅仅是设置“终止请求已经到来”这个闭锁。线程会在可以安全地开始终止处理之前检查该闭锁。如果检查结果是终止请求已经到来，线程就会开始执行终止处理。 实现Java不仅仅要设置终止请求的标志，还要使用interrupt方法来中断wait方法、sleep方法和join方法。由于线程在wait方法、sleep方法和join方法中抛出InterruptedException异常时会清除中断状态，所以在使用isInterrupted方法检查终止请求是否到来时需要格外注意。当想要实现即使在运行时发生异常也能进行终止处理时，可以使用finally语句块。 Thread-Specific Storage模式 语境当想让原本为单线程环境设计的对象（TSObject角色）运行于多线程环境时。 问题复用TSObject角色是非常困难的。即使是修改TSObject角色，让其可以运行于多线程环境，稍不注意还是会失去安全性和生存性。而且，可能根本就无法修改TSObject角色。另外，由于不想修改使用TSObject角色的对象（Client角色）的代码，所以也不想改变TSObject角色的接口。 解决方案创建每个线程所特有的存储空间，让存储空间与线程一一对应并进行管理。首先，编写一个与TSObject角色具有相同接口的TSObjectProxy角色。另外，为了能够管理“Client角色-&gt;TSObject角色”之间的对应表，还需要编写一个TSObjectCollection角色。TSObjectProxy角色使用TSObjectCollection角色来获取与当前线程对应的TSObject角色，并将处理委托给该TSObject角色。Client角色不再直接使用TSObject角色，取而代之的是TSObjectProxy角色。这样修改后，一个TSObject角色一定只会被一个线程调用，因此无需在TSObject角色中进行互斥处理。关于多线程的部分被全部隐藏在了TSObjectCollection角色内部。另外，也无需改变TSObject角色的接口。不过，在使用Thread-Specific Storage模式后，上下文会被隐式地引入到程序中，这会导致难以彻底地理解整体代码。 实现Java可以使用java.lang.ThreadLocal类来扮演TSObjectCollection角色。 Active Object模式 语境假设现在有处理请求的线程（Client角色）和包含了处理内容的对象（Servant角色），而且Servant角色只能运行于单线程环境。 问题虽然多个Client角色都想要调用Servant角色，但是Servant角色并不是线程安全的。希望，即使Servant角色的处理需要很长时间，它对Client角色的响应性也不会下降。处理的请求顺序和执行顺序并不一定相同。处理的结果需要返回给Client角色。 解决方案需要构建一个可以接收异步消息，而且与Client运行于不同线程的主动对象。首先，引入一个Scheduler角色的线程。调用Servant角色的只能是这个Scheduler角色。这是一种只有一个工人线程的Worker Thread模式。这样修改后，就可以既不用修改Servant角色去对应多线程，又可以让其可以被多个Client处理。接下来需要将来自Client角色的请求实现为对Proxy角色的方法调用。Proxy角色将一个请求转换为一个对象，使用Producer-Consumer模式将其传递给Scheduler角色。这样修改后，即使Servant角色的处理需要花费很长时间，Client角色的响应性也不会下降。选出下一个要执行的请求并执行——这是Scheduler角色的工作。这样修改后，Scheduler角色就可以决定请求的执行顺序了。最后，使用Future模式将执行结果返回给Client角色。]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.util.concurrent包和Producer-Consumer模式]]></title>
    <url>%2F2018%2F12%2F21%2Fjava-util-concurrent%E5%8C%85%E5%92%8CProducer-Consumer%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[java.util.concurrent包中的队列java.util.concurrent包提供了BlockingQueue接口及其实现类，它们相当于Producer-Consumer模式中的Channel角色。 类图 BlockingQueue接口——阻塞队列BlockingQueue接口表示的是在达到合适的状态之前线程一直阻塞（wait）的队列。BlockingQueue是java.util.Queue接口的子接口，拥有offer方法和poll方法等。但实际上，实现“阻塞”功能的方法是BlockingQueue接口固有的put方法和take方法。 ArrayBlockingQueue类——基于数组的BlockingQueueArrayBlockingQueue类表示的是元素个数有最大限制的BlockingQueue。该类基于数组，当数组满了但仍要put数据时，或者数组为空但仍要take数据时，线程就会阻塞。 LinkedBlockingQueue类——基于链表的BlockingQueueLinkedBlockingQueue类表示的是元素个数没有最大限制的BlockingQueue。该类基于链表，如果没有特别指定，元素个数将没有最大限制。只要还有内存，就可以put数据。 PriorityBlockingQueue类——带有优先级的BlockingQueuePriorityBlockingQueue类表示的是带有优先级的BlockingQueue。数据的“优先级”是依据Comparable接口的自然排序，或者构造函数的Comparator接口决定的顺序指定的。 DelayQueue类——一定时间之后才可以take的BlockingQueueDelayQueue类表示的是用于存储java.util.concurrent.Delayed对象的队列。当从该队列take时，只有在各元素指定的时间到期后才可以take。另外，到期时间最长的元素将先被take。 SynchronousQueue类——直接传递的BlockingQueueSynchronousQueue类表示的是BlockingQueue，该BlockingQueue用于执行由Producer角色到Consumer角色的“直接传递”。如果Producer角色先put，在Consumer角色take之前，Producer角色的线程将一直阻塞。相反，如果Consumer角色先take，在Producer角色put之前，Consumer角色的线程将一直阻塞。 ConcurrentLinkedQueue类——元素个数没有最大限制的线程安全队列ConcurrentLinkedQueue类并不是BlockingQueue的实现类，它表示的是元素个数没有最大限制的线程安全队列。在ConcurrentLinkedQueue中，内部的数据结构是分开的，线程之间互不影响，所以也就无需执行互斥处理。根据线程情况的不同，有时程序的性能也会有所提高。 使用java.util.concurrent.ArrayBlockingQueueArrayBlockingQueue是一个泛型类，可以通过参数类型来指定队列中添加的元素类型。 Table.java12345678910111213141516171819import java.util.concurrent.ArrayBlockingQueue;public class Table extends ArrayBlockingQueue&lt;String&gt; &#123; public Table(int count) &#123; super(count); &#125; public void put(String cake) throws InterruptedException &#123; System.out.println(Thread.currentThread().getName() + " puts " + cake); super.put(cake); &#125; public String take() throws InterruptedException &#123; String cake = super.take(); System.out.println(Thread.currentThread().getName() + " takes " + cake); return cake; &#125;&#125; 使用java.util.concurrent.Exchanger类交换缓冲区使用java.util.concurrent.Exchanger类用于让两个线程安全地交换对象。 Main.java123456789101112import java.util.concurrent.Exchanger;public class Main &#123; public static void main(String[] args) &#123; Exchanger&lt;char[]&gt; exchanger = new Exchanger&lt;&gt;(); char[] buffer1 = new char[10]; char[] buffer2 = new char[10]; new ProducerThread(exchanger, buffer1, 314159).start(); new ConsumerThread(exchanger, buffer2, 265358).start(); &#125;&#125; ProducerThread.javaProducerThread循环执行如下操作： 填充字符，直至缓冲区被填满 使用exchange方法将填满的缓冲区传递给ConsumerThread 传递缓冲区后，作为交换，接收空的缓冲区 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Random;import java.util.concurrent.Exchanger;public class ProducerThread extends Thread &#123; private final Exchanger&lt;char[]&gt; exchanger; private char[] buffer = null; private char index = 0; private final Random random; public ProducerThread(Exchanger&lt;char[]&gt; exchanger, char[] buffer, long seed) &#123; super("ProducerThread"); this.exchanger = exchanger; this.buffer = buffer; this.random = new Random(seed); &#125; public void run() &#123; try &#123; while (true) &#123; for (int i = 0; i &lt; buffer.length; i++) &#123; buffer[i] = nextChar(); System.out.println(Thread.currentThread().getName() + ": " + buffer[i] + " -&gt; "); &#125; System.out.println(Thread.currentThread().getName() + ": BEFORE exchange"); buffer = exchanger.exchange(buffer); System.out.println(Thread.currentThread().getName() + ": AFTER exchange"); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; private char nextChar() throws InterruptedException &#123; char c = (char)('A' + index % 26); index++; Thread.sleep(random.nextInt(1000)); return c; &#125;&#125; ConsumerThread.javaConsumerThread循环执行如下操作： 使用exchange方法将空的缓冲区传递给ProducerThread 传递空的缓冲区后，作为交换，接收被填满字符的缓冲区 使用缓冲区中的字符 1234567891011121314151617181920212223242526272829303132import java.util.Random;import java.util.concurrent.Exchanger;public class ConsumerThread extends Thread &#123; private final Exchanger&lt;char[]&gt; exchanger; private char[] buffer = null; private final Random random; public ConsumerThread(Exchanger&lt;char[]&gt; exchanger, char[] buffer, long seed) &#123; super("ConsumerThread"); this.exchanger = exchanger; this.buffer = buffer; this.random = new Random(seed); &#125; public void run() &#123; try &#123; while (true) &#123; System.out.println(Thread.currentThread().getName() + ": BEFORE exchange"); buffer = exchanger.exchange(buffer); System.out.println(Thread.currentThread().getName() + ": AFTER exchange"); for (int i = 0; i &lt; buffer.length; i++) &#123; System.out.println(Thread.currentThread().getName() + ": -&gt; " + buffer[i]); Thread.sleep(random.nextInt(1000)); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Timethreads图 运行结果12345678910111213141516171819202122232425262728293031323334353637383940414243ConsumerThread: BEFORE exchangeProducerThread: A -&gt; ProducerThread: B -&gt; ProducerThread: C -&gt; ProducerThread: D -&gt; ProducerThread: E -&gt; ProducerThread: F -&gt; ProducerThread: G -&gt; ProducerThread: H -&gt; ProducerThread: I -&gt; ProducerThread: J -&gt; ProducerThread: BEFORE exchangeProducerThread: AFTER exchangeConsumerThread: AFTER exchangeConsumerThread: -&gt; AConsumerThread: -&gt; BProducerThread: K -&gt; ConsumerThread: -&gt; CProducerThread: L -&gt; ProducerThread: M -&gt; ConsumerThread: -&gt; DProducerThread: N -&gt; ConsumerThread: -&gt; EProducerThread: O -&gt; ConsumerThread: -&gt; FProducerThread: P -&gt; ConsumerThread: -&gt; GProducerThread: Q -&gt; ConsumerThread: -&gt; HProducerThread: R -&gt; ConsumerThread: -&gt; IConsumerThread: -&gt; JConsumerThread: BEFORE exchangeProducerThread: S -&gt; ProducerThread: T -&gt; ProducerThread: BEFORE exchangeProducerThread: AFTER exchangeConsumerThread: AFTER exchangeConsumerThread: -&gt; KConsumerThread: -&gt; LConsumerThread: -&gt; MProducerThread: U -&gt; ProducerThread: V -&gt;]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map与JavaBean之间相互转化]]></title>
    <url>%2F2018%2F12%2F17%2FMap%E4%B8%8EJavaBean%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[反射可以操作各种不同的Java类，而内省只是通过反射来操作JavaBean的。 内省12345678910111213141516171819202122232425262728293031323334353637383940public Map&lt;String, Object&gt; beanToMap(Object bean) &#123; Map&lt;String, Object&gt; map = new HashMap(); try &#123; BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass(), Object.class); PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : propertyDescriptors) &#123; String key = propertyDescriptor.getName(); Object value = propertyDescriptor.getReadMethod().invoke(bean); map.put(key, value); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return map;&#125;public &lt;T&gt; T mapToBean(Map&lt;String, Object&gt; map, Class&lt;T&gt; beanType) &#123; T bean = null; try &#123; bean = beanType.newInstance(); BeanInfo beanInfo = Introspector.getBeanInfo(beanType, Object.class); PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : propertyDescriptors) &#123; String key = propertyDescriptor.getName(); Object value = map.get(key); propertyDescriptor.getWriteMethod().invoke(bean, value); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bean;&#125; 反射12345678910111213141516171819202122232425262728293031323334353637383940public Map&lt;String, Object&gt; beanToMap(Object bean) &#123; Map&lt;String, Object&gt; map = new HashMap(); try &#123; Class cls = bean.getClass(); Field[] fields = cls.getDeclaredFields(); for (Field field : fields) &#123; field.setAccessible(true); String key = field.getName(); Object value = field.get(bean); map.put(key, value); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return map;&#125;public &lt;T&gt; T mapToBean(Map&lt;String, Object&gt; map, Class&lt;T&gt; beanType) &#123; T bean = null; try &#123; bean = beanType.newInstance(); for (String key : map.keySet()) &#123; Object value = map.get(key); Field field = beanType.getDeclaredField(key); field.setAccessible(true); field.set(bean, value); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bean;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InterruptedException异常]]></title>
    <url>%2F2018%2F12%2F14%2FInterruptedException%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[如果方法后面加了throws InterruptedException，则表明该方法中（或者该方法进一步调用的方法中）可能会抛出InterruptedException异常。 加了throws InterruptedException的方法在Java的标准类库中，加了throws InterruptedException的典型方法有如下三个： java.lang.Object类的wait方法 java.lang.Thread类的sleep方法 java.lang.Thread类的join方法 花费时间的方法线程执行wait方法后，会进入等待队列，等待被notify/notifyAll。在等待期间，线程是不运行的，但需要花费时间来等待被notify/notifyAll。线程执行sleep方法后，会暂停执行（暂停多长时间由参数指定）。这也是花费时间的方法。线程执行join方法后，会等待指定线程终止。该方法需要花费时间，来等待指定线程终止。 可以取消的方法花费时间的处理会降低程序的响应性，所以如果存在像下面这样可以中途停止执行（取消）的方法，就非常方便了。 取消“wait方法等待notify/notifyAll”的处理 取消“在sleep方法指定的时间内停止执行”的处理 取消“join方法等待其他线程终止”的处理 sleep方法和interrupt方法使用的interrupt方法是Thread类的实例方法。当执行interrupt时，线程并不需要获取Thread实例的锁。无论何时，任何线程都可以调用其他线程的interrupt方法。interrupt方法被调用后，正在sleep的线程会终止暂停状态，抛出InterruptedException异常。这样，线程的控制权就会转移到捕捉该异常的catch语句块中。 wait方法和interrupt方法当使用interrupt方法时，该操作意即告诉正在wait的线程“不用再等待notify/notifyAll了，从等待队列出来吧”。但在wait的情况下，需要注意锁的问题。线程在进入等待队列时，已经释放了锁。当正在wait的线程被调用interrupt方法时（即线程被取消执行时），该线程会在重新获取锁之后，抛出InterruptedException异常。在获取锁之前，线程不会抛出InterruptedException异常。 join方法和interrupt方法由于调用join方法时无需获取锁，所以与使用sleep暂停运行时一样，线程的控制权也会立即跳到catch语句块中。 interrupt方法只是改变中断状态所谓中断状态（interrupted status），是一种用于表示线程是否被中断的状态。interrupt方法只是改变了线程的中断状态而已。当线程A执行了sleep、wait、join而停止运行时，线程B调用了A的interrupt方法。这时，线程A的确会抛出InterruptedException异常。但这其实是因为sleep、wait、join方法内部对线程的中断状态进行了检查，进而抛出了InterruptedException异常。如果没有调用sleep、wait、join等方法，或者没有编写检查线程的中断状态并抛出InterruptedException异常的代码，那么InterruptedException异常就不会被抛出。 isInterrupted方法——检查中断状态isInterrupted是Thread类的实例方法，用于检查指定线程的中断状态。若指定线程处于中断状态，则返回true；若指定线程未处于中断状态（即处于非中断状态），则返回false。isInterrupted并不会改变中断状态。 Thread.interrupted方法——检查并清除中断状态Thread.interrupted是Thread类的静态方法，用于检查并清除当前线程的中断状态。若当前线程处于中断状态，则返回true；若当前线程未处于中断状态，则返回false。调用Thread.interrupted后，中断状态会被清除（线程变为非中断状态）。只有这个方法才可以清除中断状态。Thread.interrupted的操作对象是当前线程（即线程本身），所以该方法并不能用于清除其他线程的中断状态。]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解Java多线程设计模式】Producer-Consumer模式]]></title>
    <url>%2F2018%2F11%2F29%2F%E3%80%90%E5%9B%BE%E8%A7%A3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Producer-Consumer%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[生产者安全地将数据交给消费者。Producer-Consumer模式在生产者和消费者之间加入了一个“桥梁角色”。该桥梁角色用于消除线程间处理速度的差异。 示例有3位糕点师制作蛋糕并将其放到桌子上，然后有3位客人来吃这些蛋糕。 时序图 Main.java123456789101112public class Main &#123; public static void main(String[] args) &#123; Table table = new Table(3); new MakerThread("MakerThread-1", table, 31415).start(); new MakerThread("MakerThread-2", table, 92653).start(); new MakerThread("MakerThread-3", table, 58979).start(); new EaterThread("EaterThread-1", table, 32384).start(); new EaterThread("EaterThread-2", table, 62643).start(); new EaterThread("EaterThread-3", table, 38327).start(); &#125;&#125; MakerThread.java12345678910111213141516171819202122232425262728import java.util.Random;public class MakerThread extends Thread &#123; private final Table table; private static int id = 0; private final Random random; public MakerThread(String name, Table table, long seed) &#123; super(name); this.table = table; this.random = new Random(seed); &#125; public void run() &#123; try &#123; while (true) &#123; Thread.sleep(random.nextInt(1000)); String cake = "[ Cake No." + nextId() + " by " + getName() + " ]"; table.put(cake); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125; private static synchronized int nextId() &#123; return id++; &#125;&#125; EaterThread.java12345678910111213141516171819202122import java.util.Random;public class EaterThread extends Thread &#123; private final Table table; private final Random random; public EaterThread(String name, Table table, long seed) &#123; super(name); this.table = table; this.random = new Random(seed); &#125; public void run() &#123; try &#123; while (true) &#123; String cake = table.take(); Thread.sleep(random.nextInt(1000)); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125; Table.java1234567891011121314151617181920212223242526272829303132333435363738public class Table &#123; private final String[] buffer; private int head; private int tail; private int count; public Table(int count) &#123; this.buffer = new String[count]; this.head = 0; this.tail = 0; this.count = 0; &#125; public synchronized void put(String cake) throws InterruptedException &#123; while (count &gt;= buffer.length) &#123; wait(); &#125; System.out.println(Thread.currentThread().getName() + " puts " + cake); buffer[tail] = cake; tail = (tail + 1) % buffer.length; count++; notifyAll(); &#125; public synchronized String take() throws InterruptedException &#123; while (count &lt;= 0) &#123; wait(); &#125; String cake = buffer[head]; head = (head + 1) % buffer.length; count--; notifyAll(); System.out.println(Thread.currentThread().getName() + " takes " + cake); return cake; &#125;&#125; 运行结果12345678910111213141516171819202122232425262728293031323334MakerThread-3 puts [ Cake No.20 by MakerThread-3 ]EaterThread-3 takes [ Cake No.20 by MakerThread-3 ]MakerThread-2 puts [ Cake No.21 by MakerThread-2 ]MakerThread-1 puts [ Cake No.22 by MakerThread-1 ]EaterThread-3 takes [ Cake No.21 by MakerThread-2 ]EaterThread-1 takes [ Cake No.22 by MakerThread-1 ]MakerThread-3 puts [ Cake No.23 by MakerThread-3 ]EaterThread-2 takes [ Cake No.23 by MakerThread-3 ]MakerThread-1 puts [ Cake No.24 by MakerThread-1 ]MakerThread-2 puts [ Cake No.25 by MakerThread-2 ]EaterThread-3 takes [ Cake No.24 by MakerThread-1 ]EaterThread-3 takes [ Cake No.25 by MakerThread-2 ]MakerThread-2 puts [ Cake No.26 by MakerThread-2 ]MakerThread-1 puts [ Cake No.27 by MakerThread-1 ]EaterThread-1 takes [ Cake No.26 by MakerThread-2 ]EaterThread-2 takes [ Cake No.27 by MakerThread-1 ]MakerThread-2 puts [ Cake No.28 by MakerThread-2 ]EaterThread-2 takes [ Cake No.28 by MakerThread-2 ]MakerThread-3 puts [ Cake No.29 by MakerThread-3 ]EaterThread-3 takes [ Cake No.29 by MakerThread-3 ]MakerThread-2 puts [ Cake No.30 by MakerThread-2 ]EaterThread-1 takes [ Cake No.30 by MakerThread-2 ]MakerThread-2 puts [ Cake No.31 by MakerThread-2 ]MakerThread-1 puts [ Cake No.32 by MakerThread-1 ]MakerThread-3 puts [ Cake No.33 by MakerThread-3 ]EaterThread-1 takes [ Cake No.31 by MakerThread-2 ]MakerThread-1 puts [ Cake No.34 by MakerThread-1 ]EaterThread-2 takes [ Cake No.32 by MakerThread-1 ]EaterThread-3 takes [ Cake No.33 by MakerThread-3 ]MakerThread-1 puts [ Cake No.35 by MakerThread-1 ]EaterThread-2 takes [ Cake No.34 by MakerThread-1 ]EaterThread-1 takes [ Cake No.35 by MakerThread-1 ]MakerThread-2 puts [ Cake No.36 by MakerThread-2 ]EaterThread-1 takes [ Cake No.36 by MakerThread-2 ] 登场角色DataData角色由Producer角色生成，供Consumer角色使用。在示例程序中，由String类扮演此角色。 Producer（生产者）Producer角色生成Data角色，并将其传递给Channel角色。在示例程序中，由MakerThread扮演此角色。 Consumer（消费者）Consumer角色从Channel角色获取Data角色并使用。在示例程序中，由EaterThread扮演此角色。 Channel（通道）Channel角色保管从Producer角色获取的Data角色，还会响应Consumer角色的请求，传递Data角色。为了确保安全性，Channel角色会对Producer角色和Consumer角色的访问执行互斥处理。当Producer角色将Data角色传递给Channel角色时，如果Channel角色的状态不适合接收Data角色，那么Producer角色将一直等待，直至Channel角色的状态变为可以接收为止。当Consumer角色从Channel角色获取Data角色时，如果Channel角色中没有可以传递的Data角色，那么Consumer角色将一直等待，直至Channel的状态变为可以传递Data角色为止。在示例程序中，由Table类扮演此角色。 类图]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超时]]></title>
    <url>%2F2018%2F11%2F22%2F%E8%B6%85%E6%97%B6%2F</url>
    <content type="text"><![CDATA[介于“直接balk并返回”和“等待到守护条件成立为止”这两种极端的处理方法之间，还有一种处理方法，那就是“在守护条件成立之前等待一段时间”。在守护条件成立之前等待一段时间，如果到时条件还未成立，则直接balk。将这种处理称为guarded timed或timeout。 wait何时终止在调用Java的wait方法时，可以传入参数，以指定超过时间。线程进入obj的等待队列，停止运行，并释放持有的obj锁。当下列情况发生时，线程便会退出等待队列。 notify方法执行时即obj的notify方法被执行后，线程被唤醒了的情况。但当等待队列中有多个等待线程时，只能有一个线程被唤醒。到底唤醒哪一个线程，Java规范中并没有明确规定。 notifyAll方法执行时即obj的notifyAll方法被执行了的情况。notifyAll会唤醒实例的等待队列中的所有线程。不管是notify，还是notifyAll，线程被唤醒后，都必须重新获取obj的锁。 interrupt方法执行时即线程的interrupt方法被执行了的情况。当被interrupt时，等待队列中的线程（与被notify、notifyAll时一样）会重新获取obj的锁，然后抛出InterruptedException异常。notify和notifyAll这两个方法是用于调用实例的，而interrupt方法是用于调用线程的。 超时发生时即wait方法的参数中指定的超时时间到期的情况。与被notify、notifyAll时一样，这时也要重新获取obj的锁。 guarded timed的实现使用wait方法来实现guarded timed。超时异常使用java.util.concurrent.TimeoutException。 Host.java123456789101112131415161718192021222324252627282930313233343536import java.util.concurrent.TimeoutException;public class Host &#123; private final long timeout; private boolean ready = false; public Host(long timeout) &#123; this.timeout = timeout; &#125; public synchronized void setExecutable(boolean on) &#123; ready = on; notifyAll(); &#125; public synchronized void execute() throws InterruptedException, TimeoutException &#123; long start = System.currentTimeMillis(); while (!ready) &#123; long now = System.currentTimeMillis(); long rest = timeout - (now - start); if (rest &lt;= 0) &#123; throw new TimeoutException("now - start = " + (now - start) + ", timeout = " + timeout); &#125; wait(rest); &#125; doExecute(); &#125; private void doExecute() &#123; System.out.println(Thread.currentThread().getName() + " calls doExecute"); &#125;&#125; Main.java1234567891011121314151617import java.util.concurrent.TimeoutException;public class Main &#123; public static void main(String[] args) &#123; Host host = new Host(10000); try &#123; System.out.println("execute BEGIN"); host.execute(); &#125; catch (TimeoutException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果1234execute BEGINjava.util.concurrent.TimeoutException: now - start = 10004, timeout = 10000 at Host.execute(Host.java:24) at Main.main(Main.java:10) java.util.concurrent中的超时java.util.concurrent包中提供了如下两个用于超时处理的方法。 通过异常通知超时当发生超时抛出异常时，返回值并不适合用于表示超时，需要使用java.util.concurrent.TimeoutException异常。 java.util.concurrent.Future接口的get方法 java.util.concurrent.Exchanger类的exchange方法 java.util.concurrent.Cyclicarrier类的await方法 java.util.concurrent.CountDownLatch类的await方法 通过返回值通知超时当执行多次try时，则不使用异常，而是使用返回值来表示超时。 java.util.concurrent.BlockingQueue接口 java.util.concurrent.Semaphore类 java.util.concurrent.locks.lock接口]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解Java多线程设计模式】Balking模式]]></title>
    <url>%2F2018%2F11%2F21%2F%E3%80%90%E5%9B%BE%E8%A7%A3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Balking%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[如果现在不适合执行这个操作，或者没必要执行这个操作，就停止处理，直接返回。 示例定期将当前数据内容写入文件中。当数据内容被写入时，会完全覆盖上次写入的内容，只有最新的内容才会被保存。 时序图 Data.java123456789101112131415161718192021222324252627282930313233343536import java.io.FileWriter;import java.io.IOException;import java.io.Writer;public class Data &#123; private final String filename; private String content; private boolean changed; public Data(String filename, String content) &#123; this.filename = filename; this.content = content; this.changed = true; &#125; public synchronized void change(String newContent) &#123; content = newContent; changed = true; &#125; public synchronized void save() throws IOException &#123; if (!changed) &#123; return; &#125; doSave(); changed = false; &#125; private void doSave() throws IOException &#123; System.out.println(Thread.currentThread().getName() + " calls doSave, content = " + content); Writer writer = new FileWriter(filename); writer.write(content); writer.close(); &#125;&#125; SaverThread.java1234567891011121314151617181920212223import java.io.IOException;public class SaverThread extends Thread &#123; private final Data data; public SaverThread(String name, Data data) &#123; super(name); this.data = data; &#125; public void run() &#123; try &#123; while (true) &#123; data.save(); Thread.sleep(1000); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ChangerThread.java1234567891011121314151617181920212223242526import java.io.IOException;import java.util.Random;public class ChangerThread extends Thread &#123; private final Data data; private final Random random = new Random(); public ChangerThread(String name, Data data) &#123; super(name); this.data = data; &#125; public void run() &#123; try &#123; for (int i = 0; ; i++) &#123; data.change("No." + i); Thread.sleep(random.nextInt(1000)); data.save(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Main.java12345678public class Main &#123; public static void main(String[] args) &#123; Data data = new Data("data.txt", "(empty)"); new ChangerThread("ChangerThread", data).start(); new SaverThread("SaverThread", data).start(); &#125;&#125; 运行结果123456789101112SaverThread calls doSave, content = No.0SaverThread calls doSave, content = No.1ChangerThread calls doSave, content = No.2SaverThread calls doSave, content = No.3ChangerThread calls doSave, content = No.4SaverThread calls doSave, content = No.5ChangerThread calls doSave, content = No.6SaverThread calls doSave, content = No.7ChangerThread calls doSave, content = No.8SaverThread calls doSave, content = No.9ChangerThread calls doSave, content = No.10SaverThread calls doSave, content = No.11 登场角色GuardedObject（被防护的对象）GuardedObject角色是一个拥有被防护的方法（guardedMethod）的类。当线程执行guardedMethod方法时，若守护条件成立，则执行实际的处理。而当守护条件不成立时，则不执行实际的处理，直接返回。守护条件的成立与否，会随着GuardedObject角色的状态变化而发生变化。除了guardedMethod之外，GuardedObject角色还有可能有其他来改变状态的方法（stateChangingMethod）。在示例程序中，由Data类扮演此角色。save方法对应的是guardedMethod，change方法对应的则是stateChangingMethod。 类图 Timethreads图 balk结果的表示方式当从guardedMethod方法中balk并返回时，balk结果的表示方式有如下几种。 忽略balk最简单的方式就是不通知调用端“发生了balk”。 通过返回值来表示balk有时会通过boolean类型的值来表示balk。例如，若返回值为true，则表明未发生balk，处理被执行了，而如果为false，则表明发生了balk，处理并未被执行。返回值为引用类型的方法有时也会用null来表示“发生了balk”。 通过异常来表示balk的发生有时也可以通过异常来表示“发生了balk”。即，当balk发生时，程序并不是从方法中return，而是抛出异常。]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解Java多线程设计模式】Guarded Suspension模式]]></title>
    <url>%2F2018%2F11%2F15%2F%E3%80%90%E5%9B%BE%E8%A7%A3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Guarded-Suspension%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[如果执行现在的处理会造成问题，就让执行处理的线程进行等待。 示例一个线程（ClientThread）会将请求（Request）的实例传递给另一个线程（ServerThread），这是一种最简单的线程间通信。 时序图 Request.java123456789101112131415public class Request &#123; private final String name; public Request(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public String toString() &#123; return "[ Request " + name + " ]"; &#125;&#125; RequestQueue.java12345678910111213141516171819202122import java.util.LinkedList;import java.util.Queue;public class RequestQueue &#123; private final Queue&lt;Request&gt; queue = new LinkedList&lt;&gt;(); public synchronized void putRequest(Request request) &#123; queue.offer(request); notifyAll(); &#125; public synchronized Request getRequest() &#123; while (queue.peek() == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; return queue.remove(); &#125;&#125; ClientThread.java12345678910111213141516171819202122232425import java.util.Random;public class ClientThread extends Thread &#123; private final RequestQueue requestQueue; private final Random random; public ClientThread(RequestQueue requestQueue, String name, long seed) &#123; super(name); this.requestQueue = requestQueue; this.random = new Random(seed); &#125; public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; Request request = new Request("No." + i); System.out.println(Thread.currentThread().getName() + " requests " + request); requestQueue.putRequest(request); try &#123; Thread.sleep(random.nextInt(1000)); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;&#125; ServerThread.java123456789101112131415161718192021222324import java.util.Random;public class ServerThread extends Thread &#123; private final RequestQueue requestQueue; private final Random random; public ServerThread(RequestQueue requestQueue, String name, long seed) &#123; super(name); this.requestQueue = requestQueue; this.random = new Random(seed); &#125; public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; Request request = requestQueue.getRequest(); System.out.println(Thread.currentThread().getName() + " handles " + request); try &#123; Thread.sleep(random.nextInt(1000)); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;&#125; Main.java12345678public class Main &#123; public static void main(String[] args) &#123; RequestQueue requestQueue = new RequestQueue(); new ClientThread(requestQueue, "Alice", 3141592L).start(); new ServerThread(requestQueue, "Bobby", 6535897L).start(); &#125;&#125; 运行结果1234567891011121314Alice requests [ Request No.0 ]Bobby handles [ Request No.0 ]Alice requests [ Request No.1 ]Alice requests [ Request No.2 ]Bobby handles [ Request No.1 ]Bobby handles [ Request No.2 ]Alice requests [ Request No.3 ]Bobby handles [ Request No.3 ]Alice requests [ Request No.4 ]Bobby handles [ Request No.4 ]Alice requests [ Request No.5 ]Alice requests [ Request No.6 ]Bobby handles [ Request No.5 ]Bobby handles [ Request No.6 ] 登场角色GuardedObject（被守护的对象）GuardedObject角色是一个持有被守护的方法（guardedMethod）的类。当线程执行guardedMethod方法时，若守护条件成立，则可以立即执行；当守护条件不成立时，就要进行等待。守护条件的成立与否会随着GuardedObject角色的状态不同而发生变化。除了guardedMethod之外，GuardedObject角色还有可能持有其他改变实例状态（特别是改变守护条件）的方法（stateChangingMethod）。在Java中，guardedMethod通过while语句和wait方法来实现，stateChangingMethod则通过notify/notifyAll方法来实现。在示例程序中，由RequestQueue类扮演此角色。getRequest方法对应guardedMethod，putRequest方法则对应stateChangingMethod。 类图 Timethreads图 使用java.util.concurrent.LinkedBlockingQueueRequestQueue.java123456789101112131415161718192021222324import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;public class RequestQueue &#123; private final BlockingQueue&lt;Request&gt; queue = new LinkedBlockingQueue&lt;&gt;(); public void putRequest(Request request) &#123; try &#123; queue.put(request); &#125; catch (InterruptedException e) &#123; &#125; &#125; public Request getRequest() &#123; Request request = null; try &#123; request = queue.take(); &#125; catch (InterruptedException e) &#123; &#125; return request; &#125;&#125; 类图]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合类与多线程]]></title>
    <url>%2F2018%2F11%2F13%2F%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[非线程安全的java.util.ArrayList类Main.java1234567891011import java.util.ArrayList;import java.util.List;public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); new WriterThread(list).start(); new ReaderThread(list).start(); &#125;&#125; WriterThread.java1234567891011121314151617import java.util.List;public class WriterThread extends Thread &#123; private final List&lt;Integer&gt; list; public WriterThread(List&lt;Integer&gt; list) &#123; super("WriterThread"); this.list = list; &#125; public void run() &#123; for (int i = 0; ; i++) &#123; list.add(i); list.remove(0); &#125; &#125;&#125; ReaderThread.java123456789101112131415161718import java.util.List;public class ReaderThread extends Thread &#123; private final List&lt;Integer&gt; list; public ReaderThread(List&lt;Integer&gt; list) &#123; super("ReaderThread"); this.list = list; &#125; public void run() &#123; while (true) &#123; for (int n : list) &#123; System.out.println(n); &#125; &#125; &#125;&#125; result1234Exception in thread "ReaderThread" java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851) at ReaderThread.run(ReaderThread.java:13) 利用Collections.synchronizedList方法所进行的同步Main.java123456789101112import java.util.ArrayList;import java.util.Collections;import java.util.List;public class Main &#123; public static void main(String[] args) &#123; final List&lt;Integer&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); new WriterThread(list).start(); new ReaderThread(list).start(); &#125;&#125; ReaderThread.java1234567891011121314151617181920import java.util.List;public class ReaderThread extends Thread &#123; private final List&lt;Integer&gt; list; public ReaderThread(List&lt;Integer&gt; list) &#123; super("ReaderThread"); this.list = list; &#125; public void run() &#123; while (true) &#123; synchronized(list) &#123; for (int n : list) &#123; System.out.println(n); &#125; &#125; &#125; &#125;&#125; 使用copy-on-write的java.util.concurrent.CopyOnWriteArrayList类Main.java1234567891011import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;public class Main &#123; public static void main(String[] args) &#123; final List&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;(); new WriterThread(list).start(); new ReaderThread(list).start(); &#125;&#125; 比较使用copy-on-write时，每次执行“写”操作都会执行复制。因此，程序频繁执行“写”操作时，如果使用CopyOnWriteArrayList，会比较花费时间。但如果写操作比较少，而读操作频率非常高时，使用CopyOnWriteArrayList是非常棒的。]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解Java多线程设计模式】Immutable模式]]></title>
    <url>%2F2018%2F11%2F12%2F%E3%80%90%E5%9B%BE%E8%A7%A3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Immutable%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Immutable模式中存在着确保实例状态不发生改变的类（immutable类）。在访问这些实例时并不需要执行耗时的互斥处理，能提高程序性能。 示例Person.java123456789101112131415161718192021public class Person &#123; private final String name; private final String address; public Person(String name, String address) &#123; this.name = name; this.address = address; &#125; public String getName() &#123; return name; &#125; public String getAddress() &#123; return address; &#125; public String toString() &#123; return "[ Person: name = " + name + ", address = " + address + " ]"; &#125; &#125; Main.java123456789public class Main &#123; public static void main(String[] args) &#123; Person alice = new Person("Alice", "Alaska"); new PrintPersonThread(alice).start(); new PrintPersonThread(alice).start(); new PrintPersonThread(alice).start(); &#125;&#125; PrintPersonThread.java12345678910111213public class PrintPersonThread extends Thread &#123; private Person person; public PrintPersonThread(Person person) &#123; this.person = person; &#125; public void run() &#123; while (true) &#123; System.out.println(Thread.currentThread().getName() + " prints " + person); &#125; &#125;&#125; 登场角色Immutable（不可变的）Immutable角色是一个类，在这个角色中，字段的值不可以修改，也不存在修改字段内容的方法。Immutable角色的实例被创建后，状态将不再发生变化。这时，无需对Immutable角色应用Single Threaded Execution模式。也就是说，无需将Immutable角色的方法声明为synchronized。在示例程序中，由Person类扮演此角色。 类图 Timethreads图]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计数信号量]]></title>
    <url>%2F2018%2F11%2F06%2F%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Semaphore的acquire方法用于确保存在可用资源。当存在可用资源时，线程会立即从acquire方法返回，同时信号量内部的资源个数会减1.如无可用资源，线程则阻塞在acquire方法内，直至出现可用资源。Semaphore的release方法用于释放资源。释放资源后，信号量内部的资源个数会增加1。另外，如果acquire中存在等待的线程， 示例多个线程使用数量有限的资源。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.Random;import java.util.concurrent.Semaphore;public class Main &#123; public static void main(String[] args) &#123; BoundedResource resource = new BoundedResource(3); for (int i = 0; i &lt; 10; i++) &#123; new UserThread(resource).start(); &#125; &#125;&#125;class UserThread extends Thread &#123; private final BoundedResource resource; private final static Random random = new Random(26535); public UserThread(BoundedResource resource) &#123; this.resource = resource; &#125; public void run() &#123; try &#123; while (true) &#123; resource.use(); Thread.sleep(random.nextInt(3000)); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125;class BoundedResource &#123; private final int permits; private final Semaphore semaphore; private final static Random random = new Random(314159); public BoundedResource(int permits) &#123; this.semaphore = new Semaphore(permits); this.permits = permits; &#125; public void use() throws InterruptedException &#123; semaphore.acquire(); try &#123; doUse(); &#125; finally &#123; semaphore.release(); &#125; &#125; protected void doUse() throws InterruptedException &#123; Log.println("BEGIN: used = " + (permits - semaphore.availablePermits())); Thread.sleep(random.nextInt(500)); Log.println("END: used = " + (permits - semaphore.availablePermits())); &#125;&#125;class Log &#123; public static void println(String s) &#123; System.out.println(Thread.currentThread().getName() + ": " + s); &#125;&#125; 运行结果1234567891011121314151617181920Thread-0: BEGIN: used = 1Thread-1: BEGIN: used = 2Thread-2: BEGIN: used = 3Thread-1: END: used = 3Thread-3: BEGIN: used = 3Thread-3: END: used = 3Thread-4: BEGIN: used = 3Thread-2: END: used = 3Thread-5: BEGIN: used = 3Thread-4: END: used = 3Thread-6: BEGIN: used = 3Thread-6: END: used = 3Thread-7: BEGIN: used = 3Thread-0: END: used = 3Thread-8: BEGIN: used = 3Thread-5: END: used = 3Thread-9: BEGIN: used = 3Thread-8: END: used = 3Thread-9: END: used = 2Thread-1: BEGIN: used = 2]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解Java多线程设计模式】Single Threaded Execution模式]]></title>
    <url>%2F2018%2F11%2F01%2F%E3%80%90%E5%9B%BE%E8%A7%A3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Single-Threaded-Execution%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[所谓Single Threaded Execution模式，意即“以一个线程执行”。该模式用于设置限制，以确保同一时间内只能让一个线程执行处理。 示例模拟三个人频繁地通过一个只允许一个人经过的门的情形。当人们通过门的时候，统计人数便会递增。另外，还会记录通行者的“姓名与出生地”。 Main.java1234567891011public class Main &#123; public static void main(String[] args) &#123; System.out.println("Testing Gate, hit CTRL+C to exit."); Gate gate = new Gate(); new UserThread(gate, "Alice", "Alaska").start(); new UserThread(gate, "Bobby", "Brazil").start(); new UserThread(gate, "Chris", "Canada").start(); &#125;&#125; UserThread.java12345678910111213141516171819public class UserThread extends Thread &#123; private final Gate gate; private final String myname; private final String myaddress; public UserThread(Gate gate, String name, String address) &#123; this.gate = gate; this.myname = name; this.myaddress = address; &#125; public void run() &#123; System.out.println(myname + " BEGIN"); while (true) &#123; gate.pass(myname, myaddress); &#125; &#125;&#125; Gate.java12345678910111213141516171819202122public class Gate &#123; private int counter = 0; private String name = "Nobody"; private String address = "Nowhere"; public synchronized void pass(String name, String address) &#123; this.counter++; this.name = name; this.address = address; check(); &#125; private void check() &#123; if (name.charAt(0) != address.charAt(0)) &#123; System.out.println("***** BROKEN ***** " + toString()); &#125; &#125; public synchronized String toString() &#123; return "No." + counter + ": " + name + ", " + address; &#125;&#125; 登场角色SharedResource（共享资源）Single Threaded Execution模式中出现了一个发挥SharedResource（共享资源）作用的类。在示例中，由Gate类扮演SharedResource角色。 SharedResource角色是可被多个线程访问的类，包含很多方法，但这些方法主要分为如下两类。 safeMethod：多个线程同时调用也不会发生问题的方法。 unsafeMethod：多个线程同时调用会发生问题，因此必须加以保护的方法。 Single Threaded Execution模式会保护unsafeMethod，使其同时只能由一个线程访问。Java则是通过将unsafeMethod声明为synchronized方法来进行保护。 类图 Timethreads图]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程的协作]]></title>
    <url>%2F2018%2F10%2F30%2F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8D%8F%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[等待队列所有实例都拥有一个等待队列，它是在实例的wait方法执行后停止操作的线程的队列。当下列任意一种情况发生时，线程便会退出等待队列。 有其他线程的notify方法来唤醒线程 有其他线程的notifyAll方法来唤醒线程 有其他线程的interrupt方法来唤醒线程 wait方法超时 wait方法——将线程放入等待队列获取了锁的线程A执行wait方法。 线程A进入等待队列，释放锁。 线程B能够获取锁。 notify方法——从等待队列中取出线程获取了锁的线程B执行notify方法。 线程A退出等待队列，想要进入wait的下一个操作，但刚才执行notify的线程B仍持有着锁。 刚才执行notify的线程B释放了锁。 退出等待队列的线程A获取锁，执行wait的下一个操作。 notifyAll方法——从等待队列中取出所有线程notifyAll方法唤醒所有线程，并让所有线程都退出等待队列。 由于notify唤醒的线程较少，所以处理速度要比使用notifyAll时快。但使用notify时，如果处理不好，程序便可能会停止。一般来说，使用notifyAll时的代码要比使用notify时的更为健壮。]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程的互斥]]></title>
    <url>%2F2018%2F10%2F30%2F%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5%2F</url>
    <content type="text"><![CDATA[Java使用关键字synchronized来执行线程的互斥处理。 synchronized方法如果声明一个方法时，在前面加上关键字synchronized，那么这个方法就只能由一个线程运行。这种方法称为synchronized方法，有时也成为同步方法。 Bank.java123456789101112131415161718192021222324252627public class Bank &#123; private int money; private String name; public Bank(String name, int money) &#123; this.name = name; this.money = money; &#125; public synchronized void deposit(int m) &#123; money += m; &#125; public synchronized boolean withdraw(int m) &#123; if (money &gt;= m) &#123; money -= m; return true; &#125; else &#123; return false; &#125; &#125; public String getName() &#123; return name; &#125;&#125; synchronized方法每次只能由一个线程运行。 线程运行完synchronized方法deposit后，释放锁。 获取锁的另一个线程开始运行synchronized方法。 synchronized实例方法和synchronized代码块1234567891011//synchronized实例方法synchronized void method() &#123; ...&#125;//synchronized代码块void method() &#123; synchronized(this) &#123; ... &#125;&#125; synchronized实例方法是使用this的锁来执行线程的互斥处理的。 synchronized静态方法和synchronized代码块123456789101112131415//synchronized静态方法class Something &#123; static synchronized void method() &#123; ... &#125;&#125;//synchronized代码块class Something &#123; static void method() &#123; synchronized(Something.class) &#123; ... &#125; &#125;&#125; synchronized静态方法是使用该类的类对象的锁来执行线程的互斥处理的。]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程的启动]]></title>
    <url>%2F2018%2F10%2F29%2F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[利用Thread类的子类创建Thread类的子类，创建子类的实例，调用start方法。 PrintThread.java12345678910111213public class PrintThread extends Thread &#123; private String message; public PrintThread(String message) &#123; this.message = message; &#125; public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; System.out.print(message); &#125; &#125;&#125; Main.java123456public class Main &#123; public static void main(String[] args) &#123; new PrintThread("Good!").start(); new PrintThread("Nice!").start(); &#125;&#125; 利用Runnable接口创建Runnable接口的实现类，将实现类的实例作为参数传给Thread的构造函数，调用start方法。 Printer.java12345678910111213public class Printer implements Runnable &#123; private String message; public Printer(String message) &#123; this.message = message; &#125; public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; System.out.print(message); &#125; &#125;&#125; Main.java123456public class Main &#123; public static void main(String[] args) &#123; new Thread(new Printer("Good!")).start(); new Thread(new Printer("Nice!")).start(); &#125;&#125; 补充java.util.concurrent包中包含一个将线程创建抽象化的ThreadFactory接口。利用该接口，可以将以Runnable作为传入参数并通过new创建Thread实例的处理隐藏在ThreadFactory内部。 Main.java12345678910import java.util.concurrent.Executors;import java.util.concurrent.ThreadFactory;public class Main &#123; public static void main(String[] args) &#123; ThreadFactory factory = Executors.defaultThreadFactory(); factory.newThread(new Printer("Good!")).start(); factory.newThread(new Printer("Nice!")).start(); &#125;&#125;]]></content>
      <categories>
        <category>Multithread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Downloader Middleware Demo]]></title>
    <url>%2F2018%2F10%2F12%2FDownloader-Middleware-Demo%2F</url>
    <content type="text"><![CDATA[核心方法每个Downloader Middleware都定义了一个或多个方法的类，核心的方法有如下三个。 process_request(request, spider) process_response(request, response, spider) process_exception(request, exception, spider) process_requestRequest被Scrapy引擎调度给Downloader之前，process_request()方法就会被调用，也就是在Request从队列里调度出来到Downloader下载执行之前，我们都可以用process_request()方法对Request进行处理。方法的返回值必须为None、Response对象、Request对象之一，或者抛出IgnoreRequest异常。 process_request()方法的参数有如下两个。 request，是Request对象，即被处理的Request。 spider，是Spider对象，即此Request对应的Spider。 process_responseDownloader执行Request下载之后，会得到对应的Response。Scrapy引擎便会将Response发送给Spider进行解析。在发送之前，我们都可以用process_response()方法来对Response进行处理。方法的返回值必须为Request对象、Response对象之一，或者抛出IgnoreRequest异常。 process_response()方法的参数有如下三个。 request，是Request对象，即此Response对应的Request。 response，是Response对象，即此被处理的Response。 spider，是Spider对象，即此Response对应的Spider。 process_exception当Downloader或process_request()方法抛出异常时，例如抛出IgnoreRequest异常，process_exception()方法就会被调用。方法的返回值必须为None、Response对象、Request对象之一。 process_exception()方法的参数有如下三个。 request，是Request对象，即产生异常的Request。 exception，是Exception对象，即抛出的异常。 spider，是Spider对象，即Request对应的Spider。 基本用法利用process_request()方法设置随机的User-Agent，使用process_response()方法修改Response的状态码。 Httpbin.py12345678910import scrapyclass HttpbinSpider(scrapy.Spider): name = 'Httpbin' allowed_domains = ['httpbin.org'] start_urls = ['http://httpbin.org/get'] def parse(self, response): self.logger.debug(response.text) self.logger.debug('Status Code: ' + str(response.status)) middlewares.py123456789101112131415import randomclass RandomUserAgentMiddleware(object): def __init__(self): self.user_agents = [ "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/11.1.1 Safari/605.1.15", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36" ] def process_request(self, request, spider): request.headers['User-Agent'] = random.choice(self.user_agents) def process_response(self, request, response, spider): response.status = 201 return response settings.py123DOWNLOADER_MIDDLEWARES = &#123; 'httpbin.middlewares.RandomUserAgentMiddleware': 543,&#125; result12345678910111213141516&#123; "args": &#123;&#125;, "headers": &#123; "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "Accept-Encoding": "gzip,deflate", "Accept-Language": "en", "Connection": "close", "Host": "httpbin.org", # "User-Agent": "Scrapy/1.5.0 (+https://scrapy.org)" "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36" &#125;, "origin": "218.82.103.201", "url": "http://httpbin.org/get"&#125;Status Code: 201]]></content>
      <categories>
        <category>Web Crawler</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web Crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy]]></title>
    <url>%2F2018%2F10%2F09%2FScrapy%2F</url>
    <content type="text"><![CDATA[架构 Engine: 引擎，处理整个系统的数据流处理、触发事务，是整个框架的核心。 Item: 项目，它定义了爬取结果的数据结构，爬取的数据会被赋值成该Item对象。 Scheduler: 调度器，接受引擎发过来的请求并将其加入队列中，在引擎再次请求的时候将请求提供给引擎。 Downloader: 下载器，下载网页内容，并将网页内容返回给蜘蛛。 Spiders: 蜘蛛，其内定义了爬取的逻辑和网页的解析规则，它主要负责解析响应并生成提取结果和新的请求。 Item Pipeline: 项目管道，负责处理由蜘蛛从网页中抽取的项目，它的主要任务是清洗、验证和存储数据。 Downloader Middlewares: 下载器中间件，位于引擎和下载器之间的钩子框架，主要处理引擎与下载器之间的请求及响应。 Spider Middlewares: 蜘蛛中间件，位于引擎和蜘蛛之间的钩子框架，主要处理蜘蛛输入的响应和输出的结果及新的请求。 数据流Scrapy中的数据流由引擎控制，数据流的过程如下: Engine首先打开一个网站，找到处理该网站的Spider，并向该Spider请求第一个要爬取的URL。 Engine从Spider中获取到第一个要爬取的URL，并通过Scheduler以Request的形式调度。 Engine向Scheduler请求下一个要爬取的URL。 Scheduler返回下一个要爬取的URL给Engine，Engine将URL通过Downloader Middlewares转发给Downloader下载。 一旦页面下载完毕，Downloader生成该页面的Response，并将其通过Downloader Middlewares发送给Engine。 Engine从下载器中接收到Response，并将其通过Spider Middlewares发送给Spider处理。 Spider处理Response，并返回爬取到的Item及新的Request给Engine。 Engine将Spider返回的Item给Item Pipeline，将新的Request给Scheduler。 重复第2步到第8步，直到Scheduler中没有更多的Request，Engine关闭该网站，爬取结束。通过多个组件的相互协作、不同组件完成工作的不同、组件对异步处理的支持，Scrapy最大限度地利用了网络带宽，大大提高了数据爬取和处理的效率。 文件 scrapy.cfg: 它是Scrapy项目的配置文件，其内定义了项目的配置文件路径、部署相关信息等内容。 items.py: 它定义Item数据结构，所有的Item的定义都可以放这里。 pipelines.py: 它定义Item Pipeline的实现，所有的Item Pipeline的实现都可以放这里。 settings.py: 它定义项目的全局配置。 middlewares.py: 它定义Spider Middlewares和Downloader Middlewares的实现。 spiders: 其内包含一个个Spider的实现，每个Spider都有一个文件。]]></content>
      <categories>
        <category>Web Crawler</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web Crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pyspider]]></title>
    <url>%2F2018%2F09%2F30%2FPyspider%2F</url>
    <content type="text"><![CDATA[pyspider的架构主要分为Scheduler(调度器)、Fetcher(抓取器)、Processer(处理器)三个部分，整个爬取过程受到Monitor(监控器)的监控，抓取的结果被Result Worker(结果处理器)处理. Scheduler发起任务调度，Fetcher负责抓取网页内容，Processer负责解析网页内容，然后将新生成的Request发给Scheduler进行调度，将生成的提取结果输出保存。 pyspider的任务执行流程的逻辑很清晰，具体过程如下所示。 每个pyspider的项目对应一个Python脚本，该脚本中定义了一个Handler类，它有一个on_start()方法。爬取首先调用on_start()方法生成最初的抓取任务，然后发送给 Scheduler进行调度。 Scheduler将抓取任务分发给Fetcher进行抓取，Fetcher执行并得到响应，随后将响应发送给Processer。 Processer处理响应并提取出新的URL生成新的抓取任务，然后通过消息队列的方式通知Scheduler当前抓取任务执行情况，并将新生成的抓取任务发送给Scheduler。如果生成了新的提取结果，则将其发送到结果队列等待Result Worker处理。 Scheduler接收到新的抓取任务，然后查询数据库，判断其如果是新的抓取任务或者是需要重试的任务就继续进行调度，然后将其发送回Fetcher进行抓取。 不断重复以上工作，直到所有的任务都执行完毕，抓取结束。 抓取结束后，程序会回调on_finished()方法，这里可以定义后处理过程。]]></content>
      <categories>
        <category>Web Crawler</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web Crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Proxy]]></title>
    <url>%2F2018%2F09%2F15%2FProxy%2F</url>
    <content type="text"><![CDATA[设置代理后测试的网址是：httpbin.org/get，访问该网址可以得到请求的相关信息，其中origin宇段就是客户端的IP，可以根据它来判断代理是否设置成功，即是否成功伪装了IP。 urllibHTTP代理123456789101112131415161718192021222324252627from urllib.request import ProxyHandler, build_openerfrom urllib.error import URLErrorproxy = "127.0.0.1:1087"proxy_handler = ProxyHandler(&#123; 'http': "http://" + proxy, 'https': "https://" + proxy&#125;)opener = build_opener(proxy_handler)try: response = opener.open("http://httpbin.org/get") print(response.read().decode('utf-8'))except URLError as e: print(e.reason)# &#123;# "args": &#123;&#125;, # "headers": &#123;# "Accept-Encoding": "identity", # "Connection": "close", # "Host": "httpbin.org", # "User-Agent": "Python-urllib/3.7"# &#125;, # "origin": "38.141.44.98", # "url": "http://httpbin.org/get"# &#125; SOCKS5代理12345678910111213141516171819202122232425from urllib import requestfrom urllib.error import URLErrorimport socketimport sockssocks.set_default_proxy(socks.SOCKS5, "127.0.0.1", 1086)socket.socket = socks.socksockettry: response = request.urlopen("http://httpbin.org/get") print(response.read().decode('utf-8'))except URLError as e: print(e.reason)# &#123;# "args": &#123;&#125;, # "headers": &#123;# "Accept-Encoding": "identity", # "Connection": "close", # "Host": "httpbin.org", # "User-Agent": "Python-urllib/3.7"# &#125;, # "origin": "38.141.44.98", # "url": "http://httpbin.org/get"# &#125; requestsHTTP代理1234567891011121314151617181920212223242526import requestsproxy = "127.0.0.1:1087"proxies = &#123; 'http': "http://" + proxy, 'https': "https://" + proxy&#125;try: response = requests.get("http://httpbin.org/get", proxies=proxies) print(response.text)except requests.ConnectionError as e: print("Error", e.args)# &#123;# "args": &#123;&#125;, # "headers": &#123;# "Accept": "*/*", # "Accept-Encoding": "gzip, deflate", # "Connection": "close", # "Host": "httpbin.org", # "User-Agent": "python-requests/2.19.1"# &#125;, # "origin": "38.141.44.98", # "url": "http://httpbin.org/get"# &#125; SOCKS5代理1234567891011121314151617181920212223242526import requestsproxy = "127.0.0.1:1086"proxies = &#123; 'http': "socks5://" + proxy, 'https': "socks5://" + proxy&#125;try: response = requests.get("http://httpbin.org/get", proxies=proxies) print(response.text)except requests.ConnectionError as e: print("Error", e.args)# &#123;# "args": &#123;&#125;, # "headers": &#123;# "Accept": "*/*", # "Accept-Encoding": "gzip, deflate", # "Connection": "close", # "Host": "httpbin.org", # "User-Agent": "python-requests/2.19.1"# &#125;, # "origin": "38.141.44.98", # "url": "http://httpbin.org/get"# &#125; Selenium123456789101112131415161718192021222324from selenium import webdriverproxy = "127.0.0.1:1087"chrome_options = webdriver.ChromeOptions()chrome_options.add_argument("--proxy-server=http://" + proxy)browser = webdriver.Chrome(chrome_options=chrome_options)browser.get("http://httpbin.org/get")# &#123;# "args": &#123;&#125;, # "headers": &#123;# "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", # "Accept-Encoding": "gzip, deflate", # "Accept-Language": "en-us", # "Connection": "close", # "Cookie": "aaa=111; undefined=undefined; _gauges_unique=1; _gauges_unique_month=1; _gauges_unique_year=1", # "Dnt": "1", # "Host": "httpbin.org", # "Upgrade-Insecure-Requests": "1", # "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/11.1.1 Safari/605.1.15"# &#125;, # "origin": "218.82.103.201", # "url": "http://httpbin.org/get"# &#125;]]></content>
      <categories>
        <category>Web Crawler</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web Crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookiejar Demo]]></title>
    <url>%2F2018%2F08%2F15%2FCookiejar-Demo%2F</url>
    <content type="text"><![CDATA[如果希望登录状态一直保持，则需要进行Cookie处理。进行Cookie处理的一种常用思路如下： 导入Cookie处理模块http.cookiejar 使用http.cookiejar.CookieJar()创建CookieJar对象 使用HTTPCookieProcessor创建cookie处理器，并以其为参数构建opener对象 创建全局默认的opener对象 123456789101112131415161718192021222324252627282930import urllib.requestimport urllib.parseimport http.cookiejarurl1 = "http://bbs.chinaunix.net/member.php?mod=logging&amp;action=login&amp;loginsubmit=yes&amp;loginhash=LhGEr"postdata = urllib.parse.urlencode(&#123; "username": "", "password": ""&#125;).encode("utf-8")req = urllib.request.Request(url1, postdata)req.add_header("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/604.4.7 (KHTML, like Gecko) Version/11.0.2 Safari/604.4.7")# 使用http.cookiejar.CookieJar()创建CookieJar对象cjar = http.cookiejar.CookieJar()# 使用HTTPCookieProcessor创建cookie处理器，并以其为参数构建opener对象cookie = urllib.request.HTTPCookieProcessor(cjar)opener = urllib.request.build_opener(cookie)# 将opener安装为全局urllib.request.install_opener(opener)data1 = opener.open(req).read()file1 = open("/Users/matianyao/Desktop/login.html", "wb")file1.write(data1)file1.close()url2 = "http://bbs.chinaunix.net"data2 = urllib.request.urlopen(url2).read()file2 = open("/Users/matianyao/Desktop/crawler.html", "wb")file2.write(data2)file2.close()]]></content>
      <categories>
        <category>Web Crawler</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web Crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regular Expression]]></title>
    <url>%2F2018%2F08%2F14%2FRegular-Expression%2F</url>
    <content type="text"><![CDATA[正则表达式就是描述字符串排列的一套规则。 基础知识原子原子是正则表达式中最基本的组成单位，每个正则表达式中至少要包含一个原子，常见的原子有以下几类： 普通字符 非打印字符 通用字符 原子表 普通字符可以使用一些普通的字符，比如数字、大小写字母、下划线等都可以作为原子使用。 1234567import repattern = "yue"string = "http://yum.iqianyue.com"result = re.search(pattern, string)print(result)# &lt;re.Match object; span=(16, 19), match='yue'&gt; 非打印字符所谓的非打印字符，指的是一些在字符串中用于格式控制的符号，比如换行符等。 12345678910111213import repattern = "\n"string1 = '''http://yum.iqianyue.comhttp://baidu.com'''result1 = re.search(pattern, string1)print(result1)# &lt;re.Match object; span=(23, 24), match='\n'&gt;string2 = "http://yum.iqianyue.comhttp://baidu.com"result2 = re.search(pattern, string2)print(result2)# None 通用字符所谓的通用字符，即一个原子可以匹配一类字符。 1234567import repattern = "\w\dpython\w"string = "abcdfphp345pythony_py"result = re.search(pattern, string)print(result)# &lt;re.Match object; span=(9, 18), match='45pythony'&gt; 原子表使用原子表，可以定义一组地位平等的原子，然后匹配的时候会取该原子表中的任意一个原子进行匹配，在Python中，原子表由[]表示。类似的，[^]代表的是除了中括号里面的原子均可以匹配。 1234567891011121314151617import restring = "abcdfphp345pythony_py"pattern1 = "\w\dpython[xyz]\w"result1 = re.search(pattern1, string)print(result1)# &lt;re.Match object; span=(9, 19), match='45pythony_'&gt;pattern2 = "\w\dpython[^xyz]\w"result2 = re.search(pattern2, string)print(result2)# Nonepattern3 = "\w\dpython[xyz]\W"result3 = re.search(pattern3, string)print(result3)# None 元字符所谓的元字符，就是正则表达式中具有一些特殊含义的字符。具体来说，元字符可以分为：任意匹配元字符、边界限制元字符、限定符、模式选择符、模式单元等。 任意匹配元字符可以使用”.”匹配一个除换行符以外的任意字符。 1234567import repattern = ".python..."string = "abcdfphp345pythony_py"result = re.search(pattern, string)print(result)# &lt;re.Match object; span=(10, 20), match='5pythony_p'&gt; 边界限制元字符可以使用”^”匹配字符串的开始，使用”$”匹配字符串的结束。 12345678910111213141516171819202122import restring = "abcdfphp345pythony_py"pattern1 = "^abd"result1 = re.search(pattern1, string)print(result1)# Nonepattern2 = "^abc"result2 = re.search(pattern2, string)print(result2)# &lt;re.Match object; span=(0, 3), match='abc'&gt;pattern3 = "py$"result3 = re.search(pattern3, string)print(result3)# &lt;re.Match object; span=(19, 21), match='py'&gt;pattern4 = "ay$"result4 = re.search(pattern4, string)print(result4)# None 限定符常见的限定符包括*、?、+、{n}、{n,}、{n, m}。 12345678910111213141516171819202122import restring = "abcdddfphp345pythony_py"pattern1 = "py.*n"result1 = re.search(pattern1, string)print(result1)# &lt;re.Match object; span=(13, 19), match='python'&gt;pattern2 = "cd&#123;2&#125;"result2 = re.search(pattern2, string)print(result2)# &lt;re.Match object; span=(2, 5), match='cdd'&gt;pattern3 = "cd&#123;3&#125;"result3 = re.search(pattern3, string)print(result3)# &lt;re.Match object; span=(2, 6), match='cddd'&gt;pattern4 = "cd&#123;2,&#125;"result4 = re.search(pattern4, string)print(result4)# &lt;re.Match object; span=(2, 6), match='cddd'&gt; 模式选择符使用模式选择符，可以设置多个模式，匹配时，可以从中选择任意一个模式匹配。 1234567import repattern = "python|php"string = "abcdfphp345pythony_py"result = re.search(pattern, string)print(result)# &lt;re.Match object; span=(5, 8), match='php'&gt; 模式单元可以使用”()”将一些原子组合成一个大原子使用，小括号括起来的部分会被当做一个整体去使用。 123456789101112import restring = "abcdcdcdcdfphp345pythony_py"pattern1 = "(cd)&#123;1,&#125;"result1 = re.search(pattern1, string)print(result1)# &lt;re.Match object; span=(2, 10), match='cdcdcdcd'&gt;pattern2 = "cd&#123;1,&#125;"result2 = re.search(pattern2, string)print(result2)# &lt;re.Match object; span=(2, 4), match='cd'&gt; 模式修正所谓模式修正符，即可以在不改变正则表达式的情况下，通过模式修正符改变正则表达式的含义，从而实现一些匹配结果的调整等功能。 1234567891011import restring = "abcdfphp345Pythony_py"pattern = "python"result1 = re.search(pattern, string)print(result1)# Noneresult2 = re.search(pattern, string, re.I)print(result2)# &lt;re.Match object; span=(11, 17), match='Python'&gt; 贪婪模式与懒惰模式在某些字符间匹配任意字符，贪婪模式的核心点就是尽可能多地匹配，而懒惰模式的核心点就是尽可能少地匹配。 123456789101112import restring = "abcdfphp345pythony_py"pattern1 = "p.*y" #贪婪模式result1 = re.search(pattern1, string)print(result1)# &lt;re.Match object; span=(5, 21), match='php345pythony_py'&gt;pattern2 = "p.*?y" #懒惰模式result2 = re.search(pattern2, string)print(result2)# &lt;re.Match object; span=(5, 13), match='php345py'&gt; 常见函数re.match()函数如果想要从源字符串的起始位置匹配一个模式，可以使用re.match()函数，使用格式是：re.match(pattern, string, flag)第一个参数代表对应的正确表达式，第二个参数代表对应的源字符，第三个参数是可选参数，代表对应的标志位，可以放模式修正符等信息。 1234567891011import restring = "apythonhellomypythonhispythonourpythonend"pattern = ".python."result1 = re.match(pattern, string)print(result1)# &lt;re.Match object; span=(0, 8), match='apythonh'&gt;result2 = re.match(pattern, string).span()print(result2)# (0, 8) re.search()函数使用该函数进行匹配，会扫描整个字符串并进行对应的匹配。 1234567891011import restring = "hellomypythonhispythonourpythonend"pattern = ".python."result1 = re.match(pattern, string)print(result1)# Noneresult2 = re.search(pattern, string)print(result2)# &lt;re.Match object; span=(6, 14), match='ypythonh'&gt; 全局匹配函数将符合模式的内容全部都匹配出来。思路如下： 使用re.compile()对正则表达式进行预编译。 编译后，使用findall()根据正则表达式从源字符串中将匹配的结果全部找出。 1234567import restring = "hellomypythonhispythonourpythonend"pattern = re.compile(".python.") #预编译result = pattern.findall(string) #找出符合模式的所有结果print(result)# ['ypythonh', 'spythono', 'rpythone'] re.sub()函数如果想根据正则表达式来实现替换某些字符串的功能，可以使用re.sub()韩式实现。re.sub(pattern, rep, string, max)其中，第一个参数为对应的正则表达式，第二个参数为要替换成的字符串，第三个参数为源字符串，第四个参数为可选项，代表最多替换的次数，如果忽略不写，则会将符合模式的结果全部替换。 1234567891011import restring = "hellomypythonhispythonourpythonend"pattern = re.compile(".python") result1 = re.sub(pattern, "php", string) #全部替换print(result1)# hellomphphiphpouphpendresult2 = re.sub(pattern, "php", string, 2) #最多替换两次print(result2)# hellomphphiphpourpythonend 常见实例解析匹配.com或.cn后缀的URL网址将一串字符串里面以.com或.cn为域名后缀的URL网址匹配出来，过滤掉其他的无关信息。 1234567import repattern = "[a-zA-Z]+://[^\s]*[.com|.cn]"string = "&lt;a href='http://www.baidu.com'&gt;百度首页&lt;/a&gt;"result = re.search(pattern, string)print(result)# &lt;re.Match object; span=(9, 29), match='http://www.baidu.com'&gt; 匹配电话号码将一串字符串里面出现的电话号码信息提取出来，过滤掉其他无关信息。 1234567import repattern = "\d&#123;4&#125;-\d&#123;7&#125;|\d&#123;3&#125;-\d&#123;8&#125;"string = "021-6728263653682382265236"result = re.search(pattern, string)print(result)# &lt;re.Match object; span=(0, 12), match='021-67282636'&gt; 匹配电子邮件地址将一串字符串里面出现的电子邮件信息提取出来，过滤掉其他无关信息。 1234567import repattern = "\w+([.+-]\w+)*@\w+([.-]\w+)*\.\w+([.-]\w+)*"string = "&lt;a href='http://www.baidu.com'&gt;百度首页&lt;/a&gt;&lt;br&gt;&lt;a href='mailto:c-e+o@iqi-anyue.com.cn'&gt;电子邮件地址&lt;/a&gt;"result = re.search(pattern, string)print(result)# &lt;re.Match object; span=(59, 81), match='c-e+o@iqi-anyue.com.cn'&gt;]]></content>
      <categories>
        <category>Web Crawler</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web Crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Singleton模式]]></title>
    <url>%2F2018%2F05%2F31%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Singleton%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[确保只能生成一个实例。 示例类图 Singleton类1234567891011public class Singleton &#123; private static Singleton singleton = new Singleton(); private Singleton()&#123; System.out.println("生成了一个实例"); &#125; public static Singleton getInstance() &#123; return singleton; &#125;&#125; Main类12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; System.out.println("Start."); Singleton obj1 = Singleton.getInstance(); Singleton obj2 = Singleton.getInstance(); if (obj1 == obj2) System.out.println("obj1与obj2是相同的实例。"); else System.out.println("obj1与obj2是不同的实例。"); System.out.println("End."); &#125;&#125; 运行结果1234Start.生成了一个实例obj1与obj2是相同的实例。End. 登场角色Singleton在Singleton模式中，只有Singleton这一个角色。Singleton角色中有一个返回唯一实例的static方法。该方法总是会返回同一个实例。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Factory Method模式]]></title>
    <url>%2F2018%2F05%2F30%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Factory-Method%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[使用Template Method模式来构建生成实例的工厂。 父类决定实例的生成方式，但并不决定所要生成的具体的类，具体的处理全部交给子类负责。这样就可以将生成实例的框架和实际负责生成实例的类解耦。 示例制作身份证（ID卡）。 类图 Product类12345package framework;public abstract class Product &#123; public abstract void use();&#125; Factory类123456789101112package framework;public abstract class Factory &#123; public final Product create(String owner) &#123; Product p = createProduct(owner); registerProduct(p); return p; &#125; protected abstract Product createProduct(String owner); protected abstract void registerProduct(Product product);&#125; IDCard类123456789101112131415161718192021package idcard;import framework.Product;public class IDCard extends Product &#123; private String owner; IDCard(String owner) &#123; this.owner = owner; System.out.println("制作" + owner + "的ID卡。"); &#125; @Override public void use() &#123; System.out.println("使用" + owner + "的ID卡。"); &#125; public String getOwner() &#123; return owner; &#125;&#125; IDCardFactory类12345678910111213141516171819202122232425package idcard;import framework.Factory;import framework.Product;import java.util.ArrayList;import java.util.List;public class IDCardFactory extends Factory &#123; private List owners = new ArrayList(); @Override protected Product createProduct(String owner) &#123; return new IDCard(owner); &#125; @Override protected void registerProduct(Product product) &#123; owners.add(((IDCard)product).getOwner()); &#125; public List getOwners() &#123; return owners; &#125;&#125; Main类1234567891011121314151617import framework.Factory;import framework.Product;import idcard.IDCardFactory;public class Main &#123; public static void main(String[] args) &#123; Factory factory = new IDCardFactory(); Product card1 = factory.create("小明"); Product card2 = factory.create("小红"); Product card3 = factory.create("小刚"); card1.use(); card2.use(); card3.use(); &#125;&#125; 运行结果123456制作小明的ID卡。制作小红的ID卡。制作小刚的ID卡。使用小明的ID卡。使用小红的ID卡。使用小刚的ID卡。 登场角色Product（产品）Product角色属于框架这一方，是一个抽象类。它定义了在Factory Method模式中生成的那些实例所持有的接口（API），但具体的处理由子类ConcreteProduct角色决定，在示例程序中，由Product类扮演此角色。 Creator（创建者）Creator角色属于框架这一方，它是负责生成Product角色的抽象类，但具体的处理则由子类ConcreteCreator角色决定。在示例程序中，由Factory类扮演此角色。Creator角色对于实际负责生成实例的ConcreteCreator角色一无所知，它唯一知道的就是，只要调用Product角色和生成实例的方法，就可以生成Product的实例。在示例程序中，createProduct方法是用于生成实例的方法。 ConcreteProduct（具体的产品）ConcreteProduct角色属于具体加工这一方，它决定了具体的产品。在示例程序中，由IDCard类扮演此角色。 ConcreteCreator（具体的创建者）ConcreteCreator角色属于具体加工这一方，它负责生成具体的产品。在示例程序中，由IDCardFactory类扮演此角色。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Template Method模式]]></title>
    <url>%2F2018%2F05%2F30%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Template-Method%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在父类中定义处理流程的框架，在子类中实现具体处理。 组成模板的方法被定义在父类中。由于这些方法是抽象方法，所以只查看父类的代码是无法知道这些方法最终会进行何种具体处理的，唯一能知道的就是父类是如何调用这些方法的。 实现上述这些抽象方法的是子类。在子类中实现了抽象方法也就决定了具体的处理。也就是说，只要在不同的子类中实现不同的具体处理，当父类的模板方法被调用时程序行为也会不同。但是不论子类中的具体实现如何，处理的流程都会按照父类中所定义的那样进行。 示例将字符和字符串循环显示5次。 类图 AbstractDisplay类1234567891011121314public abstract class AbstractDisplay &#123; abstract void open(); abstract void print(); abstract void close(); final void display() &#123; open(); for (int i = 0; i &lt; 5; i++) print(); close(); &#125;&#125; CharDisplay类12345678910111213141516171819202122public class CharDisplay extends AbstractDisplay &#123; private char ch; public CharDisplay(char ch) &#123; this.ch = ch; &#125; @Override void open() &#123; System.out.print("&lt;&lt;"); &#125; @Override void print() &#123; System.out.print(ch); &#125; @Override void close() &#123; System.out.println("&gt;&gt;"); &#125;&#125; StringDisplay类123456789101112131415161718192021222324252627282930313233public class StringDisplay extends AbstractDisplay &#123; private String string; private int width; public StringDisplay(String string) &#123; this.string = string; this.width = string.getBytes().length; &#125; @Override void open() &#123; printLine(); &#125; @Override void print() &#123; System.out.println("|" + string + "|"); &#125; @Override void close() &#123; printLine(); &#125; private void printLine() &#123; System.out.print("+"); for (int i = 0; i &lt; width; i++) System.out.print("-"); System.out.println("+"); &#125;&#125; Main类123456789101112public class Main &#123; public static void main(String[] args) &#123; AbstractDisplay d1 = new CharDisplay('H'); AbstractDisplay d2 = new StringDisplay("Hello, world."); AbstractDisplay d3 = new StringDisplay("你好，世界。"); d1.display(); d2.display(); d3.display(); &#125;&#125; 运行结果123456789101112131415&lt;&lt;HHHHH&gt;&gt;+-------------+|Hello, world.||Hello, world.||Hello, world.||Hello, world.||Hello, world.|+-------------++------------------+|你好，世界。||你好，世界。||你好，世界。||你好，世界。||你好，世界。|+------------------+ 登场角色AbstractClass（抽象类）AbstractClass角色不仅负责实现模板方法，还负责声明在模板方法中所使用到的抽象方法。这些抽象方法由子类ConcreteClass角色负责实现。在示例程序中，由AbstractDisplay类扮演此角色。 ConcreteClass（具体类）该角色负责具体实现AbstractClass角色中定义的抽象方法。这里实现的方法将会在AbstractClass角色的模板方法中被调用。在示例程序中，由CharDisplay类和StringDisplay类扮演此角色。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Adapter模式]]></title>
    <url>%2F2018%2F05%2F29%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Adapter%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[用于填补“现有的程序”和“所需的程序”之间差异。 Adapter模式有以下两种： 类适配器模式（使用继承的适配器） 对象适配器模式（使用委托的适配器） 示例将输入的字符串显示为（Hello）或是*Hello*。 类适配器模式（使用继承）类图 Banner类123456789101112131415public class Banner &#123; private String string; public Banner(String string)&#123; this.string = string; &#125; public void showWithParen()&#123; System.out.println("(" + string + ")"); &#125; public void showWithAster()&#123; System.out.println("*" + string + "*"); &#125;&#125; Print接口1234public interface Print &#123; void printWeak(); void printStrong();&#125; PrintBanner类123456789101112131415public class PrintBanner extends Banner implements Print &#123; public PrintBanner(String string) &#123; super(string); &#125; @Override public void printWeak() &#123; showWithParen(); &#125; @Override public void printStrong() &#123; showWithAster(); &#125;&#125; Main类12345678public class Main &#123; public static void main(String[] args) &#123; Print p = new PrintBanner("Hello"); p.printWeak(); p.printStrong(); &#125;&#125; 运行结果12(Hello)*Hello* 对象适配器模式（使用委托）类图 Print类1234public abstract class Print &#123; abstract void printWeak(); abstract void printStrong();&#125; PrintBanner类1234567891011121314151617public class PrintBanner extends Print &#123; private Banner banner; public PrintBanner(String string) &#123; this.banner = new Banner(string); &#125; @Override void printWeak() &#123; banner.showWithParen(); &#125; @Override void printStrong() &#123; banner.showWithAster(); &#125;&#125; 登场角色在类适配器模式中，Adapter角色通过继承来使用Adaptee角色，而在对象适配器模式中，Adapter角色通过委托来使用Adaptee角色。 Targer（对象）该角色负责定义所需的方法。在示例程序中，由Print接口（使用继承时）和Print类（使用委托时）扮演此角色。 Client（请求者）该角色负责使用Target角色所定义的方法进行具体处理。在示例程序中，由Main类扮演此角色。 Adaptee（被适配）Adaptee是一个持有既定方法的角色。在示例程序中，由Banner类扮演此角色。 Adapter(适配)Adapter模式的主人公。使用Adaptee角色的方法来满足Target角色的需求，这是Adapter模式的目的，也是Adapter角色的作用。在示例程序中，由PrintBanner类扮演这个角色。 类适配器模式的类图（使用继承） 对象适配器模式的类图（使用委托）]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图解设计模式】Iterator模式]]></title>
    <url>%2F2018%2F03%2F30%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Iterator%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[按照统一的方法遍历集合中的元素。 示例将书（Book）放置到书架（BookShelf）中，并将书的名字按顺序显示出来。 类图 Aggregate接口123public interface Aggregate &#123; Iterator iterator();&#125; Iterator接口1234public interface Iterator &#123; boolean hasNext(); Object next();&#125; Book类1234567891011public class Book &#123; private String name; public Book(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; BookShelf类1234567891011121314151617181920212223242526public class BookShelf implements Aggregate &#123; private Book[] books; private int last; public BookShelf(int maxsize) &#123; this.books = new Book[maxsize]; this.last = 0; &#125; public Book getBookAt(int index) &#123; return books[index]; &#125; public void appendBook(Book book) &#123; books[last++] = book; &#125; public int getLength() &#123; return last; &#125; @Override public Iterator iterator() &#123; return new BookShelfIterator(this); &#125;&#125; BookShelfIterator类12345678910111213141516171819public class BookShelfIterator implements Iterator &#123; private BookShelf bookShelf; private int index; public BookShelfIterator(BookShelf bookShelf) &#123; this.bookShelf = bookShelf; this.index = 0; &#125; @Override public boolean hasNext() &#123; return index &lt; bookShelf.getLength() ? true : false; &#125; @Override public Object next() &#123; return bookShelf.getBookAt(index++); &#125;&#125; Main类12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; BookShelf bookShelf = new BookShelf(4); bookShelf.appendBook(new Book("Around the World in 80 Days")); bookShelf.appendBook(new Book("Bible")); bookShelf.appendBook(new Book("Cinderella")); bookShelf.appendBook(new Book("Daddy-Long-Legs")); Iterator it = new BookShelfIterator(bookShelf); while (it.hasNext()) &#123; Book book = (Book) it.next(); System.out.println(book.getName()); &#125; &#125;&#125; 运行结果1234Around the World in 80 DaysBibleCinderellaDaddy-Long-Legs 登场角色Iterator（迭代器）该角色负责定义按顺序逐个遍历元素的接口（API）。在示例程序中，由Iterator接口扮演这个角色，它定义了hasNext和next两个方法。其中，hasNext方法用于判断是否存在下一个元素，next方法则用于获取该元素。 ConcreteIterator（具体的迭代器）该角色负责实现Iterator角色所定义的接口（API）。在示例程序中，由BookShelfIterator类扮演这个角色。该角色中包含了遍历集合所必需的信息。在示例程序中，BookShelf类的实例保存在bookShelf字段中，被指向的书的下标保存在index字段中。 Aggregate（集合）该角色负责定义创建Iterator角色的接口（API）。这个接口（API）是一个方法，会创建出“按顺序访问保存在我内部元素的人”。在示例程序中，由Aggregate接口扮演这个角色，它里面定义了iterator方法。 ConcreteAggregate（具体的集合）该角色负责实现Aggregate角色所定义的接口（API）。它会创建出具体的Iterator角色，即ConcreteIterator角色。在示例程序中，由BookShelf类扮演这个角色，它实现了iterator方法。 类图]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Slang]]></title>
    <url>%2F2018%2F03%2F06%2FSlang%2F</url>
    <content type="text"><![CDATA[ring a bellto arouse an often indistinct memory，唤起模糊的记忆多以否定形式出现：It/That/Sth does not ring a bell.记不得，想不起来了。尤其强调完全没有印象。 tell me about it告诉我吧，跟我说说，引申为（1）I have had the same experience.我也有相同经历。（2）a way of saying you agree with someone我同意你的观点。有时并不是出于不了解，想让对方再说些什么，而是表示深有同感，你懂的！ on the house（1）given away free免费赠送（2）without asking for money不用钱It’s on the house.常用于酒店、饭馆和酒吧免费招待的酒水、食物或服务。现在也更多地用于其他表达“请客”的语境中。 cold feetfearfulness or timidity preventing the completion of a course of action，因害怕胆怯临阵退缩突然缺乏自信或勇气，临阵退缩。常与动词get连用，即：get cold feet。 silver lininga hopeful or comforting prospect in the midst of difficulty，困境中的希望或安慰，出自一则西方谚语：Every cloud has a silver lining.每一朵乌云都镶着银色的边。用于在一切糟糕不幸的境遇中，看到的希望与生机，不幸中的万幸。 second thoughtsa reconsideration of a decision or opinion previously made，重新考虑已经做出的决定或意见惯用复数形式。通常表示后悔了，有了与之前不同的想法，做出了与之前不同的决定。 off the wagonno longer abstaining from alcoholic beverages，不再戒酒on the wagon戒酒中；(fall) off the wagon酒瘾复发。 break a legused to wish someone, such as an actor, success in a performance，预祝演出成功预祝表演成功。与good luck意思相近，但语境仅限于演出、表演等场合使用。 I’m all ears.acutely attentive，全神贯注全神贯注，集中注意力倾听。愿闻其详，洗耳恭听。 look over one’s shoulder往回看，回头看，引申为：keep watching for danger or threats to oneself，对危险或威胁时刻警惕可表示动作上的往后看，向后瞧；其引申义为时刻小心警惕。 put down roots播种扎根，引申为：to settle down somewhere; to make a place one’s permanent home，安顿下来，定居表示愿意在某地长久居住，定居，购置房产，在当地结交朋友等。 call the shotsto decide on the course of action; to be in charge，做重大决定、负责做得了主，说了算，也可以表示发号施令。 up one’s sleeve在袖子里，引申为：hidden but ready to be used，隐藏备用具有双重含义，直译为在袖子里，也可引申为备有锦囊妙招。 pull yourself togetherto regain one’s composure，重新镇定从字面解释，就是把“四分五裂”的自己拼凑在一起。重整精神，振作起来。 kiss the ringto show respect, often used in the imperative tense，不可免地表示尊重起源于传统宗教仪式中，亲吻罗马教皇手上戴的戒指，以表敬意和忠诚，引申为奉承讨好之意。 hang by a threadto be in danger of having something unlucky or bad happen，即将遭遇不幸或厄运形容千钧一发，朝不保夕，岌岌可危。 pull some stringsto use influence (with someone to get something done)，利用某人的影响力把事情搞定起源于木偶戏，演员在背后操作木偶身上的线。引申为通过非常规渠道，调动可利用的关系，达到目的，走后门。 tight shipto run a ship or an organization in an orderly and disciplined manner，有秩序，有纪律地管理组织原指不漏水的船，形容一艘船上纪律严明，管理井然有序。广泛地用来形容其他组织或团体。惯用动词run来搭配，run a tight ship。 turn over a new leafto start behaving in a better way，重新开始好好表现16世纪时，人们把书本的页面称为“leaf”。翻到新的一页，也就是俗话说的“翻篇”，引申为改过自新，洗心革面。 get off on the wrong footto begin doing something in a way that is likely to fail，失败的开局也作start off on the wrong foot，刚开始就进展不顺，开局不好。反义词get off on the right foot，开局良好，开了个好头。 beat a dead horseto persist in persuing or trying to revive interest in a project or subject that has lost its usefulness or relevance，在已无意义的事情上白费功夫做无用功，再怎么做也是徒劳，无济于事。搭配的动词有flog a dead horse。 jaw drops下巴掉下来，引申为：to show great surprise，惊叹不已one’s jaw drops/drop one’s jaw吃惊不已，目瞪口呆。 get one’s head aroundto be able to understand something (usually negative)，能够理解某事（通常以否定形式出现）绞尽脑汁努力想明白。常与动词wrap搭配，wrap one’s head around。 water under the bridgea past occurrence, especially something unfortunate, that cannot be undone or rectified，无法改变的过去的不幸桥下匆匆过去的流水，有覆水难收之意。尤其指不好的事，已经发生了，已经过去了。 my hands are tied绑住的双手，引申为：someone is not able to help or intervene，帮不上忙或无法介入（婉拒他人请求）无能为力，束手无策。常用于必须按照规矩办事，不能通融。 open booka person or thing without secrecy or concealment that can be easily known or interpreted，没有秘密或容易被看穿的人或事一本开启的书。指一个人坦率直言，没有秘密，没有城府。 walk on eggshells走在蛋壳上，引申为：to walk carefully, to take steps gingerly, to be very diplomatic and in offensive，步步小心谨慎，礼数周全，不冒犯“走在鸡蛋壳上”般小心翼翼，与“如履薄冰”如出一辙，形容对待某人或某事谨小慎微。 not see the forest for the treescannot perceive the overview or important things because of concentrating too much on details，太关注细节而无法领悟整体或重点常以否定形式出现，cannot/not able to see the forest for the trees。眼光不能放长远，看不到大局，也就是“一叶障目，不见泰山”。 speak of the deviltalk about a certain person, and that person appears，说到某个人，那个人就出现了Speak of the devil, and in he walks.是一句古老的西方谚语，提醒大家不要再在聊天中提起魔鬼的名字，否则魔鬼就会立刻现身。现在专指某人不经念叨，说曹操曹操到。 cats and dogsvery heavily or steadily，非常强烈，严重最早只用于形容倾盆大雨，暴风骤雨。据说早年伦敦一遇到暴雨，街上的下水道堵塞，第二天街头就会漂浮很多被淹死的猫猫狗狗。现在也用于争吵中，形容吵得不可开交。 dodge a bullet躲过一颗子弹，引申为：having successfully avoided a sticky situation，成功避免了棘手的情况省去了麻烦，躲过一劫。 clear the air净化空气，引申为：to get rid of doubts or hard feelings，摆脱怀疑或不满直译为净化空气，引申义为讲清楚，澄清事实，消除误会。 get ducks in a rowto organize things well，打理有序把一切打理妥当，有条不紊。常见的搭配还有have one’s ducks in a row。 elephant in the rooma question, problem, or controversial issue which is obvious to everyone who knows about the situation, but which is deliberately ignored，人人心知肚明却故意不提的问题或话题形容无法忽视的，明摆着的事实。 take the high roadto do the right thing even if it’s not popular or easy，即使不易或不受欢迎，也要做正确的事采取高风亮节的做法，通常用于自己站上道德制高点，把别人比下去。 red tape红色的布带，引申为：obstructive official routine or procedure; time-consuming bureaucracy，碍事的官方规定或程序、费时的官僚机构起源于17世纪官方用于捆绑文案文书的红色布条，形容繁复的手续或冗杂的程序，有繁文缛节之意。 twist one’s arm拧折胳膊，引申为：to persuade someone to do something that they do not want to do，说服某人做不想做的事向对方施压，强迫对方做某事。也常用于“并不是真的不愿意，只是表示客气”，出于客套，说话人并不是真的不愿意，盛情难却。 on a silver platter于银盘之上，引申为：provide with something valuable for nothing，无条件提供有价值的东西双手奉上，拱手相送。说话人常常有点并不心甘情愿，或者有点后悔。可搭配的动词有hand/deliver to someone on a silver platter。 blow off steam释放蒸汽，引申为：to do or say something that helps you get rid of strong feeling or energy，做或说一些能摆脱负面情绪的事用法出自老式蒸汽锅。喷出蒸汽有助于释放蒸汽锅内的压力，从而避免爆炸的危险。运用到人身上，释放压力，发泄，减压。 go southto lose value or quality, to stop working，失去价值，失效起源于地图中上北下南的方位。往南从图上看，就是往下走，走下坡路。引申为往不好的局面发展，事情败露，计划泡汤，关系闹僵。同义的搭配还有head south。 steal one’s thunderto use, appropriate, or preempt the use of another’s idea, especially to one’s own advantage and without consent by the originator，在未经允许的情况下，为了自己的利益，窃取占用别人的主意抢风头。该典故起源于17世纪，英国一位剧作家John Dennis发明了在舞台剧演出中制造雷声音效的方法。后来当他创作的舞台剧被叫停后，他发现其他正在上演的舞台剧盗用了他制造雷声的办法。John愤怒不已，抱怨道：“They will not let me play run, but they steal my thunder!“。 once in a blue moonvery rarely, almost never，极其罕见，几乎从不形容比sometimes还要罕见，绝无仅有。 nail in the coffin棺材上的钉子，引申为：an action that will cause something to end，指示终结的举动棺材上的钉子，颇有板上钉钉，死定了的意味。指最后致命的一击，最强补刀。搭配的用法有the final/another nail in the coffin (of…)。 flash in the pan锅里的一道光，引申为：someone or something that draws a lot of attention for a very brief time，短暂地吸引过关注的人或事出处说法不一，最普及的说法是来自于美国淘金热的年代。当时淘金使用的工具类似平底锅，把挖来的泥沙放在锅里浸上水，如果有金子的话，能在阳光下看到金光。flash in the pan说的是徒有一道光线，并没有真金，指空欢喜一场，昙花一现。 peas in a pod在同一颗豆荚中的豆子，引申为：very similar; two of a kind，非常相近，同一类同一颗豆荚里的豆子。既可以用来形容两人关系亲密到难舍难分，也可以用来形容两人当下的境遇相同，或志同道合。亲如兄弟（姐妹）。 ball and chain拴犯人用的枷锁，引申为：a heavy restraint, a wife，强烈的束缚，妻子枷锁，引申为牵绊，束缚，也常常用来代指妻子。 get under one’s skin深入皮肤底层，引申为：to bother or irritate someone，打扰或激怒某人用于被惹恼，被激怒，被强烈地影响了情绪。 poker face扑克脸，引申为：a face that show no emotion or intention，没有任何情感或意图的表情起源于职业扑克牌手在竞技中，为了不让对方看穿自己的牌面，要始终保持面无表情，也就是“扑克脸”。引申为板着脸，一本正经。可搭配的动词有give/lose/practise poker face。 smell bloodto recognise an opportunity to be more successful, especially by taking advantage or someone who is in a difficult situation，发掘能更成功的机会，通常要通过趁人之危原指鲨鱼在海中嗅到血腥味，就会发动攻击。现在多用来形容找准机会，随时准备行动，发动攻势，伺机而动。 push one’s luck把运气“推一推”，引申为：to try too hard to get a particular result and risk losing what you have achieved，为达到目的努力过头，冒着失去已有成就的风险过于希望好运延续，而很有可能得不偿失，即得寸进尺。经常用于否定句中，善意地提醒对方——Don’t push your luck。 cold shoulderdeliberate coldness or disregard, a slight or a snub，故意冷淡忽视、怠慢或斥责最早用来形容待客冷淡的房东或寄宿主人。如今指故意漠视冷落某人，不理不睬。 white liean often trivial, diplomatic or well-intended untruth，微不足道，高明或出于好意的假话在英语传统中，white与good，pure近义，象征着好的初衷。意味着善意的谎言，而现在也用于并非出于好意，而只是耍了耍小聪明，自以为高明的小谎言。 penny for your thoughts一便士买你的想法，引申为：what are you thinking about?你在想什么？据说已经流传了四百多年。在四百年前，一便士还是非常值钱的银币。专门针对身边突然心不在焉的人，就是说“你走神了”。现在则用于询问身边人的想法。 high timethe latest possible time, a time that is almost too late，最后可能的时间，几乎太迟的时候最后的紧要关头，再不…就迟了。比It’s time to更紧急，更刻不容缓。 loose ends绳子毛糙脱线的一端，引申为：a detail that is left unsettled, unexplained or incomplete，遗留未解决、未解释或未完成的细节本义是松开的线头。在罪案剧中，常看到杀手在灭口之前对对方说：“You’re a loose end”，指把柄、遗留问题。常搭配的动词短语是tie up。tie up loose ends解决遗留问题，扫尾。 hold your horses骑马的时候，勒紧缰绳，让马儿慢下来，引申为：stop, slow down，停下，慢点原指勒马，现在用于让对方等等，慢点说，是wait, hold on等的另一种形式。 a taste of your own medicine自己药的味道，引申为：a sample of the unpleasantness that one has been giving other people，复制一个人给其他人带来的不快你自己的苦药，自食其果。可搭配动词get/have a taste of your own medicine, give someone a taste of one’s own medicine。 humble pie用猪牛羊的内脏做的馅饼，引申为：to be forced to admit that you are wrong and to say you are sorry，被迫承认错误并道歉原指用动物内脏制作的馅饼，西方人认为动物内脏是低等的肉质，因为只有穷人才吃。吃动物内脏制作的馅饼，就是低人一等。现在则引申为被迫认识到自己的错误，屈辱地认错或自取其辱，“被打脸”。 lion’s share狮子的那份，引申为：the largest portion，最大份额出自《伊索寓言》中的一则故事。一头狮子与另外三头野兽去打猎。它们猎到了一头鹿，把鹿分成了四份，准备平分。谁料狮子拿了自己应得的那份后，说：“我是森林之王，所以还得再分一份。我的勇气与力量无人能及，所以还得再拿一块。至于第四块的归属，如果你们想跟我挑战的话，我们就来比试比试吧。”最后，狮子把整只鹿独吞了。用来形容占据最大份额或绝大多数。 sinking ship一艘将沉没的船，引申为：a company or other organization that is failing，即将衰败的公司或组织tight ship形容纪律严明、管理有序的组织。sinking ship指大势已去，每况愈下的组织。西方人很喜欢用ship来代指一个团队或组织。搭配的动词有desert/leave/jump a sinking ship。 make ends meet将两端接上，引申为：to earn and spend equal amounts of money，收入与支出持平最早起源于航海船上，系在桅杆上的绳子如果断了，船长为了节省开销，就会让人把断掉的两端重新系在一起。现在则引申为量入为出，精打细算。 a pretty pennyto be expensive; to cost a lot of money，昂贵的，花一大笔钱一大笔钱。这里pretty不是指“漂亮好看”，而是取“数额可观”之意。 hold a candleto be equal to someone; to measure up to someone，与某人平等，比得上某人当年，持烛人这份工作，因为没有任何技术含量，几乎只要长了眼睛的人都能干，所以被视为没有技术含量的低等工作。于是，人们用can’t hold a candle to来形容一个人没本事，连持烛人都不配，也就相当于“连提鞋都不配”。词条沿用到今天，便常常用于什么比不上什么，或配不上什么。 elbow greasehard work or effort, human energy，辛苦的劳作或努力，人的精力直译为在胳膊肘抹油，用于俚语中，指的是要花功夫，费力气，尤其是指体力活。 take a beatstop for a moment to relax; pause and think about what you are doing，停下来歇会儿；停下来想想自己打算怎么做表意是“休息一个节拍的时间”，实则引申为暂缓，从长计议，适用于各种想“等等再说”的语境中。 take off glovesto stop being calm or civil and show an intention of winning a dispute by any means，不再保持冷静或礼貌，表达出为赢得争执不惜一切的意图表义是摘掉手套，现多引申为为达目的，采取强硬手段，不惜一切，放手一搏。 face the musicto receive punishment; to accept the unpleasant results of one’s actions，接受惩罚，接受自身行为造成的不良后果Let’s face the music,起源于军队驱逐劣迹士兵的仪式。现用于日常对话中，包含两层含义：一是面对不好的结果；二是接受随之而来的惩罚。 late bloomera person who finally develops a useful or superior skill or talents later than expected or desired，某人比预期中晚得开发出有用或优异的技能原指晚于花季盛开的花朵，直译即迟开的花。后来便广泛地引申为较晚掌握技能或展现杰出的才能，“大器晚成”。 glass ceilingan unacknowledged discriminatory barrier that prevents women and minorities from rising to positions of power or responsibility, as within a corporation，阻止女性和少数民族在一个集团内，拥有更高权利或责任的不可言说的歧视性障碍glass ceiling就是一层看似无物，却又真实存在着的“玻璃天花板”，成为很多女性和少数民族或种族的上升瓶颈、升职障碍。 in one’s shoesto allow oneself to see or experience something from someone else’s point of view，从其他人的角度看待或经历西方人借“穿别人的鞋”来比喻设身处地，站在他人的立场上考虑问题。常用的有If I was in your shoes，如果我是你。 dust settlesWhen the dust falls out of the air; When things have calmed down，当灰尘从空气中落下；当事情缓和下来尘埃落定。常见的搭配有：When dust settles/Let the dust settle first。 icing on the cakesomething good that is added to another good thing，好事相继发生蛋糕上的装饰，指锦上添花。也用于反讽，指雪上加霜。 nest egg仿制的假蛋，留在鸡窝里，不拿走的蛋，引申为：money saved and held as a reserve for emergencies, retirement, etc，存下来的钱，用于应急或退休等等的储蓄始终留在鸡窝里的一颗蛋，如今已引申为私房钱，养老金。常用的搭配有sit on a nest egg拥有一份储蓄金。 arm’s lengtha distance, avoiding intimacy or familiarity，一段避免亲密或熟悉的距离指的不只是一只胳膊的距离。相隔一只胳膊，说的是保持一段不可逾越的距离。可搭配的词组有keep at arm’s length/stay with arm’s length。 old chestnutsomething that has been repeated so many times that it has lost its impact，重复太多，以致失去效力戏剧已被遗忘，而“老栗子”的说法沿用至今，用来指代一切过时的、老套的、陈旧的人与事。起源：19世纪英国作家William Dimond写过一出情景剧（The Broken Sword），剧中有一位爱聊天的西维尔船长，总爱反复再三地跟大家讲重复的段子。讲着讲着，后来的版本也不免与最初的版本有了出入。一天，他又讲到一个反复多遍的笑话，里面提到一棵树，这次他说是皮栎树。话音刚落，立刻被朋友博布罗打脸：“这个故事我听你讲了27遍了，我肯定你之前说的是栗子树！” no good deed goes unpunishedlife is unfair and people can do or try to do good things and still end up in a lot of trouble，抱怨生活不公，试图做好事却惹来麻烦好心没好报，说话人往往有一点挖苦或自嘲的小无奈。也常用于“初衷是好的，结果却适得其反”的对话中。 keep nose cleanto keep out of trouble, especially trouble with the law，不惹麻烦，尤其是触犯法律曾经是妈妈提醒宝贝要讲究卫生的一句叮嘱，现在用于成人世界，是警告闯祸精们，要洁身自好，不要惹麻烦。尤其在罪案剧中，是训诫有前科的犯人，不要干坏事。 safety in numberssafety achieved by being concealed in or united with large numbers of people or other creatures，通过联合或隐藏在很多人或物中达到安全的目的人越多，越能减少可能的风险，保证安全，也可以理解为常说的“人多势众”，“人多力量大”。常用的句型是There’s safety in numbers。 pins and needles图钉与针，引申为：a tingling feeling in some part of one’s body, especially the arms and legs，身体某部位发麻形容身体发麻。也可以用来表达焦虑不安的情绪，只需与介词on连用，on pins and needles，坐如针毡。 peanut gallerythe hind most or uppermost position section of seating in a theatre balcony; a group of people whose opinions are considered unimportant，剧场观众席最后或最高的位子；最无关紧要的人原指剧场演出的观众席中，最便宜的座位。从台上遥望这些座位，会有一颗颗花生的既视感，因此得名。如今，这个词组广泛地用来形容各色路人甲及围观群众。 fishing expeditiona search for information without knowledge of whether such information exists，在不知道信息是否存在的前提下搜查信息现如今这则词条已经不光用来指代捕鱼。更多地用于司法行业，指在没有嫌疑或情报指向的情况下，盘查对方的各项信息，以期找到有利的线索。而在美国，也会出现为了打击对手，蓄意组织对对方的调查，一旦找到蛛丝马迹就能抹黑对方的情况，这从法律意义上说就是非法调查。因此，既可以指撒网式盘查，也可以直接指代“非法调查”。 take the fifthrefuse to testify by invoking the fifth Amendment, which states that nobody may be forced to testify as a witness against himself ot herself，通过援引《第五修正案》中，证人不可被强迫作出对他人不利的证词，来拒绝作证来源于美国《第五修正案》的条例。条例中明确规定了证人有权保持沉默。这则原本仅用于法庭上使用的词条，被广泛地运用，来表达不想说，或不想回答的意思。 salt of the eartha person or group considered as the best or noblest part of society，被认为是社会中最好或最崇高的人或团体直译为地球之盐，可见这群人对社会的重要性。不光是a good person或者a nice guy，而是最高级：人见人爱的社会顶梁柱。 turn the tablesto change a situation so that someone’s position is opposite of what it was，使某人的处境发生了与之前相反的变化直译好似“掀桌”，实则有“翻盘”之意。就像双陆棋中有太多运气的因素，指风水轮流转，尤其是由坏转好，反败为胜，或者扭转局面之意。 save one’s skinto save someone from injury, embarrassment or punishment，拯救某人免于受伤、尴尬或惩罚意指自保，为自己开脱。不止“拯救皮肤”可以表达这个意思，save one’s neck/save one’s bacon，也都是可以互换使用的近义词条。 sitting duck可以不费吹灰之力逮到的呆坐着的野鸭，引申为：an easy target or victim，容易被攻击的目标或受害者原指容易被猎到的呆坐不动的鸭子，现在引申为容易被攻击的目标，面对攻击束手无策，坐以待毙。 cold turkeyimmediate, complete withdrawal from something on which one has become dependent, such as an addictive drug，迅速彻底地戒掉某种依赖性的习惯，比如药物上瘾指的是最早不加以任何装饰的火鸡的做法——完完全全就是一整只朴实无华的鸡！后来，人们就用来形容直截了当，不拐弯抹角。go cold turkey用来形容干脆利落地戒掉上瘾。 under your beltachieved; counted or scored; learned; mastered，取得成绩，得分；学会掌握原指把食物进入肠胃里，也就是消化掉了。现在它不仅指代消化食物，也更多地用来形容掌握了一项新技能或经过了一段经历，而这些技能或经历对往后的人生能起到积极的影响。 scratch the surfaceto just begin to find out about something; to examine only the superficial aspects of something，刚开始有所发现；对事物的观察停留在表面阶段原指工匠取材时，为了做标记，只用刀在树木或石头的表面留下浅浅的划痕，而不伤害到材料的内里。现在这则词条被广泛应用来表示略知皮毛，对事情的认知停留在表面。 cook the booksbooks账本to record false information in the accounts of an organization, especially in order to steal money，在组织的账目上记录错误信息，尤其是为了窃取钱财做假账，对账目做手脚。最早出现在18世纪的一篇新闻报道中，该记者使用了动词cook生动地描绘出对账本数字任意发挥，“添油加醋”的画面感。 bad bloodfeelings of hate between people because of arguments in the past，由于过去的争执导致彼此间仇恨最早出现在19世纪，专门用于形容家庭成员之间的关系不和，指的就是血亲。现在这则词条广泛地用于形容人与人之间各种不睦的关系，可搭配的介词是between，如(there’s) bad blood between A and B。 at one’s fingertipsimmediately and easily available，迅速而轻易地获得直译为“在指尖”，实际指近在咫尺，触手可得，完全掌握在自己手中，予取予求。 bite one’s tongueto stop yourself from saying something because it would better not to, even if you would like to say it，阻止自己说出来，因为即使很想说，也还是不说为好表意是要到舌头，现在引申为出于礼貌或其他方面考虑，不多嘴，少说话，保守秘密。 until cows come homefor a very long time，很长一段时间直到奶牛回家。因为牛儿要在山头逛上一整天，直到天黑才会回到牛圈，因此被沿用来形容要很长很长的时间，甚至是无限期。 full of beansenergetic; frisky; badly mistaken，有活力，活泼；严重弄错了表意是“满满的豆子”，而从豆子引申出了多重含义。根据语境的不同，既可以表示充满活力，精神饱满，也用来形容一个人说话不着调，胡说八道。 in the doghousein a situation in which someone is annoyed with you because of something you did，因为自己的所作所为，惹恼某人直译是在狗屋里，实际可以把“打入狗屋”理解为“打入冷宫”之意，即失宠，受冷落。而相反地，out of doghouse就是复宠，重获喜爱或青睐。起源：出自1911年发行的著名小说《彼得潘》中的情节。在书中第16章，讲到达林先生因为一时大意，把保姆赶出家门，导致自己的孩子们被绑架了。事后他非常悔恨，便惩罚自己住进了狗屋里，甚至上班的时候，也让人把狗屋一起运送过去。 beat around the bushto avoid answering a question; to stall; to waste time，避免回答问题，拖延，浪费时间表意上理解好似在树丛中放空拳，实则引申为拐弯抹角，回避重点，不直截了当。 fly on the wallsomeone who can secretly see and hear what happens，能隐秘地看见和听见事情发展经过的人直译为墙上的苍蝇，形容以及其不显眼的存在，出现在事发现场，目睹事情经过，而不引起任何人的注意。也形容窥探着的隐蔽技巧高超，无孔不入。 eat crowto be forced to accept a humiliating defeat，被迫接受羞辱的挫败起源于1812年美英战争期间。一位英国军士与一位美国猎人在尼亚加拉河畔狭路相逢。英国军士缴了猎人的步枪，并强迫他吃掉刚捕获的一只乌鸦。美国人只能从命。而等到美国人拿回自己的步枪，就立刻以其人之道还治其人之身，让英国人也受到同样的羞辱。由此引申为被迫认错，丢脸。 die-hardstubbornly resisting change or clinging to a seemingly hopeless or outdated cause，固执地拒绝变化，或坚守着希望渺茫或过时的事情由军队中一句誓死守卫的口号，演变为形容顽固不化，坚守不移的词条。可以用来形容死忠、脑残粉等等。在使用上，既可以作为名词，也可以作为形容词。起源：在1811年的阿尔布厄拉战役（Albuhera）中，西米德塞克斯（West Middlesex）的57团经过了惨烈的交火之后，他们的指挥官英格里斯（Inglis）上校被榴弹击中了脖子和胸口。英格里斯拒绝立即治疗，而是躺在士兵们面前，让他们坚守阵地，他高声喊着：“Die Hard 57th, Die Hard!”（57团不死）最后57团的570名将士中，有422名英勇就义。 out on a limbin a dangerous position to do something; at risk，做某事面临危险的局面；冒险表意为去往树枝外沿，引申义为处于危险的境地，孤立无援。常与动词go搭配，即go out on a limb去冒险。 all bets are offthe outcome of a situation is unpredictable，某种情况的结果不可预知原指在博彩中，之前下好的赌注都不算数了，后来渐渐被引申为，之前的条件、规则、逻辑等等都不作数了，推倒重来，一切皆有可能之意。 kid gloveto deal with someone very gently or carefully，温柔谨慎地对待某人treat someone with kid gloves/handle someone with kid gloves，字面理解是要戴上羊羔皮手套才能碰，意指小心翼翼，谨慎地对待。与take off gloves（不惜一切，放手一搏）正好是一对反义词。 bite the bulletto accept something difficult and try to live with it，接受并忍受困难的事情战时缺乏麻醉剂做手术，就只好咬紧子弹的做法，演变为今天指代“咬紧牙关挺住”的词条，也可以指勉为其难，为难自己做某事。 deep pocketsif an organization or a person has deep pockets, they have a lot of money，拥有大量钱财的组织或个人从字面上理解是深深的口袋，意指掌握了巨大的财富。要注意的是，既可以指代巨大的财富或资源，也可以指代拥有这些财富或资源的人。 apples and orangestwo items or groups of items are compared that cannot be practically compared，把两件或两组不具可比性的事物作比较外国人用苹果比橙子，形容把性质完全不同的事物放在一起做比较，风马牛不相及。在西方，能表达相同意思的说法还有chalk and cheese。 two left feetto be very awkward with one’s feet，出脚非常笨拙两只左脚。说的不是残疾或异形，而是用来形容脚步笨拙，不够灵巧。在各种社交场合中，尤其用来形容不会跳舞。 hard and fastdefined, fixed and invariable，已确定、固定和不可变的指严格固定下来，不容改变的。fast在这里指的是稳固，牢固。在乘机时常听到广播里说的“fasten your belt”（系紧安全带）取的也是这层意思。常用句型有：It’s not a hard and fast rule, but…（这不是硬性规定，但是…） raise the roofto be extremely noisy and boisterous; to become extremely angry。异常嘈杂喧闹；极度生气是一则多义词条。它既可以指愤怒，怒气冲天；也可以指狂欢，嗨翻全场。这两种能制造出刺耳噪音，表达的意思却截然不同的情况，都可以用这同一则词条来表达。 all thumbslacking physical coordination, skill or grace; clumsy，缺乏肢体协调性，技能或者优雅；笨拙原意是讽刺一个人十根手指都是拇指，意指不灵活，笨手笨脚。 stick in the mudone who lacks initiative, imagination or enthusiasm，被动，缺乏想象力或热情直译是插在泥里的木棍，搅也搅不动。常用来形容一个人墨守陈规，顽固不化，或者是不思进取。 go down the drainto fail; to be thrown away or wasted，失败，被丢弃或是浪费表意是冲进下水道，现在引申为白白浪费，付诸东流的意思。除了drain指下水道之外，go down the chute/tubes，都是相同的意思。 a field dayto be able to do something you enjoy a great deal, esp. criticizing someone，做某件让你非常享受的事，尤其是批评别人从19世纪的军营中诞生，到了20世纪普遍地用于日常对话中。have a field day既可以形容度过了愉快、尽兴的时光，也可以指抓住了难得的机会，尽情地批评或讽刺他人。 put finger onto indicate exactly; remember to; to discover; locate，具体地指出，记得，发现，定位直译是伸出手指指出来，引申义是明确具体地指出，说得清楚明白。同义词条还有lay one’s finger on。 up one’s alleysuited to your abilities or interests，适合你的能力或兴趣直译为在谁家狭窄的小街巷上，如今引申为适合某人的才能或特长，或特别擅长的事情。常用的句式是doing something is right up my alley。 a good sportsomeone who can accept a loss in a competition or can accept being the butt of a joke，能接受比赛失利或是不在乎成为笑柄的人从竞赛精神出发，指不看重结果，输得起，有度量，或是有参与精神的人。 brownie pointsa notional mark to one’s credit earned for being seen to do the right thing，因为被看见做了正确的事，而得到抽象的表扬现如今已经不光指代女童子军中的“做好事分数”，而是用于各种日常场合，指好评，认可和赞扬。常用搭配有earn/score (some) brownie points。 hit the jackpotto win a large amount of money gambling or in a lottery; to be exactly right; to find exactly what was sought，在赌博或彩票中赢得一大笔钱；绝对正确；找到了确切的答案指中头彩，中大奖，获得了与金钱相关的巨大胜利，它可以来自赌博或投资等等。除此之外，它还可以表示说对了，一语中的，或是发现了真谛。jackpot是起源于美国1870年代的一种赌牌游戏。参与者先把下的注都放进牌桌中心的pot（奖池）里，游戏规则是每人发5张牌，谁的手里有大于10的一对牌，方可进行下一轮，没有直接淘汰。也就是说，手里至少有一对Jack，才有赢得pot里筹码的机会。]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oral English 2]]></title>
    <url>%2F2018%2F02%2F14%2FOral-English-2%2F</url>
    <content type="text"><![CDATA[Phil’s a snore.这个人太没劲儿。 讲解关键词snore，作动词表示‘打呼’。例句1. Stop snoring.别打呼了；例句2. You snore like a pig.你打鼾打的跟猪一样；作名词表示‘无聊的事情或人’。原句也可以改为：Phil’s a snore and he always makes us snore.Phil这个人很没劲，总是让我们打鼾（无聊后睡着） 补充1.口语里表示‘无聊’的表达bore：He’s a bore.他这个人很没劲；boring指令人感到无聊的：He’s so boring.他让大家感到无聊；bored指自己感到无聊：He’s so bored.他感到很无聊；2.发音技巧：口语里经常把is与主语连读：Bingo is here=Bingo’s here；My dad is a teacher=My dad’s a teacher.养成连读习惯，因为美国人很少说is，直接是‘s. I’ll go see if the idiot has checked in yet.我去看看那个白痴来了没。 讲解关键词check in，表示‘登记’；因为登记需要本人到场，所以原句中直接翻译成‘来’，口语里的check in比较多的是酒店登记入住与机场办登记手续.例句：1. What time should I check in?我几点来登记入住比较好？2. go to the check-in counter去登记台办理登机手续 补充check在口语里作动词可表示1. 检查：go check the second floor去看下二楼；2. double-check再次检查；3. 寄存：I’m gonna go check my coat.我去把外套寄存一下；4. 下象棋时表示：将你的军！；5. 作名词表示‘账单’，在国外吃完喝完就和服务员说：Check, please.表示‘买单’。 Or perhaps you’re turning your back on a man wrongfully accused.又或者是你要离开的人是被冤枉的。 讲解关键短语1. turn one’s back on…表示‘忽略，抛弃…‘。别人对你不理睬转身离去你就可以说Don’t turn your back on me!；别人放弃一个好的职业你可以劝他说You can’t just turn your back on your career；关键短语2. wrongfully accused.Wrong表示‘错误的’；wrongful表示‘不公平的，不合法的’；违法抓人就是arrest someone wrongfully；accuse表示‘指责，控告’；常见搭配：accuse sb of sth因为某事指责或控告某人，例句：Now you’re accusing me of this?你现在觉得事情怪我？（被冤枉时可以说） 补充back作名词表示‘背部’，必须知道的还有：I got your back.我帮你，我顶你；You’d better watch your back.你最好小心点；My back hurts.我背部疼。 It’s time to take the kissing up a notch.是时候让接吻上升一个高度了。 讲解关键词notch表示‘等级’，take sth up to a notch即表示‘将某事带到一个新的高度‘，take sth down n notch则表示‘将某事降一个高度’，动词可以换，比如tone作动词表示‘用某种语调说话’，tone it down a notch表示说话音调稍微小一点。 补充类似的表达还有take sth to the next level表示将某事带到一个新的阶段，例句：It’s time to take our relationship to the next level.是时候将我们的恋情发展到一个新的高度了；a notch below表示‘稍微差一点’，例句：This movie is a notch below that one.这部电影比那部稍微差一点；a notch above则表示‘稍微好一点’，例句：Tom is a notch above her.Tom比她稍微强一点；top-notch字面意思表示最高等级的；作形容词表示最好的。We need to find some top-notch players.我们得引入一些最顶尖的球员。 I gotta break in my new bag.我得赶紧背上我的新包。 讲解关键短语break sth in表示‘穿戴’，一般是新买的，赶紧穿戴来适应；例句：When are you gonna break in the shoes you bought last week?你什么时候穿上周新买的鞋？ 补充break in最常见的意思表示1. ‘强行入室’。例句：We can’t just break in.我们不能就这样强行进去；2. break in on表示‘打扰，影响到’。例句：The noise from outside broke in on my thoughts.外面的噪音打扰到了我的思路；关于break必须要知道的短语还有：break up with someone与某人分手；break sth off断绝某种关系；Break a leg!祝你好运（上台表演时才用）；break down机器的瘫痪或人的崩溃；take a break休息一下；break the ice打破沉默 That’s some drama.真是场好戏啊。 讲解关键词drama表示’戏剧‘，在口语中经常用来表示带有戏剧性的好戏；固定短语drama queen则用来表示一个很喜欢戏剧化小题大作的人，例句：Don’t be such a drama queen.不要如此小题大作；与它相似的短语是make a scene，表示‘引起众人围观’，例句：Keep it down. You will make a scene.小声点，不然会引来大家围观的。 补充drama的形容词dramatic表示戏剧化的，当一个人小题大作时，你可以对他说：You’re being so dramatic.你也太喜欢戏剧化了；相思词是emotional表示情绪化的：Don’t be so emotional.别太情绪化；相关表达还有：Keep it low.低调点；You gotta lay low.你得保持低调；Don’t make a big deal about it.别小题大作。 Since I’m the new girl, I figured there’d be some hazing.由于我是新人，我也想到我会被欺负了。 讲解关键词1. figure，除了熟悉的表示‘数字’，‘人物’等意思之外，口语中经常表示动词‘以为，想到’，一般用过去时形式较多，例句1：You’re the boss. So I figured maybe you could help me.你是老大，所以我觉得或许你能帮我；例句2：A: She’s not coming.她不来了；B: Yeah, I figured.嗯，我想到了；关键词2. hazing表示‘被欺负’，例句：There’s lots of hazing in the military.部队里有很多人被欺负的现象。 补充hazing的原形haze作名词表示‘雾霾’，形容词hazy表示‘雾霾很多的’.例句：It’s very hazy in Shanghai today.今天上海雾霾很严重；hazy还可表示模糊的。例句：My memories of his are very hazy.我对他的记忆很模糊了；雾很大也可说it’s very foggy. For starters, she’s always harsh on my body.首先，她一直对我的身材要求很苛刻。 讲解关键短语1. for starters表示‘首先’，在举例陈述第一条时经常用，同义短语还有firstly；first of all；to start with；to begin with，在做presentation时可表达多元化；关键短语2. Harsh on表示对…要求苛刻，例句：You’re being too harsh on your kid.你对你小孩太过于严格；同义短语是be hard on，例句：Don’t be so hard on him.别对他太严格了；因为hard口语里经常表示严格痛苦.Don’t give me a hard time.的意思就是‘别跟我过不去，别故意让我难受’。中文里的敬酒不吃吃罚酒在英语里就可以用You want to do this the hard way?来表达。 补充starter在英式英语里表示‘开胃菜’；美国人则用appetizer. They started to pick on me after I just arrived.我刚到他们就开始欺负我。 讲解关键短语pick on sb表示‘欺负某人’，例句：John’s always picking on me.John总是欺负我；美国校园里也有恶霸，叫bully.也可作动词，例句：I hate bullies. Theys always bully people for no reason.我讨厌恶霸们，他们总是毫无理由欺负别人。 补充流氓可以叫hooligan或thug；关于pick必须掌握的用法还有：1. just pick one.随便选一个吧；2. Take your pick.开始选吧；3. pick sb up去接某人；4. be picky挑剔的：Don’t be so picky about food.别这么挑食；5. pick one’s nose挖鼻孔；6. toothpick牙签；7. cherry-pick择优挑选；8. pick holes in找茬儿，例句：Why do you always pick holes in what I do?为什么不管我做什么你都找茬儿？ She’s at a new extension. I’ll transfer you.她有了新的分机号。我帮你转接。 讲解关键词1. extension在这里表示‘电话分机’。本意是‘延伸’；办公室分机号就是extension number.例句：I’m looking for Bingo. Do you know his extension number?我找Bingo.你知道他的分机号吗？关键词2. transfer表示‘转移转让’，此处表示‘转机’，例句：Could you transfer me to him?能把我转接到他吗？My boss is transferring me to Hong Kong.我老板要把我调到香港去。 补充和老外打电话比面对面聊天难度大。学会这些表达：1. Hello?喂？；2. You still there? 还在吗？；3. I’m losing you.听不到你说话了；4. Sorry I have bad reception.不好意思我信号不好；5. The connection is bad. I’ll call you back.信号不好。等会打给你。 We’re just gonna drop Hilary off and come right back home.我们把Hilary送到那之后立马就会回家。 讲解关键短语drop sb off，表示‘开车将某人放下’；比如你的朋友开车送你回家，到家门口你可以说：Just drop me off here.我在这下车就好；Drop him off at my sister’s place.把他送到我姐姐家吧；come right back home表示马上回家。英语里经常在back前面加right强调很快马上。比如和朋友聊天你要出去一下，你可以说I’ll be right back.表示我马上回来。 补充关于开车送人还需要知道的表达有：1. Give sb a ride载某人一程：Could you give me a ride home?能载我回家吗？；2. Take sb for a ride带某人兜风：Let me take you for a ride.我带你出去兜一圈；3. hitch-hike免费搭顺风车旅游（老外特别喜欢这样） She was potty-trained at eight months.她八个月大就教她如何上厕所了。 讲解关键词potty表示‘马桶（小孩用语）’；trained表示‘被培训’。美国人会在小孩小的时候教他们如何如厕，文化差异是美国的小孩儿是不穿开裆裤的，中国小孩基本都穿过，英语里会经常用一些迭声词跟小孩沟通，比如：wee-wee/pee-pee小便；poo-poo大便；choo-choo火车；还有些词成人也用，如nighty-night晚安；okeydokey好的. 补充toilet在英式英语表示厕所；去洗手间就是go to the toilet；英国人还喜欢用loo；toilet在美语里表示马桶；美国人喜欢用bathroom/washroom/restroom表示厕所：I’m gonna go to the bathroom.我去下洗手间。Bathroom原本指家里的卫生间，朋友之间在公共场所也会用。女生也可以说go to the ladies’ room；男生则用go to the men’s room. Obese knees are the hardest.肥胖的膝盖是最难弄的。 讲解关键词obese表示‘超级胖的’，名词为obesity.Obesity is a very serious problem in the US.在美国，肥胖是很严重的问题。因为美国人吃junk food（垃圾食品）很多，开车也比较多。Fat作形容词表示胖的；胖子叫fatty；胖猪叫fat-ass；fat作名词表示脂肪；fatty表示脂肪多的：You gotta go easy on fatty foods.你一定要少吃脂肪多的食物。 补充文化差异：中国人对身边胖的朋友喜欢昵称叫‘胖子’，但是fat在英语里是贬义词，如果一个人胖，你可以描述说：He’s a big guy.不要说He’s a fat guy.身材好可以说She’s slim或者She has a good body或She’s in good shape.Thin表示‘瘦’，在英语里也是贬义词。 You’re on your own, buddy.哥们，你得靠你自己了。 讲解关键短语on one’s own靠自己，例句：She did that all on her own.她是靠自己完成的；From now on, you’re financially on your own.从现在开始，你经济独立了！ 补充1.拒绝帮别人时可以说：1. There’s nothing I can do (about it).我也无能为力；2. I would if I could.（完整为：I would help you if I could help you）爱莫能助；3. I’ll see what I can do.我尽力而为吧。2.buddy表示朋友间的哥们；美国的父亲也喜欢叫儿子buddy，或简短的bud.美国人叫哥们还喜欢用man，dude，bro；英国人澳大利亚人喜欢用man，mate.在伦敦经常听到英国人说：Cheers, mate.Cheers在这表示‘谢谢’。美国人则会说：Thanks, buddy. I know. Tell me about it.我知道。可不是嘛！ 讲解I know看似简单，有两个注意点，1. 翻译成中文应是‘我知道’，而在别人告知或讲解后你该说‘我知道了’，对应英文则是：I see；Got it；Got you（Gotcha）；2. 对于别人说的你感同身受时，美国人喜欢说：I know, right?表示赞同。例句：A: It’s too hot in here.这儿太热了；B: I know, right?就是啊！Tell me about it字面意思是‘跟我说说这个’，在两种语境可用：1. 有人说We kissed last night（我们昨晚接吻了）；你可以说Tell me about it.这时对方是需要跟你描述昨晚的事的；2. 当对方说一件很明显或让你感同身受的事情时，比如It’s too hot in Shanghai.上海太热了，你说Tell me about it.意思是‘可不是嘛’，这时是不需要继续描述的。 Since you volunteered, no take-backs.你既然主动报名了，不准反悔哦。 讲解关键短语take sth back，表示拿回某物；口语里在说了自己后悔的话之后，可以说：I take it back.我收回我说的话；原句里的take-back是名词形式，动词短语连起来可表示名词，类似的还有：take sth away拿走某物；takeaway外卖，例句：Let’s order some Chinese takeaway.我们打电话叫中餐外卖吧。Volunteer可作名词表示志愿者；也可作动词表示‘主动做某事’。 补充口语里说的‘话’经常用word这个词来表示，eat one’s words可以表示‘收回说的话’，跟吃没有关系；I give you my word或者You have my word都表示‘我向你保证’；Keep your word不准食言；have a word with you跟你说句话 Chop-Chop.快点！ 讲解chop本身意思为‘剁碎’；可以想象烧菜时迅速切菜的动作，表示非常迅速；例句：We’re running late. Chop-chop.我们要迟到了，快点。 补充1.口语里经常用的表示快点的短语有：1. Hurry up；2. Come on/C’mon；3. Move it快点走；4. Get a move on!；5. Be quick（用的很少）；2.美国人还喜欢在句子后面加already这个词表示快做某事；有人有事不告诉你，你就可以说Tell me already.快点告诉我；你敲门很久没人开门你可以说Open the door already.快点开门；3.chopper则是俚语，表示‘直升机（helicopter）’；4.在句尾加real quick，表示很快回来：I’m gonna go to the bathroom real quick.我去趟洗手间，很快的。 She’s really slammed. Let’s not bother her.她手里太多工作了。我们不要去麻烦她了。 讲解slam作动词表示‘砰地关上’，如slam the door用力关门；在美国俚语中可表示给某人安排很多工作。例句：My boss slammed me before I was about to leave.我刚准备走，老板给我加了很多工作。所以原句中slammed作形容词表示工作很多很忙；bother作动词表示‘麻烦或骚扰’：1. Don’t bother to call me.别打电话给我了（打了我也不会接）；2. Is this guy bothering you?这人是不是在骚扰你？ 补充口语里表示忙碌可用：I’m really busy；I’m really swamped；My hands are full；I have a lot on my plate；正在忙可以说：I’m in the middle of something.；the slam是俚语表示监狱；Slam dunk表示‘灌篮’。 High school for me was no picnic.高中对于我来说蛮艰难的。 讲解picnic除了表示野餐外，还可表示简单的事情。‘no picnic‘是固定表达表示艰难的事情。例句：Memorizing 500 new words a day is no picnic.一天背诵500个生词很难。 补充1.口语中表示事情或任务很简单轻松的表达有名词breeze/cinch/child’s play/a piece of cake/duck soup；有形容词easy/easy-breezy/easy as pie；2.表示轻松成功做成某事可以说nail sth或kill sth.比如有人问你how was the interview?面试进展怎么样？你就可以回答：Nailed it.成功搞定了；你朋友上台之前紧张，你可鼓励说：You will kill it.你会成功搞定的。 Alright. Bring it in!好吧。过来拥抱一下。 讲解关键短语bring it in字面意思是‘把它带进来’，其实是美国人在要和对方拥抱时经常说的话。也可以是人多时，比如教练会说bring it in, guys.就是让大家过来聚在一起打气。所以下次要让对面的人过来拥抱一下除了说give me a hug让我抱一下外也可以说Bring it in. 补充美国人英国人的肢体动作比较多，男生之间握手要用力，别人会夸你good handshake，否则会觉得很weak（弱）；击掌可以说：High five!或Give me five；击拳可以说：Pound it!；女孩之间在亲脸颊（kiss on the cheek）比较普遍，可以亲一边；要是好久不见也可用力亲两边；刚认识的朋友一般不亲。 Cuz my tai chi class is doing a pub crawl.因为我们太极班的同学今天要各种串吧。 讲解这边涉及到文化特色的问题，pub表示小酒馆或小酒吧，也可说tavern或bar；crawl表示‘爬行’。因为西方人喜欢喝酒的文化，pub crawl（也叫bar crawl）表示的是一种喝酒活动，一帮朋友组队，一个下午或一个晚上要去很多酒吧喝酒，在这家喝完去那家喝，感觉是从这家爬到那家似的。Bar crawl因此而得名。 补充关于酒吧，bar指那种一般安静可聊天的酒吧；club或nightclub指夜店；如果在夜店，bar则表示‘吧台’，家里的吧台也叫bar.例句：let’s go to the bar.我们去吧台吧；Let’s go to a bar.我们去一家酒吧吧。注意区别。西方大部分酒吧也是不可以抽烟的。 We’re screwed.我们完蛋了。 讲解关键词screw，除了熟悉的作名词表示螺丝钉；作动词表示‘拧’之外，口语中经常表示气愤生气，例句：Screw out!去你的！；Screw that!管它呢！；用screw的被动形式screwed表示完蛋了，是screwed up的简写：You’re so screwed (up).你毁了！ 补充关于screw必须要知道的表达有1. screw sth up搞砸了：Sorry I screwed up.对不起我搞砸了；2. screw around乱搞男女关系或闹着玩儿（具体看语境）：You can’t screw around.不要到处瞎搞；We’re just screwing around.我们俩闹着玩的；3. screw sb up使某人精神崩溃：Your divorce is gonna screw you up.离婚会让你崩溃的。 Any other topping suggestions?顶部要放什么配料呢？ 讲解关键词topping，由top变化而来，top作名词表示‘顶部’或女生穿的短袖体恤等，the top ten players最顶尖的十位球员；所以形容词topless表示上身裸体的；top作动词表示‘超越’，例句：She topped her last performance.她这次的表演超过了上次；topping作名词表示食物顶部加的配料；在英式英语中topping作形容词表示特别棒的，等于excellent. 补充关于top必须要知道的还有1. tops表示‘顶多’，放于句尾：I have 5 dollars, tops.我身上最多5块钱；2. off the top of my head我首先想到的是；3. on top of the world特别开心；4. top up my phone给我手机充值 Hey, dig in, guys.大家开吃吧！ 讲解关键词dig in，字面意思是在里面挖，想象吃饭时就不难理解了。在美国家庭中，坐上饭桌时主人家长会说这句话，也会有人说Bon appetit.法语，表示有个好胃口. 补充在国外吃饭点餐要学会说1. take it easy on…, please少放一点：Take it easy on the onions please少放点洋葱；2. hold the…不要放：Hold the onions please不要放洋葱；3. 点餐请用Can I have…句型，不要说I want…；4. Check, please买单；关于dig还要知道：1. do some digging做些调查；2. I dig you我喜欢你（dig在口语中可表示like喜欢）；3. Can you dig it你明白吗；4. This is my digs.我住这.加了s的digs表示住处 Let’s pinky swear.我们拉钩。 讲解pinky和粉色没有关系，这边表示小拇指，也可写成pinkie，swear在这表示发誓，小拇指的发誓就是我们所说的拉钩一百年不许变。美国人在和别人有约定后还喜欢说You promise?你能保证吗？ 补充1.swear to sth表示对…发誓：I swear to God.我对天发誓；swear on sth表示以…发誓：I swear on my life.我以我姓名发誓；swear allegiance to…表示对…宣誓衷心；2.swear还可以作动词表示‘说脏话’：don’t swear不要说脏话；swear words脏话；3.关于pink还要知道in the pink表示健康面色红润：My dad’s in the pink.我爸现在身体不错；tickled pink很开心：I’m tickled pink to see you.看到你我很开心。 I am so hung-over.我现在特别宿醉。 讲解关键词hung-over形容词，表示宿醉，名词是hangover.用法：I’m having a huge hangover right now也表示我现在很宿醉；宿醉的特点就是头疼（have a headache）；身体缺水（dehydrated）；喝多了叫drunk；烂醉叫trashed/wasted/loaded/hammered，还有一个搞笑的说法是three sheets to the wind；微醺叫buzzed或tipsy；很清醒叫sober；酒量很好叫can drink like a fish. 补充关于hang必须要知道的表达还有：1. Hang in there.加油，顶住；2. Hang on (a second)等下；3. leave sb hanging让某人干等着；4. How’s it hanging=How’s it going最近怎么样；5. hang out一起玩，放松（不一定是在外面）hang out at my place在我家玩 Pick up the energy.振作起来！ 讲解pick up最简单的意思是‘捡起来’，原句字面意思表示把能量捡起来，其实就是振作的意思。如果是心情的失落需要振作就说：Pull yourself together. Pick up的意思还有1. 取东西：I’m here to pick up my jacket.我来取我的外套；2. 随便学点：I picked up some French when I was in Paris.我在巴黎的时候学了点法语；3. 接人：I’ll pick you up at 5.我五点钟接你；4. 变好了：My luck has picked up.我转运了；5. 振作精神，提神：He picked me up at my lowest.在我人生最低谷时他帮我重新振作；I need something to pick myself up.我得喝点东西提神。名词pick-me-up表示提神的东西。例句：What’s your morning pick-me-up?你早上喝什么提神？；6. pick-up (truck)客货两用的卡车 Sorry I just blew it.对不起，我搞砸了。 讲解关键词blow，都知道blow表示‘吹’，如blow out the candles吹灭蜡烛；the wind is blowing in my face风吹打着我的脸；blow dry吹干；blow dryer电吹风；但是blow在口语中经常表示‘搞砸’，如：I blew my test yesterday我昨天的测试搞砸了；Don’t blow it this time.这次别搞砸了. 补充搞砸了美语里还有：mess sth up/screw sth up.Don’t mess it up别搞砸了；关于blow必须要知道的用法还有：1. blow money挥霍钱：I blew 5 grand last night昨晚我挥霍了5000美金；2. blow sb off爽约：She blew me off again她又放我鸽子了；3. blow my mind使我震撼。 I think you need to cut her some slack.我觉得你对她应该松懈一点。 讲解关键短语cut sb some slack，本意表示‘允许某人稍微落后，休息’，也就是不要要求太苛刻。比如你已经工作了一天你女朋友还让你打扫家里，你可以说：Cut me some slack.让我休息放我一马的意思；相似的表达是give sb a break，字面意思是让某人休息一下。比如你酒量不好，有人一直盯着你让你喝，你可以说Come on, give me a break.拜托，放我一马吧。注：Give me a break也可以表示对别人说的话不相信，换个语境意思就是：你可以拉倒吧！ 补充slack作形容词表示疏忽的松懈的；slacker表示懒鬼。关于cut的表达还需要知道：Cut it out.赶紧停止吧！；cut in line插队，不要插队：Don’t cut in line.或No cuts, no buts, no coconuts.或直接No cutsies! Hilary hooked up with a boy at a party this weekend.这个周末Hilary在一个派对上跟一个男生好上了。 讲解关键短语hook up，表示‘与某人搞上了’，由于西方的性文化，hook up with sb一般是指两个人发生性关系，但也不绝对；hook sb up with sb还可以单纯表示介绍两人相识：Could you hook me up with your boss?能介绍我跟你老板认识吗？；hook sb up with sth表示帮某人搞到某物：My buddy hooked me up with 2 tickets我哥们帮我搞到了两张票。 补充hook本身的意思是钩子；fishhook表示鱼钩；所以其形容词hooked表示上瘾了；短语是hooked on：My brother is hooked on computer games.我弟弟网游上瘾了；Don’t ever get hooked on drugs.永远不要对毒品上瘾。Hooker则表示妓女，很常用。 Real estate’s great for those that are business savvy.房地产适合这些会做生意的。 讲解关键词1：real estate表示房地产；房地产中介公司就说real estate agency；中介要拿提成，在英文里是commission（佣金）；中介人就是realtor.关键词2：savvy作名词可表示懂行的人，专家。原句中business savvy就是生意专家，也就是会做生意的人；如果你对电器电子设备懂的多，你就是一个tech savvy，科技专家。 补充在某个领域的专家叫expert；医学类的专家是specialist；如果很擅长做某事可以说be adept at，如：He’s so adept at negotiating.他是个谈判专家；如果一窍不通可以说：know nothing about：I know nothing about singing.我不懂唱歌；don’t know the first thing about：You don’t know the first thing about marriage.你对婚姻根本不懂。 We all took a bunch of goofy photos.我们都拍了一些很傻的照片。 讲解a bunch of表示‘一些’，也可用a few，美国人特别喜欢用a couple of，a couple表示一对夫妇或情侣；所以a couple of严格来说表示两天，但是口语里经常表示两三天，一个不确定的数字。并且of是经常省略掉也不发音的，如：a couple days ago两三天前；goofy是形容词表示愚笨的，可爱且傻傻的感觉。和silly表示傻的差不多，没有恶意。Dumb或stupid表示愚蠢就是贬义了；goof作名词可表示小傻蛋，动词短语goof around表示不做正事的度过时间。 补充拍照片叫take a picture/photo；想和别人合照说：Can I take a picture with you?；想请别人帮你拍照说：Could you take a picture for me?；想让别人拍张你的照片说：Could you take a picture of me?自拍叫take a selfie. You need to chill.你得淡定下来。 讲解关键词chill作动词表示‘冷静，放松’，省略了out.有人冲动或不淡定时你就可以说you gotta chill (out).在口语里美国人经常用chill来表示relax（放松），没做什么特别的事情的时候，别人问你在干嘛，你就可以说：Just chilling at home.在家休息放松呢。 补充1.表示淡定还可以说Calm down；Cool it；Take a chill pill；英国人喜欢说Wind down；2.美国人现在还喜欢说Chillax表示淡定，是chill与relax的合成词，类似的词还有fantabulous特别棒的，是fantastic+fabulous的合成版；3.chill作名词可表示寒冷，chilly作形容词表示寒冷的.例句：It’s a bit chilly outside.外面有点冷。 I gave her the chance to come clean and she lied to my face?我给她机会实话实说她却当着我的面撒谎？ 讲解关键短语1：come clean表示实话实说，例句：You gotta come clean about your job.你必须把你的工作老实说一下；关键短语2：to my face表示当着我的面，例句：You’re calling him to my face?你当着我的面给他打电话？ 补充与某人实话实说还可以说：be honest with：You’d better be honest with me.最好跟我说实话；level with sb：I’m just gonna level with you.我就跟你实话实说了；clean除了表示干净还可以表示一个人没有犯罪或吸毒：he’s clean.他没事（警匪片经常听到）；in one’s face表示‘直接，挑衅’：He slammed the door in my face.他直接甩门而走；lose face丢脸；save face挽回颜面。 She’s a mess.她的生活完全乱套了。 讲解关键词mess，作名词表示‘混乱’，形容词messy表示混乱的；可以是东西的乱，如：My room is a mess/My room is messy.我的房间很乱；也可以是人生活的混乱：My life is a mess.我也不知道过的什么日子；作动词经常表示弄脏弄乱搞砸，比如mess up：don’t mess up my couch别把我的沙发弄脏；You messed up again?你又搞砸了？；也经常表示‘惹怒’，比如mess with：Don’t mess with me.别惹我；mess with也表示闹着玩。Easy man. I’m just messing with you.淡定哥们，我跟你闹着玩的；mess around表示两个人胡闹着玩：We’re just messing around.我俩闹着玩呢，别当真。 补充一个人做事很有规划不混乱可以说organized，反义词则是disorganized.Bingo’s pretty disorganized.Bingo这个人做事挺混乱的。 You know that made no sense, right?你知道那根本说不通，对吧？ 讲解sense作动词表示感觉到，如：I’m sensing a little hostility here.我感到一点敌意；作名词表示感觉感官，如sense of humor幽默感；sense还可以作名词表示‘道理，合理性’；原句中make no sense的字面意思是没有任何道理合理性，即‘说不通’。下次别人做了或说了让你很奇怪的事情你可以说It doesn’t make any sense.这根本就说不通啊；别人不讲道理时你可以说Make some sense.讲点道理啊！ 补充关于讲道理的表达还有：1. talk some sense into sb劝别人讲道理：You gotta talk some sense into her. She’s crazy.你赶紧劝她讲点道理，她疯了。；2. Be reasonable.你讲点道理！；3. In a sense从某种意义上来说。 This is a breach of trust.你这是失信啊！ 讲解关键词breach，作动词表示违背，如：breach a contract（合同）违约；也可作名词，结构为a breach of…：Y=This is a breach of promise.你这是违背诺言了；a breach of law违法；原句中a breach of trust表示违背了别人信任。 补充口语里关于失信的表达还有：1. You broke your promise；2. You didn’t keep your word/promise；相关表达：1. I trusted you.我之前都是相信的；2. Trust me on this one.这次相信我；3. You failed me.你辜负了我（fail sb表示辜负某人）；文化补充：美国人喜欢给自己的孩子弄trust fund信托基金，给孩子经济上后援。这样的孩子叫trust fund baby.这个可以对应成中国的富二代。 She was completely in the dark.她根本就不知情啊！ 讲解关键短语in the dark，字面意思表示在黑暗处，引申为‘不知情’。类似表达还有：keep sb in the dark不让某人知情：We must keep him in the dark about what’s going on.不能让他知道在发生什么；keep sth dark不要别人知道：keep his identity dark不要说他的身份；dark本身表示黑暗，天黑了，皮肤黝黑，都用dark，不要说black. 补充1.守住秘密的表达还有：keep sth from sb：Don’t keep anything from me.不要跟我有秘密；It’s just between us.不要让第三个人知道；My lips are sealed/Your secret is safe with me.我不会说出去的；It stays in this room.不要说出去；2.关于dark要知道一个短语take a shot in the dark字面意思是在黑暗中射击，表示瞎猜的，瞎蒙的。 I’m gonna need to recharge my batteries.我得好好休息恢复状态。 讲解这是一个比喻表达。原句中recharge my batteries字面意思是给我的电池充电，其实就是让自己的身体休息从而恢复；关于充电，也可以说charge，如charge my phone给我的手机充电；充电器叫charger；出国会需要电源转接器adaptor；手机要没电可以说My phone’s dying；彻底没电了就说My phone’s dead. 补充一般累了我们可以take a nap，小睡一会儿；如果对方累，你也可以说go get some sleep，去休息会；失眠了就说can’t sleep.虽然insomnia也是失眠，但它表示的是长期的疾病，一般睡不着就说I can’t sleep；如果长期失眠再说：I’m suffering from insomnia；累了要休息也可以说get some rest. You brought this on yourself.这是你自找的。 讲解bring sth on oneself字面意思是‘把…带到自己身上‘，引申为自找的。例句：She brought the divorce on herself.离婚都是她自找的；口语里表示自找的还有：1. You asked for it.你自己要的（用过去时）；2. You deserve it.你活该（这是你应得的，看具体语境）；3. You’re the one to blame./It’s all your fault.都怪你；4. You had it coming.你自找的。 补充关于bring必须要知道的表达还有：1. bring sth up提起：Don’t bring it up.别提那事儿；2. be brought up长大：I was brought up in America.我在美国长大；3. Bring it (on)!放马过来./开始吧（接受挑战时说）；4. bring the home the bacon养家糊口. Lily, let’s get you dressed.我们帮你把衣服穿好。 讲解关键词dress除了表示‘裙子’，口语里经常作动词表示穿衣，穿着，被动形式居多。例句：I need to get dressed first.我得先穿好衣服；Why are you not dressed yet?你怎么还没穿好衣服？be dressed了用来表示穿的衣服，如He’s dressed in jeans today.他今天穿的是牛仔裤；dress up则表示盛装或特地穿上某种服装，如：Why are you all dressed up?干嘛穿的这么正式？dress up as表示打扮成，如：I dressed up as ironman for Halloween last year.去年万圣节我打扮成了钢铁侠。 补充一般的裙子叫dress，短裙叫skirt，连衣裙叫one-piece (dress)；盛装打扮也可以说doll up或deck out。例句：You need you doll up before you go to that fancy party.去那个高档派对之前要盛装打扮好。 I really was in a jam.我当时真的很困难。 讲解jam可以作名词表示果酱；或交通堵塞；或困境窘境。原句中短语in a jam表示处于困境中；交通堵塞完整说法是traffic jam；jam作动词可表示使…堵塞，所以路上很堵可以说：The road is jammed with traffic.超级拥挤可以说：jam-packed.例句：It was jam-packed last night.昨晚真是人挤人啊！ 补充处于困难的处境的表达还有：1. torn纠结的：I’m torn. I don’t know what to do.好纠结，不知怎么办是好；2. put sb on the spot让某人为难：Come on, man. Don’t put me on the spot.拜托哥们，别让我为难；3. 别人问你how are you，如果你过的不是很好，可以说：I’ve been better或I’ve had better days.意思就是最近不是很好。 I did my best to cram for my lectures.我尽力为我的演讲恶补了。 讲解关键短语do one’s best，表示‘尽力而为’。相似表达也可以说give it one’s best shot.例句：Just give it your best shot.尽力而为就好。关键词cram表示恶补，临时抱佛脚的感觉，例句：Everyone is cramming for their finals.大家都在为期末考试恶补。 补充提升学习的强度恶补也可以用bone up on sth，例句：He’s going to the US next week. So he has been boning up on his English.他下周要去美国，所以他最近在恶补英语；shot的字面意思表示射击，口语里经常用它表示努力或机会。如：1. Give it a shot试一试；2. This is your last shot.这是你最后一次机会；3. It’s a long shot.这事难度很大（long shot，字面意思是射击远，所以难度大） That’s the worst call ever.这个决定差到极致了。 讲解关键词1：call可表示打电话，动词名词均可：如call me tomorrow/Give me a call tomorrow都很常用；但是口语里经常把它用作‘决定’的意思，本来make a call表示打一个电话，引申为做一个决定，因为你给谁打电话是你做的决定，所以口语有这样的表达：A or B? Your call!要A还是B，你来决定；It’s your call to make, not mine.是你要做决定，不是我；别人做了你喜欢的决定你可以说Good call；反之就是Bad call.关键词2：ever，在最高级句尾加ever表示强调，加深感情，类似于中文的‘史上最…‘，如：You’re the best teacher.你是最棒的老师！感情要比you’re the best teacher要强很多。度过了很不顺利的一天，回家后就说：I just had the worst day ever! I don’t want you to jump into anything.我不希望你匆忙做决定。 讲解关键短语jump into sth，字面意思表示‘跳进去’，其实就是匆忙做决定。你朋友要闪婚的话，你就对他说：You’re jumping into this.与它相似的表达是jump to conclusions表示匆忙作出结论；口语里也常用rush into表示急匆匆的做决定：Don’t rush into anything也表示不要匆忙做决定；别人很急匆匆的你可以问：What’s the rush?或What’s the hurry?急什么？ 补充匆忙时要记得：1. Think it over.再仔细考虑考虑；2. Think it through.把事情方方面面考虑周全；3. Think twice.三思而后行；jump的形容词jumpy表示人焦虑不安的。 TMI, huh?太多信息了是吧？ 讲解TMI的完整形式是too much information.口语里用得较多；常见的缩写需要知道的有：1. FYI=for your information顺便跟你说一下；2. BTW=by the way顺便说一句或顺便问一下；3. ASAP=as soon as possible尽快（注意口语经常读成A-SAP）；4. LMAO=laugh my ass off笑死了（中国人的意象是笑掉大牙；美国人是笑掉屁股，文化差异）；5. LOL=laugh out loud哈哈；6. TGIF=thank goodness/god it’s Friday终于到星期五了（美国人在星期五喜欢说，晚上要party）；7. JK=just kidding开玩笑而已；8. RIP=rest in peace安息（有人去世时会说）；9. ROTFL=rolling on the floor laughing躺在地上笑；10. TBD=to be decided/determined待定。 And there’s a few people outside.而且外面有些人。 讲解关键结构there’s，这边有个概念，就是书面语法与口语语法的区别，基本相同，只不过口语语法相对更随意，由于后面是a few people一些人是复数，按书面语法应为there’re a few people，但口语里不管是单数还是复数，美国人都经常说there’s；常见的口语语法还有：Let’s go eat/Come say hi。即口语里表示去干嘛来干嘛可直接加动词，而不是书面语法的go and eat；If I was you，虚拟语气，如果我是你的话，书面语法应为If I were you，但口语里经常用was即可；me and Bingo，我和Bingo，按照书面语法应为Bingo and I，但‘我和谁’在口语里经常是me and 谁谁谁…。 How can they just kick us out?他们怎么能就这样赶我们出去？ 讲解关键短语kick sb out表示‘赶某人出去‘。例句：My wife kicked me out.我老婆把我赶出了家门。关于kick还需要知道的用法有：1. kick off开始：My vacation now officially kicks off.我的假期正式开始；2. kick in药起作用：The medicine hasn’t kicked in.药吃了还没感觉；3. kick back休闲放松：I’m gonna kick back at home tonight.我今晚就待在家休息了；4. kick sb’s ass/butt痛扁某人或比赛中的狂虐：He’s gonna kick your ass in the game.比赛中他会很容易打败你的；5. ass-kicking很棒的：This is an ass-kicking party.这个派对太棒了；6. kick the bucket去世；7. get a kick out of sth做某事而感到快乐：You’ll get a kick out of it.你会喜欢的。 There have been rumors.有这样的谣言在散播。 讲解关键词rumor表示‘谣言’，常用固定句型Rumor has it that…+谣言的内容。例句：Rumor has it that he is getting fired.有谣言说他要被解雇了。和rumor相近的词还有gossip八卦：Don’t gossip about my life.别八卦我的生活；talk闲聊八卦：Why did you tell him? You know people talk.你干嘛告诉他？你知道人是会闲聊的。 补充在口语学习过程中，多记句型要比死磕语法效果好的多。比如It’s been…经常用来表示‘已经过了多久’或对即将结束的事情的评价，如It’s been a week.已经过了一周了；It’s been a fun journey.旅途到现在为止很开心。不需要去纠结it’s been的完成时的种种。多积累句型，对应中文的表达。 She would’ve wanted this.如果她还活着，她也会希望你这样的。 讲解继续关注句型，少抠语法。原句中would’ve done结构，经常在描述一个已经去世的人时会用，记住这个就行了，比如：Your mom would’ve said yes.你妈要是活着也会答应的。不用太纠结其中语法。 补充would’ve的发音实际有两种：would of和woulda，不会把would have完整发出来；类似的还有：should have=should of=shoulda；could have=could of=coulda；must have=must of=musta；proud of=prouda；out of=outta；kind of=kinda；sort of=sorta；原因是两个：1. have弱读之后发音与of一样；2. t/d后面的of直接把f的发音省略，这样发音更轻松更地道。 You are so high-maintenance.你可真难伺候。 讲解maintenance是maintain（维修）的名词形式，high-maintenance指need a lot of effort to keep in good condition需要大量精力来运转良好。例：I’m tired of having a relationship with my girlfriend, she is so high-maintenance.我受够了跟我女朋友谈恋爱，她真难伺候啊。此外，‘苛求的，难讨好的‘还可以用’demanding‘和’hard to please‘. 补充其反义词‘特别好搞定的人’叫做pushover：Stop bullying me, I’m not a pushover.别再欺负我了，我可不是软柿子，随便让你捏。 This is a killer apartment!你这房子太酷了！ 讲解killer本意指‘杀手’，但口语中有另外两个意思。其一：something or someone very difficult.例：The exam was a real killer.这次考试好难。其二：something very impressive.例：The new movie is a killer.这部新电影超带劲儿。此外，killer smile迷死人的微笑；killer charm让人眩晕的个人魅力。 补充killer还可以当感叹词单独使用。例：A: Guess what? I got accepted to Harvard Law!你猜怎么着？我被哈佛法学院录取了！B: OMG, killer!天哪！简直棒呆了！ She’s playing hard-to-get.她在吊你胃口呢。 讲解hard-to-get‘很难得到手’。例：A: I’m really upset! She doesn’t find me attractive.郁闷啊！她不喜欢我！B: Relax! She is just playing hard-to-get.放松！她只是在吊你胃口而已。 补充‘吊胃口’还有‘一直让某人猜测，始终不说答案’的意思，对应英文是：‘keep/leave someone in suspense’.Suspend本意‘悬挂、吊起’，名词suspense表示‘紧张感，担心’。例：Don’t keep us in suspense any longer, tell us what happened!别再吊胃口（让我们着急）了，快告诉我们出了什么事了！ I can’t get over you.忘记你我做不到。 讲解‘get over’表示‘忘记；熬过；释怀’。例：I’m over you!我已经把你忘记了！get over还可形容‘反应过来，回过神儿来’，如果你看到以前相貌平平的同学现在很美，就可以说：I can’t get over how great you look!真不敢相信，你现在这么美了！ 补充有个很像的词组：I’m all over you!意思完全不同：我超级喜欢你！all over表示整个人都扑到什么上面，迷恋。 I took it pretty hard!我深受打击。 讲解take it easy‘放轻松，轻松接受…‘；take it hard‘难以承受’。例：A: What did he say when you told him you wanted a divorce?当你说要离婚的时候，他说了什么？B: He took it pretty hard, but he’ll get over it.他很难接受，不过他会度过伤痛的。 补充take还有很多搭配：1. Don’t take it personally.这事不是针对你，别放心上。例子：Don’t take it personally, she’s rude to everyone.别往心里去，她对谁都这么粗鲁。2. Don’t take it the wrong way.别误会。3. Don’t take it seriously.别当真，别较真。4. Don’t take it for granted.别想当然以为（这是你该得的）。 We’re just being honest here.我们这是在实话实说。 讲解关键是being这个词：强调当下的动态，让句子听起来更为活泼。最后的here，并非指‘这里’，而是‘在这件事上，此时此刻’。例：A: Stop telling me I’m wrong!别再说我错了！B: We’re just honest here. It’s for your own good.我们这是在实话实说，这是为了你好。 补充常用类似表达：You’re being unreasonable here.你在这件事上怎么这么不讲理啊。You’re being ridiculous here.你现在怎么莫名其妙啊！ Cheer up!高兴点嘛！ 讲解cheer up的意思是‘提起精神，使…不再丧志‘。例：Cheer up, better times may be ahead.高兴点嘛，好日子没准儿就在前面呢。例：A: Let’s buy her flowers to cheer her up.咱们去买花来逗她开心。B: The only thing that’s going to cheer her up is getting her job back.唯一能逗她开心的事，就是让她重回原来的工作。 补充常用类似表达：cheer sb on鼓励某人：The crowd cheered the runners on as they started the last lap.赛跑进入最后一圈时，观众为运动员加油鼓劲。 This is so made up.一听就知道是瞎编的。 讲解make up有很多用法。其一：‘乱说，瞎编’。例：A: Did you make that story up?那个故事是你乱说的吗？B: No, I’m totally serious. It really happend.不，我百分百是认真的，真有其事。其二：‘化妆’。例：She spent an hour making (herself) up before the party.她在聚会前化妆用了一个小时。例：She’s always very heavily made up.她总是浓妆艳抹的。其三：‘和好，复合’。例：Hey, you guys made it up.嘿，你们和好啦。 补充made-up当名词指化妆品，相当于cosmetics.例：She never wears make-up.她从来不搽化妆品. Lighten up!放松！ 讲解light作形容词是指‘轻的’，动词形式Lighten up字面上的意思是‘变轻巧’，就是要对方‘放松心情，放轻松’。例：A: You really need to lighten up.你真该放轻松一点。B: I know. I’ve been really tense lately.我知道，我最近一直很紧张兮兮的。例：A: I know I did terrible on my test! I’m a horrible student!我知道我考试考得很差！我是个烂学生！B: Lighten up. Maybe you’ll do better next time.放轻松，你下次或许会考得更好。 补充‘放松’还可以说‘loosen up!’.照相的时候很多人觉得很扭捏，放不开，摄影师就会说‘loosen up!‘放开点，别紧张！ I wanna get a head start.我想赢在起跑线上。 讲解head start原本是指在竞赛中拥有起跑的优势，口语中引申为‘赢在起点上’。例：A: Our Bobby goes to the best middle school in New York.我们巴比念的是纽约最好的中学。B: Yes, we want him to have a good head start for college.对，我们要他赢在起跑点上，进入一流的大学。 补充可以泛指‘先一步开始’。例：A: Are you and Greg going to the party at the beach?你跟贵格要去在海边举办的派对吗？B: Yeah. Greg got a head start. I’m leaving in a few minutes.要，他先走一步，我几分钟后就走。 I wasn’t myself.我当时不大对劲。 讲解be not oneself这个短语表达‘不正常’的意思，可以指身体上不舒服，也可以指行动上的。例：A: Why can’t you walk a little faster?你今天为什么不能走快一点呢？B: I’m not quite myself today.我今天不大对劲（身体不大舒服）。例：A: You weren’t yourself at the party the other night.那天晚上派对中你行动怪怪的。B: I know. I had too much whisky.我知道，我喝了太多威士忌。 I was on pins and needles.我当时坐如针毡。 讲解pins和needles都是指针状物，坐在上面这种被扎的感觉，正可用来形容紧张不安的情绪。例：A: I’ve been on pins and needles all week. The boss said he wants to see me this Friday.我这整个星期如坐针毡，老板说他这个星期五要召见我。B: Good luck. I hope it’s good news.祝你好运，我希望是好消息。 补充这个表达法也可以用来形容那种雀跃不已，兴奋的期待心情，例：A: They’re announcing the winner for Best Actress.他们正在宣布最佳女主角的得主。B: I’m on pins and needles. I can barely sit still in my seat.我好兴奋喔，我都快坐不住了。 He’ll survive.他会挺过来的。 讲解survive原意是‘存活，幸免于难’，用在面临生死攸关之后，得以活下来。例：Rob is in the hospital. He survived a shark attack last week.罗伯在医院里，他上周被鲨鱼攻击，死里逃生。口语中可以引申为‘捱过、度过（困境）’的意思。例：A: I’m going to fail this exam! I just know it!我这考试一定会被当掉，我有预感！B: You’ll survive. It’s just a test! You’ve studied for it all week.你会撑过去的，不就是个考试嘛！你已经用功整个星期了。 补充熬过还可以说he’ll get over it.或者He’ll be fine. Way to go.好样的！ 讲解‘Way to go.’是’That’s the way to go.’的缩写，是用来告诉一个人他做得很好，请继续保持。例：A: I passed my driving test.我通过驾驶测验了。B: Way to go! I think we should go out to celebrate.太好了！我觉得我们该出去庆祝一下。 补充这个说法也可以用来讽刺太过离谱的人，例子：Way to go. You lost my cell phone again.真有你的，你又搞丢了我的手机了。 This is just too much.这太让人吃不消了。 讲解这个句子通常形容感觉压力很大，或者事出突然无法接受的时候。例：I have to work on five projects at a time? This is just too much.我要同时做5个项目？这实在是太扯了。这个说法除了可以表示心里压力以外，还可以表示体力上吃不消。例：This is just too much. Now I have to drive to Tainan tonight for business.真让人吃不消，我现在得连夜开车去台南出差。 补充吃不消还可以讲：I can’t take/stand this anymore；I’m pushed over the edge；drive somebody crazy What are you up for tonight?你今晚想去哪儿？ 讲解be up for表示‘有想做某事的心情’。例：A: I’ll pick you up at eight. What are you up for tonight?我今晚八点去接你，你今晚想去哪儿？B: Dinner and dancing!吃饭和跳舞！这个表达特别适用‘邀约’，例：A: Are you up for a game of tennis tonight?你今晚想打网球吗？B: I’m always up for tennis!我永远都想打网球！ 补充相似词组联想记忆：be up to sth忙于某事。例子：What are you up to?你平时都忙些什么？ This is incredible.这简直太好了！ 讲解incredible一词源于credit信用；相信，常见于credit card信用卡，credible是可以相信的，incredible是难以置信的，不可思议的，相当于unbelievable。例：What an incredible actress.她是个了不起的演员。credit当相信时，还可做动词：Would you credit it?你相信吗？ 补充口语中表示好的词还有：amazing；awesome；impressive；fantastic；fabulous等等。 I’m totally into photography.我超爱摄影。 讲解into sth本意是‘进到…里面‘，所以口语中可以表示be enthusiastic about sth in which one takes an active interest对某事物很有兴趣；非常喜欢：be into yoga, science fiction, stamp collecting喜爱瑜伽、科幻小说、集邮。be into sb还有一个意思：to owe someone money.例：He’s into me for $50.他欠我50美元。 补充口语中表达喜欢的小词还有：my thing.例子：我超喜欢做饭：cooking is my thing. Don’t flatter yourself.別臭美了；少自作多情了。 讲解flatter本意是奉承，讨好。例：If you flatter your mother a bit she might invite us all to dinner.你要是奉承你母亲几句，说不定她会把我们全请去吃饭；flatter oneself就是讨好自己，让自己开心。例：Do you really think he likes you? You flatter yourself!你真以为他喜欢你？你那是自作多情！常用被动表示某人感到荣幸的，相当于I’m honored. I was very flattered by your invitation to talk at the conference.承蒙你邀我在会上讲话，深感荣幸。 补充形容词flattering使人显得很美的：That’s a very flattering dress.那条连衣裙显得你更漂亮了。或者figure-flattering表示显身材的，使看上去有体型的。 I‘m all ears.我洗耳恭听。 讲解I’m all ears‘我到处都是耳朵，我随时准备好倾听’。例：A: I’ll give you a few pointers on how to study English.我可以给你一些指点，帮助你学习英语。B: I’m all ears.洗耳恭听。 补充这话特别适合用来表示关心别人，show that your are a good listener.A: My boyfriend just dumped me.我男朋友刚把我甩了。B: Are you OK? If you want to talk about it, I’m all ears.你还好吧？假如你想聊，我很愿意听。 Now we’re getting somewhere.这下有眉目了。 讲解‘get somewhere‘’到达某处‘，引申为’有进展，有成果‘。例：A: I don’t want to fight anymore, I just got angry because you were ignoring me.我不想再吵了，我气你是因为你一直忽略我。B: Now we’re getting somewhere. I’m sorry I hurt your feelings.这下子有眉目了（我知道你生气的原因了），对不起我伤了你的感情。当然如果表示没进展的话，就要说成‘not get anywhere‘或者’get nowhere‘.例：A: What do you say if we stop seeing each other for a while?你觉得我们先暂停交往好不好？B: That would get us nowhere.这对我们无济于事。 补充在疑问句中，要用‘get anywhere’.A: I was working on that building design all night.我整晚都在忙那个建筑设计。B: Did you get anywhere?有进展吗？ You should get out more.你应该多出去见见世面。 讲解‘get out’可以是调侃的语气，要对方出去见见世面，免得落伍了；例：A: Have you been to the new bar ‘MUSE’ by CarinaLau?你去过刘嘉玲新开的那家酒吧吗？B: You need to get out more! That bar has been open for 3 years!你真该出去见见世面了，那酒吧开了3年了！也可以作为关心鼓励，要对方‘出去看看，开开眼界’。例：Mom, you and dad need to get out more. You look so pale and weak.妈，您和爸需要多出去走走，您看起来很苍白虚弱。 Are you seeing anyone special?你是不是谈恋爱啦？ 讲解see有‘约会，交往’的意思，但常用于进行时态。例：we should stop seeing each other.我们应该分手了；例：Michael and Anna are seeing each other.迈克和安开始约会了。其二，see还常见于I see，表达‘原来是这样，现在我明白了’，和I know（我本来就知道）不同；其三，‘让我想想啊’的英文：let’s see.比let me think更地道。 补充约会的其他表达：date，后面通常直接跟人：I only dated her once.我和她只约会过一次；go out with：are you going out with Beth?你是不是开始和Beth约会了？ That’s how the world works!这就是社会！ 讲解‘这就是世界运行的方式’，也就是说‘社会就是这样进化变迁的！’例：I know how the world works.我懂这些人情世故，例：A: Can you believe it? He got a promotion! I bet it’s all political!你敢相信吗？他居然被提拔了！我觉得肯定是靠关系上去的！B: Forget it! It’s how the world works!别想了！现在的社会就这样！ 补充类似表达：That’s the way it is!本来就是这么回事！（stop complaining!） You’ve got a point.你说的有道理。 讲解point表示重点，what’s your point?你到底想说什么（重点）？let’s get to the point.咱们说重点吧；got a point说到了重点。例：A: But she might not agree.可是她有可能不同意呀。B: You’ve got a point there.你这话说得很有道理。 补充‘重点’还可以用message表达；get the message=see your point：She said it was getting late, I got the message and left.她说时间不早了，我心领神会，于是告辞. That doesn’t make sense.这讲不通啊！ 讲解sense本意指‘感觉’，a sixth sense第六感；sense of humor/security/direction/guilt幽默/安全/方向/罪恶感；sense还可以指道理，common sense常识；make sense能讲出道理来，有逻辑。例：None of these makes any sense.这一切都讲不通啊。例：You don’t make sense today.你今天不讲理。 补充make sense后面还可以加上of sth表示understand sth理解或弄懂：Can you make sense of this poem?你看得懂这首诗吗？ My treat!我请客。 讲解treat表示‘宴请，招待’，my treat就是‘我来招待你’，例：It’s my treat, don’t sweat it!我请客，别计较了！更简单的‘我请客’是‘It’s on me!‘，用’on‘就表示这顿饭’记我头上，记我账上‘。例：The movies are on me, don’t worry about it!电影算我的，别计较！ 补充‘我买单’还可以说：I’m paying tonight!/Let me treat you./Let me have the check, please!/Let me get the bill, I insist!/My dollar/My buck! Nice try.想得美，做梦呢你。 讲解字面上理解是‘做得好’，可以用来鼓励别人继续努力；但更常用于讽刺别人，某人想骗你上当的时候，你就可以说。例：A: I am currently a professional tennis player and have 3 supermodel girlfriends.B: Umm…Nice try! Do you take me for a fool?（骗谁啊！你当我傻子啊？） 补充想得美还可以说You wish（你就幻想吧）/wishful thinking（痴心妄想）.I think she likes me. But maybe that’s just wishful thinking. My thoughts exactly!跟我想得一模一样！ 讲解当朋友和你很有心电感应，说出和你一模一样的想法时，你就可以用这句话表示惊叹！例：A: Rose and Jack look cute together. Have you ever thought…露丝和杰克在一起看起来好顺眼哦，你有没有想过…B: …that they’re a match made in heaven?…他们俩是天造地设的一对？A: My thoughts exactly!一点没错，我就是这么觉得！ 补充同exactly一样意思的是precisely，也是表达‘精准得，确切得’：A: Let’s fire Allan and promote Ann.咱们让艾伦走路，给安升官。B: My thoughts precisely!我正有此意！ Don’t freak out.别发飙！ 讲解freak本意是a person with a very strong interest in a particular subject有某种强烈癖好的人：a fitness/clean freak健身狂/洁癖；还可以做定语：a freak accident/storm反常的事故/暴风雨；而freak (sb) (out)则是（使某人）吓到、受惊、发飙、抓狂。例：Don’t freak out, but I kinda lost your earrings.别发飙啊，但我好像把你耳环弄丢了；例：The whole idea freaked me out.这个想法吓到我自己了。 补充同义词flip (out)也是表达特别激动的情绪：生气或者兴奋：He completely flipped when he saw the mess in the kitchen.他看到厨房乱糟糟的景象立马发飙了。 Just the opposite.恰恰相反。 讲解适用于别人不但没有猜中你的意思，反而猜的恰恰相反。例：A: What? You got fired?咋啦？被炒鱿鱼了？B: Just the opposite. I got a promotion!恰恰相反，我升官了！ 补充还有一个类似的说法：Not even close.close是接近，even是用来强调，猜测甚至都不沾边。 I have a weakness for sweets.我最招架不住甜食。 讲解If you have a difficulty in resisting sth/sb, then you have a weakness for it.抵挡不了…的诱惑。例：Girls have a weakness for chocolate.女孩子都招架不住巧克力的诱惑。例：A: If you want to win Tom’s heart, make him a cheesecake.如果你想讨汤姆的欢心，就给他做起司蛋糕准没错。B: Great idea! I know he has a weakness got sweets.好主意！我知道他看见甜食就没辙。 补充当然也可以颠倒过来说：…is my weakness.某事是我的致命弱点。 Don’t blow it out of proportion.别夸大其词了。 讲解proportion是比例；out of proportion是‘大到不成比例’，而blow是‘吹’的意思，在美语中有‘吹牛’的意思。例：A: I can’t believe you ignored me like that!我不敢相信你竟这样躲避我！B: I couldn’t take your call! Don’t blow it out of proportion.我只是没办法接你的电话，别夸大其词了。 补充夸张还有一个基本英文叫exaggerate.例：You are exaggerating the difficulties.你把困难夸大了。 We’ll see.我们走着瞧。 讲解当你不同意别人的看法时，就可以用这句话，表示‘现在跟你吵也没用，我们到时候就知道了’。例：A: A guy that listens to heavy metal could never be charming.听重金属的男生不可能有什么魅力。B: We’ll see, remember, Prince Charming comes disguised as a frog sometimes.我们等着瞧吧，别忘了，有时候王子会扮成青蛙的哦。 补充We’ll see口语中也经常拿来敷衍别人，表示‘再看看吧，再说吧’。A: Can we go camping this summer?我们今年夏天可以去野营吗？B: We’ll see.到时候再说吧。 I got stood up.我被放鸽子了。 讲解约会时某人没有按规定的时间到场就可以说‘他放我鸽子he stood me up!’例：A: Can’t you go out with her another day?你不能改天再跟她出去吗？B: It’s too late to cancel, and I don’t wanna stand her up!现在取消来不及了，而我又不想放她鸽子！ 补充no-show也是表示someone who does not arrive or appear somewhere they were expected to be该出场而没来的：The bad weather meant there were a lot of no-shows at the game.天气不好，肯定会有很多人不到场了。 I didn’t mean anything bad.我没有恶意。 讲解若是不小心伤害了别人赶紧用这个句子解释一下吧。例：A: Do you go to bars often?你经常去酒吧吗？B: Of course not. What kind of a girl do you think I am?当然不是，你当我是什么样的女孩儿啊？A: Sorry, I didn’t mean anything bad.很抱歉，我没恶意嘛。例：A: You look very mature in that dress.你穿那件连衣裙很显成熟。B: Are you saying I’m old?你是不是想说我老？A: I didn’t mean anything bad. It looks nice.我没那意思！很好看的。 补充也可以简单得说：I didn’t mean it.我不是这个意思；那么反义词I mean it.就表示‘我是认真的’，相当于I’m serious. Think outside the box.换种思路想想。 讲解‘box’是指被限制在一个范围之内的意思，固有的守旧的思维模式。‘think out of the box‘就是‘think creatively/unconventionally/or from a new perspective‘思维创新、跳出固有思维模式。例：Let’s think outside the box for a minute and try to find a better solution.我们跳出思维定式来想，看看能不能找出更好的解决方案；例：These guys are incredibly creative - they really know how to think out of the box.这些人很有创造力，知道如何创新思维。 I’ll let you off the hook this time.这次我就放你一马。 讲解hook是钩子，所以on hook就是被勾住，陷入麻烦；off the hook就是脱离危险。例：You’re not getting off the hook.你这次休想逃掉；主语如果是电话the phone rang off the hook all day.则表示‘电话响了一天’，根本没办法挂在听筒上，一直处于off the hook的状态；play hooky是‘翘课、逃学’的意思：You wanna play hooky again? No way!你又想翘课啊？没门！ 补充’放我一马‘还可以说go easy on you.在你这里走缓和路线。或者cut me some slack.slack本身表示‘懒散怠慢的’，所以这个词组是‘允许我放肆一次，通融一次’。 What’ve you been up to?你最近都在忙什么啊？ 讲解up to表示occupied or busy with sth忙于某事，一般时态what are you up to?你在忙什么？而现在完成时what’ve you been up to?你最近在忙什么？是常见问候语。例：A: what’ve you been up to?你最近忙什么啊？B: you won’t believe it, but I’ve been seeing a guy from work.跟你说你都不信，我在跟同事谈恋爱。 补充最基本英文how are you?也常换成完成时态how’ve you been?最近好吗？ We have a lot to catch up on.我们有好多要叙叙旧聊一聊的。 讲解catch up本身是‘赶上’的意思。例：A: I haven’t seen you in class for over a week.我已经一个多星期没看见你来上课了。B: Well, I have been sick. I have a ton of homework to catch up on.我生病了，有一大堆功课要补起来。朋友好久没见，所以要‘赶上’分别后彼此的生活。例：A: It’s been almost a year since we’ve seen each other.我们将近快一年没见了。B: you bet. We have a lot to catch up on.没错，我们可得好好叙叙旧。 I’m not falling for this again.我不会再上当了。 讲解fall for sth：allow oneself to be persuaded by sth相信某事。例：The salesman said the car was in good condition, and I was foolish enough to fall for it.推销员说这辆汽车状况良好，而我那么傻竟然信以为真；例：I’m surprised you fell for that trick.真不敢相信你居然相信这个骗局。 补充fall for sb表示fall in love with sb被某人所吸引；爱上某人；迷恋：They met, fell for each other and got married six weeks later.他们俩一见倾心，六个星期后就结了婚。 I’m not a cheapskate.我可不是小气鬼。 讲解cheap（东西）便宜的；（人）小气的；cheapskate则是指小气鬼，a person who is unwilling to spend money.例：Are you saying I’m cheapskate?你说我是小气鬼？其他表示小气的词：形容词stingy吝啬的：He’s very stingy about lending money.他非常吝啬，不愿借钱给别人；形容词mean小抠的：She’s too mean to make a donation.她很小气，不肯捐款；名词miser‘守财奴’：Why don’t you buy me a drink for a change, you old miser!你就不能也请我喝一杯，你这老财迷！ 补充反义词‘花钱大手大脚的人’叫做spendthrift：someone who spends a lot of money in a wasteful way：My father tells me I’m too much of a spendthrift.我父亲说我是个败家子。 You’re off to a good start.你有一个很好的开始。 讲解off to a good start表示starting out correctly；beginning something carefully and cautiously开了个好头，常搭配be/get，例：Their marriage got off to rather a shaky start.他们的婚姻一开始就有些不稳固。例：A: How’re things going with you and Dan?你和丹之间的关系如何了？B: We got off to a good start, but things are kinda falling apart now.我们开始的时候很好，但事情现在有点失控了。 补充开个好/坏头还可以说：start off on the right/wrong foot：begin sth in the right/wrong way.例：The new student started off on the wrong foot with the teacher by answering back rudely.那个新来的学生粗鲁地跟老师顶嘴，一开始就把关系搞僵了。 I’ve had enough of it!我受够了！ 讲解have had enough已经经历过太多的某事物。例：A: I’ve had enough of your being late.我受不了你老爱迟到了。B: Then buy me an alarm clock.那你给我买个闹钟啊。当你表示受够了这个意思，还可以用I’ve had it up to here (with…).例：A: I hate this weather, it sucks!讨厌这种天气，真糟透了！B: I’ve had it up to here with your complaining!我受够了你的抱怨！ 补充‘受够了’还可以很形象的说：I’m fed up.我被喂饱了。 Can you try to talk him out of it?你能劝他打消这个念头吗？ 讲解除了‘persuade’这个词，‘talk’也有‘说服’的意思，‘talk somebody out of/into (doing) something’，说服某人（不）去做某事。例：A: Don’t you think that dress is just beautiful?你不觉得那件洋装漂亮死了吗？B: Are you trying to talk me into buying it for you?你是想说服我帮你买下来吧？例：A: Sammy said that he has decided to drop out of school!山米说他决定辍学！B: Can you try to talk him out of it?你能说服他别这样做吗？ Let’s hang out sometime.我们有时间出来聚吧。 讲解hang out是指visit a place often常去某处。例：Where does he hang out these days?他这些日子里都在什么地方来着？hang in there是表示‘加油，坚持住了’；hang on表示‘等等’，相当于hold on；hang up (on sb)是指挂（某人）电话，例：Did you just hang up on me?你刚刚是不是挂我电话来着？而被动be hung up (about/on sb)对…神魂颠倒，无法释怀，例：Are you still hung up on him?你还想着他吗？ 补充hangout作名词：a place someone likes to go to often某人常去的地方：The bar is a favorite hangout fpr students.这个酒吧是学生们最喜欢去的地方。 This is ridiculous.这太扯了！ 讲解ridiculous本意是指very silly or unreasonable非常傻帽可笑的，例：You look ridiculous in those tight jeans.你穿上那紧身牛仔裤样子真可笑。例：What a ridiculous idea!多么荒谬的念头！ 补充荒唐可笑的还可以说absurd.例：What an absurd suggestion!多么荒唐的建议！或者out of nowhere表示（莫名的行为）没有任何根源，无厘头。还可以说joke，例：Your job is a joke!你的工作就是一个玩笑。 You got it!听你的，没问题。 讲解You got it!两个用法。其一：‘你说对了’。例：A: You mean we have to write a 20-page report on John F. Kennedy by next week?你是说我们下周前，要交出一份关于肯尼迪的二十页的报告？B: Yep. You got it!没错，你说对了！其二：‘没问题’。例：A: Will you get me some Coke while you’re at the store?你去店里买东西的时候，可以帮我捎些可乐吗？B: You got it! Is that all you want?没问题！就只要可乐吗？ 补充口语还用You’re on.表达‘没问题’.这句话本意是‘（演出）该你上场了’，引申为‘这事情你是主角，听你的’。 Don’t be so petty.不要这么小气嘛。 讲解petty愿意是small or unimportant小的；不重要的：petty details/troubles细节/小麻烦；也可以指having or showing a small mind气量小的；小气的：petty and childish behavior小心眼和孩子气的行为。 补充反义词‘大度’叫做generous：He is really generous with his time, he’s always fixing my computer.他很乐于助人，总是花时间帮我修电脑。 She’s out of my league.我配不上这女生。 讲解league本意‘联盟，同盟’，美国8所名校‘常春藤联盟’叫Ivy League；in league表示‘共谋，联合’。例：He pretended not to know her but in fact they were in league (together).他装着不认识她，其实他们暗中勾结（在一起）；league还可以表示本句的‘（好或坏的）等级、范畴’，所以She’s out of my league.就是她跟你不是一个档次的，她不是你能配得上的。 补充‘我配不上她’还可以说I’m not good enough for her.或者She deserves much better. Now that’s perfect English.这才叫好的英语嘛。 讲解用Now that’s…这个句型做开头，是指‘这才像话，这才配称做…‘的意思，表示说话者所给予的正面评价。例：A: Here’s your 12-ounce steak, sir.这是您点的十二盎司牛排。B: Now that’s what I call a steak.这才叫做牛排嘛。例：A: look at my new car!快看我的新车！B: Now that’s a sportscar.这才叫做跑车嘛！]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oral English 1]]></title>
    <url>%2F2018%2F02%2F03%2FOral-English-1%2F</url>
    <content type="text"><![CDATA[I’m heading out.我准备走了。 讲解关键词head，除了熟悉的‘头’，还可以表示‘出发，前往’，例句：Where are you heading?/Where are you headed?主被动都可以。 补充口语中其他常见的表示‘我要走了’的表达：I’m leaving；I’m gonna go；I’m out of here；’我们走吧’：Let’s get out of here；Let’s blow this place off；Let’s roll! You’ll make it.你会成功的！ 讲解关键短语‘make it’表示成功（succeed）.例句：You must make it this time.你这次一定要成功！He made it to the finals.他成功闯进总决赛了. 补充口语中还经常：1）用‘can‘t make it to…’表示不能去…；例句：I’m sorry. I can’t make it to dinner tonight.不好意思，晚饭我去不了了；2）用‘not make it till’表示‘撑不到…’；例句：He won’t make it till tomorrow.他撑不到明天了. Apology accepted!嗯，接受你的道歉。 讲解这是典型的将动词变被动形式的口语句型。原句应为：I accept your apology，当别人说I apologize. Forgive me please（我道歉，请原谅我）时用。 补充口语中常见的类似表达还有：1. Agreed!（表示‘我同意’）；2. None taken.（表示‘没事儿’），在回答别人说No offense（表示‘没有冒犯之意’）时用；3. Problem solved.（表示‘问题解决了’）. I’m stuffed.我吃的撑死了。 讲解关键词‘stuff’，除了作名词表示‘东西/事情’，还可以作动词表示‘塞满’，stuffed字面意思是肚子被塞满了，也就是撑死了的意思.这也是为什么‘stuffy’表示‘天气闷热的’. 补充我饱了：I’m full；我吃撑了还可以说：My stomach is going to pop（字面意思是我的胃要炸了）；我饿了：I’m hungry；我很饿：I’m starved/starving/famished；我饿死了：I’m starving to death/I could eat a horse now（字面意思是：我现在可以吃下一匹马）. Stay put.待着别动。 讲解关键词‘put’这里不表示熟悉的‘放’，而是形容词‘固定的/静止的’，所以这句话也可以说Stay still.（still这里也表示‘静止的’意思）。 注警察抓人时喜欢说：Freeze!（也是‘别动’的意思） 补充口语中put也经常表示‘说/表达’；例句：I don’t know how to put this.（我不知道该怎么说）；Let me put it this way.（我这么跟你说吧）；Well put!（说得好！） What’s with you?你怎么了？ 讲解难点在于‘wrong’一词在口语中省略了，完整句应为：What’s wrong with you?（是不是出事了？） 补充口语中常见的类似表达还有：What’s up?/What’s the matter?（怎么了？）；Is everything okay?（一切还好吧？）；Is something wrong?（是不是出事了？）；What’s bothering you?（你在烦什么呢？） 注What’s wrong with you?和What’s the matter with you?用气愤的语气读也可以表示：你脑子进水了啊？ How’s it going?最近一切可好？ 讲解关键词‘go’，除了表示熟悉的‘去/走’；口语中经常表示‘进展’，所以how’s it going?字面意思是‘一切进展得怎么样？’；而刚见面时说则表示‘最近好吗？’，也经常说：Hey.How’s everything going?例句补充：I hope the meeting will go well.我希望会议能开得顺利. 补充口语中常见的表示打招呼的还有：How are you?/How (are) you doing?/What’s up!（年轻人喜欢用） You rock!你太牛啦！ 讲解关键词‘rock’，除了表示熟悉的‘岩石/摇滚’，口语中经常作动词表示‘很棒/很牛’；例句：Adele really rocks!（Adele实在太棒了！） 补充（1）口语中经常用来表示‘很棒’的词还有rule（动词）：This movie rules!（这部电影真不错！）；awesome（形容词）：This food is awesome.（这东西很好吃！）（2）‘rock’口语中还经常表示‘喝酒放的冰块儿’.例句：Do you want your whiskey on the rocks?（你的威士忌要加冰块儿吗？） He was so pissed off.他当时气得不得了。 讲解关键短语‘piss off’，表示‘使…生气’；piss me off惹我生气；英国人还喜欢用‘Piss off’表示‘滚开’.被动形式pissed off表示生气的.口语中也经常将off省略。例句：I’m so pissed (off) at him right now.我现在特别生他的气。 补充（1）除了pissed off，口语中常用来表示生气的还有：angry：Don’t be angry with me；mad：Don’t be mad at me.都表示‘别生我气’。（2）piss这个词本身表示动词或名词‘小便’，但是较粗鲁，建议在公共场合或陌生人面前不要用，而在朋友面前可以用.例句：I need to piss./I need to take a piss.我得去小便一下。 You’re so sick.你真变态。 讲解关键词‘sick’，除了表示‘生病的’，还可以表示恶心的/变态的。但是看表示生病的还是表示恶心的，得看具体语境。常见例句：You’re sick!你真变态！You make me sick.你真让我感到恶心！ 补充口语中常见的表示‘恶心的’还有形容词gross和disgusting.例句：You’re gross/disgusting.你真恶心；还有动词gross out.例句：You really gross me out.你真让我感到恶心。 I’m beat.我累死了。 讲解关键词‘beat’，除了熟悉的意思动词‘击打’，也可以作形容词表示‘筋疲力尽的’.例句：I wanna sleep, cuz I’m so beat（我想睡觉，因为我实在太累了）. 补充（1）口语中常见的表示‘很累的’形容词还有：very tried；exhausted；dog-tired；worn out；（2）关于beat在口语中的常见表达还有：beat a dead horse白费口舌；beat sb up/beat the hell out of sb痛扁某人一顿；beat around the bush绕弯子；Beats me.（问倒我了，我也不知道） We’re in a hurry.我们挺赶时间的。 讲解关键词‘hurry’表示‘快点’，in a hurry表示赶时间，口语中也经常用in a rush表示赶时间。 补充口语中其他常见类似表达：What’s the rush?你急匆匆的干嘛呀？；No rush.不用急.；We’re running out of time.我们快没时间了.；Hold your horses!别急，等下.；Take your time.你慢慢来，我不着急.；Don’t rush to conclusions.不要仓促做决定.；rush hour上下班高峰期 Watch your tone, young man.年轻人，注意你的说话语气哦。 讲解关键词‘tone’表示‘说话的语气/声调’。例句：I don’t like your tone.我不喜欢你说话的语气；first tone（第一声）/second tone（第二声）. 补充口语中类似的表达还有Watch your mouth和Watch your language（都表示‘注意你的嘴巴和你说的话’，在别人说脏话时可以用）；You eat with that mouth?（你是用那张嘴吃饭的吗？别人说脏话时用）；Swearing is bad. Don’t swear.（说脏话不好，不要说脏话.swear也表示‘说脏话’） I’m really not in the mood.我真的没那心情。 讲解关键词‘mood’表示‘心情’；常见口语搭配：in the mood（有做…事情的心情），经常用in the mood for sth/to do sth；例句：I’m in the mood for a movie.我想看部电影；Sorry, I’m not in the mood to go out.不好意西，我没心情出去玩；Not in the mood!没心情 补充口语中常见相关的表达：（1）心情不好：in a bad mood：She’s in a bad mood.（她心情不好）（2）情绪多变的：moody：She’s really moody.（她这人真的喜怒无常情绪多变） She dumped me!她把我给甩了。 讲解关键词‘dump’，能查到的词典意思是‘倒垃圾/清理废物’，除此之外还可以表示‘甩/抛弃’.例句：I got dumped.我被甩了. Lily dumped Tom yesterday.昨天Lily把Tom甩了. 补充（1）口语中经常用take a dump表示‘大便’（但是较粗俗，建议公共场合不要用，和朋友之间没关系）.例句：I need to go take a dump!我得去大便一下！（2）关于‘甩’：口语中也经常用break up（表示分手）.例句：Don’t break up with me.別跟我分手啊. We’ve broken up.我们已经分手了. Count me in.算上我一个呗。 讲解count表示‘计算/数数’，短语字面意思是：把我算进去，所以count sb in就表示算上某人.例句：Tom’s coming tonight. So count him in.（Tom今晚要来的，把他也算上。） 补充口语中必须掌握的还有（1）count sb out表示不要算上.例句：He’s not coming. So count him out.（他不来了，所以就不要算上他了）；（2）countdown倒计时：The countdown begins.（倒计时开始）；（3）count：重要；例句：That doesn’t count. One more time.（刚才那局不算，我们再来一次.） I’m gonna throw a party this week.这周我要开个party。 讲解关键词‘throw’，这里不表示‘扔’，而表示的是‘举办’：throw a party（开派对）.口语中常见的还有have a party/hold a party（都表示‘开派对’）.例句：I’m having a party at my place this Friday? You wanna come?（这周五我要在家开个派对，你想来吗？） 补充在美国常见的party有：birthday party生日派对；housewarming party暖房派对（搬入新家后邀请朋友过来的派对）；bachelor party新郎新婚前告别单身的派对；bachelorette party新娘结婚前告别单身的派对；costume party化妆舞会；going-away party离别派对 Can I get a refill?我能续杯吗？ 讲解关键词‘refill’，表示‘重新加满’，在这里就是名词‘再次满杯’的意思。‘re’作前缀经常表示‘再次’.比如consider-reconsider：You should reconsider it.（你应该重新考虑一下）；do-redo：I want to redo the house.（我想把房子重新装修一下） 补充口语中的喝酒常用语还有：Can I get some more?（能给我再倒一点吗？）；I’m having a blast right now.（我现在特别开心）；This is very strong.（这酒真烈！）；Bottoms up!（干杯.全部干完！）；I think I’m drunk.（我好像已经醉了。） Like you know him.说的好像你认识他似的。 讲解关键词‘like’，在这不表示‘喜欢’，而表示‘好像’，典型的‘讽刺句’/‘鄙视句’，翻译成中文是：‘说的好像…’。比如：1.你的一个朋友整天和你说英国怎么怎么的好，你就可以说：Like you’ve been there.（说得好像你去过似的）；2.你朋友笑话你昨晚喝醉了，你就可以说：Like you’ve never gotten drunk before.（说得好像你以前从来没喝醉过似的）。 补充口语中还经常用like表示‘比如’.例句：I saw many people last night, like Lily and Tom.我昨晚看到了很多熟人，比如说Lily和Tom. I didn’t mean to.我不是存心的。 讲解关键词‘mean’，mean to do表示‘打算做某事’，didn’t mean to表示‘没打算做’，即不是故意存心的.在美国，两人分手时A说：You hurt me（你伤害了我），此时B经常回答：Sorry, but I really didn’t mean to.（对不起，但是我真的不是存心的）。所以下次再犯无心之错时就对对方说：Sorry, I didn’t mean to. 补充（1）口语中经常用mean表示人‘尖酸刻薄的’：My boss is really mean to me.（我的老板对我真的很坏）；You’re mean!（你这人太坏了！）（2）固定短句I mean it.表示‘我是认真的（没开玩笑）’。 Yeah, I’ve been there before.对的，我也有过类似经历。 讲解此句为典型‘英语思维’句，字面意思为：我以前去过那儿（身体去过那儿）；语境一变，也经常用来表示：我也有过类似经历（思维想法去过那儿）.这里的思维习惯就是：英文里经常把‘身体’与‘思维/想法’对等。常见的表达有：I’m with Bingo.（可以理解为：我和Bingo在一起呢；也可以理解为：我同意Bingo的）；Are you following me?（身体层面：你是不是在跟踪我？；思维层面：你听懂我说的了吗？）；I’m lost.（身体层面：我迷路了；思维层面：我听不懂了）.所以下次你的朋友再说你英语不好的话你就说：I will get there.（我会到达那个水平的）。 Keep in touch.保持联系哦。 讲解关键词touch，这里不表示‘触摸’，而表示‘联系’.常见搭配表达还有：lose touch with sb与某人失去联系；get in touch with sb与某人取得联系；stay in touch保持联系 补充（1）touch被动形式还可以表示‘感动的’：I’m really touched by that movie.（我真的被那部电影感动到了）；（2）a touch经常用来表示‘一点点’；a touch of your love你的一点点爱 Could you do me a huge favor?你能帮我个大忙吗？ 讲解关键词‘favor’作名词时经常表示‘帮忙’.常用搭配有：do me a favor帮我个忙；ask you for a favor请你帮个忙；I got a huge favor to ask.我有个大忙需要你帮. 补充口语中常见的表示‘帮忙’的表达还有：Can you help me (out)?你能帮我吗？；You need a hand?要帮忙不？；Let me give you a hand.我来帮你.更礼貌的表达：I was wondering if you could do me a favor.不知你可不可以帮我个忙？ When are you gonna pop the question?你打算什么时候求婚呢？ 讲解pop the question：表示‘求婚‘.question指代的就是那句经典的‘Will you marry me?’（你愿意嫁给我吗？）；求婚也经常用一个动词叫propose.例句：I’m going to propose to her tonight.我准备今晚向她求婚.求婚的时候一般是单膝跪地：get down on one knee.准备好戒指ring.如果她答应了，那么戒指就是engagement ring（订婚戒指）.而你就可以说I’m engaged.（我已经订婚了）.那么她就是你的fiancee（未婚妻）.你是她的fiance（未婚夫）. Take it easy, man.兄弟你淡定！ 讲解关键词take，这里表示‘接受’.原句字面意思是‘轻松的接受它’，言外之意就是‘淡定，放轻松’。类似的常见口语表达还有：Don’t take it personal.别往心里去，不是针对你！；Don’t take it too seriously.不要太当回事儿.；I can’t take it anymore.我实在受不了了. 补充口语中经常用来表达淡定的还有：Calm down/Chill/Chill out!/Easy!例句：Chill out, man. It’s no big deal.哥们，淡定。没什么大不了的 Can I crash at your place?我能睡你家吗？ 讲解关键词crash，这里不表示熟悉的‘撞击/坠毁’，而表示‘sleep’睡觉，区别在于crash强调的是‘临时决定睡觉或者强调睡觉环境不好或者借宿’。例句：I’m tired. I’m gonna go crash.我累了。我准备去睡觉了；She crashed on the couch.她睡在沙发上的。 补充口语中和睡觉有关的表达还有：hit the bed/hit the hay/hit the sack，都表示去睡觉；take a nap则表示稍微睡一小会儿. Oh, I don’t know about that.这可说不准。 讲解本句意思为引申义，而字面意思是：我不知道这事儿.口语中经常用don’t know（不知道）来表示not sure（不确定）。比如你在shopping时销售人员（salesperson）说这衣服很适合你（you look good in it），你应该买下来（you should buy it），你就可以说：I don’t know. It’s a bit expensive for me.（我不确定，对我来说有点儿贵了） You look stunning.你看上去美极了。 讲解关键词stunning表示‘惊艳的，令人印象深刻的’，此句经常在某种场合遇到朋友时使用.比如在某个party上遇到朋友时就可以打招呼说：Hey. How are you? You look stunning!类似的表达还有：You look amazing/good/sharp today.（表示：你今天看起来很不错）；如果只对女生还可以说：You look beautiful/gorgeous!对男生可以说：You look dapper, dude! 补充聊天时夸对方，美国人还经常喜欢用：You’re funny!你很有趣；You’re cute.你很可爱！ Out with it.你就说出来吧！ 讲解当你感觉对方想说但是还在思考要不要说的时候就可以用这句.口语中常见的表示‘说’的还有很多.但是语境不同，用法也有差异.举例补充：（1）A: Can I ask you something?（我能问你点事儿吗？）B: Shoot.（说吧！）；（2）I know you know her name. Just spill it, man.（我知道你知道她的名字，你就说吧，哥们）；（3）Do you want me to spell it out for you?（你要我帮你说出来吗？）；（4）Can I run something by you?（我能跟你说点事儿吗？；（5）We need to talk.（我们得好好谈一谈）（语气很重，慎用） I need to throw up.我得吐一下。 讲解关键短语throw up：表示呕吐.口语中经常用来表示‘呕吐’的还有：puke和vomit.也可以作名词表示‘呕吐物’。例句：1. Don’t throw up on me!別吐到我身上；2. There’s your vomit all over the place.地上都是你吐的东西. 补充呕吐的原因可能是怀孕了（you’re pregnant），可能是你喝多了（you’re drunk），也有可能是你胃不舒服（Your stomach is not feeling well）. Have I made myself clear?都听懂我说的意思了吗？ 讲解关键短语make oneself clear：表示‘让别人听懂意思’.原句也可改为：Am I making myself clear?例句：You’ve made yourself clear.懂你的意思了. 补充口语中常见的表示‘你听懂了吗？’还有：You understand?；You got it?；You got me?；You following me?；You see what I’m saying?；You understand what I’m talking about?；Are we clear?（经常伴有命令的口吻） You ran out on me.当初是你抛弃我的。 讲解关键短语run out on sb：表示抛弃某人.等于abandon.口语中也可以用walk out on sb表示抛弃某人.例句：My father ran out on us when I was 5.（我5岁的时候我父亲就丢下我们不管走了）。 补充关于run在口语中的用法，必须掌握的还有：（1）I gotta run.（我得走了）；（2）I ran into Bingo yesterday.（我昨天碰到Bingo了）(run into sb表示偶遇某人)；（3）We’re running out of time（我们快没时间了）（run out of sth表示‘快用完…了’）。 I’ll fix you up with Beth.我把Beth介绍给你做女友。 讲解关键短语fix sb up：给某人安排对象，做媒.口语当中也经常用set sb up来表示。例句：Your friend is so pretty! Can you set me up with her?你朋友长得太漂亮了，你能把我介绍给她认识吗？ 补充关于fix在口语中的用法，必须掌握的还有：（1）It can’t be fixed.修不了了/你补不了了；（2）I’ll fix you up with a bigger room.我再给你提供个大一点的房间. Whatever.随便，无所谓了。 讲解whatever表示‘不管什么/随便什么’.单独的‘whatever’经常伴有不屑无所谓的口吻.口语中经常包含whatever短句有：Whatever you say!你说什么就是什么咯；Whatever you’re having.你吃/喝什么我就要什么.（点菜时经常用）；Whatever you do, I’ll be there for you.不管你做什么，我都会支持你的。 补充whatever还经常在刚碰面的时候用来问候别人.例如：Hey. Whatever happened to your brother? Haven’t seen him for a while.你弟弟最近怎么样了？有段时间没见到他了。 Can you put her on the phone?你能让她接下电话吗？ 讲解关键短语put sb on the phone：表示让某人接电话.常用的同义短语还有put sb through.例句：Is Bingo there? Can you put him through?（请问Bingo在吗？能让他接下电话吗？） 补充口语中常用的和电话有关的表达还有：pick up the phone接电话；hang up the phone挂电话；Don’t hang up on me.不要挂我电话；Who is it?你是谁？；Gimme a call tomorrow.明天给我电话哦；I’ll text you.我会给你短信的. You’re unbelievable!你真是不可理喻！ 讲解关键词unbelievable：字面意思是难以置信的；太棒或太极端到难以置信的；例句：Did you hear him sing? It’s unbelievable.你听到他唱歌了没？唱的太棒了！而原句的You’re unbelievable则表示你太极端，难以接受。 补充口语中常用的表示‘不可理喻’的表达还有：Are you out of your mind?（你是不是疯了？）；Are you serious?（你不是吧！） I really appreciate it.我真的很感激。 讲解关键词appreciate表示‘感激’.当表示对别人的感激和帮助时经常用：Thanks. I really appreciate it.例句：I really appreciate you trying to help me.真的很感激你尝试帮我。 补充当希望别人做某事或者希望别人不做某事时经常用句型：I’d really appreciate it if you…例句：I’d really appreciate it if you left right now.如果你现在就走，我会很感激的. I owe you one.我欠你个人情！ 讲解关键词owe：表示‘欠’.口语中常见表达有：You owe me money.你欠我钱；I owe you bigtime.我欠你太多了（人情/金钱都可以）；I owe you an apology.我得跟你道歉；I owe my life to you.我的命是你的了！ 补充关于owe的表达必须掌握的还有（1）You owe it to yourself.这是你应得的；（2）Owing to the rain, we can’t go.由于下雨，我们不能去了(owe to sth表示‘因为某事’) That goes without saying.那还用说？ 讲解习语。字面意思是：不用说就可以进行，言外之意就是不用说了。口语中常见的包含say的短语短句还有：（1）Need I say more?还需要再说下去吗？；（2）Says who?谁说的！；（3）I’m just saying.我只是说说而已；（4）If you say so.你说是的话那就是咯；（5）I can’t say the same.不敢苟同；（6）Do as I say.听我的，我说什么你就做什么;（7）You don’t say!是嘛！/可不是嘛！ Dinner’s on me.晚饭我请客。 讲解关键词on：此处表示‘算…的‘。Lunch is on me.午饭算我的（言外之意就是午饭我买单）.邀请别人吃饭喝酒时常用此句型.例句：First drink’s on me.第一杯算我的. 补充口语中常用和用餐有关的表达还有：（1）Let me buy your dinner.我请你吃晚饭吧；（2）It’s on the house.店主请客（免费）；（3）It’s my treat.算我的，我买单；（4）Let’s split the bill.我们分开付账吧；（5）I got it this time.这次我来请。 Where does that come from?你怎么想起来说这种话呢？ 讲解字面意思是：那是从哪来的？在别人说了一些让你不可思议的话的时候你可以用这句。例句：A: I think you don’t love me anymore.（我觉得你不爱我了）；B: What? Where does that come from?（什么？你怎么想起来说这种话呢？） 补充口语中和‘说话’有关的句子必须掌握的还有：（1）Where were we?我们刚才说到哪了？；（2）I know where this is going.我知道你想要说什么了。 You deserve it!你活该！/这是你应得的！ 讲解关键词deserve表示：值得。原句字面意思是：你值得这个.语境变意思也变。如果是自作自受就翻译为你活该；如果是通过努力理所应当就翻译为你应得的。口语中常见的deserve还有：You deserve someone better.你值得拥有更好的人（别人失恋时安慰可以用） 补充‘你活该’的口语表达还有：You had it coming；You brought this on yourself；表示‘这是你应得的’还有：You owe this to yourself! How am I supposed to know?你问我我问谁？ 讲解关键短语be supposed to表示：应该.原句字面理解为：我怎么会应该知道？.其他例句：What am I supposed to say?我应该说什么好呢？ 补充口语中表示‘不知道’的表达还可以用God。如God knows where he is.（鬼才知道他现在人在哪）。 I’ve been working out lately.我最近一直在健身。 讲解关键短语work out在原句中表示：健身，锻炼身体.例句：I need to go to the gym to work out.我得去健身房锻炼去。口语中也经常用此句夸别人的身材：You look good. Been working out, huh?你看上去不错，最近在健身是吧？ 补充口语中关于‘健身’常见的表达还有：1. lose some weight/shed some pounds减肥；2. You’ve put on some weight.你最近变胖了；3. I’m on a diet.我最近在控制饮食；4. hit the gym去健身房锻炼 He never cheated on me.他从来没背着我偷过人。 讲解关键短语cheat on表示：偷人.例句：I’ve never cheated on her.我从来没有背着她偷过人。cheat本身表示的是作弊欺骗，在考试中作弊叫cheat in exams. 补充口语中和感情有关的常见表达还有：have an affair有婚外恋；break up分手；get dumped被甩了；get back together和好；a perfect match天生一对；go out with与某人约会；in a relationship恋爱中；fall in love坠入爱河 Are you in or are you out?你到底要不要一起做？ 讲解关键词in和out，字面意思是在里面和在外面，口语中经常用来表示‘加入’和‘退出’.当有活动时别人会问你想不想加入，你想加入时可说：I’m in.如果你想退出活动时可说：I’m out.例句：A: We’re going shopping tomorrow. Wanna come?（我们明天去逛街，想来吗？）B: Yeah, I’m in.（好，我来） 补充如果别人邀请，你不想加入时可用pass这个词。例句：Do you want to have dinner with us?（你想和我们一起吃晚饭吗？）B: I’ll pass/I’ll take a pass.（我就不参加了） I failed you.我辜负了你们的期望。 讲解关键词fail，表示失败。例句：Don’t fail again.别再失败了.口语中经常用fail sb表示：另某人失望。或者fail sth表示：未成功.例句：I failed the test, mom. I’m sorry I failed you again.妈妈，我测试没过，对不起，又让你失望了. 补充口语中表示‘失望’的表达还有：Don’t let me down.别让我失望；I’m disappointed in you.我对你感到失望；I expected more.没达到我的期望；not as good as I’d expected.没我期望中的好。 I have no credit left on my phone.我手机没钱了。 讲解关键词credit表示‘信用’，在这引申为‘费用’的意思。给手机充值叫做：top up my phone/put money on my phone/add money to my phone. 补充手机常见的问题还有：I’m losing you.我快听不清你说话了；You there?你还在听我说话吗？；No reception here.手机在这没信号；My cell phone has some bad reception.我手机信号不好；My phone isn’t working well.我手机出了点问题；Hello?Hello?喂，喂？（听不到对方说话时用） That would be great.那样的话就太好啦！ 讲解关键短语would be，口语中，在对方主动提出要做事情或者提到一个可能性时，经常用‘that would be…’句型。例句：1. A: Do you want me to pick you up tomorrow?（你要我明天接你吗？）；B: That would be nice.（那样的话就太好了）；2. A: I think it’s going to rain tomorrow.（我觉得明天要下雨）；B: That would be too bad.（那样就太不好了）. 补充would在口语中经常变成’d.并且d不发音，that would be经常说成that’d be…，如That’d be awesome.那样的话就太棒了！ Big deal!有什么了不起的！ 讲解deal表示交易买卖.big deal字面意思为大买卖，引申为‘了不起’，例句：It’s a big deal. Don’t mess it up.这事儿很重要，别搞砸了。但是口语中经常用big deal，再配合讽刺不屑的语气表示：有什么大不了的。 补充口语中和deal表示‘买卖’的常见表达还有：Deal!一言为定；Don’t make a big deal about it/Don’t make a big deal out of it.別小题大做；This is a good deal.这买卖真划算；cut a deal达成协议。 You got me wrong.你误会我了。 讲解关键词get，除了熟悉的表示获得得到，也经常表示‘理解’。例句：I don’t get it.我不懂；I don’t get her.我真搞不懂她。原句里的got me wrong就是错误的理解我了（即误会我了）.其他常用句子：别误会我：Don’t get me wrong；你全搞错了：You got it all wrong. 补充口语中用get表示理解的短句还有：You got it/You get it?你懂了吗？；You got me?你懂我意思了吗？；I got you/I gotcha.我懂你意思了。 Hey, you wanna hang out?喂，你要不要一起玩啊？ 讲解关键短语hang out，表示：一起玩儿一起放松.例句：1. I like hanging out with you.我喜欢和你一起玩儿；2. I’ll just hang out at home tonight.我今晚就在家休息放松了。口语中也经常会把out省略，比如：Let’s hang tomorrow night.我们明晚一起玩吧。 补充口语中关于hang常见的短语还有：hang in there加油顶住；hang on等一下；hang up the phone挂电话；hang up on sb挂某人电话；have a hangover宿醉；hung-over宿醉的（形容词）；How’s it hanging?最近怎么样（打招呼用） You poor thing!你真可怜！ 讲解poor在这表示可怜。原句理解为：你这个可怜的东西。也经常说：Poor you.英语中，当听到对方描述自己不好的经历时经常用poor表示同情。也经常用：Sorry to hear that.或者That’s terrible.例句：A: I’m not feeling well today.（今天感觉身体不舒服）；B: Oh, you poor thing/Sorry to hear that/That’s terrible.（都表示对对方的同情）。 补充英语中当听到对方描述自己好的经历时经常用：That’s great/awesome；Good for you；That’s good to hear；I’m happy for you；Congratulations（恭喜）等表达。 How come you’re still single?你怎么还是单身呢？ 讲解关键短语how come表示：怎么会？口语中在感到惊讶时用。例句：1. A: I lost my wallet.（我钱包丢了）；B: How come?（怎么会呢？）；2. How come you’re sick?你怎么会生病呢？ 补充当别人说出一些你认为难以置信的事情时，比如你朋友说：I just got into Harvard.（我被哈佛大学录取了），你就可以说：What!/No way!/Are you kidding?/Are you serious?/Really?/Seriously?都表示很惊讶，不会吧！ This guy is nuts.这哥们绝对是个疯子！ 讲解关键词nut，愿意是坚果，俚语意思是疯子，复数nuts表示‘疯的’.常用短语：go nuts发疯（Don’t go nuts别发疯）；drive sb nuts使某人发疯（You’re driving me nuts你真让我崩溃） 补充除了nuts表示疯的，口语中也常用crazy/insane/bananas/out of one’s mind；例句：Are you crazy?/Are you insane?/Are you bananas?/Are you out of mind?都表示你疯了吗？；lunatic也表示疯子（名词）. Let’s take a short break.我们短暂休息一会儿。 讲解关键词break表示短休息。短语take a break.由于寒假假期较短，所以寒假叫做winter take.在美国，休息多长时间用take，并把分钟省略。如休息五分钟可直接说：Let’s take five.不需要加minutes. 补充表示短暂休息睡眠的也可以用nap.例句：I need to take a nap.我得稍微睡一会儿（强调短睡眠）；较长的假期叫vacation，如暑假：summer vacation；中国的法定假日一般用holiday描述，如：National Day holiday国庆假期。去度假叫go on a vacation. It’s all on him.都怪他！ 讲解关键词是on，和前面dinner’s on me一样，表示：算…的。吃饭算我的，所以是我请客；但是语境一变，责任算他的，就表示：都怪他。例句：If anything goes wrong, it’s on you.如果出什么事儿的话就怪你。 补充其他表示‘承担责任’的表达还有：It’s all your fault.都是你的错；My bad.我的错；I blame you.我责怪你；He is to blame.怪他；I’m responsible for this.这事儿我有责任. She’s seeing someone again.她又开始约会了。 讲解关键词seeing表示约会，而不是熟悉的看见.等于dating.例句：I heard that Lily’s seeing Tom.我听说Lily最近在和Tom约会。 补充口语中表示约会常用的短语还有：go out字面意思是出去（男女之间可特指出去约会）：I’ve been going out with Sarah（我最近在和Sarah出去约会）；go on a date去约会；blind date相亲；bring a date带一个男伴/女伴；in a relationship恋爱中；It’s getting serious.（感情）变的认真了. You stay out of this.你别多管闲事儿。 讲解短语stay out of表示：别插手.例句：You stay out of this fight.你别插手这场斗争。 补充口语中常见的表示‘别多管闲事’的句子还有：It has nothing to do with you.（跟你没关系）；It’s none of/not your business.（不关你事儿）；Keep your nose out of this.（别没事儿找事儿）；Mind your own business.（管好你自己的事儿就行）；Don’t get in the way.（別碍事儿）;短语interfere with…（干涉） Sleep tight.睡个好觉。 讲解关键词tight不表示熟悉的‘紧的’，而是俚语意思：舒服地/稳健地.例句：Sit tight.坐好了.晚上睡前经常用sleep tight表示希望对方睡个好觉。 补充常见的和‘睡觉’有关的表达还有：good night晚安；Sweet dreams好梦。一般会经常说（Good night and sleep tight比较押韵）；can’t fall asleep睡不着；have a nightmare做噩梦；I’ll sleep on it.我睡觉时好好考虑；You’ll sleep it off.你睡一觉就好了；sleeping pills安眠药 She’s gonna be crushed.她会崩溃的。 讲解关键词crush，表示‘压碎’；crushed被压碎的，引申为‘人崩溃了’.例句：Lucy’s crushed by the whole breakup thing.整个分手事件把Lucy搞得崩溃了，打击很大. 补充（1）口语中表示‘心情很差’的词还有：heart-broken极其伤心的；broken-hearted极度悲伤的；desperate绝望的；miserable痛苦的；（2）crush在口语中还可以表示‘迷恋，有好感’，可做动词和名词，例句：I have a crush on Sarah/I’m crushing on Sarah.我对Sarah有好感。 This one is way better.这个好多了。 讲解关键词way，除了熟悉的‘方法，方式，道路’，还可以表示‘非常地/远远地’。Better表示更好，way better则表示好的多，修饰程度.经常还会和too搭配表示‘太/非常’；例句：1. It’s way too hot today.今天实在太热了；2. I’m way taller than you.我比你高多了；3. He’s way gone.他早就走了；4. Way ahead of you.早就在你前面想到了。 补充way的口语用法还有：way to go!干得漂亮！；This way please.这边请；the way you talk你说话的方式；in a different way以不同的方式 I’m in the middle of something.我现在正在忙。 讲解短语in the middle of something：字面意思是在某件事的正中间，言外之意就是脱不了身，所以用此短语表示：说话时正在忙。开会时别人给你打电话你就可以说：Sorry. I’m in the middle of something. I’ll call you back.对不起，我在忙，回头给你回电话.也可以具体说出事情：I’m in the middle of a meeting.我在忙着开会呢 补充表示忙的短语还有：busy忙碌的；busy as hell忙得要死；I will be tied up tomorrow.我明天会超忙. Buckle up!系好安全带！ 讲解开车用语，buckle指的是‘皮带扣’，作动词就是把安全带扣上，也经常说：Fasten your seatbelt. Seatbelt表示‘座位安全带’. 补充常见的汽车用语还有：Hop in/Get in the car.上车；Pull over靠边停；Stop the car停车；run red lights闯红灯；Don’t drive when you’re drunk不要醉驾；Don’t drive under the influence不要酒驾；speed limit限速；drive over the speed limit超速；give you a lift让你搭顺风车 Bring it on.放马过来。 讲解口语中也经常说Bring it.表示：开始吧（很有自信）。当别人挑战你时或者比赛时经常说。例句：A: I think you’re no competition.（我觉得你根本不是我对手）B: Really? Bring it on.（是嘛？放马过来吧！） 补充口语中回应对方挑战的表达还有：We’ll see (about that).我们到时看咯，走着瞧了；I don’t know about that.这可说不准；You’re gonna be sorry for saying this.你会为说这话而后悔的；Ok, it’s on!行，我应战！ I don’t buy any of your crap.我才不信你的鬼话呢。 讲解1.关键词buy，除了熟悉的‘买’，口语中经常用来表示‘相信（believe）’.例句：1. I don’t buy a word you just said.你刚才说的话我一个字也不信；2. She buys your story.她是相信你的故事的；2.关键词crap，除了表示‘大便’，口语中经常用来表示‘鬼话废话’.例句：1. Cut the crap.别说废话；2. He’s full of crap.他这人鬼话连篇。 补充表示‘不相信’还可以说：I doubt that.我可不信；Bullshit!胡说；Nonsense.瞎说！ Let’s just take a cab.我们还是打车吧。 讲解关键词cab表示出租车，也可以用熟悉的‘taxi’.计程车司机叫cab driver/taxi driver.英语里用take表示乘坐交通工具，如：take the bus坐公交；take the subway坐地铁；take the train坐火车等. 补充在国外打车可跟司机说地点加please.如：Central park, please.请把我带到中央公园；最后不要忘了给小费说：Keep the change.（零钱不用找了） I quit my job.我辞职了。 讲解关键词quit表示停止/放弃.常见的有：quit smoking戒烟；quit drinking戒酒等.quit my job就是停止我的工作（辞职）；辞职时也可直接说：I quit!我不干了.正式一点的词表示辞职的有：resign: He resigned from the company yesterday.（他昨天辞职了） 补充和工作有关的常见表达还有：fire/lay off解雇：I’m fired/I’m laid off.我被炒鱿鱼了；hire招聘；employ雇佣；employer雇主；employee雇员；suspended被停职了；between jobs没有工作 Almost slippped my mind.差点儿忘记了。 讲解关键短语slip my mind，字面意思是滑过我的脑子，引申为：忘记了。例句：A: Why didn’t you go to the meeting?（你为什么不去开会）；B: Oh, it slipped my mind.（那事儿我忘记了）；与之意思相反的是cross my mind，字面意思是穿过我的脑子，引申为：想起.例句：You always cross my mind before I go to bed.我睡前总是会想到你！ 补充口语中的‘忘记’还有：Just forget about it.忘了吧（没事儿了）；Forget what I said.当我什么也没说。 Dummy up.别说话。 讲解关键词dummy表示：笨蛋，口语中语气更重的还有stupid-ass和dumb-ass，也表示笨蛋.Dummy up表示’保持安静‘.愿意是嘴笨不要说话。 补充口语中和‘闭嘴’有关的表达还有：Shut up/Shut it/Shut your mouth(shut表示关上，就是把嘴关上)；Zip it/Zip your mouth（zip表示拉链，就是把嘴拉上）；Keep quiet保持安静；Keep your voice down/Keep it down声音小点儿；Shh/shush/hush嘘，别说话；No talking!不准说话. I couldn’t care less.我才不在乎呢。 讲解关键语法点couldn’t+比较级表示最高级：couldn’t care less，字面意思是不能在乎的更少了，言外之意就是在乎地已经少的不能再少了，也就是很不在乎。类似常见表达还有：I couldn’t agree more（不能同意更多，即非常同意）；It couldn’t be better（不能更好了，即非常好） 补充口语中表示‘我不在乎’的表达还有：I don’t care我无所谓；Whatever随便；I don’t give a damn/crap/shit（慎用）/rat’s ass我无所谓 Let me be clear.我跟你说清楚吧。 讲解clear在口语中经常表示‘说话意思的清楚’。比如说话时可以问：Am I making myself clear?我说的你们听懂没？；说完话可以问：Have I made myself clear?/Are we clear?（大家都清楚了吧？） 补充口语中的各种’说‘还有：1. I’m gonna be straight with you./I’m just gonna level with you.我就和你直说了；2. Don’t beat around the bush.别绕弯子；3. cut to the chase直接说重点；4. Get down to business谈正事儿；5. Says who?谁说的？ I’ll be right back.我马上回来。 讲解此句在口语中也可以直接说Be right back，并经常用简写BRB.表示失陪下，马上回来。比如和朋友聊天时电话突然响，你就可以说：Be right back（出去接个电话，马上回来），在线聊天时会经常用缩写BRB。而中文里的‘失陪’就可以用：Excuse me. 补充口语中常见的缩写除了BRB还有：TTYL（talk to you later回聊）；TBD（to be determined待定）；LOL（laugh out loud哈哈）；LMAO（laugh my ass off笑死了）；CU（see you再见）；FYI（for your information顺便告诉你）；ASAP（as soon as possible）等 You’ve crossed a line here.你这事儿做的有点过了。 讲解关键短语cross a line，字面意思是越过一条线，引申为‘过分’。例句：Don’t cross the line.不要太过分；There’s a line you should never cross.凡事有个度。 补充口语中表示‘过分’的表达还有：Enough. This is too much.够了，这个太过分了；This is out of line.这个太过分了！；Know your limits.知道自己的底线；This is terrible/awful.这样太不好了！；Don’t push it.别得寸进尺！；You’ve gone too far.你做的太过分了 Listen up, everyone.大家都给我听好了。 讲解关键词listen表示‘听’，后面加up表示‘认真听好了’，用来吸引大家的注意力，相当于listen carefully. everyone. 补充口语中的各种‘听’还有：1. Please hear me out.请听我说完。2. Are you listening to yourself?你在胡说什么啊？3. Look, it’s over.你听着，一切都结束了。4. Sorry, I was eavesdropping.不好意思，我刚才在偷听。5. Never heard of it.从来没有听说过。6. She’s a great listener.她是个不错的倾听者。 Don’t overthink this.你别想多了。 讲解关键词overthink=over（过度地）+think（想）：过渡地想，即想多了。也可以说：Don’t think too much（别想太多了）.口语中经常用over放在动词前面表示：过度地…；常见单词有：overreact：over+react反应过度；overspend：over+spend花费过多；overestimate：over+estimate高估；与之相反的是：under+…，如：underreact：under+react未作出应有反应；underspend：under+spend花费过少；underestimate：under+estimate低估。 Now we’re even.现在我们扯平了。 讲解关键词even除了表示‘甚至’，口语中还经常表示‘平等的’。例句：1. After this, we’re even.这事情结束后我们就扯平了；2. Ok, let’s call it even.好，我们之间扯平了。 补充口语中的和‘平等，公平’有关的表达还有：1. an even break一个公平的机会；2. This is not fair.这太不公平了（fair强调公平）；3. All men are created equal.人生而平等（equal强调平等）；even表示‘甚至’时在否定句中放否定词后面，和中文顺序不一样，如：I don’t even know you.；I’ve never even met you before. Leave me alone.让我一个人静一静。 讲解关键词是leave，除了表示‘离开’，也经常表示‘让…保持…状态‘，原句字面意思是：让我保持alone（一个人）的状态，即让我一个人待着，换一个语境，也可以翻译为：离我远一点（如果有人骚扰你时）。类似的语法表达还有：Leave the door open.把门开着；Leave the lights on.把灯开着（保持开的状态）；Leave it on the table.放在桌上就行（强调状态） 补充著名生活服务类节目‘非诚勿扰’可翻译为：Leave me alone unless you mean it：除非你是认真的（you mean it），不然就离我远一点（leave me alone）. I’m wasted.我喝醉了。 讲解关键词wasted，除了表示‘浪费的’，口语中还表示‘烂醉如泥的’.例句：Let’s go get wasted tonight.我们今晚去大醉一场吧！ 补充（1）口语中用来表示‘喝酒’的形容词还有：I’m sober.我清醒着呢；I’m tipsy/buzzed我微醉 drunk/hammered/trashed醉了；（2）酒鬼：drunkard/alcoholic/lush/alky/booze hound；（3）西方常见酒的分类：alcohol酒精；liquor/booze烈酒；cocktail鸡尾酒；beer啤酒；white wine白葡萄酒；red wine红葡萄酒；whiskey威士忌；scotch苏格兰威士忌；vodka伏特加；rum朗姆酒等 Something’s up.出事了。 讲解关键词up，除了表示‘向上’，还表示‘发生了’，另外的常见短句是What’s up?（发生了什么）；原句在口语中也经常说Something’s come up.意思一样。类似的表达还有：Something’s wrong.有些不对劲儿；Something happened.发生了点事情；We got a problem.我们遇到问题了. 补充‘up’在口语中还经常表示‘醒着’，如：Who’s still up?谁还醒着；What’are you doing up?你不睡觉在干嘛？；还经常表示‘到时间了’，如：Time’s up!时间到；My shift’s up.我轮班结束了。 You totally had it coming.这完全是你自找的。 讲解关键短语have sth coming表示‘应得的’，可以是好的，也可以是坏的。有人自作自受，你就可以说：You had it coming.你自找的。口语中类似表达还有：You deserve it.你活该（也可以用褒义表示：这是你应得的）；You asked for it/You brought this on yourself.你自找的 补充口语中还经常用see sth coming表示‘预料中的’。例句：A: Tom won the game.（Tom赢了比赛）；B: Yeah, I didn’t see it coming though.（对，但是我根本没想到，出乎意料） Don’t play dirty.别跟我玩阴的哦。 讲解关键词dirty，表示脏的；下流的；阴险的。原句中play dirty也可以用fight dirty，在两人比赛斗争时提醒对方不要玩阴招就说Don’t play dirty；当一个人经常说脏话时可说：What a dirty mouth you got!你嘴巴真脏啊！；有人说话下流可以说：He always talks dirty.他说话总是很下流。 补充口语中当别人说脏话时还可以用：You eat with that mouth?（你是用这张嘴吃饭的吗？）；或直接说：Come on.（切）；或Don’t swear.（不要说脏话） Beats me.我也不知道，问倒我了。 讲解不要误解为‘打我’，口语中类似的表达还有：I don’t know/I don’t have any clue/I have no idea我不知道；You got me/I’m stumped你难住我了. 补充口语中表示‘不理解’的表达有：I don’t understand/Not following you/You lost me/I don’t get it.没听懂你说的；I don’t see your point.我不知道你的重点是什么；表示‘迷惑‘的表达有：I’m confused/I’m baffled/I’m bewildered/I’m perplexed.我迷惑了. What’s in it for me?对我有什么好处呢？ 讲解字面意思是：里面有什么是给我的？引申为：对我有什么好处？类似表达还有do me good对我有好处；do me bad对我有坏处；in your interest对你有好处；for your own good为你自己好 补充（1）与原句同义的还有：Why would I say yes?我为什么要答应你呢？（2）口语句‘what’s there to…‘经常表示‘有什么好…的‘。What’s there to see?那有什么好看的呢？；What’s there to eat?那有什么好吃的呢？ I think I’m in love with you.我觉得我爱上你了。 讲解关键短语in love with爱上某人.类似表达还有：fall in love坠入爱河；love at first sight一见钟情；Love me, love my dog.爱屋及乌。 补充口语中的‘喜欢’还有：I like you/I dig you/I’m into you/I’ve got a crush on you/I have a thing for you/I fancy you（英国人喜欢用）都表示我喜欢你；I’m crazy about you. I think about you all the time.非常喜欢你，喜欢的发狂，每时每刻都在想你。 Could you give us a sec?你能让我们俩单独说会儿话吗？ 讲解关键短语give us a sec表示：让我们单独说话；也可以表示：稍等一下；sec是second的缩写，也可以说give us a second/minute/moment.下次想和某人单独说话你就可以说：Can I see you for a sec?或者Can I talk to you for a sec?，这边的sec都可以换成second/minute/moment；而give me a sec一般表示：稍等一下（给我一小会儿）。 补充单独说话在口语中也可用：Can we talk in private?/Can we talk privately?我们能单独聊会儿吗？ Don’t take this the wrong way.别误会哦。 讲解关键词take，表示‘理解/接受’，(in) the wrong way表示‘以错误的方式’，字面意思是不要以错误的方式理解这个，即不要误会。 补充口语中关于take的短语必须知道的还有：take sb for把某人当作…（1. what do you take me for?你把我当成什么人了？；2. Sorry, I took you for someone else不好意思我认错人了）；take it out on me拿我发火解气；take care of you照顾你；take care of it搞定这事儿；I need to take off.我得走了。 Shame on you!真为你感到羞耻。 讲解关键词‘shame’表示‘耻辱’.Shame on sb表示‘为…感到羞耻丢人’。例句：A: Tom stole his mom’s money yesterday（昨天Tom偷他妈的钱了）；B: Shame on him.（他真丢人！）类似表达还有：You should be ashamed of yourself.你应该为自己感到羞耻。；This is so embarrassing.这太丢人了/难为情了；It’s so awkward.太尴尬了 补充shame还经常表示‘遗憾可惜’，如：What a shame!太可惜了！；It’s a shame that you can’t come with us.你不能和我们一起来太遗憾了 You’re doomed.你死定了。 讲解关键词doomed表示‘注定要倒霉的’。类似表达还有：You’re dead!你死翘翘了；You’re dead meat.你死定了；You’re screwed/You’re done.你完蛋了。 补充口语中‘求饶’的表达：Just give me another chance（再给我一次机会吧）；Give me a break.（先让我休息一下吧）；Cut me some slack（放过我吧）；I promise it’s not ganna happen again（我保证这样的事儿不会再发生了）；I swear to God that I won’t do it again（我对天发誓我以后再也不这样了） Don’t play that game with me.不要跟我玩那套。 讲解关键词play game（玩游戏）引申为‘玩…哪套‘。例句：I know what game you’re playing. It won’t work.我知道你在跟我玩哪一套。没有的！ 补充（1）play the … card表示用…招数：I always play the ‘I can’t drink’ card when I don’t want to drink.我不想喝酒的时候我就骗他们说我不能喝酒；He played the ‘I’m sick’ card again.他又骗我们说他生病了。（2）‘不上当’在口语中可表达为：I won’t fall for that.我不会上当的。 I need some time to figure it out.我需要点时间好好弄清楚。 讲解关键短语figure sth out表示：把…弄清楚。例句：You figure out why he didn’t come today.你给我弄清楚为什么他今天没来；I’ve got it all figured out.我把一切都搞清楚了. 补充口语中必须要掌握的‘out’短语还有：Cut it out.停止，别闹了；Check it out.看一看；Don’t freak out.别惊慌失措；knock sb up使某人怀孕；sell out卖光；knockout美女；takeout外卖；move out搬出去；worn out筋疲力尽的；creep sb out使某人感到不舒服自在。 I’ll catch up.我会跟上的。 讲解关键短语catch up表示‘跟上进度’。例句：A: We’re on our third glass. What’s wrong with you?（我们已经喝第三杯了，你怎么回事？）B: Don’t worry. I’ll catch up with you.（別担心，我会跟上你们的进度的）。 补充catch up在口语中经常也表示‘叙旧’。叙旧的常见表达有：Long time no see. We need to catch up.好久不见，我们得好好叙旧；It’s been a while since I saw you last.从我上次见你到现在得有一阵子了吧；Let’s go grab a couple of drinks.我们去喝两杯！；Where’ve you been?最近跑哪去了？；What’ve you been doing?最近忙什么呢？ Get your ass out of here.滚！ 讲解口语中经常用sb’s ass表示‘人’。如：Thank you for saving my ass.谢谢你救了我（不是救了我的屁股）；I’ll kick your ass.我会揍你的（不是踢你的屁股）；所以原句就等于：You get out of here.你滚出去 补充（1）口语中让别人滚的表达还有：Get out of my face/Get lost.从我眼前消失；Get out of the way.别挡道；Be gone!赶紧消失！；Scram/Eff off/Piss off（英国人喜欢用）滚（语气很重）；（2）美语中out of经常缩读成outta.如：I’m out of here.=I’m outta here.（我走了） You don’t wanna do this.你最好别这样做。 讲解字面意思是：你不会想要这么做的，引申为：我建议不要这么做。口语中‘给建议’的表达有：1. You might wanna…如：You might wanna call your mom first.我建议你先给你妈妈打个电话；2. I think you should…如：I think you should give her a chance.我觉得你应该给她个机会；3. You’d better…如：You’d better leave now.你最好现在就走；4. I would … (if I were you)：I would go to LA (if I were you).我建议你去洛杉矶（口语中经常把If I were you省略） That blew my mind.太让我震撼了。 讲解关键短语blow one’s mind表示：令某人震撼，惊叹不已.例句：I think her song is gonna blow your mind.我觉得她的歌会让你为之惊叹.表示‘惊艳‘的美语表达还有：Your song was really mind-blowing/awesome/amazing.你的歌真的很不错；You killed it.你刚才表现很棒 补充口语中的‘mind’还有：change my mind我改变主意；out of my mind我疯了；keep/bear sth in mind记住某事；cross my mind让我想起；slip my mind我忘记；never mind.没事了；I don’t mind.我不介意；What’s in your mind?你脑子里想的什么？ I’m off on Sunday.我周日不用上班。 讲解关键词off在这边表示’不上班‘.原句也可以改为：I got Sunday off.下班：get off work. 补充（1）请假用take off即可：Sir, can I take this Friday off?先生，这周五我可以请假吗？；I took 3 day off last week.我上周请了3天假；生病不用上班叫做off on sick leave；（2）off还可以表示‘走，离开’：I’m off, guys.（各位，我先走了）；Off to Macao later.（等会儿去澳门）；（3）off也可以表示‘取消了’：The wedding’s off.婚礼取消了！ She got the message.她有数了。 讲解get the message字面意思表示：收到消息，引申为：‘懂你意思了’。例句：I got the message when you said you were not feeling well.你说你身体不舒服的时候我就懂你意思了。类似表达有get the idea。 补充口语中‘我懂你意思了’的表达还有：I see what you’re saying；I gotcha；I totally feel you；I see what you’re getting at. What’s with the sad face?你干嘛一脸伤心的样子？ 讲解what’s with the…表示：干嘛…一般觉得好奇不理解时用。例句：What’s with the car?你干嘛开车过来？；What’s with the red t-shirt?你干嘛穿件红体恤？；What’s with the long face?你干嘛拉着个脸？ 补充口语中表示好奇的常见句子还有：What’s the occasion?有什么重要的场合要参加吗？；What brings you here?什么风把你吹来了？；What’re you doing here?你在这干嘛？；What the hell?什么情况？（搞什么？） I wouldn’t say so.我不是很同意你说的话。 讲解完整句为I wouldn’t say so (if I were you).字面意思就是：如果我是你的话我不会这样说的，引申为：我不赞成你说的话。口语中If I were you（如果我是你）经常省略.I wouldn’t经常用来表示委婉的否认别人。例句：A: It’s a beautiful day today.（今天天气真美）；B: I wouldn’t call it beautiful.（我不认为今天算美） 补充口语中经常不赞同别人说的话的表达还有：I don’t think so.我不这么认为；I’m afraid I have to disagree.恐怕我不能赞成你说的了；I can’t say the same.我有不同观点 I kind of miss you.我有点想你了。 讲解关键短语kind of表示：有点儿。例句：I’m kind of hungry.我有点儿饿了。Kind of在口语中经常缩读成kinda；与kind of意思用法一模一样的是sort of，可缩读成sorta.例句：I sorta wanna go out.我有点想出去玩。 补充（1）口语中表示‘一点点’的短语还有：a little/a bit/a little bit/a tad.例句：I’m a bit tired.我有点累了；（2）kind of与sort of还经常表示委婉的语气，如不敢或者不想告诉对方但又必须说时可以用，例句：I kind of kissed your girlfriend last night.我昨晚亲了你女朋友（不敢告诉你，但又必须得说，不能理解成‘我有点亲了你女朋友’）]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 69 - Sqrt(x)]]></title>
    <url>%2F2018%2F01%2F23%2FLeetCode-Problem-69-Sqrt-x%2F</url>
    <content type="text"><![CDATA[Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. ExampleNo.1Input: 4 Output: 2 No.2Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842…, and since we want to return an integer, the decimal part will be truncated. Code1234567891011121314151617181920public int mySqrt(int x) &#123; if (x == 0) return 0; int start = 1; int end = x; while (true) &#123; int mid = start + (end - start) / 2; if (mid &gt; x / mid) end = mid - 1; else &#123; if ((mid + 1) &gt; x / (mid + 1)) return mid; start = mid + 1; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 88 - Merge Sorted Array]]></title>
    <url>%2F2018%2F01%2F23%2FLeetCode-Problem-88-Merge-Sorted-Array%2F</url>
    <content type="text"><![CDATA[Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. NoteThe number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. ExampleInput:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Code123456789101112131415public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int pos = m + n - 1; int i = m - 1; int j = n - 1; while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; if (nums1[i] &lt; nums2[j]) nums1[pos--] = nums2[j--]; else nums1[pos--] = nums1[i--]; &#125; while (j &gt;= 0) nums1[pos--] = nums2[j--];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 27 - Remove Element]]></title>
    <url>%2F2018%2F01%2F16%2FLeetCode-Problem-27-Remove-Element%2F</url>
    <content type="text"><![CDATA[Given an array and a value, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. ExampleNo.1Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. It doesn’t matter what you leave beyond the returned length. No.2Given nums = [0,1,2,2,3,0,4,2], val = 2, Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary. It doesn’t matter what values are set beyond the returned length. ClarificationConfused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeElement(nums, val);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; Code12345678910111213public int removeElement(int[] nums, int val) &#123; if (nums == null || nums.length &lt; 1) return 0; int length = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != val) nums[length++] = nums[i]; &#125; return length;&#125; When elements to remove are rare12345678910111213141516public int removeElement(int[] nums, int val) &#123; if (nums == null || nums.length &lt; 1) return 0; int start = 0; int end = nums.length - 1; while (start &lt;= end) &#123; if (nums[start] == val) nums[start] = nums[end--]; else start++; &#125; return end + 1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 26 - Remove Duplicates from Sorted Array]]></title>
    <url>%2F2018%2F01%2F16%2FLeetCode-Problem-26-Remove-Duplicates-from-Sorted-Array%2F</url>
    <content type="text"><![CDATA[Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. ExampleNo.1Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length. No.2Given nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn’t matter what values are set beyond the returned length. ClarificationConfused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; Code12345678910111213public int removeDuplicates(int[] nums) &#123; if (nums == null || nums.length &lt; 1) return 0; int length = 0; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] != nums[length]) nums[++length] = nums[i]; &#125; return length + 1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Urllib Demo]]></title>
    <url>%2F2017%2F12%2F29%2FUrllib-Demo%2F</url>
    <content type="text"><![CDATA[使用Urllib爬取网页将爬取到的网页以网页的形式保存在本地1234567891011121314import urllib.request# 爬取百度首页file = urllib.request.urlopen("http://www.baidu.com")# 将对应的网页内容读取出来data = file.read()#print(data)# 以二进制写入的方式打开文件fhandle = open("/Users/matianyao/Desktop/crawler.html", "wb")# 写入对应的数据fhandle.write(data)# 关闭文件fhandle.close() 直接将对应信息写入本地文件123456import urllib.request# 直接将网页写入本地文件filename = urllib.request.urlretrieve("http://edu.51cto.com", filename="/Users/matianyao/Desktop/crawler.html")# 清除urlretrieve执行所造成的缓存urllib.request.urlcleanup() 其它常见用法12345678910# 返回与当前环境有关的信息file.info()# 获取当前爬取网页的状态码file.getcode()# 获取当前所爬取的url地址file.geturl()# 对网址进行编码urllib.request.quote("http://www.sina.com.cn")# 对编码的网址进行解码urllib.request.unquote("http%3A//www.sina.com.cn") 浏览器的模拟——Headers属性有时候，无法爬取一些网页，会出现403错误，因为这些网页为了防止别人恶意采集其信息所以进行了一些反爬虫的设置。可以设置一些Headers信息，模拟成浏览器去访问这些网站。 使用build_opener()修改报头1234567891011import urllib.requesturl = "http://worldagnetwork.com/"headers = ("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/604.4.7 (KHTML, like Gecko) Version/11.0.2 Safari/604.4.7")# 创建自定义的opener对象opener = urllib.request.build_opener()# 设置对应的头信息opener.addheaders = [headers]# 打开对应的网址，再读取对应数据data = opener.open(url).read() 使用add_header()添加报头12345678910import urllib.requesturl = "http://worldagnetwork.com/"# 创建一个Request对象req = urllib.request.Request(url)# 添加对应的报头信息req.add_header("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/604.4.7 (KHTML, like Gecko) Version/11.0.2 Safari/604.4.7")# 打开对应网址并读取了网页内容data = urllib.request.urlopen(req).read() 超时设置有时候，访问一个网页，如果该网页长时间未响应，那么系统就会判断该网页超时了，即无法打开该网页。 12345678910import urllib.requestfor i in range (1, 30): try: # 在爬取的时候设置超时异常的值 file = urllib.request.urlopen("http://yum.iqianyue.com", timeout=0.1) data = file.read() print(len(data)) except Exception as e: print("ERROR--&gt;" + str(e)) HTTP协议请求实战GET请求实例分析 构建对应的url地址，该url地址包含GET请求的字段名和字段内容等信息，并且url地址满足GET请求的格式，即“http://网址?字段名1=字段内容1&amp;字段名2=字段内容2” 以对应的url为参数，构建Request对象 通过urlopen()打开构建的Request对象 按需求进行后续的处理操作，比如读取网页的内容、将内容写入文件等 123456789101112import urllib.requestkey = "哈哈"url = "http://www.baidu.com/s?wd="key_code = urllib.request.quote(key)url_all = url + key_codereq = urllib.request.Request(url_all)data = urllib.request.urlopen(req).read()fhandle = open("/Users/matianyao/Desktop/crawler.html", "wb")fhandle.write(data)fhandle.close() POST请求实例分析 设置好url网址 构建表单数据，并使用urllib.parse.urlencode对数据进行编码处理 创建Request对象，参数包括url地址和要传递的数据 使用add_header()添加头信息，模拟浏览器进行爬取 使用urllib.request.urlopen()打开对应的Request对象，完成信息的传递 后续处理，比如读取网页内容、将内容写入文件等 123456789101112131415import urllib.requestimport urllib.parseurl = "http://www.iqianyue.com/mypost/"postdata = urllib.parse.urlencode(&#123; "name": "ceo@iqianyue.com", "pass": "aA123456"&#125;).encode("utf-8")req = urllib.request.Request(url, postdata)req.add_header("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/604.4.7 (KHTML, like Gecko) Version/11.0.2 Safari/604.4.7")data = urllib.request.urlopen(req).read()fhandle = open("/Users/matianyao/Desktop/crawler.html", "wb")fhandle.write(data)fhandle.close() 代理服务器的设置有时使用同一个IP去爬取同一个网站上的网页，久了之后会被该网站服务器屏蔽。 1234567891011121314151617import urllib.request# 使用代理服务器来爬取某个url网页def use_proxy(proxy_addr, url): # 设置对应的代理服务器信息 proxy = urllib.request.ProxyHandler(&#123;"http": proxy_addr&#125;) # 创建一个自定义的opener对象 opener = urllib.request.build_opener(proxy, urllib.request.HTTPHandler) # 创建全局默认的opener对象 urllib.request.install_opener(opener) # 打开对应网址爬取网页并读取 data = urllib.request.urlopen(url).read().decode("utf-8") return dataproxy_addr = "61.135.217.7:80"data = use_proxy(proxy_addr, "http://www.baidu.com")print(len(data)) 异常处理神器——URLError实战一般来说，产生URLError的原因有如下几种可能：1） 连接不上服务器2） 远程url不存在3） 无网络4） 触发了HTTPError HTTPError12345678import urllib.requestimport urllib.errortry: urllib.request.urlopen("http://worldagnetwork.com/")except urllib.error.HTTPError as e: print(e.code) print(e.reason) URLError1234567import urllib.requestimport urllib.errortry: urllib.request.urlopen("http://www.baidusss.net/")except urllib.error.URLError as e: print(e.reason) 整合改进12345678910import urllib.requestimport urllib.errortry: urllib.request.urlopen("http://www.baidusss.com/")except urllib.error.URLError as e: if hasattr(e, "code"): print(e.code) if hasattr(e, "reason"): print(e.reason)]]></content>
      <categories>
        <category>Web Crawler</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web Crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 264 - Ugly Number II]]></title>
    <url>%2F2017%2F10%2F31%2FLeetCode-Problem-264-Ugly-Number-II%2F</url>
    <content type="text"><![CDATA[Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Note1 is typically treated as an ugly number. n does not exceed 1690. ExampleInput: n = 10 Output: 12 Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Code1234567891011121314151617181920212223public int nthUglyNumber(int n) &#123; int[] ugly = new int[n]; int t2 = 0; int t3 = 0; int t5 = 0; ugly[0] = 1; for (int i = 1; i &lt; n; i++) &#123; ugly[i] = Math.min(2 * ugly[t2], Math.min(3 * ugly[t3], 5 * ugly[t5])); if (ugly[i] == 2 * ugly[t2]) t2++; if (ugly[i] == 3 * ugly[t3]) t3++; if (ugly[i] == 5 * ugly[t5]) t5++; &#125; return ugly[n-1];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 263 - Ugly Number]]></title>
    <url>%2F2017%2F10%2F31%2FLeetCode-Problem-263-Ugly-Number%2F</url>
    <content type="text"><![CDATA[Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Note1 is typically treated as an ugly number. Input is within the 32-bit signed integer range: [−2^31, 2^31 − 1]. ExampleNo.1Input: 6 Output: true Explanation: 6 = 2 × 3 No.2Input: 8 Output: true Explanation: 8 = 2 × 2 × 2 No.3Input: 14 Output: false Explanation: 14 is not ugly since it includes another prime factor 7. Code123456789101112131415161718public boolean isUgly(int num) &#123; if (num &lt;= 0) return false; if (num == 1) return true; while (num % 2 == 0) num /= 2; while (num % 3 == 0) num /= 3; while (num % 5 == 0) num /= 5; return num == 1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 202 - Happy Number]]></title>
    <url>%2F2017%2F10%2F31%2FLeetCode-Problem-202-Happy-Number%2F</url>
    <content type="text"><![CDATA[Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. ExampleInput: 19 Output: true Explanation: 12341^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1 Code123456789101112131415161718192021222324public boolean isHappy(int n) &#123; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); while (n != 1) &#123; if (set.contains(n)) return false; set.add(n); n = sum(n); &#125; return true;&#125;private int sum(int n) &#123; int sum = 0; while (n != 0) &#123; sum += Math.pow(n % 10, 2); n /= 10; &#125; return sum;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 82 - Remove Duplicates from Sorted List II]]></title>
    <url>%2F2017%2F10%2F12%2FLeetCode-Problem-82-Remove-Duplicates-from-Sorted-List-II%2F</url>
    <content type="text"><![CDATA[Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. ExampleNo.1Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 Output: 1-&gt;2-&gt;5 No.2Input: 1-&gt;1-&gt;1-&gt;2-&gt;3 Output: 2-&gt;3 Code12345public class ListNode &#123; int val; ListNode next = null; ListNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516171819202122public ListNode deleteDuplicates(ListNode head) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode prev = dummy; ListNode current = head; while (current != null &amp;&amp; current.next != null) &#123; if (current.val == current.next.val) &#123; while (current.next != null &amp;&amp; current.next.val == prev.next.val) current = current.next; current = current.next; prev.next = current; &#125; else &#123; prev = current; current = current.next; &#125; &#125; return dummy.next;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 83 - Remove Duplicates from Sorted List]]></title>
    <url>%2F2017%2F10%2F12%2FLeetCode-Problem-83-Remove-Duplicates-from-Sorted-List%2F</url>
    <content type="text"><![CDATA[Given a sorted linked list, delete all duplicates such that each element appear only once. ExampleNo.1Input: 1-&gt;1-&gt;2 Output: 1-&gt;2 No.2Input: 1-&gt;1-&gt;2-&gt;3-&gt;3 Output: 1-&gt;2-&gt;3 Code12345public class ListNode &#123; int val; ListNode next = null; ListNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) return null; ListNode current = head; while (current.next != null) &#123; if (current.val == current.next.val) current.next = current.next.next; else current = current.next; &#125; return head;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 61 - Rotate List]]></title>
    <url>%2F2017%2F10%2F12%2FLeetCode-Problem-61-Rotate-List%2F</url>
    <content type="text"><![CDATA[Given a linked list, rotate the list to the right by k places, where k is non-negative. ExampleNo.1Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Explanation:rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULLrotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL No.2Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4 Output: 2-&gt;0-&gt;1-&gt;NULL Explanation:rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULLrotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULLrotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULLrotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL Code12345public class ListNode &#123; int val; ListNode next = null; ListNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637public ListNode rotateRight(ListNode head, int k) &#123; if (head == null) return null; ListNode dummy = new ListNode(0); dummy.next = head; ListNode slow = dummy; ListNode fast = dummy; int length = getLength(head); k %= length; for (int i = 0; i &lt; k; i++) fast = fast.next; while (fast.next != null) &#123; fast = fast.next; slow = slow.next; &#125; fast.next = head; dummy.next = slow.next; slow.next = null; return dummy.next;&#125;private int getLength(ListNode head) &#123; int count = 0; while (head != null) &#123; head = head.next; count++; &#125; return count;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 19 - Remove Nth Node From End of List]]></title>
    <url>%2F2017%2F10%2F12%2FLeetCode-Problem-19-Remove-Nth-Node-From-End-of-List%2F</url>
    <content type="text"><![CDATA[Given a linked list, remove the nth node from the end of list and return its head. ExampleGiven linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. NoteGiven n will always be valid. Follow upCould you do this in one pass? Code12345public class ListNode &#123; int val; ListNode next = null; ListNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode slow = dummy; ListNode fast = dummy; for (int i = 0; i &lt; n; i++) fast = fast.next; while (fast.next != null) &#123; fast = fast.next; slow = slow.next; &#125; slow.next = slow.next.next; return dummy.next;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 213 - House Robber II]]></title>
    <url>%2F2017%2F09%2F27%2FLeetCode-Problem-213-House-Robber-II%2F</url>
    <content type="text"><![CDATA[You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. ExampleNo.1Input: [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses. No.2Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Code123456789101112131415161718192021public int rob(int[] nums) &#123; if (nums == null || nums.length &lt; 1) return 0; else if (nums.length == 1) return nums[0]; else if (nums.length == 2) return Math.max(nums[0], nums[1]); return Math.max(robHelper(nums, 0, nums.length - 2), robHelper(nums, 1, nums.length - 1));&#125;private int robHelper(int[] nums, int start, int end) &#123; int[] dp = new int[2]; dp[start%2] = nums[start]; dp[(start+1)%2] = Math.max(nums[start], nums[start+1]); for (int i = start + 2; i &lt;= end; i++) dp[i%2] = Math.max(dp[(i-1)%2], dp[(i-2)%2] + nums[i]); return dp[end%2];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 198 - House Robber]]></title>
    <url>%2F2017%2F09%2F27%2FLeetCode-Problem-198-House-Robber%2F</url>
    <content type="text"><![CDATA[You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. ExampleNo.1Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. No.2Input: [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. Code123456789101112public int rob(int[] nums) &#123; if (nums == null || nums.length &lt; 1) return 0; int[] dp = new int[nums.length+1]; dp[1] = nums[0]; for (int i = 2; i &lt;= nums.length; i++) dp[i] = Math.max(dp[i-1], nums[i-1] + dp[i-2]); return dp[nums.length];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 154 - Find Minimum in Rotated Sorted Array II]]></title>
    <url>%2F2017%2F09%2F26%2FLeetCode-Problem-154-Find-Minimum-in-Rotated-Sorted-Array-II%2F</url>
    <content type="text"><![CDATA[Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. ExampleNo.1Input: [1,3,5] Output: 1 No.2Input: [2,2,2,0,1] Output: 0 NoteThis is a follow up problem to Find Minimum in Rotated Sorted Array.Would allow duplicates affect the run-time complexity? How and why? Code1234567891011121314151617public int findMin(int[] nums) &#123; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int middle = (left + right) &gt;&gt; 1; if (nums[middle] &gt; nums[right]) left = middle + 1; else if (nums[middle] &lt; nums[left]) right = middle; else right--; &#125; return nums[left];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 153 - Find Minimum in Rotated Sorted Array]]></title>
    <url>%2F2017%2F09%2F26%2FLeetCode-Problem-153-Find-Minimum-in-Rotated-Sorted-Array%2F</url>
    <content type="text"><![CDATA[Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. You may assume no duplicate exists in the array. ExampleNo.1Input: [3,4,5,1,2] Output: 1 No.2Input: [4,5,6,7,0,1,2] Output: 0 Code123456789101112131415public int findMin(int[] nums) &#123; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int middle = (left + right) &gt;&gt; 1; if (nums[middle] &gt; nums[right]) left = middle + 1; else right = middle; &#125; return nums[left];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 35 - Search Insert Position]]></title>
    <url>%2F2017%2F09%2F26%2FLeetCode-Problem-35-Search-Insert-Position%2F</url>
    <content type="text"><![CDATA[Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. ExampleNo.1Input: [1,3,5,6], 5 Output: 2 No.2Input: [1,3,5,6], 2 Output: 1 No.3Input: [1,3,5,6], 7 Output: 4 No.4Input: [1,3,5,6], 0 Output: 0 Code1234567891011121314151617public int searchInsert(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int middle = (left + right) &gt;&gt; 1; if (nums[middle] &gt; target) right = middle - 1; else if (nums[middle] &lt; target) left = middle + 1; else return middle; &#125; return left;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 152 - Maximum Product Subarray]]></title>
    <url>%2F2017%2F09%2F26%2FLeetCode-Problem-152-Maximum-Product-Subarray%2F</url>
    <content type="text"><![CDATA[Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. ExampleNo.1Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. No.2Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray. Code12345678910111213141516public int maxProduct(int[] nums) &#123; int[][] dp = new int[nums.length][2]; int max = nums[0]; dp[0][0] = dp[0][1] = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; int localMin = dp[i-1][1] * nums[i]; int localMax = dp[i-1][0] * nums[i]; dp[i][0] = Math.max(nums[i], Math.max(localMax, localMin)); dp[i][1] = Math.min(nums[i], Math.min(localMax, localMin)); max = Math.max(max, dp[i][0]); &#125; return max;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 53 - Maximum Subarray]]></title>
    <url>%2F2017%2F09%2F25%2FLeetCode-Problem-53-Maximum-Subarray%2F</url>
    <content type="text"><![CDATA[Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. ExampleInput: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Follow upIf you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. O(nlogn) runtime, O(logn) stack space – Divide and Conquer123456789101112131415161718192021222324252627282930313233public int maxSubArray(int[] nums) &#123; return subArrayHelper(nums, 0, nums.length - 1);&#125;private int subArrayHelper(int[] nums, int left, int right)&#123; if (left &gt; right) return Integer.MIN_VALUE; int middle = (left + right) &gt;&gt; 1; int leftSum = subArrayHelper(nums, left, middle - 1); int rightSum = subArrayHelper(nums, middle + 1, right); int sum = 0; int sumFromLeft = 0; for (int i = middle - 1; i &gt;= left; i--)&#123; sum += nums[i]; sumFromLeft = Math.max(sumFromLeft, sum); &#125; sum = 0; int sumFromRight = 0; for (int i = middle + 1; i &lt;= right; i++)&#123; sum += nums[i]; sumFromRight = Math.max(sumFromRight, sum); &#125; int middleSum = sumFromLeft + sumFromRight + nums[middle]; return Math.max(middleSum, Math.max(leftSum, rightSum));&#125; O(n) runtime, O(1) space – Dynamic programming1234567891011public int maxSubArray(int[] nums) &#123; int[] dp = new int[nums.length+1]; int max = Integer.MIN_VALUE; for (int i = 1; i &lt;= nums.length; i++) &#123; dp[i] = Math.max(nums[i-1], dp[i-1] + nums[i-1]); max = Math.max(max, dp[i]); &#125; return max;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 63 - Unique Paths II]]></title>
    <url>%2F2017%2F09%2F25%2FLeetCode-Problem-63-Unique-Paths-II%2F</url>
    <content type="text"><![CDATA[A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. Notem and n will be at most 100. ExampleInput:[ [0,0,0], [0,1,0], [0,0,0]] Output: 2 Explanation:There is one obstacle in the middle of the 3x3 grid above.There are two ways to reach the bottom-right corner: Right -&gt; Right -&gt; Down -&gt; Down Down -&gt; Down -&gt; Right -&gt; Right Code123456789101112131415161718192021// O(mn) runtime, O(mn) space – Dynamic programmingpublic int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; dp[0][0] = obstacleGrid[0][0] ^ 1; for (int i = 1; i &lt; n; i++) dp[0][i] = obstacleGrid[0][i] == 1 ? 0 : dp[0][i-1]; for (int i = 1; i &lt; m; i++) dp[i][0] = obstacleGrid[i][0] == 1 ? 0 : dp[i-1][0]; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i-1][j] + dp[i][j-1]; &#125; return dp[m-1][n-1];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 62 - Unique Paths]]></title>
    <url>%2F2017%2F09%2F25%2FLeetCode-Problem-62-Unique-Paths%2F</url>
    <content type="text"><![CDATA[A robot is located at the top-left corner of a m x n grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. How many possible unique paths are there? Notem and n will be at most 100. ExampleNo.1Input: m = 3, n = 2 Output: 3 Explanation:From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: Right -&gt; Right -&gt; Down Right -&gt; Down -&gt; Right Down -&gt; Right -&gt; Right No.2Input: m = 7, n = 3 Output: 28 Code123456789101112131415// O(mn) runtime, O(mn) space – Bottom-up dynamic programmingpublic int uniquePaths(int m, int n) &#123; int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == 0 || j == 0) dp[i][j] = 1; else dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 70 - Climbing Stairs]]></title>
    <url>%2F2017%2F09%2F25%2FLeetCode-Problem-70-Climbing-Stairs%2F</url>
    <content type="text"><![CDATA[You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? NoteGiven n will be a positive integer. ExampleNo.1Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1 step + 1 step 2 steps No.2Input: 3 Output: 3 Explanation: There are three ways to climb to the top. 1 step + 1 step + 1 step 1 step + 2 steps 2 steps + 1 step Code1234567891011121314// O(n) runtime, O(1) space – Dynamic programmingpublic int climbStairs(int n) &#123; int[] dp = new int[2]; dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;=n; i++) &#123; int current = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = current; &#125; return dp[1];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 150 - Evaluate Reverse Polish Notation]]></title>
    <url>%2F2017%2F09%2F19%2FLeetCode-Problem-150-Evaluate-Reverse-Polish-Notation%2F</url>
    <content type="text"><![CDATA[Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. NoteDivision between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation. ExampleNo.1Input: [“2”, “1”, “+”, “3”, “*”] Output: 9 Explanation: ((2 + 1) * 3) = 9 No.2Input: [“4”, “13”, “5”, “/“, “+”] Output: 6 Explanation: (4 + (13 / 5)) = 6 No.3Input: [“10”, “6”, “9”, “3”, “+”, “-11”, “*“, “/“, “*”, “17”, “+”, “5”, “+”] Output: 22 Explanation: 1234567 ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 Code123456789101112131415161718192021222324252627282930313233343536373839public int evalRPN(String[] tokens) &#123; if (tokens == null || tokens.length &lt; 1) return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Set&lt;String&gt; operation = new HashSet&lt;String&gt;()&#123;&#123; add("+"); add("-"); add("*"); add("/"); &#125;&#125;; for (String token : tokens) &#123; if (!operation.contains(token)) &#123; stack.push(Integer.valueOf(token)); continue; &#125; int b = stack.pop(); int a = stack.pop(); switch (token) &#123; case "+" : stack.push(a + b); continue; case "-" : stack.push(a - b); continue; case "*" : stack.push(a * b); continue; case "/" : stack.push(a / b); continue; &#125; &#125; return stack.peek();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 20 - Valid Parentheses]]></title>
    <url>%2F2017%2F09%2F18%2FLeetCode-Problem-20-Valid-Parentheses%2F</url>
    <content type="text"><![CDATA[Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order. Note that an empty string is also considered valid. ExampleNo.1Input: “()” Output: true No.2Input: “()[]{}” Output: true No.3Input: “(]” Output: false No.4Input: “([)]” Output: false No.5Input: “{[]}” Output: true Code123456789101112131415161718public boolean isValid(String s) &#123; Map&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;()&#123;&#123; put('(', ')'); put('[', ']'); put('&#123;', '&#125;'); &#125;&#125;; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (Character ch : s.toCharArray()) &#123; if (map.containsKey(ch)) stack.push(ch); else if (stack.isEmpty() || map.get(stack.pop()) != ch) return false; &#125; return stack.isEmpty();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 155 - Min Stack]]></title>
    <url>%2F2017%2F09%2F18%2FLeetCode-Problem-155-Min-Stack%2F</url>
    <content type="text"><![CDATA[Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. ExampleMinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; Returns -3.minStack.pop();minStack.top(); –&gt; Returns 0.minStack.getMin(); –&gt; Returns -2. Code123456789101112131415161718192021222324252627282930313233// O(n) runtime, O(n) space – Minor space optimizationclass MinStack &#123; private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; min; public MinStack() &#123; stack = new Stack&lt;&gt;(); min = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; stack.push(x); if (min.isEmpty() || x &lt;= min.peek()) min.push(x); &#125; public void pop() &#123; int x = stack.pop(); if (x == min.peek()) min.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return min.peek(); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 133 - Clone Graph]]></title>
    <url>%2F2017%2F09%2F18%2FLeetCode-Problem-133-Clone-Graph%2F</url>
    <content type="text"><![CDATA[Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors. Example Input:{“$id”:”1”,”neighbors”:[{“$id”:”2”,”neighbors”:[{“$ref”:”1”},{“$id”:”3”,”neighbors”:[{“$ref”:”2”},{“$id”:”4”,”neighbors”:[{“$ref”:”3”},{“$ref”:”1”}],”val”:4}],”val”:3}],”val”:2},{“$ref”:”4”}],”val”:1} Explanation:Node 1’s value is 1, and it has two neighbors: Node 2 and 4.Node 2’s value is 2, and it has two neighbors: Node 1 and 3.Node 3’s value is 3, and it has two neighbors: Node 2 and 4.Node 4’s value is 4, and it has two neighbors: Node 1 and 3. NoteThe number of nodes will be between 1 and 100. The undirected graph is a simple graph, which means no repeated edges and no self-loops in the graph. Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too. You must return the copy of the given node as a reference to the cloned graph. O(n) runtime, O(n) space – Depth-first traversal12345public class UndirectedGraphNode &#123; int label; List&lt;UndirectedGraphNode&gt; neighbors; UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125;&#125; 123456789101112131415161718192021public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123; if (node == null) return null; Map&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = new HashMap&lt;&gt;(); return dfs(map, node);&#125;private UndirectedGraphNode dfs(Map&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map, UndirectedGraphNode node) &#123; UndirectedGraphNode copy = new UndirectedGraphNode(node.label); map.put(node, copy); for (UndirectedGraphNode neighbor : node.neighbors) &#123; if (!map.containsKey(neighbor)) copy.neighbors.add(dfs(map, neighbor)); else copy.neighbors.add(map.get(neighbor)); &#125; return copy;&#125; O(n) runtime, O(n) space – Breadth-first traversal12345public class UndirectedGraphNode &#123; int label; List&lt;UndirectedGraphNode&gt; neighbors; UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125;&#125; 1234567891011121314151617181920212223242526272829public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123; if (node == null) return null; Map&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = new HashMap&lt;&gt;(); return bfs(map, node);&#125;private UndirectedGraphNode bfs(Map&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map, UndirectedGraphNode node) &#123; Queue&lt;UndirectedGraphNode&gt; queue = new LinkedList&lt;&gt;(); UndirectedGraphNode copy = new UndirectedGraphNode(node.label); map.put(node, copy); queue.offer(node); while (!queue.isEmpty()) &#123; UndirectedGraphNode current = queue.poll(); for (UndirectedGraphNode neighbor : current.neighbors) &#123; if (!map.containsKey(neighbor)) &#123; queue.offer(neighbor); map.put(neighbor, new UndirectedGraphNode(neighbor.label)); &#125; map.get(current).neighbors.add(map.get(neighbor)); &#125; &#125; return copy;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 13 - Roman to Integer]]></title>
    <url>%2F2017%2F09%2F18%2FLeetCode-Problem-13-Roman-to-Integer%2F</url>
    <content type="text"><![CDATA[Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900. ExampleNo.1Input: “III” Output: 3 No.2Input: “IV” Output: 4 No.3Input: “IX” Output: 9 No.4Input: “LVIII” Output: 58 Explanation: L = 50, V= 5, III = 3. No.5Input: “MCMXCIV” Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Code12345678910111213141516171819202122public int romanToInt(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;()&#123;&#123; put('I', 1); put('V', 5); put('X', 10); put('L', 50); put('C', 100); put('D', 500); put('M', 1000); &#125;&#125;; int num = 0; int prev = 0; for (Character ch : s.toCharArray()) &#123; int current = map.get(ch); num += current &lt;= prev ? current : current - 2 * prev; prev = current; &#125; return num;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 12 - Integer to Roman]]></title>
    <url>%2F2017%2F09%2F18%2FLeetCode-Problem-12-Integer-to-Roman%2F</url>
    <content type="text"><![CDATA[Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900. ExampleNo.1Input: 3 Output: “III” No.2Input: 4 Output: “IV” No.3Input: 9 Output: “IX” No.4Input: 58 Output: “LVIII” Explanation: L = 50, V = 5, III = 3. No.5Input: 1994 Output: “MCMXCIV” Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Code1234567891011121314public String intToRoman(int num) &#123; StringBuilder sb = new StringBuilder(); int[] key = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;; String[] val = &#123;"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"&#125;; for (int i = 0; i &lt; key.length; i++) &#123; while (num &gt;= key[i]) &#123; sb.append(val[i]); num -= key[i]; &#125; &#125; return sb.toString();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 54 - Spiral Matrix]]></title>
    <url>%2F2017%2F09%2F17%2FLeetCode-Problem-54-Spiral-Matrix%2F</url>
    <content type="text"><![CDATA[Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. ExampleNo.1Input:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]] Output: [1,2,3,6,9,8,7,4,5] No.2Input:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]] Output: [1,2,3,4,8,12,11,10,9,5,6,7] Code12345678910111213141516171819202122232425262728293031323334353637383940public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (matrix == null || matrix.length == 0) return result; int m = matrix.length; int n = matrix[0].length; int start = 0; while (2 * start &lt; m &amp;&amp; 2 * start &lt; n) &#123; spiralOrderHelper(result, matrix, m, n, start); start++; &#125; return result;&#125;private void spiralOrderHelper(List&lt;Integer&gt; result, int[][] matrix, int m, int n, int start) &#123; int endX = n - 1 - start; int endY = m - 1 - start; for (int i = start; i &lt;= endX; i++) result.add(matrix[start][i]); if (endY &gt; start) &#123; for (int i = start + 1; i &lt;= endY; i++) result.add(matrix[i][endX]); &#125; if (endY &gt; start &amp;&amp; endX &gt; start) &#123; for (int i = endX - 1; i &gt;= start; i--) result.add(matrix[endY][i]); &#125; if (endY &gt; start + 1 &amp;&amp; endX &gt; start) &#123; for (int i = endY - 1; i &gt; start; i--) result.add(matrix[i][start]); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 137 - Single Number II]]></title>
    <url>%2F2017%2F09%2F16%2FLeetCode-Problem-137-Single-Number-II%2F</url>
    <content type="text"><![CDATA[Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. NoteYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory? ExampleNo.1Input: [2,2,3,2] Output: 3 No.2Input: [0,1,0,1,0,1,99] Output: 99 Code12345678910111213141516public int singleNumber(int[] nums) &#123; int num = 0; for (int i = 0; i &lt; 32; i++) &#123; int sum = 0; for (int j = 0; j &lt; nums.length; j++) &#123; if (((nums[j] &gt;&gt; i) &amp; 1) == 1) sum++; &#125; num |= (sum % 3) &lt;&lt; i; &#125; return num;&#125; Improvement A new number appears - It gets XOR’d to the variable “ones”. A number gets repeated(appears twice) - It is removed from “ones” and XOR’d to the variable “twos”. A number appears for the third time - It gets removed from both “ones” and “twos”. 123456789101112131415public int singleNumber(int[] nums) &#123; int once = 0; int twice = 0; int common; for (int i = 0; i &lt; nums.length; i++) &#123; twice |= once &amp; nums[i]; once ^= nums[i]; common = ~(once &amp; twice); once &amp;= common; twice &amp;= common; &#125; return once;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 136 - Single Number]]></title>
    <url>%2F2017%2F09%2F16%2FLeetCode-Problem-136-Single-Number%2F</url>
    <content type="text"><![CDATA[Given an array of integers, every element appears twice except for one. Find that single one. NoteYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory? ExampleNo.1Input: [2,2,1] Output: 1 No.2Input: [4,1,2,1,2] Output: 4 Code12345678public int singleNumber(int[] nums) &#123; int num = 0; for (int n : nums) num ^= n; return num;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 124 - Binary Tree Maximum Path Sum]]></title>
    <url>%2F2017%2F09%2F16%2FLeetCode-Problem-124-Binary-Tree-Maximum-Path-Sum%2F</url>
    <content type="text"><![CDATA[Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. ExampleNo.1Input: [1,2,3] 123 1 / \2 3 Output: 6 No.2Input: [-10,9,20,null,null,15,7] 12345 -10 / \9 20 / \ 15 7 Output: 42 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617private int max = Integer.MIN_VALUE;public int maxPathSum(TreeNode root) &#123; maxPathSumHelper(root); return max;&#125;private int maxPathSumHelper(TreeNode root) &#123; if (root == null) return 0; int left = Math.max(maxPathSumHelper(root.left), 0); int right = Math.max(maxPathSumHelper(root.right), 0); max = Math.max(max, root.val + left + right); return Math.max(left, right) + root.val;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 109 - Convert Sorted List to Binary Search Tree]]></title>
    <url>%2F2017%2F09%2F15%2FLeetCode-Problem-109-Convert-Sorted-List-to-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. ExampleGiven the sorted linked list: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 12345 0 / \ -3 9 / /-10 5 Code123456789101112public class ListNode &#123; int val; ListNode next = null; ListNode(int x) &#123; val = x; &#125;&#125;public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324252627282930313233// O(n) runtime, O(logn) stack space – Bottom-up recursionprivate ListNode current;public TreeNode sortedListToBST(ListNode head) &#123; ListNode node = head; current = head; int length = 0; while (node != null) &#123; length++; node = node.next; &#125; return sortedListToBSTHelper(0, length - 1);&#125;private TreeNode sortedListToBSTHelper(int start, int end) &#123; if (start &gt; end) return null; int mid = (start + end) &gt;&gt; 1; TreeNode left = sortedListToBSTHelper(start, mid - 1); TreeNode parent = new TreeNode(current.val); parent.left = left; current = current.next; TreeNode right = sortedListToBSTHelper(mid + 1, end); parent.right = right; return parent;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 108 - Convert Sorted Array to Binary Search Tree]]></title>
    <url>%2F2017%2F09%2F15%2FLeetCode-Problem-108-Convert-Sorted-Array-to-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. ExampleGiven the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 12345 0 / \ -3 9 / /-10 5 Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324// O(n) runtime, O(log n) stack spacepublic TreeNode sortedArrayToBST(int[] nums) &#123; if (nums == null || nums.length &lt; 1) return null; return sortedArrayToBSTHelper(nums, 0, nums.length - 1);&#125;private TreeNode sortedArrayToBSTHelper(int[] nums, int start, int end) &#123; if (start &gt; end) return null; if (start == end) return new TreeNode(nums[start]); int mid = (start + end) &gt;&gt; 1; TreeNode root = new TreeNode(nums[mid]); root.left = sortedArrayToBSTHelper(nums, start, mid - 1); root.right = sortedArrayToBSTHelper(nums, mid + 1, end); return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 110 - Balanced Binary Tree]]></title>
    <url>%2F2017%2F09%2F15%2FLeetCode-Problem-110-Balanced-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1. ExampleNo.1Given the following tree [3,9,20,null,null,15,7]: 12345 3 / \9 20 / \ 15 7 Return true. No.2Given the following tree [1,2,2,3,3,null,null,4,4]: 1234567 1 / \ 2 2 / \ 3 3 / \4 4 Return false. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021// O(n) runtime, O(n) stack space – Bottom-up recursionpublic boolean isBalanced(TreeNode root) &#123; return maxDepth(root) == -1 ? false : true;&#125;private int maxDepth(TreeNode root) &#123; if (root == null) return 0; int leftDepth = maxDepth(root.left); if (leftDepth == -1) return -1; int rightDepth = maxDepth(root.right); if (rightDepth == -1) return -1; return (Math.abs(leftDepth - rightDepth) &gt; 1) ? -1 : Math.max(leftDepth, rightDepth) + 1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 111 - Minimum Depth of Binary Tree]]></title>
    <url>%2F2017%2F09%2F15%2FLeetCode-Problem-111-Minimum-Depth-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. NoteA leaf is a node with no children. ExampleGiven binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its minimum depth = 2. O(n) runtime, O(log n) space – Depth-first traversal123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112public int minDepth(TreeNode root) &#123; if (root == null) return 0; if (root.left == null) return minDepth(root.right) + 1; if (root.right == null) return minDepth(root.left) + 1; return Math.min(minDepth(root.right), minDepth(root.left)) + 1;&#125; O(n) runtime, O(n) space – Breadth-first traversal123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617181920212223242526272829public int minDepth(TreeNode root) &#123; if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); TreeNode levelEnd = root; int depth = 1; while (!queue.isEmpty()) &#123; TreeNode current = queue.poll(); if (current.left == null &amp;&amp; current.right == null) break; if (current.left != null) queue.offer(current.left); if (current.right != null) queue.offer(current.right); if (current == levelEnd) &#123; levelEnd = current.right == null ? current.left : current.right; depth++; &#125; &#125; return depth;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 104 - Maximum Depth of Binary Tree]]></title>
    <url>%2F2017%2F09%2F15%2FLeetCode-Problem-104-Maximum-Depth-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. NoteA leaf is a node with no children. ExampleGiven binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its depth = 3. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910// O(n) runtime, O(log n) space – Recursionpublic int maxDepth(TreeNode root) &#123; if (root == null) return 0; int leftDepth = maxDepth(root.left); int rightDepth = maxDepth(root.right); return Math.max(leftDepth, rightDepth) + 1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 98 - Validate Binary Search Tree]]></title>
    <url>%2F2017%2F09%2F14%2FLeetCode-Problem-98-Validate-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than the node’s key.Both the left and right subtrees must also be binary search trees. ExampleNo.1Input: 123 2 / \1 3 Output: true No.2Input: 12345 5 / \1 4 / \ 3 6 Output: false Explanation: The input is: [5,1,4,null,null,3,6]. The root node’s value is 5 but its right child’s value is 4. O(n) runtime, O(n) stack space – Top-down recursion123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213public boolean isValidBST(TreeNode root) &#123; return isValidBSTHelper(root, Long.MIN_VALUE, Long.MAX_VALUE);&#125;private boolean isValidBSTHelper(TreeNode root, long low, long high) &#123; if (root == null) return true; if (root.val &lt;= low || root.val &gt;= high) return false; return isValidBSTHelper(root.left, low, root.val) &amp;&amp; isValidBSTHelper(root.right, root.val, high);&#125; O(n) runtime, O(n) stack space – In-order traversal123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415private TreeNode prev = null;public boolean isValidBST(TreeNode root) &#123; if (root == null) return true; if (isValidBST(root.left)) &#123; if (prev == null || root.val &gt; prev.val) &#123; prev = root; return isValidBST(root.right); &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 138 - Copy List with Random Pointer]]></title>
    <url>%2F2017%2F09%2F14%2FLeetCode-Problem-138-Copy-List-with-Random-Pointer%2F</url>
    <content type="text"><![CDATA[A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. Example Input:{“$id”:”1”,”next”:{“$id”:”2”,”next”:null,”random”:{“$ref”:”2”},”val”:2},”random”:{“$ref”:”2”},”val”:1} Explanation:Node 1’s value is 1, both of its next and random pointer points to Node 2.Node 2’s value is 2, its next pointer points to null and its random pointer points to itself. Code12345public class RandomListNode &#123; int label; RandomListNode next, random; RandomListNode(int x) &#123; this.label = x; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738// O(n) runtime, O(1) space – Modify original structurepublic RandomListNode copyRandomList(RandomListNode head) &#123; RandomListNode current = head; RandomListNode copyHead = null, copyCurrent = null; while (current != null) &#123; RandomListNode copy = new RandomListNode(current.label); copy.next = current.next; current.next = copy; current = copy.next; &#125; current = head; while (current != null) &#123; if (current.random != null) current.next.random = current.random.next; current = current.next.next; &#125; current = head; if (current != null) &#123; copyHead = copyCurrent = current.next; current.next = current.next.next; current = copyCurrent.next; &#125; while (current != null) &#123; copyCurrent.next = current.next; current.next = current.next.next; copyCurrent = copyCurrent.next; current = current.next; &#125; return copyHead;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 23 - Merge K Sorted Linked Lists]]></title>
    <url>%2F2017%2F09%2F14%2FLeetCode-Problem-23-Merge-K-Sorted-Linked-Lists%2F</url>
    <content type="text"><![CDATA[Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. ExampleInput:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6] Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 O(nklogk) runtime, O(k) space – Heap12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length &lt; 1) return null; PriorityQueue&lt;ListNode&gt; minHeap = new PriorityQueue&lt;&gt;(lists.length, (o1, o2) -&gt; o1.val - o2.val); ListNode head = new ListNode(0); ListNode current = head; for (ListNode node : lists) &#123; if (node != null) minHeap.add(node); &#125; while (!minHeap.isEmpty()) &#123; current.next = minHeap.poll();; current = current.next; if (current.next != null) minHeap.offer(current.next); &#125; return head.next;&#125; O(nklogk) runtime, O(1) space – Divide and conquer using two way merge12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length &lt; 1) return null; return partition(lists, 0, lists.length - 1);&#125;private ListNode partition(ListNode[] lists, int start, int end) &#123; if (start == end) return lists[start]; int mid = (start + end) &gt;&gt; 1; ListNode left = partition(lists, start, mid); ListNode right = partition(lists, mid + 1, end); return mergeTwoLists(left, right);&#125;private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 24 - Swap Nodes in Pairs]]></title>
    <url>%2F2017%2F09%2F13%2FLeetCode-Problem-24-Swap-Nodes-in-Pairs%2F</url>
    <content type="text"><![CDATA[Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list, only nodes itself can be changed. ExampleGiven 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Code12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516public ListNode swapPairs(ListNode head) &#123; ListNode node = new ListNode(0); node.next = head; ListNode prev = node; while (prev.next != null &amp;&amp; prev.next.next != null) &#123; ListNode current = prev.next; ListNode next = prev.next.next; current.next = next.next; next.next = current; prev.next = next; prev = current; &#125; return node.next;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 2 - Add Two Numbers]]></title>
    <url>%2F2017%2F09%2F13%2FLeetCode-Problem-2-Add-Two-Numbers%2F</url>
    <content type="text"><![CDATA[You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. ExampleInput: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. Code12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617181920212223242526272829public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0); ListNode current1 = l1; ListNode current2 = l2; ListNode current = head; int carry = 0; while (current1 != null || current2 != null) &#123; int val1 = current1 == null ? 0 : current1.val; int val2 = current2 == null ? 0 : current2.val; int sum = val1 + val2 + carry; current.next = new ListNode(sum % 10); carry = sum / 10; current = current.next; if (current1 != null) current1 = current1.next; if (current2 != null) current2 = current2.next; &#125; if (carry &gt; 0) current.next = new ListNode(carry); return head.next;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 21 - Merge Two Sorted Lists]]></title>
    <url>%2F2017%2F09%2F13%2FLeetCode-Problem-21-Merge-Two-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. ExampleInput: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4 Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 Code12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt;= l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 9 - Palindrome Number]]></title>
    <url>%2F2017%2F09%2F13%2FLeetCode-Problem-9-Palindrome-Number%2F</url>
    <content type="text"><![CDATA[Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. ExampleNo.1Input: 121 Output: true No.2Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. No.3Input: 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow upCoud you solve it without converting the integer to a string? Code12345678910111213public boolean isPalindrome(int x) &#123; if (x &lt; 0 || (x != 0 &amp;&amp; x % 10 == 0)) return false; int reverseX = 0; while (x &gt; reverseX) &#123; reverseX = reverseX * 10 + x % 10; x /= 10; &#125; return x == reverseX || reverseX / 10 == x;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 66 - Plus One]]></title>
    <url>%2F2017%2F09%2F13%2FLeetCode-Problem-66-Plus-One%2F</url>
    <content type="text"><![CDATA[Given a non-negative integer represented as a non-empty array of digits, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. ExampleNo.1Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. No.2Input: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321. Code123456789101112131415public int[] plusOne(int[] digits) &#123; for (int i = digits.length - 1; i &gt;= 0; i--) &#123; if (digits[i] != 9) &#123; digits[i]++; return digits; &#125; else digits[i] = 0; &#125; int[] newDigit = new int[digits.length+1]; newDigit[0] = 1; return newDigit;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 7 - Reverse Integer]]></title>
    <url>%2F2017%2F09%2F13%2FLeetCode-Problem-7-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[Given a 32-bit signed integer, reverse digits of an integer. ExampleNo.1Input: 123 Output: 321 No.2Input: -123 Output: -321 No.3Input: 120 Output: 21 NoteAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Code12345678910111213public int reverse(int x) &#123; int reverseX = 0; while (x != 0) &#123; if (Math.abs(reverseX) &gt; Integer.MAX_VALUE / 10) return 0; reverseX = reverseX * 10 + x % 10; x /= 10; &#125; return reverseX;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 5 - Longest Palindromic Substring]]></title>
    <url>%2F2017%2F09%2F12%2FLeetCode-Problem-5-Longest-Palindromic-Substring%2F</url>
    <content type="text"><![CDATA[Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. ExampleNo.1Input: “babad” Output: “bab” Note: “aba” is also a valid answer. No.2Input: “cbbd” Output: “bb” O(n^2) runtime, O(n) space – Dynamic programming1234567891011121314151617181920212223public String longestPalindrome(String s) &#123; String str = ""; int n = s.length(); if (n &gt; 1000) return str; boolean[][] dp = new boolean[n][n]; // P[i, i] ← true // P[i, i+1] ← (Si = Si+1) // P[i, j] ← (P[i+1, j-1] and Si = Sj) for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i; j &lt; n; j++) &#123; dp[i][j] = (s.charAt(i) == s.charAt(j)) &amp;&amp; (j - i + 1 &lt; 3 || dp[i+1][j-1]); if (dp[i][j] &amp;&amp; (j - i + 1) &gt; str.length()) str = s.substring(i, j + 1); &#125; &#125; return str;&#125; O(n^2) runtime, O(1) space – Simpler solution123456789101112131415161718192021222324252627public String longestPalindrome(String s) &#123; String str = ""; int n = s.length(); if (n &gt; 1000) return str; for (int i = 0; i &lt; n; i++) &#123; int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int max = Math.max(len1, len2); if (max &gt; str.length()) str = s.substring(i - (max - 1) / 2, i + 1 + max / 2); &#125; return str;&#125;private int expandAroundCenter(String s, int i, int j) &#123; while (i &gt;= 0 &amp;&amp; j &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(j)) &#123; i--; j++; &#125; return j - i - 1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 3 - Longest Substring Without Repeating Characters]]></title>
    <url>%2F2017%2F09%2F12%2FLeetCode-Problem-3-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[Given a string, find the length of the longest substring without repeating characters. ExampleNo.1Input: “abcabcbb” Output: 3 Explanation: The answer is “abc”, with the length of 3. No.2Input: “bbbbb” Output: 1 Explanation: The answer is “b”, with the length of 1. No.3Input: “pwwkew” Output: 3 Explanation: The answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. Code123456789101112131415161718// O(n) runtime, O(1) spacepublic int lengthOfLongestSubstring(String s) &#123; int[] ascii = new int[256]; int max = 0; int idx = 0; Arrays.fill(ascii, -1); for (int i = 0; i &lt; s.length(); i++) &#123; if (ascii[s.charAt(i)] &gt;= idx) idx = ascii[s.charAt(i)] + 1; ascii[s.charAt(i)] = i; max = Math.max(max, i - idx + 1); &#125; return max;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 65 - Valid Number]]></title>
    <url>%2F2017%2F09%2F12%2FLeetCode-Problem-65-Valid-Number%2F</url>
    <content type="text"><![CDATA[Validate if a given string is numeric. Example“0” =&gt; true“ 0.1 “ =&gt; true“abc” =&gt; false“1 a” =&gt; false“2e10” =&gt; true“ -90e3 “ =&gt; true“ 1e” =&gt; false“e3” =&gt; false“ 6e-1” =&gt; true“ 99e2.5 “ =&gt; false“53.5e93” =&gt; true“ –6 “ =&gt; false“-+3” =&gt; false“95a54e53” =&gt; false NoteIt is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number: Numbers 0-9Exponent - “e”Positive/negative sign - “+”/“-“Decimal point - “.” Of course, the context of these characters also matters in the input. Code123456789101112131415161718192021222324252627282930313233343536373839404142public boolean isNumber(String s) &#123; boolean isNum = false; int i = 0; while (i &lt; s.length() &amp;&amp; Character.isWhitespace(s.charAt(i))) i++; if (i &lt; s.length() &amp;&amp; (s.charAt(i) == '+' || s.charAt(i) == '-')) i++; while (i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i))) &#123; isNum = true; i++; &#125; if (i &lt; s.length() &amp;&amp; s.charAt(i) == '.') &#123; i++; while (i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i))) &#123; isNum = true; i++; &#125; &#125; if (isNum &amp;&amp; i &lt; s.length() &amp;&amp; s.charAt(i) == 'e') &#123; isNum = false; i++; if (i &lt; s.length() &amp;&amp; (s.charAt(i) == '+' || s.charAt(i) == '-')) i++; while (i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i))) &#123; isNum = true; i++; &#125; &#125; while (i &lt; s.length() &amp;&amp; Character.isWhitespace(s.charAt(i))) i++; return isNum &amp;&amp; i == s.length();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 8 - String to Integer (atoi)]]></title>
    <url>%2F2017%2F09%2F12%2FLeetCode-Problem-8-String-to-Integer-atoi%2F</url>
    <content type="text"><![CDATA[Implement atoi to convert a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. ExampleNo.1Input: “42” Output: 42 No.2Input: “ -42” Output: -42 Explanation: The first non-whitespace character is ‘-‘, which is the minus sign. Then take as many numerical digits as possible, which gets 42. No.3Input: “4193 with words” Output: 4193 Explanation: Conversion stops at digit ‘3’ as the next character is not a numerical digit. No.4Input: “words and 987” Output: 0 Explanation: The first non-whitespace character is ‘w’, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. No.5Input: “-91283472332” Output: -2147483648 Explanation: The number “-91283472332” is out of the range of a 32-bit signed integer. Thefore INT_MIN (−2^31) is returned. NotesOnly the space character ‘ ‘ is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned. Code123456789101112131415161718192021222324252627public int myAtoi(String str) &#123; int flag = 1; int num = 0; int i = 0; while (i &lt; str.length() &amp;&amp; Character.isWhitespace(str.charAt(i))) i++; if (i &lt; str.length() &amp;&amp; str.charAt(i) == '-') &#123; flag = -1; i++; &#125; else if (i &lt; str.length() &amp;&amp; str.charAt(i) == '+') i++; while (i &lt; str.length() &amp;&amp; Character.isDigit(str.charAt(i))) &#123; int digit = Character.getNumericValue(str.charAt(i)); if (num &gt; Integer.MAX_VALUE / 10 || (num == 214748364 &amp;&amp; digit &gt; 7)) return flag == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; num = 10 * num + digit; i++; &#125; return flag * num;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 28 - Implement strStr()]]></title>
    <url>%2F2017%2F09%2F12%2FLeetCode-Problem-28-Implement-strStr%2F</url>
    <content type="text"><![CDATA[Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. ExampleNo.1Input: haystack = “hello”, needle = “ll” Output: 2 No.2Input: haystack = “aaaaa”, needle = “bba” Output: -1 ClarificationWhat should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf(). Code1234567891011121314// O(nm) runtime, O(1) spacepublic int strStr(String haystack, String needle) &#123; for (int i = 0; i &lt;= haystack.length() - needle.length(); i++) &#123; for (int j = 0; ; j++) &#123; if (j == needle.length()) return i; if (needle.charAt(j) != haystack.charAt(i+j)) break; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 125 - Valid Palindrome]]></title>
    <url>%2F2017%2F09%2F12%2FLeetCode-Problem-125-Valid-Palindrome%2F</url>
    <content type="text"><![CDATA[Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. NoteFor the purpose of this problem, we define empty string as valid palindrome. ExampleNo.1Input: “A man, a plan, a canal: Panama” Output: true No.2Input: “race a car” Output: false Code123456789101112131415161718192021// O(n) runtime, O(1) spacepublic boolean isPalindrome(String s) &#123; int start = 0; int end = s.length() - 1; while (start &lt; end) &#123; while (start &lt; end &amp;&amp; !Character.isLetterOrDigit(s.charAt(start))) start++; while (start &lt; end &amp;&amp; !Character.isLetterOrDigit(s.charAt(end))) end--; if (Character.toLowerCase(s.charAt(start)) != Character.toLowerCase(s.charAt(end))) return false; start++; end--; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 167 - Two Sum II - Input array is sorted]]></title>
    <url>%2F2017%2F09%2F11%2FLeetCode-Problem-167-Two-Sum-II-Input-array-is-sorted%2F</url>
    <content type="text"><![CDATA[Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. NoteYour returned answers (both index1 and index2) are not zero-based.You may assume that each input would have exactly one solution and you may not use the same element twice. ExampleInput: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. O(nlogn) runtime, O(1) space1234567891011121314151617181920212223242526public int[] twoSum(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length &amp;&amp; nums[i] &lt;= target; i++) &#123; int num = nums[i]; int j = binarySearch(nums, i + 1, nums.length - 1, target - num); if (j != -1) return i &lt; j ? new int[] &#123;i + 1, j + 1&#125; : new int[] &#123;j + 1, i + 1&#125;; &#125; return null;&#125;private int binarySearch(int[] nums, int start, int end, int target) &#123; while (start &lt;= end) &#123; int mid = (start + end) &gt;&gt; 1; if (nums[mid] &lt; target) start = mid + 1; else if (nums[mid] &gt; target) end = mid - 1; else return mid; &#125; return -1;&#125; O(n) runtime, O(1) space123456789101112131415public int[] twoSum(int[] nums, int target) &#123; int start = 0; int end = nums.length - 1; while (start &lt; end) &#123; if (nums[start] + nums[end] &lt; target) start++; else if (nums[start] + nums[end] &gt; target) end--; else return new int[] &#123;start + 1, end + 1&#125;; &#125; return null;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Problem 1 - Two Sum]]></title>
    <url>%2F2017%2F09%2F10%2FLeetCode-Problem-1-Two-Sum%2F</url>
    <content type="text"><![CDATA[Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. ExampleGiven nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Code123456789101112131415// O(n) runtime, O(n) spacepublic int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int num = nums[i]; if (map.containsKey(target - num)) return new int[] &#123;i, map.get(target - num)&#125;; map.put(num, i); &#125; return null;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】机器人的运动范围]]></title>
    <url>%2F2017%2F09%2F10%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[题目地上有一个m行n列的方格。一个机器人从坐标(0,0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格(35,37)，因为3+5+3+7=18。但它不能进入方格(35,38)。因为3+5+3+8=19.请问该机器人能够到达多少个格子？ 实现123456789101112131415161718192021222324252627282930public int movingCount(int threshold, int rows, int cols) &#123; boolean[] visited = new boolean[rows*cols]; return movingCountHelper(threshold, rows, cols, 0, 0, visited);&#125;private int movingCountHelper(int threshold, int rows, int cols, int row, int col, boolean[] visited) &#123; if (row &lt; 0 || col &lt; 0 || row &gt;= rows || col &gt;= cols || visited[row*cols+col] || getDigitSum(row) + getDigitSum(col) &gt; threshold) return 0; int count = 1; visited[row*cols+col] = true; count += movingCountHelper(threshold, rows, cols, row - 1, col, visited) + movingCountHelper(threshold, rows, cols, row + 1, col, visited) + movingCountHelper(threshold, rows, cols, row, col - 1, visited) + movingCountHelper(threshold, rows, cols, row, col + 1, visited); return count;&#125;private int getDigitSum(int num) &#123; int sum = 0; while (num != 0) &#123; sum += num % 10; num /= 10; &#125; return sum;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】矩阵中的路径]]></title>
    <url>%2F2017%2F09%2F10%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如在下面的3x4的矩阵中包含一条字符串“bcced”的路径。但矩阵中不包含字符串“abcb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 a b c es f c sa d e e 实现123456789101112131415161718192021222324252627282930313233343536373839public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; if (matrix == null || rows &lt; 1 || cols &lt; 1 || str == null) return false; boolean[] visited = new boolean[matrix.length]; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) if (hasPathHelper(matrix, rows, cols, i, j, str, 0, visited)) return true; &#125; return false;&#125;private boolean hasPathHelper(char[] matrix, int rows, int cols, int row, int col, char[] str, int strIdx, boolean[] visited) &#123; if (row &lt; 0 || col &lt; 0 || row &gt;= rows || col &gt;= cols) return false; int matrixIdx = row * cols + col; if (visited[matrixIdx] || str[strIdx] != matrix[matrixIdx]) return false; if (strIdx == str.length - 1) return true; visited[matrixIdx] = true; boolean result = hasPathHelper(matrix, rows, cols, row - 1, col, str, strIdx + 1, visited) || hasPathHelper(matrix, rows, cols, row + 1, col, str, strIdx + 1, visited) || hasPathHelper(matrix, rows, cols, row, col - 1, str, strIdx + 1, visited) || hasPathHelper(matrix, rows, cols, row, col + 1, str, strIdx + 1, visited); if (!result) visited[matrixIdx] = false; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】滑动窗口的最大值]]></title>
    <url>%2F2017%2F09%2F09%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。例如，如果输入数组{2, 3, 4, 2, 6, 2, 5, 1}及滑动窗口的大小3，那么一共存在6个滑动窗口，它们的最大值分别为{4, 4, 6, 6, 6, 5}。 实现1234567891011121314151617181920212223public ArrayList&lt;Integer&gt; maxInWindows(int[] num, int size) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (num == null || num.length &lt; 1 || size &lt; 1) return result; LinkedList&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; num.length; i++) &#123; while (!deque.isEmpty() &amp;&amp; num[i] &gt; num[deque.peekLast()]) deque.pollLast(); deque.offerLast(i); if (i - deque.peekFirst() &gt; size - 1) deque.pollFirst(); if (i &gt;= size - 1) result.add(num[deque.peekFirst()]); &#125; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】数据流中的中位数]]></title>
    <url>%2F2017%2F09%2F08%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序后中间两个数的平均值。 实现123456789101112131415161718192021222324252627private PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(5, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2.compareTo(o1); &#125;&#125;);private PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();public void Insert(Integer num) &#123; if (maxHeap.size() == minHeap.size()) maxHeap.add(num); else minHeap.add(num); if (!minHeap.isEmpty() &amp;&amp; !maxHeap.isEmpty() &amp;&amp; maxHeap.peek() &gt; minHeap.peek()) &#123; maxHeap.offer(minHeap.poll()); minHeap.offer(maxHeap.poll()); &#125;&#125;public Double GetMedian() &#123; if (maxHeap.size() &gt; minHeap.size()) return (double) maxHeap.peek(); else return (maxHeap.peek() + minHeap.peek()) / 2.0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】二叉搜索树的第k个结点]]></title>
    <url>%2F2017%2F09%2F08%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目给定一棵二叉搜索树，请找出其中的第k大的结点。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819202122232425262728private int count = 0;public TreeNode KthNode(TreeNode pRoot, int k) &#123; if (pRoot == null || k &lt; 1) return null; return KthNodeHelper(pRoot, k);&#125;private TreeNode KthNodeHelper(TreeNode root, int k) &#123; if (root == null) return null; TreeNode node = KthNodeHelper(root.left, k); if (node != null) return node; if (++count == k) return root; node = KthNodeHelper(root.right, k); if (node != null) return node; return null;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】序列化二叉树]]></title>
    <url>%2F2017%2F09%2F08%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目请实现两个函数，分别用来序列化和反序列化二叉树。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738private int idx = -1;public String Serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); if (root == null) &#123; sb.append("$,"); return sb.toString(); &#125; sb.append(root.val).append(","); sb.append(Serialize(root.left)); sb.append(Serialize(root.right)); return sb.toString();&#125;public TreeNode Deserialize(String str) &#123; if (str == null || str.length() &lt; 1) return null; String[] strs = str.split(","); return Deserialize(strs);&#125;private TreeNode Deserialize(String[] strs) &#123; idx++; TreeNode root = null; if (idx &lt; strs.length &amp;&amp; !strs[idx].equals("$")) &#123; root = new TreeNode(Integer.valueOf(strs[idx])); root.left = Deserialize(strs); root.right = Deserialize(strs); &#125; return root;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】按之字形顺序打印二叉树]]></title>
    <url>%2F2017%2F09%2F08%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); if (pRoot != null) &#123; Stack&lt;TreeNode&gt;[] stack = (Stack&lt;TreeNode&gt;[]) new Stack[2]; for (int i = 0; i &lt; 2; i++) stack[i] = new Stack&lt;&gt;(); int idx = 0; stack[idx].push(pRoot); while (!stack[idx].isEmpty()) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int start = 0; int end = stack[idx].size(); while (start++ &lt; end)&#123; TreeNode node = stack[idx].pop(); result.add(node.val); if (idx == 0) &#123; if (node.left != null) stack[1-idx].push(node.left); if (node.right != null) stack[1-idx].push(node.right); &#125; else &#123; if (node.right != null) stack[1-idx].push(node.right); if (node.left != null) stack[1-idx].push(node.left); &#125; &#125; idx = 1 - idx; results.add(result); &#125; &#125; return results;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】把二叉树打印成多行]]></title>
    <url>%2F2017%2F09%2F08%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[题目从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印到一行。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 1234567891011121314151617181920212223242526272829public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); if (pRoot != null) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(pRoot); while (!queue.isEmpty()) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int start = 0; int end = queue.size(); while (start++ &lt; end)&#123; TreeNode node = queue.poll(); result.add(node.val); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); &#125; results.add(result); &#125; &#125; return results;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】对称的二叉树]]></title>
    <url>%2F2017%2F09%2F08%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 1234567891011121314151617public boolean isSymmetrical(TreeNode pRoot) &#123; if (pRoot == null) return true; return isSymmetricalHelper(pRoot.left, pRoot.right);&#125;private boolean isSymmetricalHelper(TreeNode left, TreeNode right) &#123; if (left == null &amp;&amp; right == null) return true; else if (left == null || right == null) return false; else if (left.val != right.val) return false; return isSymmetricalHelper(left.left, right.right) &amp;&amp; isSymmetricalHelper(left.right, right.left);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】二叉树的下一个结点]]></title>
    <url>%2F2017%2F09%2F08%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。 实现12345678910public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if (pNode == null) return null; if (pNode.right != null) &#123; pNode = pNode.right; while (pNode.left != null) pNode = pNode.left; &#125; else &#123; while (pNode.next != null &amp;&amp; pNode.next.right == pNode) pNode = pNode.next; pNode = pNode.next; &#125; return pNode;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】删除链表中重复的结点]]></title>
    <url>%2F2017%2F09%2F08%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目在一个排序的链表中，如何删除重复的结点？ 实现12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 123456789101112131415161718192021222324252627public ListNode deleteDuplication(ListNode pHead) &#123; if (pHead == null) return null; ListNode current = pHead; ListNode prev = null; while (current != null &amp;&amp; current.next != null) &#123; if (current.next.val &gt; current.val) &#123; prev = current; current = current.next; &#125; else &#123; while (current.next != null &amp;&amp; current.next.val == current.val) current = current.next; current = current.next; if (prev != null) prev.next = current; else pHead = current; &#125; &#125; return pHead;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】链表中环的入口结点]]></title>
    <url>%2F2017%2F09%2F08%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目一个链表中包含环，如何找出环的入口结点？ 实现12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public ListNode EntryNodeOfLoop(ListNode pHead) &#123; ListNode node = meetingNode(pHead); if (node == null) return null; int count = countNodes(node); return findEntry(pHead, count);&#125;private ListNode meetingNode(ListNode head) &#123; if (head == null) return null; ListNode slow = head; ListNode fast = head.next; while (fast != null) &#123; if (fast == slow) return slow; if (fast.next == null) return null; slow = slow.next; fast = fast.next.next; &#125; return null;&#125;private int countNodes(ListNode node) &#123; ListNode current = node.next; int count = 1; while (current != node) &#123; count++; current = current.next; &#125; return count;&#125;private ListNode findEntry(ListNode head, int count) &#123; ListNode slow = head; ListNode fast = head; for (int i = 0; i &lt; count; i++) fast = fast.next; while (fast != slow) &#123; fast = fast.next; slow = slow.next; &#125; return slow;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】字符流中第一个不重复的字符]]></title>
    <url>%2F2017%2F09%2F07%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[题目请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符“go”时，第一个只出现一次的字符是‘g’。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是‘l’。 实现1234567891011121314151617181920212223242526272829private int[] occurrence = new int[256];private int index = 0;public void Insert(char ch) &#123; index++; int current = (int) ch; if (occurrence[current] == 0) occurrence[current] = index; else if (occurrence[current] &gt; 0) occurrence[current] = -1;&#125;public char FirstAppearingOnce() &#123; char result = '\0'; int min = Integer.MAX_VALUE; for (int i = 0; i &lt; 256; i++) &#123; if (occurrence[i] &gt; 0 &amp;&amp; occurrence[i] &lt; min) &#123; result = (char) i; min = occurrence[i]; &#125; &#125; if (result == '\0') result = '#'; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】表示数值的字符串]]></title>
    <url>%2F2017%2F09%2F07%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串“+100”、“5e2”、“-123”、“3.1416”及“-1E-16”都表示数值，但“12e”、“1a3.14”、“1.2.3”、“+-5”及“12e+5.4”都不是。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public boolean isNumeric(char[] str) &#123; if (str == null || str.length &lt; 1) return false; int idx = 0; boolean isNum = true; if (str[idx] == '+' || str[idx] == '-') idx++; idx = scanNumber(str, idx); if (idx &lt; str.length &amp;&amp; str[idx] == '.') &#123; idx++; idx = scanNumber(str, idx); if (idx &lt; str.length &amp;&amp; (str[idx] == 'e' || str[idx] == 'E')) isNum = isExponential(str, idx + 1); else if (idx &lt; str.length &amp;&amp; str[idx] != 'e' &amp;&amp; str[idx] != 'E') return false; &#125; else if (idx &lt; str.length &amp;&amp; (str[idx] == 'e' || str[idx] == 'E')) isNum = isExponential(str, idx + 1); else if (idx &lt; str.length &amp;&amp; str[idx] != '.' &amp;&amp; str[idx] != 'e' &amp;&amp; str[idx] != 'E') isNum = false; return isNum;&#125;private int scanNumber(char[] str, int idx) &#123; for(; idx &lt; str.length; idx++) &#123; if (str[idx] &lt; '0' || str[idx] &gt; '9') return idx; &#125; return idx;&#125;private boolean isExponential(char[] str, int idx) &#123; if (idx == str.length) return false; if (str[idx] == '+' || str[idx] == '-') idx++; if (idx == str.length) return false; idx = scanNumber(str, idx); if (idx &lt; str.length) return false; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】正则表达式匹配]]></title>
    <url>%2F2017%2F09%2F07%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[题目请实现一个函数用来匹配包含‘.’和‘’的正则表达式。模式中的字符‘.’表示任意一个字符，而‘’表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串“aaa”与模式“a.a”和“abaca”匹配，但与“aa.a”及“ab*a”均不匹配。 实现12345678910111213141516171819202122232425262728public boolean match(char[] str, char[] pattern) &#123; if (str == null || pattern == null) return false; return matchHelper(str, 0, pattern, 0 );&#125;private boolean matchHelper(char[] str, int strIdx, char[] pattern, int patternIdx) &#123; if (strIdx == str.length &amp;&amp; patternIdx == pattern.length) return true; if (strIdx != str.length &amp;&amp; patternIdx == pattern.length) return false; if (patternIdx + 1 &lt; pattern.length &amp;&amp; pattern[patternIdx+1] == '*') &#123; if (strIdx &lt; str.length &amp;&amp; (str[strIdx] == pattern[patternIdx] || pattern[patternIdx] == '.')) return matchHelper(str, strIdx, pattern, patternIdx + 2) || matchHelper(str , strIdx + 1, pattern, patternIdx) || matchHelper(str, strIdx + 1, pattern, patternIdx + 2); else return matchHelper(str, strIdx, pattern, patternIdx + 2); &#125; if (strIdx &lt; str.length &amp;&amp; (str[strIdx] == pattern[patternIdx] || pattern[patternIdx] == '.')) return matchHelper(str, strIdx + 1, pattern, patternIdx + 1); return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】构建乘积数组]]></title>
    <url>%2F2017%2F09%2F07%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目给定一个数组A[0, 1, … , n-1]，请构建一个数组B[0, 1, … , n-1]，其中B中的元素B[i]=A[0]xA[1]x…xA[i-1]xA[i+1]x…xA[n-1]。不能使用除法。 实现12345678910111213141516171819public int[] multiply(int[] A) &#123; int[] B = new int[A.length]; if (A == null || A.length &lt; 1) return B; B[0] = 1; int temp = 1; for (int i = 1; i &lt;= A.length - 1; i++) B[i] = A[i-1] * B[i-1]; for (int i = A.length - 2; i &gt;= 0; i--) &#123; temp *= A[i+1]; B[i] *= temp; &#125; return B;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】数组中重复的数字]]></title>
    <url>%2F2017%2F09%2F07%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3. 实现12345678910111213141516171819202122public boolean duplicate(int numbers[], int length, int[] duplication) &#123; if (numbers == null || length &lt; 1) return false; for (int i = 0; i &lt; length; i++) &#123; while (numbers[i] != i) &#123; if (numbers[i] == numbers[numbers[i]]) &#123; duplication[0] = numbers[i]; return true; &#125; swap(numbers, i, numbers[i]); &#125; &#125; return false;&#125;private void swap(int numbers[], int i, int j) &#123; numbers[i] = numbers[i] ^ numbers[j]; numbers[j] = numbers[i] ^ numbers[j]; numbers[i] = numbers[i] ^ numbers[j];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】树中两个结点的最低公共祖先]]></title>
    <url>%2F2017%2F09%2F06%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%2F</url>
    <content type="text"><![CDATA[题目输入两个树结点，求它们的最低公共祖先。这棵树是普通的树，而且树中的结点没有指向父结点的指针。 实现12345678public class TreeNode &#123; int val = 0; List&lt;TreeNode&gt; children = new ArrayList&lt;&gt;(); public TreeNode(int val) &#123; this.val = val; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public TreeNode getLastCommonParent(TreeNode root, TreeNode node1, TreeNode node2) &#123; if (root == null || node1 == null || node2 == null) return null; List&lt;TreeNode&gt; path1 = new ArrayList&lt;&gt;(); getPath(path1, root, node1); List&lt;TreeNode&gt; path2 = new ArrayList&lt;&gt;(); getPath(path2, root, node2); Iterator&lt;TreeNode&gt; iterator1 = path1.iterator(); Iterator&lt;TreeNode&gt; iterator2 = path2.iterator(); TreeNode parent = null; while (iterator1.hasNext() &amp;&amp; iterator2.hasNext()) &#123; TreeNode n1 = iterator1.next(); TreeNode n2 = iterator2.next(); if(n1 != n2) break; parent = n1; &#125; return parent;&#125;private void getPath(List&lt;TreeNode&gt; path, TreeNode root, TreeNode node) &#123; if (root == null) return; path.add(root); if (root == node) return; for (TreeNode child : root.children) &#123; getPath(path, child, node); if (path.contains(node)) break; &#125; if (!path.contains(node)) path.remove(path.size() - 1);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】把字符串转换成整数]]></title>
    <url>%2F2017%2F09%2F06%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目写一个函数StrToInt，实现把字符串转换成整数的功能。不能使用atoi或者其他类似的库函数。 实现12345678910111213141516171819202122232425262728293031323334353637private boolean isInvalid = false;public int StrToInt(String str) &#123; if (str == null || str.length() &lt; 1) &#123; isInvalid = true; return 0; &#125; char[] array = str.toCharArray(); long result = 0; boolean minus = false; int index = 0; if (array[index] == '+') index++; else if (array[index] == '-') &#123; minus = true; index++; &#125; for (; index &lt; array.length; index++) &#123; if (array[index] &lt; '0' || array[index] &gt; '9') &#123; isInvalid = true; return 0; &#125; int flag = minus ? -1 : 1; result = result * 10 + flag * (array[index] - '0'); if ((!minus &amp;&amp; result &gt; Integer.MAX_VALUE) || (minus &amp;&amp; result &lt; Integer.MIN_VALUE)) &#123; isInvalid = true; return 0; &#125; &#125; return (int)result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】不用加减乘除做加法]]></title>
    <url>%2F2017%2F09%2F06%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目写一个函数，求两个整数之和，要求在函数体内不得使用+、-、x、／四则运算符号。 实现123456789public int Add(int num1, int num2) &#123; while (num2 != 0) &#123; int sum = num1 ^ num2; num2 = (num1 &amp; num2) &lt;&lt; 1; num1 = sum; &#125; return num1;&#125; 相关问题不使用新的变量，交换两个变量的值。比如有两个变量a、b，希望交换它们的值。有两种不同的办法： 基于加减法 基于异或运算 a = a + b a = a ^ b b = a - b b = a ^ b a = a - b a = a ^ b]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】求1+2+...+n]]></title>
    <url>%2F2017%2F09%2F06%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%B1%821-2-n%2F</url>
    <content type="text"><![CDATA[题目求1+2+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 实现12345public int Sum_Solution(int n) &#123; int sum = n; boolean end = n &gt; 0 &amp;&amp; (sum += Sum_Solution(n - 1)) &gt; 0; return sum;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】圆圈中最后剩下的数字]]></title>
    <url>%2F2017%2F09%2F05%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目0, 1, …, n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。 经典的解法，用环形链表模拟圆圈12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 123456789101112131415161718192021222324252627282930public int LastRemaining_Solution(int n, int m) &#123; if (n &lt; 1 || m &lt; 1) return -1; ListNode head = new ListNode(0); ListNode tail = head; for (int i = 1; i &lt; n; i++) &#123; ListNode node = new ListNode(i); tail.next = node; tail = node; &#125; tail.next = head; ListNode current = head; ListNode prev = null; while (n &gt; 1) &#123; for (int i = 1; i &lt; m; i++) &#123; prev = current; current = current.next; &#125; prev.next = current.next; current = prev.next; n--; &#125; return current.val;&#125; 创新的解法，拿到Offer不在话下12345678910111213public int LastRemaining_Solution(int n, int m) &#123; if (n &lt; 1 || m &lt; 1) return -1; int result = 0; //f(n, m) = f'(n-1,m) = [f(n-1,m) + m] % n for (int i = 2; i &lt;= n; i++) result = (result + m) % i; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】扑克牌的顺子]]></title>
    <url>%2F2017%2F09%2F05%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%89%91%E5%85%8B%E7%89%8C%E7%9A%84%E9%A1%BA%E5%AD%90%2F</url>
    <content type="text"><![CDATA[题目从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王可以看成任意数字。 实现12345678910111213141516171819public boolean isContinuous(int[] numbers) &#123; if (numbers == null || numbers.length &lt; 1) return false; Arrays.sort(numbers); int numOfZero = 0; int numOfGap = 0; for (int i = 0; i &lt; numbers.length - 1; i++) &#123; if (numbers[i] == 0) numOfZero++; else if (numbers[i] == numbers[i+1]) return false; else numOfGap += numbers[i+1] - numbers[i] - 1; &#125; return numOfZero &gt;= numOfGap ? true : false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】n个骰子的点数]]></title>
    <url>%2F2017%2F09%2F04%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 基于递归求骰子点数，时间效率不够高12345678910111213141516171819202122232425262728public void PrintProbability(int number) &#123; if (number &lt; 1) return; int[] prob = new int[6*number-number+1]; for (int i = 1; i &lt;= 6; i++) probability(prob, number, number, i); print(prob, number);&#125;private void probability(int[] prob, int number, int current, int sum) &#123; if (current == 1) &#123; prob[sum-number]++; return; &#125; for (int i = 1; i &lt;= 6; i++) probability(prob, number, current - 1, sum + i);&#125;private void print(int[] prob, int number) &#123; double total = Math.pow(6, number); for (int i = 0; i &lt; prob.length; i++) System.out.println(i+number + ": " + prob[i] / total);&#125; 基于循环求骰子点数，时间性能好123456789101112131415161718192021222324252627282930public void PrintProbability(int number) &#123; if (number &lt; 1) return; int[][] prob = new int[2][6*number+1]; int flag = 0; for (int i = 1; i &lt;= 6; i++) prob[flag][i] = 1; //f(i,n) = f(i-1,n-1) + f(i-1,n-2) + f(i-1,n-3) + f(i-1,n-4) + f(i-1,n-5) + f(i-1,n-6) for (int i = 2; i &lt;= number; i++) &#123; flag = 1 - flag; for (int j = i; j &lt;= 6 * i; j++) &#123; for (int k = 1; k &lt;= 6 &amp;&amp; k &lt;= j; k++) prob[flag][j] += prob[1-flag][j-k]; &#125; &#125; print(prob[flag], number);&#125;private void print(int[] prob, int number) &#123; double total = Math.pow(6, number); for (int i = number; i &lt;= 6 * number; i++) System.out.println(i + ": " + prob[i] / total);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】翻转单词顺序VS左旋转字符串]]></title>
    <url>%2F2017%2F09%2F03%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8FVS%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目一输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student.”，则输出”student. a am I”。 实现123456789101112131415161718192021222324252627282930313233public String ReverseSentence(String str) &#123; if (str == null || str.length() &lt; 1) return ""; char[] result = str.toCharArray(); int start = 0; int end = 0; reverse(result, 0, result.length - 1); while (end &lt; result.length) &#123; if (result[end] == ' ') &#123; reverse(result, start, end - 1); start = ++end; &#125; else if (end == result.length - 1) reverse(result, start, end++); else end++; &#125; return String.valueOf(result);&#125;private void reverse(char[] result, int start, int end) &#123; while (start &lt; end) &#123; char tmp = result[start]; result[start] = result[end]; result[end] = tmp; start++; end--; &#125;&#125; 题目二字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如输入字符串”abcdefg”和数字2，该函数将返回左旋转2位得到的结果”cdefgab”。 实现123456789101112131415161718192021public String LeftRotateString(String str, int n) &#123; if (str == null || str.length() &lt; n) return ""; char[] result = str.toCharArray(); reverse(result, 0, n - 1); reverse(result, n, result.length - 1); reverse(result, 0, result.length - 1); return String.valueOf(result);&#125;private void reverse(char[] result, int start, int end) &#123; while (start &lt; end) &#123; char tmp = result[start]; result[start] = result[end]; result[end] = tmp; start++; end--; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】和为s的两个数字VS和为s的连续正数序列]]></title>
    <url>%2F2017%2F09%2F02%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97VS%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目一输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，输出任意一对即可。 实现1234567891011121314151617181920212223public ArrayList&lt;Integer&gt; FindNumbersWithSum(int[] array, int sum) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (array == null || array.length &lt; 2) return list; int start = 0; int end = array.length - 1; while (start &lt; end) &#123; if (array[start] + array[end] &lt; sum) start++; else if (array[start] + array[end] &gt; sum) end--; else &#123; list.add(array[start]); list.add(array[end]); return list; &#125; &#125; return list;&#125; 题目二输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。例如输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以结果打印出3个连续序列1～5、4～6和7～8。 实现1234567891011121314151617181920212223242526272829303132333435363738public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); if (sum &lt; 3) return results; int start = 1; int end = 2; int middle = (sum + 1) / 2; int current = start + end; while (start &lt; middle) &#123; if (current &lt; sum) &#123; end++; current += end; &#125; else if (current &gt; sum) &#123; current -= start; start++; &#125; else &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); findContinuousSequence(result, start, end); results.add(result); current -= start; start++; end++; current += end; &#125; &#125; return results;&#125;private void findContinuousSequence(ArrayList&lt;Integer&gt; result, int start, int end) &#123; for (int i = start; i &lt;= end; i++) result.add(i);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】数组中只出现一次的数字]]></title>
    <url>%2F2017%2F09%2F02%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目一个整形数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 实现12345678910111213141516171819202122232425262728293031323334public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) &#123; if (array == null || array.length &lt; 2) return; int result = 0; for (int i = 0; i &lt; array.length; i++) result ^= array[i]; int index = findFirstBitIsOne(result); for (int i = 0; i &lt; array.length; i++) &#123; if (isBitOne(array[i], index)) num1[0] ^= array[i]; else num2[0] ^= array[i]; &#125;&#125;private int findFirstBitIsOne(int result) &#123; int index = 0; while (index &lt; 32 &amp;&amp; (result &amp; 1) == 0) &#123; result &gt;&gt;= 1; index++; &#125; return index;&#125;private boolean isBitOne(int num, int index) &#123; num &gt;&gt;= index; return (num &amp; 1) == 1 ;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】二叉树的深度]]></title>
    <url>%2F2017%2F09%2F02%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目一输入一棵二叉树的根结点，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 123456789public int TreeDepth(TreeNode root) &#123; if (root == null) return 0; int leftDepth = TreeDepth(root.left); int rightDepth = TreeDepth(root.right); return leftDepth &gt; rightDepth ? leftDepth + 1 : rightDepth + 1;&#125; 题目二输入一棵二叉树的根结点，判断该树是不是平衡二叉树。如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 需要重复遍历结点多次的解法，简单但不足以打动面试官123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819public boolean IsBalanced_Solution(TreeNode root) &#123; if (root == null) return true; int leftDep = TreeDepth(root.left); int rightDep = TreeDepth(root.right); return IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right) &amp;&amp; Math.abs(leftDep - rightDep) &lt; 2;&#125;private int TreeDepth(TreeNode root) &#123; if (root == null) return 0; int leftDepth = TreeDepth(root.left); int rightDepth = TreeDepth(root.right); return leftDepth &gt; rightDepth ? leftDepth + 1 : rightDepth + 1;&#125; 每个结点只遍历一次的解法，正是面试官喜欢的123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819private boolean isBalanced = true;public boolean IsBalanced_Solution(TreeNode root) &#123; getDepth(root); return isBalanced;&#125;private int getDepth(TreeNode root) &#123; if (root == null) return 0; int leftDep = getDepth(root.left); int rightDep = getDepth(root.right); if (Math.abs(leftDep - rightDep) &gt; 1) isBalanced = false; return Math.max(leftDep, rightDep) + 1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】数字在排序数组中出现的次数]]></title>
    <url>%2F2017%2F09%2F02%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目统计一个数字在排序数组中出现的次数。例如输入排序数组{1, 2, 3, 3, 3, 3, 4, 5}和数字3，由于3在这个数组中出现了4次，因此输出4. 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public int GetNumberOfK(int[] array , int k) &#123; int count = 0; if (array != null || array.length &lt;1) &#123; int firstIdx = getFirstK(array, k, 0, array.length - 1); int lastIdx = getLastK(array, k, 0, array.length - 1); if (firstIdx != -1 &amp;&amp; lastIdx != -1) count = lastIdx - firstIdx + 1; &#125; return count;&#125;private int getFirstK(int[] array, int k, int start, int end) &#123; if (start &gt; end) return -1; int middle = (start + end) / 2; if (array[middle] &lt; k) return getFirstK(array, k, middle + 1, end); else if (array[middle] &gt; k) return getFirstK(array, k, start, middle - 1); else &#123; if (middle == 0 || (middle &gt; 0 &amp;&amp; array[middle - 1] != k)) return middle; else return getFirstK(array, k, start, middle - 1); &#125;&#125;private int getLastK(int[] array, int k, int start, int end) &#123; if (start &gt; end) return -1; int middle = (start + end) / 2; if (array[middle] &lt; k) return getLastK(array, k, middle + 1, end); else if (array[middle] &gt; k) return getLastK(array, k, start, middle - 1); else &#123; if (middle == array.length - 1 || (middle &lt; array.length - 1 &amp;&amp; array[middle + 1] != k)) return middle; else return getLastK(array, k, middle + 1, end); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】两个链表的第一个公共结点]]></title>
    <url>%2F2017%2F09%2F01%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目输入两个链表，找出它们的第一个公共结点。 实现12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; int firstLen = getListLength(pHead1); int secondLen = getListLength(pHead2); int diff = firstLen - secondLen; if (diff &gt; 0) pHead1 = findFirstNodeHelper(pHead1, diff); else if (diff &lt; 0) pHead2 = findFirstNodeHelper(pHead2, -diff); while (pHead1 != null &amp;&amp; pHead2 != null &amp;&amp; pHead1 != pHead2) &#123; pHead1 = pHead1.next; pHead2 = pHead2.next; &#125; return pHead1;&#125;private int getListLength(ListNode head) &#123; int count = 0; while (head != null) &#123; count++; head = head.next; &#125; return count;&#125;private ListNode findFirstNodeHelper(ListNode head, int step) &#123; while (step != 0) &#123; step--; head = head.next; &#125; return head;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】数组中的逆序对]]></title>
    <url>%2F2017%2F09%2F01%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题目在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对，输入一个数组，求出这个数组中的逆序对的总数。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public int InversePairs(int[] array) &#123; if (array == null || array.length &lt; 1) return 0; int[] aux = new int[array.length]; for (int i = 0; i &lt; array.length; i++) aux[i] = array[i]; return sortAndCount(array, aux, 0, array.length - 1);&#125;private int sortAndCount(int[] array, int[] aux, int start, int end)&#123; if (start == end) return 0; int mid = (start + end) / 2; int leftCount = sortAndCount(array, aux, start, mid); int rightCount = sortAndCount(array, aux, mid + 1, end); int splitCount = countSplitInv(array, aux, start, mid, end); return (leftCount + rightCount + splitCount) % 1000000007;&#125;private int countSplitInv(int[] array, int[] aux, int start, int mid, int end) &#123; int count = 0; int j = start; int k = mid + 1; for (int i = start; i &lt;= end; i++) &#123; if (j &gt; mid) array[i] = aux[k++]; else if (k &gt; end) array[i] = aux[j++]; else if (aux[j] &lt; aux[k]) array[i] = aux[j++]; else &#123; count += mid - j + 1; array[i] = aux[k++]; if (count &gt; 1000000007) count %= 1000000007; &#125; &#125; for (int i = start; i &lt;= end; i++) aux[i] = array[i]; return count;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】第一个只出现一次的字符]]></title>
    <url>%2F2017%2F08%2F31%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[题目在字符串中找出第一个只出现一次的字符。如输入“abaccdeff”，则输出’b’。 实现123456789101112131415161718192021222324public int FirstNotRepeatingChar(String str) &#123; if (str == null || str.length() == 0) return -1; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; Character ch = str.charAt(i); if (map.containsKey(ch)) map.put(ch, map.get(ch) + 1); else map.put(ch, 1); &#125; for (int i = 0; i &lt; str.length(); i++) &#123; Character ch = str.charAt(i); if (map.get(ch) == 1) return i; &#125; return -1;&#125; 相关题目 定义一个函数，输入两个字符串，从第一个字符串中删除在第二个字符串中出现过的所有字符。例如从第一个字符串“We are students. ”中删除在第二个字符串“aeiou”中出现过的字符得到的结果是“W r Stdnts. ”。为了解决这个问题，可以创建一个用数组实现的简单哈希表来存储第二个字符串。这样从头到尾扫描第一个字符串的每一个字符时，用O(1)时间就能判断出该字符是不是在第二个字符中。如果第一个字符串的长度是n，那么总的时间复杂度是O(n)。 定义一个函数，删除字符串中所有重复出现的字符。例如输入“google”，删除重复的字符之后的结果是“gole”。可以创建一个用布尔型数组实现的简单的哈希表。数组中的元素的意义是其下标看做ASCII码后对应的字母在字符串中是否已经出现。先把数组中所有的元素都设为false。以“google”为例，当扫描到第一个g时，g的ASCII码是103，那么把数组中下标为103的元素设为true。当扫描到第二个g时，发现数组中下标为103的元素的值是true，就知道g在前面已经出现了。也就是说，用O(1)时间就能判断出每个字符是否在前面已经出现过。如果字符串的长度是n，那么总的时间复杂度是O(n)。 在英语中，如果两个单词中出现的字母相同，并且每个字母出现的次数也相同，那么这两个单词互为变位词（Anagram）。例如silent与listen、evil与live等互为变位词。请完成一个函数，判断输入的两个字符串是不是互为变位词。可以创建一个用数组实现的简单哈希表，用来统计字符串中每个字符出现的次数。当扫描到第一个字符串中的每个字符时，为哈希表对应的项的值增加1.接下来扫描第二个字符串，扫描到每个字符时，为哈希表对应的项的值减去1.如果扫描完第二个字符串后，哈希表中所有的值都是0，那么这两个字符串就互为变位词。]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】丑数]]></title>
    <url>%2F2017%2F08%2F31%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目把只包含因子2、3和5的数称作丑数（Ugly Number）。求按从小到大的顺序的第1500个丑数。例如6、8都是丑数，但14不是，因为它包含因子7.习惯上把1当做第一个丑数。 逐个判断每个整数是不是丑数的解法，直观但不够高效123456789101112131415161718192021222324252627public int GetUglyNumber_Solution(int index) &#123; if (index &lt; 1) return 0; int number = 1; int currentIdx = 1; while (currentIdx &lt; index) &#123; if (isUglyNumber(number)) currentIdx++; number++; &#125; return number;&#125;private boolean isUglyNumber(int number) &#123; while (number % 2 == 0) number /= 2; while (number % 3 == 0) number /= 3; while (number % 5 == 0) number /= 5; return number == 1 ? true :false;&#125; 创建数组保存已经找到的丑数，用空间换时间的解法1234567891011121314151617181920212223public int GetUglyNumber_Solution(int index) &#123; if (index &lt; 1) return 0; int[] array = new int[index]; int t2 = 0; int t3 = 0; int t5 = 0; array[0] = 1; for (int i = 1; i &lt; index; i++) &#123; array[i] = Math.min(array[t2] * 2, Math.min(array[t3] * 3, array[t5] * 5)); if(array[i] == array[t2] * 2) t2++; if (array[i] == array[t3] * 3) t3++; if (array[i] == array[t5] * 5) t5++; &#125; return array[index - 1];&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】把数组排成最小的数]]></title>
    <url>%2F2017%2F08%2F31%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3, 32, 321}，则打印出这3个数字能排成的最小数字321323。 实现123456789101112131415161718192021public String PrintMinNumber(int[] numbers) &#123; StringBuilder sb = new StringBuilder(); String[] str = new String[numbers.length]; for (int i = 0; i &lt; numbers.length; i++) str[i] = String.valueOf(numbers[i]); Arrays.sort(str, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; String m = o1 + o2; String n = o2 + o1; return m.compareTo(n); &#125; &#125;); for (int i = 0; i &lt; str.length; i++) sb.append(str[i]); return sb.toString();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】从1到n整数中1出现的次数]]></title>
    <url>%2F2017%2F08%2F31%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BB%8E1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1的数字有1，10，11和12，1一共出现了5次。 不考虑时间效率的解法，靠它想拿Offer有点难123456789101112131415161718192021public int NumberOf1Between1AndN_Solution(int n) &#123; int count = 0; for (int i = 1; i &lt;= n; i++) count += NumberOf1(i); return count;&#125;private int NumberOf1(int n) &#123; int count = 0; while (n != 0) &#123; if (n % 10 == 1) count++; n /= 10; &#125; return count;&#125; 从数字规律着手明显提高时间效率的解法，能让面试官耳目一新1234567891011121314151617181920212223public int NumberOf1Between1AndN_Solution(int n) &#123; int count = 0; int index = 1; int currentN = n; while (currentN &gt; 0)&#123; int current = currentN % 10; int high = currentN / 10; int low = n - currentN * index; count += high * index; if (current &gt; 1) count += index; else if (current == 1) count += low + 1; index *= 10; currentN /= 10; &#125; return count;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】连续子数组的最大和]]></title>
    <url>%2F2017%2F08%2F30%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目输入一个整形数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。 举例分析数组的规律12345678910111213141516171819public int FindGreatestSumOfSubArray(int[] array) &#123; if (array == null || array.length &lt; 1) return 0; int max = Integer.MIN_VALUE; int sum = -1; for (int i = 0; i &lt; array.length; i++) &#123; if (sum &lt; 0) sum = array[i]; else sum += array[i]; if (sum &gt; max) max = sum; &#125; return max;&#125; 应用动态规划法123456789101112131415public int FindGreatestSumOfSubArray(int[] array) &#123; if (array == null || array.length &lt; 1) return 0; int max = Integer.MIN_VALUE; int[] s = new int[array.length]; s[0] = array[0]; for (int i = 1; i &lt; s.length; i++) &#123; s[i] = Math.max(array[i], s[i - 1] + array[i]); max = Math.max(s[i] , max); &#125; return max;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】最小的K个数]]></title>
    <url>%2F2017%2F08%2F29%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目输入n个整数，找出其中最小的k个数。例如输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4. O(n)的算法，只有当我们可以修改输入的数组时可用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] input, int k) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (input == null || input.length &lt;= 0 || k &gt; input.length || k &lt; 1) return result; int left = 0; int right = input.length - 1; int pivot = Partition(input, left, right); while (pivot != k - 1) &#123; if (pivot &lt; k - 1) &#123; left = pivot + 1; pivot = Partition(input, left, right); &#125; else &#123; right = pivot - 1; pivot = Partition(input, left, right); &#125; &#125; for (int i = 0; i &lt; k; i++) result.add(input[i]); return result;&#125;private int Partition(int[] array, int start, int end)&#123; int i = start + 1; for (int j = start + 1; j &lt;= end; j++)&#123; if (array[j] &lt; array[start]) &#123; Swap(array, i, j); i++; &#125; &#125; Swap(array, start, --i); return i;&#125;private void Swap(int[] array, int i, int j)&#123; if (i == j) return; array[i] = array[i] ^ array[j]; array[j] = array[i] ^ array[j]; array[i] = array[j] ^ array[i];&#125; O(nlogk)的算法，特别适合处理海量数据123456789101112131415161718192021222324252627public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] input, int k) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (input == null || input.length &lt;= 0 || k &gt; input.length || k &lt; 1) return result; PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(k, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2.compareTo(o1); &#125; &#125;); for (int i = 0; i &lt; input.length; i++) &#123; if (maxHeap.size() &lt; k) maxHeap.offer(input[i]); else if (input[i] &lt; maxHeap.peek()) &#123; maxHeap.poll(); maxHeap.offer(input[i]); &#125; &#125; for (Integer i : maxHeap) result.add(i); return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】数组中出现次数超过一半的数字]]></title>
    <url>%2F2017%2F08%2F28%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1，2，3，2，2，2，5，4，2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2. 基于Partition函数的O(n)算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public int MoreThanHalfNum_Solution(int[] array) &#123; if (array == null || array.length &lt;= 0) return 0; int left = 0; int right = array.length - 1; int middle = (left + right) / 2; int pivot = Partition(array, left, right); while (pivot != middle) &#123; if (pivot &lt; middle) &#123; left = pivot + 1; pivot = Partition(array, left, right); &#125; else &#123; right = pivot - 1; pivot = Partition(array, left, right); &#125; &#125; int result = array[middle]; if (!CheckMoreThanHalf(array, result)) return 0; return result;&#125;private int Partition(int[] array, int start, int end)&#123; int i = start + 1; for (int j = start + 1; j &lt;= end; j++)&#123; if (array[j] &lt; array[start]) &#123; Swap(array, i, j); i++; &#125; &#125; Swap(array, start, --i); return i;&#125;private void Swap(int[] array, int i, int j)&#123; if (i == j) return; array[i] = array[i] ^ array[j]; array[j] = array[i] ^ array[j]; array[i] = array[j] ^ array[i];&#125;private boolean CheckMoreThanHalf(int[] array, int result) &#123; int count = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (result == array[i]) count++; &#125; if (2 * count &lt;= array.length) return false; return true;&#125; 根据数组特点找出O(n)的算法12345678910111213141516171819202122232425262728293031323334353637public int MoreThanHalfNum_Solution(int[] array) &#123; if (array == null || array.length &lt;= 0) return 0; int result = array[0]; int count = 1; for (int i = 1; i &lt; array.length; i++) &#123; if (count == 0) &#123; count = 1; result = array[i]; &#125; else if (array[i] == result) count++; else count--; &#125; if (!CheckMoreThanHalf(array, result)) return 0; return result;&#125;private boolean CheckMoreThanHalf(int[] array, int result) &#123; int count = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (result == array[i]) count++; &#125; if (2 * count &lt;= array.length) return false; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】字符串的排列]]></title>
    <url>%2F2017%2F08%2F28%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。 实现1234567891011121314151617181920212223242526272829303132public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;(); HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); if (str != null &amp;&amp; str.length() != 0) &#123; Permutation(str.toCharArray(), 0, set); result.addAll(set); Collections.sort(result); &#125; return result;&#125;private void Permutation(char[] str, int pos, HashSet&lt;String&gt; result) &#123; if (pos == str.length - 1) &#123; result.add(String.valueOf(str)); return; &#125; for (int i = pos; i &lt; str.length; i++)&#123; swap(str, i, pos); Permutation(str, pos + 1, result); swap(str, pos, i); &#125;&#125;private void swap(char[] str, int i, int j) &#123; char temp = str[i]; str[i] = str[j]; str[j] = temp;&#125; 相关题目 输入一个含有8个数字的数组，判断有没有可能把这8个数字分别放到正方体的8个顶点上，使得正方体上三组相对的面上的4个顶点的和都相等。 在8x8的国际象棋上摆放8个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者同一对角线上。请问总共有多少种符合条件的摆法？]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】二叉搜索树与双向链表]]></title>
    <url>%2F2017%2F08%2F27%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 123456789101112131415161718192021222324private TreeNode last = null;public TreeNode Convert(TreeNode pRootOfTree) &#123; ConvertNode(pRootOfTree); while (last != null &amp;&amp; last.left != null) last = last.left; return last;&#125;private void ConvertNode(TreeNode root) &#123; if (root == null) return; ConvertNode(root.left); root.left = last; if (last != null) last.right = root; last = root; ConvertNode(root.right);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Demo]]></title>
    <url>%2F2017%2F06%2F15%2FReact-Demo%2F</url>
    <content type="text"><![CDATA[React makes it painless to create interactive UIs. Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes. Declarative views make your code more predictable and easier to debug. Build encapsulated components that manage their own state, then compose them to make complex UIs. Since component logic is written in JavaScript instead of templates, you can easily pass rich data through your app and keep state out of the DOM. build an interactive tic-tac-toe gameWe have three components: Square Board Game The Square component renders a single button, the Board renders 9 squares, and the Game component renders a board with some placeholders. index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;reactDemo&lt;/title&gt; &lt;script src="https://unpkg.com/react@latest/dist/react.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/react-dom@latest/dist/react-dom.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="root"&gt;&lt;/div&gt;&lt;script type="text/babel" src="index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105class Game extends React.Component&#123; render() &#123; return ( &lt;div className="game"&gt; &lt;div className="game-board"&gt; &lt;Board /&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;class Board extends React.Component &#123; constructor()&#123; super(); this.state = &#123; squares: Array(9).fill(null), xIsNext: true, &#125;; &#125; handleClick(i)&#123; const squares = this.state.squares.slice(); if (calculateWinner(squares) || squares[i]) return; squares[i] = this.state.xIsNext ? 'X' : 'O'; this.setState(&#123; squares: squares, xIsNext: !this.state.xIsNext, &#125;); &#125; renderSquare(i) &#123; return ( &lt;Square value=&#123;this.state.squares[i]&#125; onClick=&#123;() =&gt; this.handleClick(i)&#125; /&gt; ); &#125; render() &#123; const winner = calculateWinner(this.state.squares); let status; if (winner) status = 'Winner: ' + winner; else status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O'); return ( &lt;div&gt; &lt;div className="status"&gt;&#123;status&#125;&lt;/div&gt; &lt;div className="board-row"&gt; &#123;this.renderSquare(0)&#125; &#123;this.renderSquare(1)&#125; &#123;this.renderSquare(2)&#125; &lt;/div&gt; &lt;div className="board-row"&gt; &#123;this.renderSquare(3)&#125; &#123;this.renderSquare(4)&#125; &#123;this.renderSquare(5)&#125; &lt;/div&gt; &lt;div className="board-row"&gt; &#123;this.renderSquare(6)&#125; &#123;this.renderSquare(7)&#125; &#123;this.renderSquare(8)&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;function Square(props) &#123; return ( &lt;button className="square" onClick=&#123;props.onClick&#125;&gt; &#123;props.value&#125; &lt;/button&gt; );&#125;function calculateWinner(squares) &#123; const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; for (let i = 0; i &lt; lines.length; i++) &#123; const [a, b, c] = lines[i]; if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) &#123; return squares[a]; &#125; &#125; return null;&#125;ReactDOM.render( &lt;Game /&gt;, document.getElementById('root')); result]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot Demo]]></title>
    <url>%2F2017%2F06%2F07%2FSpring-Boot-Demo%2F</url>
    <content type="text"><![CDATA[Spring Boot offers a fast way to build applications. It looks at your classpath and at beans you have configured, makes reasonable assumptions about what you’re missing, and adds it. With Spring Boot you can focus more on business features and less on infrastructure. Build with Mavendirectory structure pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;springbootDemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; execute1mvn package Create a simple web applicationcreate a web controller1234567891011121314package hello;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.bind.annotation.RequestMapping;@RestControllerpublic class HelloController &#123; @RequestMapping("/") public String index() &#123; return "Greetings from Spring Boot!"; &#125;&#125; create an Application class12345678910111213package hello;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; result Add Testsmock the HTTP request cycle a simple unit test12345678910111213141516171819202122232425262728293031package hello;import static org.hamcrest.Matchers.equalTo;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.http.MediaType;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;@RunWith(SpringRunner.class)@SpringBootTest@AutoConfigureMockMvcpublic class HelloControllerTest &#123; @Autowired private MockMvc mvc; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/").accept(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().string(equalTo("Greetings from Spring Boot!"))); &#125;&#125; a very simple full-stack integration test1234567891011121314151617181920212223242526272829303132333435363738394041package hello;import static org.hamcrest.Matchers.equalTo;import static org.junit.Assert.assertThat;import java.net.URL;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.context.embedded.LocalServerPort;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.boot.test.web.client.TestRestTemplate;import org.springframework.http.ResponseEntity;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class HelloControllerIT &#123; @LocalServerPort private int port; private URL base; @Autowired private TestRestTemplate template; @Before public void setUp() throws Exception &#123; this.base = new URL("http://localhost:" + port + "/"); &#125; @Test public void getHello() throws Exception &#123; ResponseEntity&lt;String&gt; response = template.getForEntity(base.toString(), String.class); assertThat(response.getBody(), equalTo("Greetings from Spring Boot!")); &#125;&#125; result]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】复杂链表的复制]]></title>
    <url>%2F2017%2F05%2F16%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[题目请实现函数ComplexListNode Clone(ComplexListNode pHead)，复制一个复杂链表。在复杂链表中，每个结点除了有一个m_pNext指针指向下一个结点外，还有一个m_pSibling指向链表中的任意结点或者NULL。 实现123456789public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public RandomListNode Clone(RandomListNode pHead) &#123; CloneNodes(pHead); ConnectSiblingNodes(pHead); return ReconnectNodes(pHead);&#125;private void CloneNodes(RandomListNode pHead) &#123; RandomListNode node = pHead; while (node != null) &#123; RandomListNode clone = new RandomListNode(node.label); clone.next = node.next; node.next = clone; node = clone.next; &#125;&#125;private void ConnectSiblingNodes(RandomListNode pHead) &#123; RandomListNode node = pHead; while (node != null) &#123; if (node.random != null) node.next.random = node.random.next; node = node.next.next; &#125;&#125;private RandomListNode ReconnectNodes(RandomListNode pHead) &#123; RandomListNode node = pHead; RandomListNode cloneNode = null, cloneHead = null; if (node != null) &#123; cloneHead = cloneNode = node.next; node.next = cloneNode.next; node = node.next; &#125; while (node != null) &#123; cloneNode.next = node.next; cloneNode = cloneNode.next; node.next = cloneNode.next; node = node.next; &#125; return cloneHead;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】二叉树中和为某一值的路径]]></title>
    <url>%2F2017%2F05%2F16%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 123456789101112131415161718192021222324public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; paths = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; path = new ArrayList&lt;&gt;(); FindPath(root, target, 0, path, paths); return paths;&#125;private void FindPath(TreeNode root, int target, int sum, ArrayList&lt;Integer&gt; path, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; paths) &#123; if (root == null) return; int currentSum = sum + root.val; path.add(root.val); if (currentSum == target &amp;&amp; root.left == null &amp;&amp; root.right == null) paths.add(new ArrayList(path)); FindPath(root.left, target, currentSum, path, paths); FindPath(root.right, target, currentSum, path, paths); path.remove(path.size() - 1);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】二叉搜索树的后序遍历序列]]></title>
    <url>%2F2017%2F05%2F16%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。 实现12345678910111213141516171819202122232425public boolean VerifySquenceOfBST(int[] sequence) &#123; if (sequence.length == 0) return false; return VerifySquenceOfBST(sequence, 0, sequence.length - 1);&#125;private boolean VerifySquenceOfBST(int[] sequence, int start, int end)&#123; if (start &gt;= end) return true; int idx = start; for (; idx &lt; end; idx++)&#123; if (sequence[idx] &gt; sequence[end]) break; &#125; for (int i = idx + 1; i &lt; end; i++)&#123; if (sequence[i] &lt; sequence[end]) return false; &#125; return VerifySquenceOfBST(sequence, start, idx - 1) &amp;&amp; VerifySquenceOfBST(sequence, idx, end - 1);&#125; 相关题目输入一个整数数组，判断该数组是不是某二叉搜索树的前序遍历的结果。这和前面问题的后序遍历很类似，只是在前序遍历得到的序列中，第一个数字是根结点的值。]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】从上往下打印二叉树]]></title>
    <url>%2F2017%2F05%2F16%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819202122public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty())&#123; TreeNode node = queue.poll(); result.add(node.val); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); &#125; return result;&#125; 相关题目如何广度优先遍历一个有向图》这同样也可以基于队列实现。树是图的一种特殊退化形式，从上到下按层遍历二叉树，从本质上来说就是广度优先遍历二叉树。]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】栈的压入、弹出序列]]></title>
    <url>%2F2017%2F05%2F15%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1、2、3、4、5是某栈的压栈序列，序列4、5、3、2、1是该压栈序列对应的一个弹出序列，但4、3、5、1、2就不可能是该压栈序列的弹出序列。 实现12345678910111213141516public boolean IsPopOrder(int[] pushA, int[] popA) &#123; int popPos = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; pushA.length; i++)&#123; if (stack.isEmpty() || stack.peek() != popA[popPos]) stack.push(pushA[i]); while (!stack.isEmpty() &amp;&amp; stack.peek() == popA[popPos])&#123; stack.pop(); popPos++; &#125; &#125; return stack.isEmpty();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】包含min函数的栈]]></title>
    <url>%2F2017%2F05%2F15%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[题目定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O(1)。 实现123456789101112131415161718192021222324Stack&lt;Integer&gt; data = new Stack&lt;&gt;();Stack&lt;Integer&gt; min = new Stack&lt;&gt;();public void push(int node) &#123; data.push(node); if (min.size() == 0 || node &lt; min.peek()) min.push(node); else min.push(min.peek());&#125;public void pop() &#123; data.pop(); min.pop();&#125;public int top() &#123; return data.peek();&#125;public int min() &#123; return min.peek();&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】顺时针打印矩阵]]></title>
    <url>%2F2017%2F05%2F14%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 实现1234567891011121314151617181920212223242526272829303132333435363738public ArrayList&lt;Integer&gt; printMatrix(int[][] matrix) &#123; int rows = matrix.length; int columns = matrix[0].length; int start = 0; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); while (2 * start &lt; rows &amp;&amp; 2 * start &lt; columns)&#123; printMatrixInCircle(result, matrix, start); start++; &#125; return result;&#125;private void printMatrixInCircle(ArrayList&lt;Integer&gt; result, int[][] matrix, int start)&#123; int rows = matrix.length; int columns = matrix[0].length; int endX = columns - start - 1; int endY = rows - start - 1; for (int i = start; i &lt;= endX; i++) result.add(matrix[start][i]); if (start &lt; endY)&#123; for (int i = start + 1; i &lt;= endY; i++) result.add(matrix[i][endX]); &#125; if (start &lt; endX &amp;&amp; start &lt; endY)&#123; for (int i = endX - 1; i &gt;= start; i--) result.add(matrix[endY][i]); &#125; if (start &lt; endY - 1 &amp;&amp; start &lt; endX)&#123; for (int i = endY - 1; i &gt; start; i--) result.add(matrix[i][start]); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】二叉树的镜像]]></title>
    <url>%2F2017%2F05%2F14%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[题目请完成一个函数，输入一个二叉树，该函数输出它的镜像。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213public void Mirror(TreeNode root) &#123; if (root == null) return; else if (root.left == null &amp;&amp; root.right == null) return; TreeNode tmp = root.left; root.left = root.right; root.right = tmp; Mirror(root.left); Mirror(root.right);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】树的子结构]]></title>
    <url>%2F2017%2F05%2F14%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[题目输入两棵二叉树A和B，判断B是不是A的子结构。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 123456789101112131415161718192021222324252627public boolean HasSubtree(TreeNode root1, TreeNode root2) &#123; boolean result = false; if (root1 != null &amp;&amp; root2 != null)&#123; if (root1.val == root2.val) result = DoesTree1HasTree2(root1, root2); if (result == false) result = HasSubtree(root1.left, root2); if (result == false) result = HasSubtree(root1.right, root2); &#125; return result;&#125;private boolean DoesTree1HasTree2(TreeNode root1, TreeNode root2)&#123; if (root2 == null) return true; else if (root1 == null) return false; else if (root1.val != root2.val) return false; return DoesTree1HasTree2(root1.left, root2.left) &amp;&amp; DoesTree1HasTree2(root1.right, root2.right);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】合并两个排序的链表]]></title>
    <url>%2F2017%2F05%2F14%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。 实现12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819public ListNode Merge(ListNode list1, ListNode list2) &#123; if (list1 == null) return list2; else if (list2 == null) return list1; ListNode head = null; if (list1.val &lt; list2.val)&#123; head = list1; head.next = Merge(list1.next, list2); &#125; else &#123; head = list2; head.next = Merge(list1, list2.next); &#125; return head;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】反转链表]]></title>
    <url>%2F2017%2F05%2F14%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。 实现12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 123456789101112131415161718public ListNode ReverseList(ListNode head) &#123; ListNode current = head; ListNode previous = null; ListNode tail = null; while (current != null)&#123; ListNode next = current.next; if (next == null) tail = current; current.next = previous; previous = current; current = next; &#125; return tail;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】链表中倒数第k个结点]]></title>
    <url>%2F2017%2F05%2F14%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目输入一个链表，输出该链表中倒数第k个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是值为4的结点。 实现12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 123456789101112131415161718192021public ListNode FindKthToTail(ListNode head, int k) &#123; if (k == 0 || head == null) return null; ListNode ahead = head; ListNode behind = head; for (int i = 1; i &lt; k; i++) &#123; if (ahead.next == null) return null; ahead = ahead.next; &#125; while (ahead.next != null)&#123; ahead = ahead.next; behind = behind.next; &#125; return behind;&#125; 相关题目 求链表的中间结点。如果链表中结点总数为奇数，返回中间结点；如果结点总数是偶数，返回中间两个结点的任意一个。我们也可以定义两个指针，同时从链表的头结点出发，一个指针一次走一步，另一个指针一次走两步。当走得快的指针走到链表的末尾时，走得慢的指针正好在链表的中间。 判断一个单向链表是否形成了环形结构。定义两个指针，同时从链表的头结点出发，一个指针一次走一步，另一个指针一次走两步。如果走得快的指针追上了走得慢的指针，那么链表就是环形链表；如果走得快的指针走到了链表的末尾都没有追上第一个指针，那么链表就不是环形链表。]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】调整数组顺序使奇数位于偶数前面]]></title>
    <url>%2F2017%2F05%2F13%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[题目输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 只完成基本功能的解法，仅适用于初级程序员123456789101112131415161718public void reOrderArray(int[] array) &#123; int begin = 0; int end = array.length - 1; while (begin &lt; end)&#123; while (begin &lt; end &amp;&amp; (array[begin] &amp; 1) == 1) begin++; while (begin &lt; end &amp;&amp; (array[end] &amp; 1) != 1) end--; if (begin &lt; end)&#123; int tmp = array[end]; array[end] = array[begin]; array[begin] = tmp; &#125; &#125;&#125; 考虑可扩展性的解法，能秒杀Offer12345678910111213141516171819202122public void reOrderArray(int[] array) &#123; int begin = 0; int end = array.length - 1; while (begin &lt; end)&#123; while (begin &lt; end &amp;&amp; isOdd(array[begin])) begin++; while (begin &lt; end &amp;&amp; !isOdd(array[end])) end--; if (begin &lt; end)&#123; int tmp = array[end]; array[end] = array[begin]; array[begin] = tmp; &#125; &#125;&#125;private boolean isOdd(int n)&#123; return (n &amp; 1) == 1;&#125; 本题扩展输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 实现12345678910111213141516171819202122232425public void reOrderArray(int[] array) &#123; int[] aux = new int[array.length]; int countOdd = 0; for (int i = 0; i &lt; array.length; i++) &#123; aux[i] = array[i]; if (isOdd(array[i])) countOdd++; &#125; int oddPos = 0; int evenPos = countOdd; for (int i = 0; i &lt; aux.length; i++)&#123; if (isOdd(aux[i])) array[oddPos++] = aux[i]; else array[evenPos++] = aux[i]; &#125;&#125;private boolean isOdd(int n)&#123; return (n &amp; 1) == 1;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】在O(1)时间删除链表结点]]></title>
    <url>%2F2017%2F05%2F13%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%9C%A8O-1-%E6%97%B6%E9%97%B4%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。 实现12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 1234567891011121314public void deleteNode(ListNode head, ListNode node)&#123; if (node.next != null)&#123; node.val = node.next.val; node.next = node.next.next; &#125; else if (head == node) head = null; else &#123; while (head.next != node) head = head.next; head.next = null; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】打印1到最大的n位数]]></title>
    <url>%2F2017%2F05%2F13%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%89%93%E5%8D%B01%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目输入数字n，按顺序打印出从1到最大的n为十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。 跳进面试官的陷阱123456public void Print1ToMaxOfNDigits(int n) &#123; int number = (int) Math.pow(10, n); for (int i = 1; i &lt; number; i++) System.out.println(i);&#125; 在字符串上模拟数字加法的解法，绕过陷阱才能拿到Offer123456789101112131415161718192021222324252627282930313233343536373839404142434445public void Print1ToMaxOfNDigits(int n) &#123; char[] number = new char[n]; Arrays.fill(number, '0'); while (!Increment(number))&#123; PrintNumber(number); System.out.println(); &#125;&#125;private boolean Increment(char[] number)&#123; int carry = 0; for (int i = number.length - 1; i &gt;= 0; i--)&#123; int sum = number[i] - '0' + carry; if (i == number.length - 1) sum++; carry = sum / 10; if (carry == 1)&#123; if (i == 0) return true; number[i] = (char) (sum % 10 + '0'); &#125; else number[i] = (char) (sum + '0'); &#125; return false;&#125;private void PrintNumber(char[] number)&#123; boolean isBeginning0 = true; for (int i = 0; i &lt; number.length; i++)&#123; if (isBeginning0 == true &amp;&amp; number[i] != '0') isBeginning0 = false; if (isBeginning0 == false) System.out.print(number[i]); &#125;&#125; 把问题转换成数字排列的解法，递归让代码更简洁123456789101112131415161718192021222324252627282930313233343536public void Print1ToMaxOfNDigits(int n) &#123; char[] number = new char[n]; Arrays.fill(number, '0'); for (int i = 0; i &lt;= 9; i++)&#123; number[0] = (char) (i + '0'); Print1ToMaxOfNDigits(number, 0); &#125;&#125;private void Print1ToMaxOfNDigits(char[] number, int index)&#123; if (index == number.length - 1)&#123; PrintNumber(number); return; &#125; for (int i = 0; i &lt;= 9; i++) &#123; number[index+1] = (char) (i + '0'); Print1ToMaxOfNDigits(number, index + 1); &#125;&#125;private void PrintNumber(char[] number)&#123; boolean isBeginning0 = true; for (int i = 0; i &lt; number.length; i++)&#123; if (isBeginning0 == true &amp;&amp; number[i] != '0') isBeginning0 = false; if (isBeginning0 == false) System.out.print(number[i]); &#125; if (isBeginning0 == false) System.out.println();&#125; 相关题目定义一个函数，在该函数中可以实现任意两个整数的加法。由于没有限定输入两个数的大小范围，我们也要把它当做大数问题来处理。]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】数值的整数次方]]></title>
    <url>%2F2017%2F05%2F12%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%2F</url>
    <content type="text"><![CDATA[题目实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 自以为题目简单的解法1234567891011public double Power(double base, int exponent) &#123; double result = 1; for (int i = 1; i &lt;= Math.abs(exponent); i++) result *= base; if (exponent &lt; 0) result = 1 / result; return result;&#125; 全面又高效的解法，确保我们能拿到Offer123456789101112131415161718public double Power(double base, int exponent) &#123; if (exponent == 1) return base; else if (exponent == 0) return 1; double result = Power(base, Math.abs(exponent) &gt;&gt; 1); result *= result; if ((exponent &amp; 1) == 1) result *= base; if (exponent &lt; 0) result = 1 / result; return result;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】二进制中1的个数]]></title>
    <url>%2F2017%2F05%2F12%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。 可能引起死循环的解法123456789101112public int NumberOf1(int n) &#123; int count = 0; while (n != 0)&#123; if ((n &amp; 1) == 1) count++; n = n &gt;&gt; 1; &#125; return count;&#125; 常规解法12345678910111213public int NumberOf1(int n) &#123; int count = 0; int flag = 1; while (flag != 0)&#123; if ((n &amp; flag) == flag) count++; flag = flag &lt;&lt; 1; &#125; return count;&#125; 能给面试官带来惊喜的解法12345678910public int NumberOf1(int n) &#123; int count = 0; while (n != 0)&#123; count++; n = n &amp; (n - 1); &#125; return count;&#125; 相关题目 用一条语句判断一个整数是不是2的整数次方。一个整数如果是2的整数次方，那么它的二进制表示中有且只有一位是1，而其他所有位都是0.根据前面的分析，把这个整数减去1之后再和它自己做与运算，这个整数中唯一的1就会变成0. 输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n。比如10的二进制表示为1010，13的二进制表示为1101，需要改变1010中的3位才能得到1101.我们可以分为两步解决这个问题：第一步求这两个数的异或，第二步统计异或结果中1的位数。]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】斐波那契数列]]></title>
    <url>%2F2017%2F05%2F12%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。 效率很低的解法，挑剔的面试官不会喜欢123456public int Fibonacci(int n) &#123; if (n == 0 || n == 1) return n; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125; 面试官期待的实用解法123456789101112131415public static int Fibonacci(int n) &#123; if (n == 0 || n == 1) return n; int fib1 = 0; int fib2 = 1; for (int i = 2; i &lt;= n; i++)&#123; int current = fib1 + fib2; fib1 = fib2; fib2 = current; &#125; return fib2;&#125; 时间复杂度O(logn)但不够实用的解法相关题目跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 实现123456public int JumpFloor(int target) &#123; if (target == 1 || target == 2) return target; return JumpFloor(target - 1) + JumpFloor(target - 2);&#125; 变态跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。此时该青蛙跳上一个n级的台阶总共有多少种跳法？ 实现123456public int JumpFloorII(int target) &#123; if (target == 0 || target == 1) return 1; return 2 * JumpFloorII(target - 1);&#125; 矩形覆盖我们可以用2x1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2x1的小矩形无重叠地覆盖一个2xn的大矩形，总共有多少种方法？ 实现123456public int RectCover(int target) &#123; if (target == 0 || target == 1 || target == 2) return target; return RectCover(target - 1) + RectCover(target - 2);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】旋转数组的最小数字]]></title>
    <url>%2F2017%2F05%2F12%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 实现1234567891011121314151617181920212223242526272829303132public int minNumberInRotateArray(int[] array) &#123; int left = 0; int right = array.length - 1; int mid = left; while (array[left] &gt;= array[right])&#123; if (right - left == 1) &#123; mid = right; break; &#125; mid = (left + right) / 2; if (array[mid] == array[left] &amp;&amp; array[mid] == array[right]) return minInOrder(array, left, right); else if (array[mid] &gt;= array[left]) left = mid; else if (array[mid] &lt;= array[right]) right = mid; &#125; return array[mid];&#125;private int minInOrder(int[] array, int left, int right)&#123; int min = array[left]; for (int i = left + 1; i &lt;= right; i++) min = Math.min(min, array[i]); return min;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】用两个栈实现队列]]></title>
    <url>%2F2017%2F05%2F11%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目用两个栈实现一个队列。分别完成在队列尾部插入结点和在队列头部删除结点的功能。 实现123456789101112131415Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();public void push(int node) &#123; stack1.push(node);&#125;public int pop() &#123; if (stack2.isEmpty())&#123; while (!stack1.isEmpty()) stack2.push(stack1.pop()); &#125; return stack2.pop();&#125; 相关题目用两个队列实现一个栈。]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】重建二叉树]]></title>
    <url>%2F2017%2F05%2F11%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出二叉树并输出它的头结点。 实现123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; return reConstructBinaryTree(pre, in, 0, pre.length - 1, 0, in.length - 1);&#125;private TreeNode reConstructBinaryTree(int[] pre, int[] in, int startPreorder, int endPreorder, int startInorder, int endInorder)&#123; if (startPreorder &gt; endPreorder || startInorder &gt; endInorder) return null; TreeNode node = new TreeNode(pre[startPreorder]); for (int i = startInorder; i &lt;= endInorder; i++)&#123; if (in[i] == pre[startPreorder])&#123; int leftLength = i - startInorder; node.left = reConstructBinaryTree(pre, in, startPreorder + 1, startPreorder + leftLength, startInorder, i - 1); node.right = reConstructBinaryTree(pre, in, startPreorder + leftLength + 1, endPreorder, i + 1, endInorder); break; &#125; &#125; return node;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】从尾到头打印链表]]></title>
    <url>%2F2017%2F05%2F11%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目输入一个链表的头结点，从尾到头反过来打印出每个结点的值。 实现12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 12345678910ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; if (listNode != null)&#123; printListFromTailToHead(listNode.next); list.add(listNode.val); &#125; return list;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】替换空格]]></title>
    <url>%2F2017%2F05%2F10%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题目请实现一个函数，把字符串中的每个空格替换成“%20”。例如输入“We are happy.”，则输出“We%20are%20happy.“。 时间复杂度为O(n^2)的解法，不足以拿到Offer时间复杂度为O(n)的解法，搞定Offer就靠它了123456789101112131415161718192021222324252627282930public String replaceSpace(StringBuffer str) &#123; int originalLength = str.length(); int numberOfBlank = 0; for (int i = 0; i &lt; originalLength; i++)&#123; if (str.charAt(i) == ' ') numberOfBlank++; &#125; int newLength = originalLength + 2 * numberOfBlank; str.setLength(newLength); int indexOfOriginal = originalLength - 1; int indexOfNew = newLength - 1; while (indexOfNew &gt; indexOfOriginal)&#123; if (str.charAt(indexOfOriginal) == ' ')&#123; str.setCharAt(indexOfNew, '0'); str.setCharAt(--indexOfNew, '2'); str.setCharAt(--indexOfNew, '%'); &#125; else str.setCharAt(indexOfNew, str.charAt(indexOfOriginal)); indexOfNew--; indexOfOriginal--; &#125; return str.toString();&#125; 相关题目有两个排序的数组A1和A2，内存在A1的末尾有足够多的空余空间容纳A2。请实现一个函数，把A2中的所有数字插入到A1中并且所有的数字是排序的。]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】二维数组中的查找]]></title>
    <url>%2F2017%2F05%2F10%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 实现123456789101112131415public boolean Find(int target, int[][] array) &#123; int rows = 0; int columns = array[0].length - 1; while (rows &lt; array.length &amp;&amp; columns &gt;= 0)&#123; if (array[rows][columns] &lt; target) rows++; else if (array[rows][columns] &gt; target) columns--; else return true; &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指Offer】实现Singleton模式]]></title>
    <url>%2F2017%2F05%2F09%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%AE%9E%E7%8E%B0Singleton%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[题目设计一个类，我们只能生成该类的一个实例。 不好的解法一：只适用于单线程环境1234567891011121314public class Singleton1&#123; private static Singleton1 instance = null; private Singleton1()&#123; &#125; public static Singleton1 getInstance()&#123; if (instance == null) instance = new Singleton1(); return instance; &#125;&#125; 不好的解法二：虽然在多线程环境中能工作但效率不高1234567891011121314public class Singleton2&#123; private static Singleton2 instance = null; private Singleton2()&#123; &#125; public static synchronized Singleton2 getInstance()&#123; if (instance == null) instance = new Singleton2(); return instance; &#125;&#125; 可行的解法：加同步锁前后两次判断实例是否已存在123456789101112131415161718public class Singleton3&#123; private static Singleton3 instance = null; private Singleton3()&#123; &#125; public static Singleton3 getInstance()&#123; if (instance == null)&#123; synchronized (Singleton3.class)&#123; if (instance == null) instance = new Singleton3(); &#125; &#125; return instance; &#125;&#125; 强烈推荐的解法一：利用静态构造函数1234567891011public class Singleton4&#123; private static Singleton4 instance = new Singleton4(); private Singleton4()&#123; &#125; public static Singleton4 getInstance()&#123; return instance; &#125;&#125; 强烈推荐的解法二：实现按需创建实例12345678910111213public class Singleton5&#123; private Singleton5()&#123; &#125; public static Singleton5 getInstance()&#123; return Nested.instance; &#125; private static class Nested&#123; private static Singleton5 instance = new Singleton5(); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】图]]></title>
    <url>%2F2017%2F04%2F16%2F%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[union-find算法动态连通性 quick-find算法示意 实现123456789101112131415161718public void union(int p, int q)&#123; int pID = find(p); int qID = find(q); if (pID == qID) return; for (int i = 0; i &lt; id.length; i++)&#123; if (id[i] == pID) id[i] = qID; &#125; count--;&#125;public int find(int p)&#123; return id[p];&#125; 特点在quick-find算法中，每次find调用只需要访问数组一次，而归并两个分量的union操作访问数组的次数在N+3到2N+1之间。 quick-union算法示意 实现123456789101112131415161718public void union(int p, int q)&#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; id[pRoot] = qRoot; count--;&#125;public int find(int p)&#123; while (id[p] != p) p = id[p]; return id[p];&#125; 特点 quick-union算法中的find方法访问数组的次数为1加上给定触点所对应的节点的深度的两倍。union和connected访问数组的次数为两次find操作（如果union中给定的两个触点分别在不同的树中则还需要加1）。 加权quick-union算法记录每一棵树的大小并总是将较小的树连接到较大的树上。 示意 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class UnionFind &#123; private int[] id; private int[] size; private int count; public UnionFind(int n)&#123; count = n; id = new int[n]; size = new int[n]; for (int i = 0; i &lt; n; i++)&#123; id[i] = i; size[i] = 1; &#125; &#125; public int count()&#123; return count; &#125; public boolean connected(int p, int q)&#123; return find(p) == find(q); &#125; public void union(int p, int q)&#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; if (size[pRoot] &lt; size[qRoot])&#123; id[pRoot] = qRoot; size[qRoot] += size[pRoot]; &#125; else&#123; id[qRoot] = pRoot; size[pRoot] += size[qRoot]; &#125; count--; &#125; public int find(int p)&#123; while (id[p] != p) p = id[p]; return id[p]; &#125;&#125; 特点对于N个触点，加权quick-union算法构造的森林中的任意节点的深度最多为lgN。 对于加权quick-union算法和N个触点，在最坏情况下find、connected和union的成本的增长数量级为lgN。 总结 无向图深度优先搜索要搜索一幅图，只需用一个递归方法来遍历所有顶点。在访问其中一个顶点时： 将它标记为已访问 递归地访问它的所有没有被标记过的邻居顶点 如果图是连通的，每个连接链表中的元素都会被检查到。 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142public class DepthFirstPaths &#123; private final int s; private boolean[] marked; private int[] edgeTo; public DepthFirstPaths(Graph g, int s)&#123; this.s = s; marked = new boolean[g.V()]; edgeTo = new int[g.V()]; dfs(g, s); &#125; private void dfs(Graph g, int v)&#123; marked[v] = true; for (int w : g.adj(v))&#123; if (marked[w] == false)&#123; edgeTo[w] = v; dfs(g, w); &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return marked[v]; &#125; public Iterable&lt;Integer&gt; pathTo(int v)&#123; if (!hasPathTo(v)) return null; Stack&lt;Integer&gt; path = new Stack&lt;Integer&gt;(); path.push(v); while (v != s)&#123; path.push(edgeTo[v]); v = edgeTo[v]; &#125; return path; &#125;&#125; 特点深度优先搜索标记与起点连通的所有顶点所需的时间和顶点的度数之和成正比。 使用深度优先搜索得到从给定起点到任意标记顶点的路径所需的时间与路径的长度成正比。 单点路径：给定一幅图和一个起点s，回答“从s到给定目的顶点v是否存在一条路径？如果有，找出这条路径。”等类似问题。 广度优先搜索使用一个队列来保存所有已经被标记过但其邻接表还未被检查过的顶点。先将起点加入队列，然后重复以下步骤直到队列为空： 取队列中的下一个顶点v并标记它 将与v相邻的所有未被标记过的顶点加入队列 示意 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class BreadthFirstPaths &#123; private final int s; private boolean[] marked; private int[] edgeTo; public BreadthFirstPaths(Graph g, int s)&#123; this.s = s; marked = new boolean[g.V()]; edgeTo = new int[g.V()]; bfs(g, s); &#125; private void bfs(Graph g, int s)&#123; Queue&lt;Integer&gt; queue = new Queue&lt;Integer&gt;(); marked[s] = true; queue.enqueue(s); while(!queue.isEmpty())&#123; int v = queue.dequeue(); for (int w : g.adj(v))&#123; if (marked[w] == false)&#123; marked[w] = true; queue.enqueue(w); edgeTo[w] = v; &#125; &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return marked[v]; &#125; public Iterable&lt;Integer&gt; pathTo(int v)&#123; if (!hasPathTo(v)) return null; Stack&lt;Integer&gt; path = new Stack&lt;Integer&gt;(); path.push(v); while (v != s)&#123; path.push(edgeTo[v]); v = edgeTo[v]; &#125; return path; &#125;&#125; 特点对于从s可达的任意顶点v，广度优先搜索都能找到一条从s到v的最短路径（没有其他从s到v的路径所含的边比这条路径更少）。 广度优先搜索所需的时间在最坏情况下和V+E成正比。 单点最短路径：给定一幅图和一个起点s，回答“从s到给定目的顶点v是否存在一条路径？如果有，找出其中最短的那条（所含边数最少）。”等类似问题。 比较在搜索中都会先将起点存入数据结构中，然后重复以下步骤直到数据结构被清空： 取其中的下一个顶点并标记它 将v的所有相邻而又未被标记的顶点加入数据结构 这两个算法的不同之处仅在于从数据结构中获取下一个顶点的规则（对于广度优先搜索来说是最早加入的顶点，对于深度优先搜索来说是最晚加入的顶点）。 连通分量深度优先搜索的直接应用是找出一幅图的所有连通分量。它能够将所有顶点切分为等价类。 示意 实现12345678910111213141516171819202122232425262728293031323334353637383940public class ConnectedComponents &#123; private int count; private boolean[] marked; private int[] id; public ConnectedComponents(Graph g)&#123; count = 0; marked = new boolean[g.V()]; id = new int[g.V()]; for (int s = 0; s &lt; g.V(); s++)&#123; if (marked[s] == false)&#123; dfs(g, s); count++; &#125; &#125; &#125; private void dfs(Graph g, int v)&#123; marked[v] = true; id[v] = count; for (int w : g.adj(v))&#123; if (marked[w] == false) dfs(g, w); &#125; &#125; public boolean connected(int v, int w)&#123; return id[v] == id[w]; &#125; public int id(int v)&#123; return id[v]; &#125; public int count()&#123; return count; &#125;&#125; 特点深度优先搜索的预处理使用的时间和空间与V+E成正比且可以在常数时间内处理关于图的连通性查询。 比较union-find算法其实更快，因为它不需要完整地构造并表示一幅图，是一种动态算法（在任何时候都能用接近常数的时间检查两个顶点是否连通，甚至是在添加一条边的时候），但深度优先搜索则必须要对图进行预处理。因此，在完成只需要判断连通性或是需要完成有大量连通性查询和插入操作混合等类似的任务时，更倾向使用union-find算法，而深度优先搜索则更适合实现图的抽象数据类型，因为它能更有效地利用已有的数据结构。 检测环给定的图是无环图吗？ 实现1234567891011121314151617181920212223242526272829public class Cycle &#123; private boolean[] marked; private boolean hasCycle; public Cycle(Graph g)&#123; marked = new boolean[g.V()]; hasCycle = false; for (int s = 0; s &lt; g.V(); s++)&#123; if (marked[s] == false) dfs(g, s, s); &#125; &#125; private void dfs(Graph g, int v, int p)&#123; marked[v] = true; for (int w : g.adj(v))&#123; if (marked[w] == false) dfs(g, w, v); else if (w != p) hasCycle = true; &#125; &#125; public boolean hasCycle()&#123; return hasCycle; &#125;&#125; 双色问题能够用两种颜色将图的所有顶点着色，使得任意一条边的两个端点的颜色都不相同吗？（这是一幅二分图吗？） 实现123456789101112131415161718192021222324252627282930313233public class TwoColor &#123; private boolean[] marked; private boolean[] color; private boolean isTwoColorable; public TwoColor(Graph g)&#123; marked = new boolean[g.V()]; color = new boolean[g.V()]; isTwoColorable = true; for (int s = 0; s &lt; g.V(); s++)&#123; if (marked[s] == false) dfs(g, s); &#125; &#125; private void dfs(Graph g, int v)&#123; marked[v] = true; for (int w : g.adj(v))&#123; if (marked[w] == false)&#123; color[w] = !color[v]; dfs(g, w); &#125; else if (color[w] == color[v]) isTwoColorable = false; &#125; &#125; public boolean isBipartite()&#123; return isTwoColorable; &#125;&#125; 有向图深度优先搜索实现123456789101112131415161718192021222324252627282930313233343536373839404142public class DepthFirstDirectedPaths &#123; private final int s; private boolean[] marked; private int[] edgeTo; public DepthFirstDirectedPaths(Digraph g, int s)&#123; this.s = s; marked = new boolean[g.V()]; edgeTo = new int[g.V()]; dfs(g, s); &#125; private void dfs(Digraph g, int v)&#123; marked[v] = true; for (int w : g.adj(v))&#123; if (marked[w] == false)&#123; edgeTo[w] = v; dfs(g, w); &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return marked[v]; &#125; public Iterable&lt;Integer&gt; pathTo(int v)&#123; if (!hasPathTo(v)) return null; Stack&lt;Integer&gt; path = new Stack&lt;Integer&gt;(); path.push(v); while (v != s)&#123; path.push(edgeTo[v]); v = edgeTo[v]; &#125; return path; &#125;&#125; 特点在有向图中，深度优先搜索标记由一个集合的顶点可达的所有顶点所需的时间与被标记的所有顶点的出度之和成正比。 单向有向路径给定一幅有向图和一个起点s，回答“从s到给定目的顶点v是否存在一条有向路径？如果有，找出这条路径。”等类似问题。 广度优先搜索实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class BreadthFirstDirectedPaths &#123; private final int s; private boolean[] marked; private int[] edgeTo; public BreadthFirstDirectedPaths(Digraph g, int s)&#123; this.s = s; marked = new boolean[g.V()]; edgeTo = new int[g.V()]; bfs(g, s); &#125; private void bfs(Digraph g, int v)&#123; Queue&lt;Integer&gt; queue = new Queue&lt;Integer&gt;(); marked[v] = true; queue.enqueue(v); while (!queue.isEmpty())&#123; int x = queue.dequeue(); for (int w : g.adj(x))&#123; if (marked[w] == false)&#123; marked[w] = true; edgeTo[w] = x; queue.enqueue(w); &#125; &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return marked[v]; &#125; public Iterable&lt;Integer&gt; pathTo(int v)&#123; if (!hasPathTo(v)) return null; Stack&lt;Integer&gt; path = new Stack&lt;Integer&gt;(); path.push(v); while (v != s)&#123; path.push(edgeTo[v]); v = edgeTo[v]; &#125; return path; &#125;&#125; 特点单点最短有向路径给定一幅有向图和一个起点s，回答“从s到给定目的顶点v是否存在一条有向路径？如果有，找出其中最短的那条（所含边数最少）。”等类似问题。 有向环检测给定的有向图中包含有向环吗？如果有，按照路径的方向从某个顶点并返回自己来找到环上的所有顶点。 定义有向无环图（DAG）就是一幅不含有环的有向图。 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class DirectedCycle &#123; private boolean[] marked; private int[] edgeTo; private boolean[] onStack; private Stack&lt;Integer&gt; cycle; public DirectedCycle(Digraph g)&#123; marked = new boolean[g.V()]; edgeTo = new int[g.V()]; onStack = new boolean[g.V()]; for (int v = 0; v &lt; g.V(); v++)&#123; if (marked[v] == false) dfs(g, v); &#125; &#125; private void dfs(Digraph g, int v)&#123; marked[v] = true; onStack[v] = true; for (int w : g.adj(v))&#123; if (hasCycle()) return; else if (marked[w] == false)&#123; edgeTo[w] = v; dfs(g, w); &#125; else if (onStack[w] == true)&#123; cycle = new Stack&lt;Integer&gt;(); int x = v; cycle.push(x); while (x != w)&#123; cycle.push(edgeTo[x]); x = edgeTo[x]; &#125; cycle.push(v); &#125; &#125; onStack[v] = false; &#125; public boolean hasCycle()&#123; return cycle != null; &#125; public Iterable&lt;Integer&gt; cycle()&#123; return cycle; &#125;&#125; 拓扑排序给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素（或者说明无法做到这一点）。 定义当且仅当一幅有向图是无环图时它才能进行拓扑排序。 一幅有向无环图的拓扑排序即为所有顶点的逆后序排列。 基于深度优先搜索的顶点排序将dfs的参数顶点保存在一个数据结构中，遍历这个数据结构实际上就能访问图中的所有顶点。顶点有以下三种排列顺序： 前序：在递归调用之前将顶点加入队列 后序：在递归调用之后将顶点加入队列 逆后序：在递归调用之后将顶点压入栈 示意 实现12345678910111213141516171819202122232425262728293031323334353637383940414243public class DepthFirstOrder &#123; private boolean[] marked; private Queue&lt;Integer&gt; pre; private Queue&lt;Integer&gt; post; private Stack&lt;Integer&gt; reversePost; public DepthFirstOrder(Digraph g)&#123; marked = new boolean[g.V()]; pre = new Queue&lt;Integer&gt;(); post = new Queue&lt;Integer&gt;(); reversePost = new Stack&lt;Integer&gt;(); for (int v = 0; v &lt; g.V(); v++)&#123; if (marked[v] == false) dfs(g, v); &#125; &#125; private void dfs(Digraph g, int v)&#123; marked[v] = true; pre.enqueue(v); for (int w : g.adj(v))&#123; if (marked[w] == false) dfs(g, w); &#125; post.enqueue(v); reversePost.push(v); &#125; public Iterable&lt;Integer&gt; pre()&#123; return pre; &#125; public Iterable&lt;Integer&gt; post()&#123; return post; &#125; public Iterable&lt;Integer&gt; reversePost()&#123; return reversePost; &#125;&#125; 示意 实现123456789101112131415161718192021public class Topological &#123; private Iterable&lt;Integer&gt; order; public Topological(Digraph g)&#123; DirectedCycle cycle = new DirectedCycle(g); if (!cycle.hasCycle())&#123; DepthFirstOrder dfs = new DepthFirstOrder(g); order = dfs.reversePost(); &#125; &#125; public Iterable&lt;Integer&gt; order()&#123; return order; &#125; public boolean isDAG()&#123; return order != null; &#125;&#125; 特点使用深度优先搜索对有向无环图进行拓扑排序所需的时间和V+E成正比。 强连通性使用深度优先搜索查找给定有向图G的反向图G’，根据由此得到的所有顶点的逆后序再次用深度优先搜索处理有向图G（Kosaraju算法），其构造函数中的每一次递归调用所标记的顶点都在同一个强连通分量之中。 示意 实现1234567891011121314151617181920212223242526272829303132333435363738394041public class KosarajuSCC &#123; private boolean[] marked; private int[] id; private int count; public KosarajuSCC(Digraph g)&#123; marked = new boolean[g.V()]; id = new int[g.V()]; count = 0; DepthFirstOrder order = new DepthFirstOrder(g.reverse()); for (int v : order.reversePost())&#123; if (marked[v] == false)&#123; dfs(g, v); count++; &#125; &#125; &#125; private void dfs(Digraph g, int v)&#123; marked[v] = true; id[v] = count; for (int w : g.adj(v))&#123; if (marked[w] == false) dfs(g, w); &#125; &#125; public boolean stronglyConnected(int v, int w)&#123; return id[v] == id[w]; &#125; public int id(int v)&#123; return id[v]; &#125; public int count()&#123; return count; &#125;&#125; 特点Kosaraju算法的预处理所需的时间和空间与V+E成正比且支持常数时间的有向图强连通性的查询。 给定一幅有向图，回答“给定的两个顶点是强连通的吗？这幅有向图中含有多少个强连通分量？”等类似问题。 最小生成树Prim算法每一步都会为一棵生长中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加V-1条边，每次总是将下一条连接树中的顶点与不在树中的顶点且权重最小的边（黑色表示）加入树中（即由树中的顶点所定义的切分中的一条横向边）。 每当向树中添加了一条边之后，也向树中添加了一个顶点。要维护一个包含所有横切边的集合，就要将连接这个顶点和其他所有不在树中的顶点的边加入优先队列。但，连接新加入树中的顶点与其他已经在树中顶点的所有边都失效了。（这样的边都已经不是横切边了，因为它的两个顶点都在树中。） 示意 定义Prim算法能够得到任意加权无向图的最小生成树。 延时实现将失效的边先留在优先队列中，等到要删除它们的时候再检查边的有效性。 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class LazyPrimMST &#123; private double weight; private boolean[] marked; private Queue&lt;Edge&gt; mst; private MinPQ&lt;Edge&gt; pq; public LazyPrimMST(EdgeWeightedGraph g)&#123; weight = 0; marked = new boolean[g.V()]; mst = new Queue&lt;Edge&gt;(); pq = new MinPQ&lt;Edge&gt;(g.E()); prim(g); &#125; private void prim(EdgeWeightedGraph g)&#123; visit(g, 0); while (!pq.isEmpty())&#123; Edge e = pq.delMin(); int v = e.either(); int w = e.other(v); if (marked[v] == true &amp;&amp; marked[w] == true) continue; weight += e.weight(); mst.enqueue(e); if (marked[v] == false) visit(g, v); else if (marked[w] == false) visit(g, w); &#125; &#125; private void visit(EdgeWeightedGraph g, int v)&#123; marked[v] = true; for (Edge e : g.adj(v))&#123; if (marked[e.other(v)] == false) pq.insert(e); &#125; &#125; public Iterable&lt;Edge&gt; edges()&#123; return mst; &#125; public double weight()&#123; return weight; &#125;&#125; 特点Prim算法的延时实现计算一幅含有V个顶点和E条边的连通加权无向图的最小生成树所需的空间与E成正比，所需的时间与ElogE成正比（最坏情况）。 即时实现只会在优先队列中保存每个非树顶点w的一条边：将它与树中的顶点连接起来的权重最小的那条边。将w和树的顶点连接起来的其他权重较大的边迟早都会失效，所以没必要在优先队列中保存它们。 示意 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class PrimMST &#123; private boolean[] marked; private Edge[] edgeTo; private double[] distTo; private IndexMinPQ&lt;Double&gt; pq; public PrimMST(EdgeWeightedGraph g)&#123; marked = new boolean[g.V()]; edgeTo = new Edge[g.V()]; distTo = new double[g.V()]; pq = new IndexMinPQ&lt;Double&gt;(g.V()); for (int v = 0; v &lt; g.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; prim(g); &#125; private void prim(EdgeWeightedGraph g)&#123; pq.insert(0, 0.0); while (!pq.isEmpty()) visit(g, pq.delMin()); &#125; private void visit(EdgeWeightedGraph g, int v)&#123; marked[v] = true; for (Edge e : g.adj(v))&#123; int w = e.other(v); if (marked[w] == true) continue; if (e.weight() &lt; distTo[w])&#123; distTo[w] = e.weight(); edgeTo[w] = e; if (pq.contains(w)) pq.change(w, distTo[w]); else pq.insert(w, distTo[w]); &#125; &#125; &#125; public Iterable&lt;Edge&gt; edges()&#123; Queue&lt;Edge&gt; mst = new Queue&lt;Edge&gt;(); for (int v = 1; v &lt; edgeTo.length; v++) mst.enqueue(edgeTo[v]); return mst; &#125; public double weight()&#123; double weight = 0.0; for (int v = 1; v &lt; distTo.length; v++) weight += distTo[v]; return weight; &#125;&#125; 特点Prim算法的即时实现计算一幅含有V个顶点和E条边的连通加权无向图的最小生成树所需的空间和V成正比，所需的时间和ElogV成正比（最坏情况）。 Kruskal算法按照边的权重顺序（从小到大）处理它们，将边加入最小生成树中，加入的边不会与已经加入的边构成环，直到树中含有V-1条边为止。这些黑色的边逐渐由一片森林合并为一棵树，也就是图的最小生成树。 定义Kruskal算法能够计算任意加权无向图的最小生成树。 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142public class KruskalMST &#123; private Queue&lt;Edge&gt; mst; private MinPQ&lt;Edge&gt; pq; private UnionFind uf; private double weight; public KruskalMST(EdgeWeightedGraph g)&#123; weight = 0; mst = new Queue&lt;Edge&gt;(); pq = new MinPQ&lt;Edge&gt;(g.E()); uf = new UnionFind(g.V()); for (Edge e : g.edges()) pq.insert(e); kruskal(g); &#125; private void kruskal(EdgeWeightedGraph g)&#123; while (!pq.isEmpty() &amp;&amp; mst.size() &lt; g.V())&#123; Edge e = pq.delMin(); int v = e.either(); int w = e.other(v); if (uf.connected(v, w)) continue; uf.union(v, w); mst.enqueue(e); weight += e.weight(); &#125; &#125; public Iterable&lt;Edge&gt; edges()&#123; return mst; &#125; public double weight()&#123; return weight; &#125;&#125; 特点Kruskal算法计算一幅含有V个顶点和E条边的连通加权无向图的最小生成树所需的空间和E成正比，所需的时间和ElogE成正比（最坏情况）。 比较Prim算法是一条边一条边地来构造最小生成树，每一步都为一棵树添加一条边。 Kruskal算法构造最小生成树的时候也是一条边一条边地构造，但不同的是它寻找的边会连接一片森林中的两棵树。从一片由V棵单顶点的树构成的森林开始并不断将两棵树合并（用可以找到的最短边）直到只剩下一棵树，它就是最小生成树。 总结 最短路径树Dijkstra算法采用了类似Prim算法的方法来计算最短路径树。 定义Dijkstra算法能够解决边权重非负的加权有向图的单起点最短路径问题。 示意 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class DijkstraSPT &#123; private DirectedEdge[] edgeTo; private double[] distTo; private IndexMinPQ&lt;Double&gt; pq; private int s; public DijkstraSPT(EdgeWeightedDigraph g, int s)&#123; edgeTo = new DirectedEdge[g.V()]; distTo = new double[g.V()]; pq = new IndexMinPQ&lt;Double&gt;(g.V()); this.s = s; for (int v = 0; v &lt; g.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; distTo[s] = 0; pq.insert(s, 0.0); while (!pq.isEmpty()) relax(g, pq.delMin()); &#125; private void relax(EdgeWeightedDigraph g, int v)&#123; for (DirectedEdge e : g.adj(v))&#123; int w = e.to(); if (distTo[v] + e.weight() &lt; distTo[w])&#123; distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; if (pq.contains(w)) pq.change(w, distTo[w]); else pq.insert(w, distTo[w]); &#125; &#125; &#125; public double distTo(int v)&#123; return distTo[v]; &#125; public boolean hasPathTo(int v)&#123; return distTo[v] &lt; Double.POSITIVE_INFINITY; &#125; public Iterable&lt;DirectedEdge&gt; pathTo(int v)&#123; if (!hasPathTo(v)) return null; Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;(); DirectedEdge e = edgeTo[v]; while (e.from() != s)&#123; path.push(e); e = edgeTo[e.from()]; &#125; path.push(e); return path; &#125;&#125; 特点在一幅含有V个顶点和E条边的加权有向图中，使用Dijkstra算法计算根结点为给定起点的最短路径树所需的空间与V成正比，时间与ElogV成正比（最坏情况下）。 比较Prim算法每次添加的都是离树最近的非树顶点，Dijkstra算法每次添加的都是离起点最近的非树顶点。 拓扑排序将顶点的放松和拓扑排序结合起来。 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class AcyclicSPT &#123; private DirectedEdge[] edgeTo; private double[] distTo; private int s; public AcyclicSPT(EdgeWeightedDigraph g, int s)&#123; edgeTo = new DirectedEdge[g.V()]; distTo = new double[g.V()]; this.s = s; for (int v = 0; v &lt; g.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; distTo[s] = 0; Topological t = new Topological(g); for (int v : t.order()) relax(g, v); &#125; private void relax(EdgeWeightedDigraph g, int v)&#123; for (DirectedEdge e : g.adj(v))&#123; int w = e.to(); if (distTo[v] + e.weight() &lt; distTo[w])&#123; distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; &#125; &#125; &#125; public double distTo(int v)&#123; return distTo[v]; &#125; public boolean hasPathTo(int v)&#123; return distTo[v] &lt; Double.POSITIVE_INFINITY; &#125; public Iterable&lt;DirectedEdge&gt; pathTo(int v)&#123; if (!hasPathTo(v)) return null; Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;(); DirectedEdge e = edgeTo[v]; while (e.from() != s)&#123; path.push(e); e = edgeTo[e.from()]; &#125; path.push(e); return path; &#125;&#125; 特点按照拓扑排序放松顶点，就能在和E+V成正比的时间内解决无环有向图的单点最短路径问题。 能够在线性时间内解决单点最短路径问题 能够处理负权重的边 能够解决相关的问题，例如找出最长的路径 Bellman-Ford算法解决一般有向图中的以下问题： 负权重环的检测。给定的加权有向图中含有负权重环吗？如果有，找到它。 负权重环不可达时的单点最短路径。给定一幅加权有向图和一个起点s且从s无法到达任何负权重环，回答“是否存在一条从s到给定的顶点v的有向路径？如果有，找出最短（总权重最小）的那条路径。“等类似问题。 定义在任意含有V个顶点的加权有向图中给定起点s，从s无法到达任何负权重环，以下算法能够解决其中的单点最短路径问题：以任意顺序放松有向图的所有边，重复V轮。 示意 负权重环的检测在将所有边放松V轮之后当且仅当队列非空时有向图中才存在从起点可达的负权重环。 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class BellmanFordSPT &#123; private DirectedEdge[] edgeTo; private double[] distTo; private Iterable&lt;DirectedEdge&gt; cycle; private Queue&lt;Integer&gt; queue; private boolean[] onQ; private int s; private int cost; public BellmanFordSPT(EdgeWeightedDigraph g, int s)&#123; this.s = s; cost = 0; edgeTo = new DirectedEdge[g.V()]; distTo = new double[g.V()]; onQ = new boolean[g.V()]; queue = new Queue&lt;Integer&gt;(); for (int v = 0; v &lt; g.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; distTo[s] = 0; onQ[s] = true; queue.enqueue(s); while (!queue.isEmpty() &amp;&amp; !hasNegativeCycle())&#123; int v = queue.dequeue(); onQ[v] = false; relax(g, v); if (++cost % g.V() == 0) findNegativeCycle(); &#125; &#125; private void relax(EdgeWeightedDigraph g, int v)&#123; for (DirectedEdge e : g.adj(v))&#123; int w = e.to(); if (distTo[v] + e.weight() &lt; distTo[w])&#123; distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; if (onQ[w] == false)&#123; onQ[w] = true; queue.enqueue(w); &#125; &#125; &#125; &#125; private void findNegativeCycle()&#123; int V = edgeTo.length; EdgeWeightedDigraph g = new EdgeWeightedDigraph(V); for (int v = 0; v &lt; V; v++)&#123; if (edgeTo[v] != null) g.addEdge(edgeTo[v]); &#125; EdgeWeightedDirectedCycle c = new EdgeWeightedDirectedCycle(g); cycle = c.cycle(); &#125; public boolean hasNegativeCycle()&#123; return cycle != null; &#125; public Iterable&lt;DirectedEdge&gt; negativeCycle()&#123; return cycle; &#125; public double distTo(int v)&#123; return distTo[v]; &#125; public boolean hasPathTo(int v)&#123; return distTo[v] &lt; Double.POSITIVE_INFINITY; &#125; public Iterable&lt;DirectedEdge&gt; pathTo(int v)&#123; if (!hasPathTo(v)) return null; Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;(); DirectedEdge e = edgeTo[v]; while (e.from() != s)&#123; path.push(e); e = edgeTo[e.from()]; &#125; path.push(e); return path; &#125;&#125; 特点对于任意含有V个顶点的加权有向图和给定的起点s，在最坏情况下基于队列的Bellman-Ford算法解决最短路径问题（或者找到从s可达的负权重环）所需的时间和EV成正比，空间和V成正比。 总结]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】查找]]></title>
    <url>%2F2017%2F04%2F16%2F%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[顺序查找（无序链表）符号表中使用的数据结构的一个简单选择是链表，每个结点存储一个键值对。 示意 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class SequentialSearch&lt;Key, Value&gt; &#123; private Node first; private int n; private class Node&#123; Key key; Value value; Node next; public Node (Key key, Value value, Node next)&#123; this.key = key; this.value = value; this.next = next; &#125; &#125; public void put(Key key, Value value)&#123; for (Node x = first; x != null; x = x.next)&#123; if (key.equals(x.key))&#123; x.value = value; return; &#125; &#125; first = new Node(key, value, first); n++; &#125; public Value get(Key key)&#123; for (Node x = first; x != null; x = x.next)&#123; if (key.equals(x.key)) return x.value; &#125; return null; &#125; public void delete(Key key)&#123; if (isEmpty()) return; if (key.equals(first.key)) first = first.next; else deleteNode(first, key); n--; &#125; private void deleteNode(Node x, Key key)&#123; if (x.next == null) return; if (key.equals(x.next.key)) x.next = x.next.next; else deleteNode(x.next, key); &#125; public Iterable&lt;Key&gt; keys()&#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); for (Node x = first; x != null; x = x.next) queue.enqueue(x.key); return queue; &#125; public int size()&#123; return n; &#125; public boolean isEmpty()&#123; return size() == 0; &#125; public boolean contains(Key key)&#123; return get(key) != null; &#125;&#125; 特点在含有N对键值的基于（无序）链表的符号表中，未命名的查找和插入操作都需要N次比较。命中的查找在最坏情况下需要N次比较。特别地，向一个空表中插入N个不同的键需要~N^2/2次比较。 二分查找（有序数组）符号表使用的数据结构是一对平行的数组，一个存储键一个存储值。 计算小于给定键的键的数量：首先将key和中间键比较，如果相等则返回其索引；如果小于中间键则在左半部分查找；大于则在右半部分查找。 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152public class BinarySearch&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private int n; private Key[] keys; private Value[] values; public BinarySearch(int capacity)&#123; keys = (Key[]) new Comparable[capacity]; values = (Value[]) new Object[capacity]; &#125; public void put(Key key, Value value)&#123; int i = rank(key); if (i &lt; n &amp;&amp; key.compareTo(keys[i]) == 0)&#123; values[i] = value; return; &#125; for (int j = n; j &gt; i; j--)&#123; keys[j] = keys[j-1]; values[j] = values[j-1]; &#125; keys[i] = key; values[i] = value; n++; &#125; public Value get(Key key)&#123; if (isEmpty()) return null; int i = rank(key); if (i &lt; n &amp;&amp; key.compareTo(keys[i]) == 0) return values[i]; else return null; &#125; public int rank(Key key)&#123; int lo = 0; int hi = n - 1; while (lo &lt;= hi)&#123; int mid = lo + (hi - lo) / 2; int compare = key.compareTo(keys[mid]); if (compare &lt; 0) hi = mid - 1; else if (compare &gt; 0) lo = mid + 1; else return mid; &#125; return lo; &#125; public void delete(Key key)&#123; if (isEmpty()) return; int i = rank(key); if (key.compareTo(keys[i]) != 0) return; for (int j = i + 1; j &lt; n; j++)&#123; keys[j-1] = keys[j]; values[j-1] = values[j]; &#125; keys[n] = null; values[n] = null; n--; &#125; public int size()&#123; return n; &#125; public int size(Key lo, Key hi)&#123; if (hi.compareTo(lo) &lt; 0) return 0; else if (contains(hi)) return rank(hi) - rank(lo) + 1; else return rank(hi) - rank(lo); &#125; public Key floor(Key key)&#123; int i = rank(key); if (i &lt; n &amp;&amp; key.compareTo(keys[i]) == 0) return keys[i]; if (i == 0) return null; else return keys[i-1]; &#125; public Key ceiling(Key key)&#123; int i = rank(key); return keys[i]; &#125; public Iterable&lt;Key&gt; keys()&#123; return keys(min(), max()); &#125; public Iterable&lt;Key&gt; keys(Key lo, Key hi)&#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); for (int i = rank(lo); i &lt; rank(hi); i++) queue.enqueue(keys[i]); if (contains(hi)) queue.enqueue(hi); return queue; &#125; public boolean isEmpty()&#123; return size() == 0; &#125; public boolean contains(Key key)&#123; return get(key) != null; &#125; public Key min()&#123; return keys[0]; &#125; public Key max()&#123; return keys[n-1]; &#125; public Key select(int k)&#123; return keys[k]; &#125; public void deleteMin()&#123; delete(min()); &#125; public void deleteMax()&#123; delete(max()); &#125;&#125; 特点在N个键的有序数组中进行二分查找最多需要（lgN+1）次比较（无论是否成功）。 向大小为N的有序数组中插入一个新的元素在最坏情况下需要访问～2N次数组，因此向一个空符号表中插入N个元素在最坏情况下需要访问~N^2次数组。 比较 二叉查找树定义一个类表示二叉查找树上的一个结点。每个结点都含有一个键、一个值、一条左链接、一条右链接和一个结点计数器。左链接指向一棵由小于该结点的所有键组成的二叉查找树，右链接指向一棵由大于该结点的所有键组成的二叉查找树。变量N给出了以该结点为根的子树的结点总数。 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287public class BinarySearchTree&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private Node root; private class Node&#123; Key key; Value value; Node left; Node right; int n; public Node(Key key, Value value, int n)&#123; this.key = key; this.value = value; this.n = n; &#125; &#125; public void put(Key key, Value value)&#123; root = put(root, key, value); &#125; private Node put(Node x, Key key, Value value)&#123; if (x == null) return new Node(key, value, 1); int compare = key.compareTo(x.key); if (compare &lt; 0) x.left = put(x.left, key, value); else if (compare &gt; 0) x.right = put(x.right, key, value); else x.value = value; x.n = size(x.left) + size(x.right) + 1; return x; &#125; public Value get(Key key)&#123; return get(root, key); &#125; private Value get(Node x, Key key)&#123; if (x == null) return null; int compare = key.compareTo(x.key); if (compare &lt; 0) return get(x.left, key); else if (compare &gt; 0) return get(x.right, key); else return x.value; &#125; public void delete(Key key)&#123; root = delete(root, key); &#125; private Node delete(Node x, Key key)&#123; if (x == null) return null; int compare = key.compareTo(x.key); if (compare &lt; 0) x.left = delete(x.left, key); else if (compare &gt; 0) x.right = delete(x.right, key); else&#123; if (x.left == null) return x.right; else if (x.right == null) return x.left; Node t = x; x = min(t.right); x.right = deleteMin(t.right); x.left = t.left; &#125; x.n = size(x.left) + size(x.right) + 1; return x; &#125; public void deleteMin()&#123; root = deleteMin(root); &#125; private Node deleteMin(Node x)&#123; if (x.left == null) return x.right; x.left = deleteMin(x.left); x.n = size(x.left) + size(x.right) + 1; return x; &#125; public void deleteMax()&#123; root = deleteMax(root); &#125; private Node deleteMax(Node x)&#123; if (x.right == null) return x.left; x.right = deleteMax(x.right); x.n = size(x.left) + size(x.right) + 1; return x; &#125; public Key min()&#123; return min(root).key; &#125; private Node min(Node x)&#123; if (x.left == null) return x; else return min(x.left); &#125; public Key max()&#123; return max(root).key; &#125; private Node max(Node x)&#123; if (x.right == null) return x; else return max(x.right); &#125; public Key floor(Key key)&#123; Node x = floor(root, key); if (x == null) return null; else return x.key; &#125; private Node floor(Node x, Key key)&#123; if (x == null) return null; int compare = key.compareTo(x.key); if (compare == 0) return x; else if (compare &lt; 0) return floor(x.left, key); else &#123; Node y = floor(x.right, key); if (y != null) return y; else return x; &#125; &#125; public int rank(Key key)&#123; return rank(root, key); &#125; private int rank(Node x, Key key)&#123; if (x == null) return 0; int compare = key.compareTo(x.key); if (compare &lt; 0) return rank(x.left, key); else if (compare &gt; 0) return rank(x.right, key) + size(x.left) + 1; else return size(x.left); &#125; public Key select(int k)&#123; return select(root, k).key; &#125; private Node select(Node x, int k)&#123; if (x == null) return null; int t = size(x.left); if (t &gt; k) return select(x.left, k); else if (t &lt; k) return select(x.right, k-t-1); else return x; &#125; public Key ceiling(Key key)&#123; Node x = ceiling(root, key); if (x == null) return null; else return x.key; &#125; private Node ceiling(Node x, Key key)&#123; if (x == null) return null; int compare = key.compareTo(x.key); if (compare == 0) return x; else if (compare &gt; 0) return ceiling(x.right, key); else &#123; Node y = ceiling(x.left, key); if (y != null) return y; else return x; &#125; &#125; public int size()&#123; return size(root); &#125; private int size(Node x)&#123; if (x == null) return 0; else return x.n; &#125; public int size(Key lo, Key hi)&#123; if (hi.compareTo(lo) &lt; 0) return 0; else if (contains(hi)) return rank(hi) - rank(lo) + 1; else return rank(hi) - rank(lo); &#125; public Iterable&lt;Key&gt; keys()&#123; return keys(min(), max()); &#125; public Iterable&lt;Key&gt; keys(Key lo, Key hi)&#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); keys(root, queue, lo, hi); return queue; &#125; private void keys (Node x, Queue&lt;Key&gt; queue, Key lo, Key hi)&#123; if (x == null) return; int compareLo = lo.compareTo(x.key); int compareHi = hi.compareTo(x.key); if (compareLo &lt; 0) keys(x.left, queue, lo, hi); if (compareLo &lt;= 0 &amp;&amp; compareHi &gt;= 0) queue.enqueue(x.key); if (compareHi &gt; 0) keys(x.right, queue, lo, hi); &#125; public boolean isEmpty()&#123; return size() == 0; &#125; public boolean contains(Key key)&#123; return get(key) != null; &#125;&#125; 特点在由N个随机键构造的二叉查找树中，查找命中平均所需的比较次数为2lnN（约为1.39lgN），插入操作和查找未命中平均所需的比较次数为2lnN（约为1.39lgN）。 在一棵二叉查找树中，所有操作在最坏情况下所需的时间都和树的高度成正比。 比较 红黑二叉查找树只要谨慎地使用左旋转、右旋转和颜色转换这三种简单的操作，就能够保证插入操作后红黑树和2-3树的一一对应关系： 如果右子结点是红色的而左子结点是黑色的，进行左旋转 如果左子结点是红色的且它的左子结点也是红色的，进行右旋转 如果左右子结点均为红色，进行颜色转换 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403public class RedBlackTree&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private static final boolean RED = true; private static final boolean BLACK = false; private Node root; private class Node&#123; Key key; Value value; Node left; Node right; int n; boolean color; public Node(Key key, Value value, int n, boolean color)&#123; this.key = key; this.value = value; this.n = n; this.color = color; &#125; &#125; private boolean isRed(Node x)&#123; if (x == null) return BLACK; return x.color == RED; &#125; private Node rotateLeft(Node h)&#123; Node x = h.right; h.right = x.left; x.left = h; x.color = h.color; h.color = RED; x.n = h.n; h.n = size(h.left) + size(h.right) + 1; return x; &#125; private Node rotateRight(Node h)&#123; Node x = h.left; h.left = x.right; x.right = h; x.color = h.color; h.color = RED; x.n = h.n; h.n = size(h.left) + size(h.right) + 1; return x; &#125; private void flipColors(Node h)&#123; h.left.color = !h.left.color; h.right.color = !h.right.color; h.color = !h.color; &#125; private Node balance(Node h)&#123; if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h); if (isRed(h.right)) h = rotateLeft(h); if (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h); h.n = size(h.left) + size(h.right) + 1; return h; &#125; private Node moveRedLeft(Node h)&#123; flipColors(h); if (isRed(h.right.left))&#123; h.right = rotateRight(h.right); h = rotateLeft(h); &#125; return h; &#125; private Node moveRedRight(Node h)&#123; flipColors(h); if (isRed(h.left.left)) h = rotateRight(h); return h; &#125; public void put(Key key, Value value)&#123; root = put(root, key, value); root.color = BLACK; &#125; private Node put(Node h, Key key, Value value)&#123; if (h == null) return new Node(key, value, 1, RED); int compare = key.compareTo(h.key); if (compare &lt; 0) h.left = put(h.left, key, value); else if (compare &gt; 0) h.right = put(h.right, key, value); else h.value = value; if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h); if (!isRed(h.left) &amp;&amp; isRed(h.right)) h = rotateLeft(h); if (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h); h.n = size(h.left) + size(h.right) + 1; return h; &#125; public Value get(Key key)&#123; return get(root, key); &#125; private Value get(Node x, Key key)&#123; while (x != null)&#123; int compare = key.compareTo(x.key); if (compare &lt; 0) x = x.left; else if (compare &gt; 0) x = x.right; else return x.value; &#125; return null; &#125; public void delete(Key key)&#123; if (!isRed(root.left) &amp;&amp; !isRed(root.right)) root.color = RED; root = delete(root, key); if (!isEmpty()) root.color = BLACK; &#125; private Node delete(Node h, Key key)&#123; if (key.compareTo(h.key) &lt; 0)&#123; if (!isRed(h.left) &amp;&amp; !isRed(h.left.left)) h = moveRedLeft(h); h.left = delete(h.left, key); &#125; else&#123; if (isRed(h.left)) h = rotateRight(h); //如果被查找的键在树的底部，可以直接删除它 if (h.right == null &amp;&amp; key.compareTo(h.key) == 0) return null; if (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) h = moveRedRight(h); //如果不在，需要将它和它的后继结点交换 if (key.compareTo(h.key) == 0)&#123; h.key = min(h.right).key; h.value = get(h.right, min(h.right).key); h.right = deleteMin(h.right); &#125; else h.right = delete(h.right, key); &#125; return balance(h); &#125; public void deleteMin()&#123; if (!isRed(root.left) &amp;&amp; !isRed(root.right)) root.color = RED; root = deleteMin(root); if (!isEmpty()) root.color = BLACK; &#125; private Node deleteMin(Node h)&#123; if (h.left == null) return null; if (!isRed(h.left) &amp;&amp; !isRed(h.left.left)) h = moveRedLeft(h); h.left = deleteMin(h.left); return balance(h); &#125; public void deleteMax()&#123; if (!isRed(root.left) &amp;&amp; !isRed(root.right)) root.color = RED; root = deleteMax(root); if (!isEmpty()) root.color = BLACK; &#125; private Node deleteMax(Node h)&#123; if (isRed(h.left)) h = rotateRight(h); if (h.right == null) return null; if (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) h = moveRedRight(h); h.right = deleteMax(h.right); return balance(h); &#125; public int size()&#123; return size(root); &#125; private int size(Node x)&#123; if (x == null) return 0; else return x.n; &#125; public int size(Key lo, Key hi)&#123; if (hi.compareTo(lo) &lt; 0) return 0; else if (contains(hi)) return rank(hi) - rank(lo) + 1; else return rank(hi) - rank(lo); &#125; public int rank(Key key)&#123; return rank(root, key); &#125; private int rank(Node x, Key key)&#123; if (x == null) return 0; int compare = key.compareTo(x.key); if (compare &lt; 0) return rank(x.left, key); else if (compare &gt; 0) return rank(x.right, key) + size(x.left) + 1; else return size(x.left); &#125; public Key select(int k)&#123; return select(root, k).key; &#125; private Node select(Node x, int k)&#123; if (x == null) return null; int t = size(x.left); if (t &gt; k) return select(x.left, k); else if (t &lt; k) return select(x.right, k-t-1); else return x; &#125; public Key floor(Key key)&#123; Node x = floor(root, key); if (x == null) return null; else return x.key; &#125; private Node floor(Node x, Key key)&#123; if (x == null) return null; int compare = key.compareTo(x.key); if (compare == 0) return x; else if (compare &lt; 0) return floor(x.left, key); else &#123; Node y = floor(x.right, key); if (y != null) return y; else return x; &#125; &#125; public Key ceiling(Key key)&#123; Node x = ceiling(root, key); if (x == null) return null; else return x.key; &#125; private Node ceiling(Node x, Key key)&#123; if (x == null) return null; int compare = key.compareTo(x.key); if (compare == 0) return x; else if (compare &gt; 0) return ceiling(x.right, key); else &#123; Node y = ceiling(x.left, key); if (y != null) return y; else return x; &#125; &#125; public Key min()&#123; return min(root).key; &#125; private Node min(Node x)&#123; if (x.left == null) return x; else return min(x.left); &#125; public Key max()&#123; return max(root).key; &#125; private Node max(Node x)&#123; if (x.right == null) return x; else return max(x.right); &#125; public Iterable&lt;Key&gt; keys()&#123; return keys(min(), max()); &#125; public Iterable&lt;Key&gt; keys(Key lo, Key hi)&#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); keys(root, queue, lo, hi); return queue; &#125; private void keys (Node x, Queue&lt;Key&gt; queue, Key lo, Key hi)&#123; if (x == null) return; int compareLo = lo.compareTo(x.key); int compareHi = hi.compareTo(x.key); if (compareLo &lt; 0) keys(x.left, queue, lo, hi); if (compareLo &lt;= 0 &amp;&amp; compareHi &gt;= 0) queue.enqueue(x.key); if (compareHi &gt; 0) keys(x.right, queue, lo, hi); &#125; public boolean contains(Key key)&#123; return get(key) != null; &#125; public boolean isEmpty()&#123; return size() == 0; &#125;&#125; 特点一棵大小为N的红黑树的高度不会超过2lgN。 一棵大小为N的红黑树中，根结点到任意结点的平均路径长度为~1.00lgN。 在一棵红黑树中，以下操作在最坏情况下所需的时间是对数级别的：查找（get）、插入（put）、查找最小键、查找最大键、floor、ceiling、rank、select、删除最小键（deleteMin）、删除最大键（deleteMax）、删除（delete）和范围查询。 比较 散列使用散列的查找算法分为两步。第一步是用散列函数将被查找的键转化为数组的一个索引（散列函数）；第二步就是一个处理碰撞冲突的过程（拉链法和线性探测法）。 因为需要的是数组的索引而不是一个32位的整数，在实现中会将默认的hashCode()方法和除留余数法结合起来产生一个0到M-1的整数，方法如下： 123private int hash(Key x)&#123; return (x.hashCode() &amp; 0x7fffffff) % M;&#125; 这段代码会将符号位屏蔽（将一个32位整数变为一个31位非负整数），然后用除留余数法计算它除以M的余数。在使用这样的代码一般会将数组的大小M取为素数以充分利用原散列值的所有位。 基于拉链法的散列表（链表数组）将大小为M的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。 查找分两步：首先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。 示意 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class SeparateChainHash&lt;Key, Value&gt; &#123; private int M; private int N; private SequentialSearch&lt;Key, Value&gt;[] st; public SeparateChainHash(int M)&#123; this.M = M; this.N = 0; st = (SequentialSearch&lt;Key, Value&gt;[]) new SequentialSearch[M]; for (int i = 0; i &lt; M; i++) st[i] = new SequentialSearch(); &#125; private int hash(Key x)&#123; return (x.hashCode() &amp; 0x7fffffff) % M; &#125; public void put(Key key, Value value)&#123; int m = hash(key); if (!contains(key)) N++; st[m].put(key, value); &#125; public Value get(Key key)&#123; int m = hash(key); return st[m].get(key); &#125; public void delete(Key key)&#123; int m = hash(key); if (contains(key)) N--; st[m].delete(key); &#125; public Iterable&lt;Key&gt; keys()&#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); for (int i = 0; i &lt; st.length; i++) &#123; for (Key key : st[i].keys()) queue.enqueue(key); &#125; return queue; &#125; public boolean contains(Key key)&#123; return get(key) != null; &#125; public int size()&#123; return N; &#125; public boolean isEmpty()&#123; return size() == 0; &#125;&#125; 特点在一张含有M条链表和N个键的散列表中，任意一条链表中的键的数量均在N/M的常熟因子范围内的概率无限趋于1，未命中查找和插入操作所需的比较次数为～N/M。 基于线性探测法的散列表（并行数组）用大小为M的数组保存N个键值对，其中M&gt;N，需要依靠数组中的空位解决碰撞冲突。基于这种策略的所有方法被统称为开放地址散列表。 最简单的方法叫做线性探测法：当碰撞发生时（当一个键的散列值已经被另一个不同的键占用），直接检查散列表中的下一个位置（将索引值加1）。这样的线性探测可能会产生三种结果： 命中，该位置的键和被查找的键相同 未命中，键为空（该位置没有键） 继续查找，该位置的键和被查找的键不同 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class LinearProbingHash&lt;Key, Value&gt; &#123; private int M; private int N; private Key[] keys; private Value[] values; public LinearProbingHash(int M)&#123; this.M = M; keys = (Key[]) new Object[M]; values = (Value[]) new Object[M]; &#125; private int hash(Key x)&#123; return (x.hashCode() &amp; 0x7fffffff) % M; &#125; private void resize(int m)&#123; LinearProbingHash&lt;Key, Value&gt; tmp = new LinearProbingHash&lt;Key, Value&gt;(m); for (int i = 0; i &lt; M; i++)&#123; if (keys[i] != null) tmp.put(keys[i], values[i]); &#125; this.M = m; keys = tmp.keys; values = tmp.values; &#125; public void put(Key key, Value value)&#123; if (N &gt;= M / 2) resize(2 * M); int m = hash(key); for (m = hash(key); keys[m] != null; m = (m + 1) % M)&#123; if (keys[m].equals(key))&#123; values[m] = value; return; &#125; &#125; keys[m] = key; values[m] = value; N++; &#125; public Value get(Key key)&#123; for (int m = hash(key); keys[m] != null; m = (m + 1) % M)&#123; if (keys[m].equals(key)) return values[m]; &#125; return null; &#125; public void delete(Key key)&#123; int m; for (m = hash(key); keys[m] != null; m = (m + 1) % M)&#123; if (keys[m].equals(key))&#123; keys[m] = null; values[m] = null; break; &#125; &#125; for (m = (m + 1) % M; keys[m] != null; m = (m + 1) % M)&#123; Key k = keys[m]; Value v = values[m]; keys[m] = null; values[m] = null; put(k, v); N--; &#125; N--; if (N &gt; 0 &amp;&amp; N == M / 8) resize(M / 2); &#125; public Iterable&lt;Key&gt; keys()&#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); for (int i = 0; i &lt; M; i++)&#123; if (keys[i] != null) queue.enqueue(keys[i]); &#125; return queue; &#125; public boolean contains(Key key)&#123; return get(key) != null; &#125; public int size()&#123; return N; &#125; public boolean isEmpty()&#123; return size() == 0; &#125;&#125; 特点在一张大小为M并含有N=aM个键的基于线性探测的散列表中，命中和未命中的查找所需的探测次数分别为： 假设一张散列表能够自己调整数组的大小，初始为空。执行任意数序的t次查找、插入和删除操作所需的时间和t成正比，所使用的内存量总是在表中的键的总数的常数因子范围内。 线性探测的平均成本取决于元素在插入数组后聚集成的一组连续的条目，也叫做键簇。短小的键簇才能保证较高的效率，因此需要动态调整数组的大小来保证使用率在1/8到1/2之间。 比较将a=N/M称为散列表的使用率。对于基于拉链法的散列表，a是每条链表的长度，因此一般大于1；对于基于线性探测的散列表，a是表中已被占用的空间的比例，它是不可能大于1的。 特点 每种类型的键都需要一个优秀的散列函数 性能保证来自于散列函数的质量 散列函数的计算可能复杂而且昂贵 难以支持有序性相关的符号表操作 比较 总结]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】排序]]></title>
    <url>%2F2017%2F04%2F13%2F%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。 示意 实现12345678910111213141516171819202122232425262728293031public class Selection &#123; public void sort(Comparable[] a)&#123; for (int i = 0; i &lt; a.length - 1; i++)&#123; int minIndex = i; for (int j = i + 1; j &lt; a.length; j++)&#123; if (!less(a[minIndex], a[j])) minIndex = j; &#125; exch(a, i, minIndex); &#125; &#125; private boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b) &lt; 0; &#125; private void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; public void show(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); System.out.println(); &#125;&#125; 特点对于长度为N的数组，选择排序需要大约N^2/2次比较和N次交换。 运行时间和输入无关 数据移动是最少的 插入排序将元素插入到其他已经有序的数组中的适当位置。为了要给插入的元素腾出空间，需要将其余所有元素在插入之前都向右移动一位。 示意 实现12345678910111213141516171819202122232425public class Insertion &#123; public void sort(Comparable[] a)&#123; for (int i = 1; i &lt; a.length; i++)&#123; for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j-1]); j--) exch(a, j-1, j); &#125; &#125; private boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b) &lt; 0; &#125; private void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; public void show(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); System.out.println(); &#125;&#125; 特点对于随机排列的长度为N且主键不重复的数组，平均情况下插入排序需要～N^2/2次比较以及~N^2/4次交换。最坏情况下需要～N^2/2次比较和～N^2/2次交换，最好情况下需要N-1次比较和0次交换。 插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。 所需的时间取决于输入中元素的初始顺序，对于部分有序的数组十分高效，也很适合小规模数组 比较对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数。 插入排序不会访问索引右侧的元素，而选择排序不会访问索引左侧的元素 插入排序所需的比较次数平均只有选择排序的一半 希尔排序希尔排序的思想是使数组中任意间隔为h的元素都是有序的。这样的数组被称为h有序数组。在进行排序时，如果h很大，就能将元素移动到很远的地方，为实现更小的h有序创造方便。用这种方式，对于任意以1结尾的h序列，都能够将数组排序。 示意 实现12345678910111213141516171819202122232425262728293031323334public class Shell &#123; public void sort(Comparable[] a)&#123; int h = 1; while (h &lt;= a.length / 3) h = 3 * h + 1; while (h &gt;= 1)&#123; for (int i = h; i &lt; a.length; i++)&#123; for (int j = i; j &gt; h &amp;&amp; less(a[j], a[j-h]); j -= h) exch(a, j-h, j); &#125; h = (h - 1) / 3; &#125; &#125; private boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b) &lt; 0; &#125; private void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; public void show(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); System.out.println(); &#125;&#125; 特点使用递增序列1，4，13，40，121，364…的希尔排序所需的比较次数不会超出N的若干倍数乘以递增序列的长度。 希尔排序更高效的原因是它权衡了子数组的规模和有序性。排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。 希尔排序可以用于大型数组。它对任意排序（不一定是随机的）的数组表现也很好。 希尔排序对于中等大小的数组它的运行时间是可以接受的。它的代码量很小，且不需要使用额外的内存空间。 归并排序要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。 递归实现的归并排序是算法设计中分治思想的典型应用。 示意 特点 能够保证将任意长度为N的数组排序所需时间和NlogN成正比，所需的额外空间和N成正比。 可以用归并排序处理数百万甚至更大规模的数组，这是插入排序或者选择排序做不到的。 自顶向下的归并排序示意 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Merge &#123; private Comparable[] aux; public void sort(Comparable[] a)&#123; aux = new Comparable[a.length]; sort(a, 0, a.length-1); &#125; private void sort(Comparable[] a, int lo, int hi)&#123; if (lo == hi) return; int mid = (hi + lo) / 2; sort(a, lo, mid); sort(a, mid+1, hi); merge(a, lo, mid, hi); &#125; private void merge(Comparable[] a, int lo, int mid, int hi)&#123; int j = lo; int k = mid + 1; for (int i = lo; i &lt;= hi; i++) aux[i] = a[i]; for (int i = lo; i &lt;= hi; i++)&#123; if (j &gt; mid) a[i] = aux[k++]; else if (k &gt; hi) a[i] = aux[j++]; else if (less(aux[j], aux[k])) a[i] = aux[j++]; else a[i] = aux[k++]; &#125; &#125; private boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b) &lt; 0; &#125; public void show(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); System.out.println(); &#125;&#125; 特点对于长度为N的任意数组，自顶向下的归并排序需要1/2*NlgN至NlgN次比较，最多需要访问数组6NlgN次。 自底向上的归并排序示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142public class Merge &#123; private Comparable[] aux; public void sort(Comparable[] a)&#123; aux = new Comparable[a.length]; for (int i = 1; i &lt; a.length; i *= 2)&#123; for (int j = 0; j &lt; a.length; j += 2*i) merge(a, j, j+i-1, Math.min(j+2*i-1, a.length-1)); &#125; &#125; private void merge(Comparable[] a, int lo, int mid, int hi)&#123; int j = lo; int k = mid + 1; for (int i = lo; i &lt;= hi; i++) aux[i] = a[i]; for (int i = lo; i &lt;= hi; i++)&#123; if (j &gt; mid) a[i] = aux[k++]; else if (k &gt; hi) a[i] = aux[j++]; else if (less(aux[j], aux[k])) a[i] = aux[j++]; else a[i] = aux[k++]; &#125; &#125; private boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b) &lt; 0; &#125; public void show(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); System.out.println(); &#125;&#125; 特点对于长度为N的任意数组，自底向上的归并排序需要1/2*NlgN至NlgN次比较，最多访问数组6NlgN次。 比较适合用链表组织的数据。只需要重新组织链表链接就能将链表原地排序（不需要创建任何的链表结点）。 归并排序是一种渐进最优的基于比较排序的算法。 快速排序快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。 示意 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.Random;public class Quick &#123; private static Random random; private static long seed; static &#123; seed = System.currentTimeMillis(); random = new Random(seed); &#125; public void sort(Comparable[] a)&#123; shuffle(a); sort(a, 0, a.length-1); &#125; private void sort(Comparable[] a, int lo, int hi)&#123; if (hi &lt;= lo) return; int i = partition(a, lo, hi); sort(a, lo, i-1); sort(a, i+1, hi); &#125; private int partition(Comparable[] a, int lo, int hi)&#123; int i = lo; int j = hi; while (i &lt; j)&#123; while (i &lt; j &amp;&amp; less(a[i], a[lo])) i++; while (i &lt; j &amp;&amp; less(a[lo], a[j])) j--; exch(a, i, j); &#125; exch(a, lo, i); return i; &#125; private boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b) &lt; 0; &#125; private void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; public void show(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); System.out.println(); &#125; private static void shuffle(Object[] a) &#123; if (a == null) throw new IllegalArgumentException("argument array is null"); int n = a.length; for (int i = 0; i &lt; n; i++) &#123; int r = i + uniform(n-i); Object temp = a[i]; a[i] = a[r]; a[r] = temp; &#125; &#125; private static int uniform(int n) &#123; if (n &lt;= 0) throw new IllegalArgumentException("argument must be positive"); return random.nextInt(n); &#125;&#125; 特点将长度为N的无重复数组排序，快速排序平均需要~2NlnN次比较（以及1/6的交换），最多需要约N^2/2次比较，但随机打乱数组能够预防这种情况。 快速排序实现简单、适用于各种不同的输入数据且在一般应用中比其他排序算法都要快得多。 快速排序是原地排序（只需要一个很小的辅助栈），且将长度为N的数组排序所需的时间和NlgN成正比。 非常脆弱，在实现时要非常小心才能避免低劣的性能。 比较快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。 在第一种情况中，递归调用发生在处理整个数组之前；在第二种情况中，递归调用发生在处理整个数组之后。 在归并排序中，一个数组被等分为两半；在快速排序中，切分的位置取决于数组的内容。 三向切分的快速排序在有大量重复元素的情况下，快速排序的递归性会使元素全部重复的子数组经常出现。一个简单的想法是将数组切分为三部分，分别对应小于、等于和大于切分元素的数组元素。这样的切分能够将和切分元素相等的元素归位，就不会被包含在递归调用处理的子数组之中了。 对于包含大量重复元素的数组，三向切分的快速排序将排序时间从线性对数级降低到了线性级别。 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.Random;public class Quick &#123; private static Random random; private static long seed; static &#123; seed = System.currentTimeMillis(); random = new Random(seed); &#125; public void sort(Comparable[] a)&#123; shuffle(a); sort(a, 0, a.length-1); &#125; private void sort(Comparable[] a, int lo, int hi)&#123; if (hi &lt;= lo) return; int lt = lo; int gt = hi; int i = lo + 1; Comparable v = a[lo]; while (i &lt;= gt)&#123; if (a[i].compareTo(v) &lt; 0)&#123; exch(a, lt, i); lt++; i++; &#125; else if (a[i].compareTo(v) &gt; 0)&#123; exch(a, gt, i); gt--; &#125; else i++; &#125; sort(a, lo, lt-1); sort(a, gt+1, hi); &#125; private void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; public void show(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); System.out.println(); &#125; private static void shuffle(Object[] a) &#123; if (a == null) throw new IllegalArgumentException("argument array is null"); int n = a.length; for (int i = 0; i &lt; n; i++) &#123; int r = i + uniform(n-i); Object temp = a[i]; a[i] = a[r]; a[r] = temp; &#125; &#125; private static int uniform(int n) &#123; if (n &lt;= 0) throw new IllegalArgumentException("argument must be positive"); return random.nextInt(n); &#125;&#125; 特点对于大小为N的数组，三向切分的快速排序需要~(2ln2)NH次比较。其中H为由主键值出现频率定义的香农信息量。 堆排序堆排序可以分为两个阶段。在堆的构造阶段中，将原始数组重新组织安排进一个堆中（从右至左用sink函数构造子堆）；然后在下沉排序阶段，从堆中按递减顺序取出所有元素得到排序结果（将堆中的最大元素删除，然后放入堆缩小后数组空出的位置）。 示意 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Heap &#123; public void sort(Comparable[] a)&#123; int n = a.length; for (int i = n / 2; i &gt;= 1; i--) sink(a, i, n); while (n &gt; 1)&#123; exch(a, 0, n-1); sink(a, 1, --n); &#125; &#125; private boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b) &lt; 0; &#125; private void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; private void sink(Comparable[] a, int k, int n)&#123; while (2 * k &lt;= n)&#123; int j = 2 * k; if (j &lt; n &amp;&amp; less(a[j-1], a[j])) j++; if (!less(a[k-1], a[j-1])) break; exch(a, k-1, j-1); k = j; &#125; &#125; public void show(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); System.out.println(); &#125;&#125; 特点用下沉操作由N个元素构造堆只需少于2N次比较以及少于N次交换。 将N个元素排序，堆排序只需少于（2NlgN+2N）次比较（以及一半次数的交换）。 总结快速排序是最快的通用排序算法。]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】基础]]></title>
    <url>%2F2017%2F04%2F13%2F%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[链表链表是一种递归的数据结构，它或者为空（null），或者是指向一个结点（node）的引用，该结点含有一个泛型的元素和一个指向另一条链表的引用。 结点记录用一个嵌套类来定义结点的抽象数据类型。一个Node对象含有两个实例变量，类型分别为Item（参数类型）和Node。调用的结果是一个指向Node对象的引用，它的实例变量均被初始化为null。 1234private class Node&#123; Item item; Node next;&#125; 构造链表 在表头插入结点 从表头删除结点 在表尾插入结点 遍历123for (Node x = first; x != null; x = x.next)&#123; //处理x.item&#125; 优点 可以处理任意类型的数据 所需的空间总是和集合的大小成正比 操作所需的时间总是和集合的大小无关 栈栈是一种基于后进先出（LIFO）策略的集合类型。 实现将栈保存为一条链表，栈的顶部即为表头，实例变量first指向栈顶。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.Iterator;public class Stack&lt;E&gt; implements Iterable&lt;E&gt;&#123; private int n; private Node first; private class Node&#123; E e; Node next; &#125; public boolean isEmpty()&#123; return n == 0; &#125; public int size()&#123; return n; &#125; public void push(E e)&#123; Node oldFirst = first; first = new Node(); first.e = e; first.next = oldFirst; n++; &#125; public E pop()&#123; E e = first.e; first = first.next; n--; return e; &#125; public Iterator&lt;E&gt; iterator()&#123; return new ListIterator(); &#125; private class ListIterator implements Iterator&lt;E&gt;&#123; Node current = first; @Override public boolean hasNext() &#123; return current != null; &#125; @Override public E next() &#123; E e = current.e; current = current.next; return e; &#125; &#125;&#125; 队列队列是一种基于先进先出（FIFO）策略的集合类型。 实现将队列表示为一条从最早插入的元素到最近插入的元素的链表，实例变量first指向队列的开头，实例变量last指向队列的结尾。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Iterator;public class Queue&lt;E&gt; implements Iterable&lt;E&gt;&#123; private int n; private Node first; private Node last; private class Node&#123; E e; Node next; &#125; public boolean isEmpty()&#123; return n == 0; &#125; public int size()&#123; return n; &#125; public void enqueue(E e)&#123; Node oldLast = last; last = new Node(); last.e = e; if (isEmpty()) first = last; else oldLast.next = last; n++; &#125; public E dequeue()&#123; E e = first.e; first = first.next; if (isEmpty()) last = first; n--; return e; &#125; public Iterator&lt;E&gt; iterator()&#123; return new ListIterator(); &#125; private class ListIterator implements Iterator&lt;E&gt;&#123; Node current = first; @Override public boolean hasNext() &#123; return current != null; &#125; @Override public E next() &#123; E e = current.e; current = current.next; return e; &#125; &#125;&#125; 二叉堆在二叉堆的数组中，每个元素都要保证大于等于另两个特定位置的元素。相应地，这些位置的元素又至少要大于等于数组中的另两个元素，以此类推。 定义当一棵二叉树的结点都大于等于它的两个子结点时，它被称为堆有序。 二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组的第一个位置）。 根结点是堆有序的二叉树中的最大结点 一棵大小为N的完全二叉树的高度为floor(lgN) 示意 由下至上的堆有序化（上浮）如果堆的有序状态因为某个结点变得比它的父结点更大而被打破，那么就需要通过交换它和它的父结点来修复堆。 示意 实现123456private void swim(int k)&#123; while (k &gt; 1 &amp;&amp; less(k/2, k))&#123; exch(k, k/2); k /= 2; &#125;&#125; 由上至下的堆有序化（下沉）如果堆的有序状态因为某个结点变得比它的两个子结点或是其中之一更小了而被打破了，那么可以通过将它和它的两个子结点中的较大者交换来恢复堆。 示意 实现123456789101112131415private void sink(int k)&#123; while (2 * k &lt;= n)&#123; int j = 2 * k; if (j &lt; n &amp;&amp; less(j, j+1)) j++; if (!less(k, j)) break; exch(k, j); k = j; &#125;&#125; 优先队列优先队列是一种抽象数据类型，它表示了一组值和对这些值的操作。优先队列最重要的操作就是删除最大元素delMax()和插入元素insert()。 示意 插入元素将新元素加到数组末尾，增加堆的大小并让这个新元素上浮到合适的位置。 删除最大元素从数组顶端删去最大的元素并将数组的最后一个元素放到顶端，减小堆的大小并让这个元素下沉到合适的位置。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt; &#123; private Key[] pq; private int n = 0; public MaxPQ(int max)&#123; pq = (Key[]) new Comparable[max+1]; &#125; public boolean isEmpty()&#123; return n == 0; &#125; public int size()&#123; return n; &#125; public void insert(Key k)&#123; pq[++n] = k; swim(n); &#125; public Key delMax()&#123; Key k = pq[1]; exch(1, n); n--; pq[n+1] = null; sink(1); return k; &#125; private boolean less(int i, int j)&#123; return pq[i].compareTo(pq[j]) &lt; 0; &#125; private void exch(int i, int j)&#123; Key t = pq[i]; pq[i] = pq[j]; pq[j] = t; &#125; private void swim(int k)&#123; while (k &gt; 1 &amp;&amp; less(k/2, k))&#123; exch(k, k/2); k /= 2; &#125; &#125; private void sink(int k)&#123; while (2 * k &lt;= n)&#123; int j = 2 * k; if (j &lt; n &amp;&amp; less(j, j+1)) j++; if (!less(k, j)) break; exch(k, j); k = j; &#125; &#125;&#125; 特点对于一个含有N个元素的基于堆的优先队列，插入元素操作只需不超过（lgN+1）次比较，删除最大元素的操作需要不超过2lgN次比较。 二叉树二叉树由结点组成，结点包含的链接可以指向空（null）或者其他结点。在二叉树中，每个结点只能有一个父结点指向自己（只有一个例外，也就是根结点，它没有父结点），而且每个结点都只有左右两个链接，分别指向自己的左子结点和右子结点。 示意 二叉查找树一棵二叉查找树（BST）是一棵二叉树，其中每个结点都含有一个Comparable的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。 示意 查找 插入 向下取整 选择 删除最小键 删除 范围查找需要一个遍历二叉查找树的基本方法，叫做中序遍历。 平衡查找树在一棵含有N个结点的树中，树高为～lgN。 2-3查找树一棵2-3查找树或为一棵空树，或由以下结点组成： 2-结点，含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。 3-结点，含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。 将指向一棵空树的链接称为空链接。 一棵完美平衡的2-3查找树中的所有空链接到根结点的距离都应该是相同的。 示意 查找 插入向2-结点中插入新键 向一棵只含有一个3-结点的树中插入新键 向一个父结点为2-结点的3-结点中插入新键 向一个父结点为3-结点的3-结点中插入新键 分解根结点 特点在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过lgN个。 2-3树插入算法的根本在于这些变换都是局部的：除了相关的结点和链接之外不必修改或者检查树的其他部分。 这些局部变换不会影响树的全局有序性和平衡性：任意空链接到根结点的路径长度都是相等的。 比较和标准的二叉查找树由上向下生长不同，2-3树的生长是由下向上的。 需要维护两种不同类型的结点，将被查找的键和结点中的每个键进行比较，将链接和其他信息从一种结点复制到另一种结点，将结点从一种数据类型转换到另一种数据类型等等。实现这些不仅需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。 红黑二叉查找树红黑二叉查找树背后的基本思想是用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。将树中的链接分为两种类型： 红链接：将两个2-结点连接起来构成一个3-结点 黑链接：2-3树中的普通链接。 确切的说，将3-结点表示为由一条左斜的红色链接（两个2-结点其中之一是另一个的左子结点）相连的两个2-结点。 示意 定义红黑树是含有红黑链接并满足下列条件的二叉查找树： 红链接均为左链接 没有任何一个结点同时和两条红链接相连 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同 颜色表示 颜色转换 旋转 实现12345678910111213141516171819202122232425private Node rotateLeft(Node h)&#123; Node x = h.right; h.right = x.left; x.left = h; x.color = h.color; h.color = RED; x.n = h.n; h.n = size(h.left) + size(h.right) + 1; return x;&#125;private Node rotateRight(Node h)&#123; Node x = h.left; h.left = x.right; x.right = h; x.color = h.color; h.color = RED; x.n = h.n; h.n = size(h.left) + size(h.right) + 1; return x;&#125; 插入向2-结点中插入新键 向树底部的2-结点插入新键 向一棵双键树（即一个3-结点）中插入新键 向树底部的3-结点插入新键 删除不仅要在构造临时4-结点时沿着查找路径向下进行变换，还要在分解遗留的4-结点时沿着查找路径向上进行变换。 删除最小键 特点 对于任意的2-3树，只要对结点进行转换，都可以立即派生出一棵对应的二叉查找树。 红黑树既是二叉查找树，也是2-3树。 散列表示意 散列函数如果有一个能够保存M个键值对的数组，那么就需要一个能够将任意键转化为该数组范围内的索引（[0, M-1]范围内的整数）的散列函数。要找的散列函数应该易于计算并且能够均匀分布所有的键，即对于任意键，0到M-1之间的每个整数都有相等的可能性与之对应（与键无关）。 特点散列表是算法在时间和空间上作出权衡的经典例子。不必重写代码，只需要调整散列算法的参数就可以在空间和时间之间作出取舍。 邻接表将每个顶点的所有相邻顶点都保存在该顶点对应的元素所指向的一张链表中。 示意 特点 使用的空间和V+E成正比 添加一条边所需的时间为常数 遍历顶点v的所有相邻顶点所需的时间和v的度数成正比（处理每个相邻顶点所需的时间为常数） 无向图边仅仅是两个顶点之间的连接。 当两个顶点通过一条边相连时，称这两个顶点是相邻的，并称该连接依附于这两个顶点。某个顶点的度数即为依附于它的边的总数。子图是由一幅图的所有边的一个子集（以及它们所依附的所有顶点）组成的图。 当两个顶点之间存在一条连接双方的路径时，称一个顶点和另一个顶点是连通的。 特殊的图： 自环，即一条连接一个顶点和其自身的边 连接同一对顶点的两条边称为平行边 当且仅当一幅含有V个结点的图G满足下列5个条件之一时，它就是一棵树： G有V-1条边且不含有环 G有V-1条边且是连通的 G是连通的，但删除任意一条边都会使它不再连通 G是无环图，但添加任意一条边都会产生一条环 G中的任意一对顶点之间仅存在一条简单路径 图的密度是指已经连接的顶点对占所有可能被连接的顶点对的比例。在稀疏图中，被连接的顶点对很少；而在稠密图中，只有少部分顶点对之间没有边连接。 二分图是一种能够将所有结点分为两部分的图，其中图的每条边所连接的两个顶点都分别属于不同的部分。 定义图是由一组顶点和一组能够将两个顶点相连的边组成的。 在图中，路径是由边顺序连接的一系列顶点。简单路径是一条没有重复顶点的路径。环是一条至少含有一条边且起点和终点相同的路径，简单环是一条（除了起点和终点必须相同之外）不含有重复顶点和边的环。路径或者环的长度为其中所包含的边数。 如果从任意一个顶点都存在一条路径到达另一个任意顶点，称这幅图是连通图。一幅非连通的图由若干连通的部分组成，它们都是其极大连通子图。 树是一幅无环连通图。互不相连的树组成的集合称为森林。连通图的生成树是它的一幅子图，它含有图中的所有顶点且是一棵树。图的生成树森林是它的所有连通子图的生成树的集合。 示意 实现1234567891011121314151617181920212223242526272829303132public class Graph &#123; private final int V; private int E; private Stack&lt;Integer&gt;[] adj; public Graph(int V)&#123; this.V = V; this.E = 0; adj = (Stack&lt;Integer&gt;[]) new Stack[V]; for (int v = 0; v &lt; V; v++) adj[v] = new Stack&lt;Integer&gt;(); &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; public void addEdge(int v, int w)&#123; adj[v].push(w); adj[w].push(v); E++; &#125; public Iterable&lt;Integer&gt; adj(int v)&#123; return adj[v]; &#125;&#125; 有向图边是单向的：每条边所连接的两个顶点都是一个有序对，它们的邻接性是单向的。 一个顶点的出度为由该顶点指出的边的总数；一个顶点的入度为指向该顶点的边的总数。 一条有向边的第一个顶点称为它的头，第二个顶点则被称为它的尾。 两个顶点是强连通的当且仅当它们都在一个普通的有向环中。 有向图中的强连通性是一种顶点之间平等关系，因为它有着以下性质： 自反性：任意顶点v和自己都是强连通的。 对称性：如果v和w是强连通的，那么w和v也是强连通的。 传递性：如果v和w是强连通的且w和x也是强连通的，那么v和x也是强连通的。 作为一种平等关系，强连通行将所有顶点分为了一些平等的部分，每个部分都是由相互均为强连通的顶点的最大子集组成的，将这些子集称为强连通分量。一个含有V个顶点的有向图含有1～V个强连通分量，一个强连通图只含有一个强连通分量，而一个有向无环图中则含有V个强连通分量。 定义一幅有方向性的图（或有向图）是由一组顶点和一组有方向的边组成的，每条有方向的边都连接着有序的一对顶点。 在一幅有向图中，有向路径由一系列顶点组成，对于其中的每个顶点都存在一条有向边从它指向序列中的下一个顶点。有向环为一条至少含有一条边且起点和终点相同的有向路径。简单有向环是一条（除了起点和终点必须相同之外）不含有重复的顶点和边的环。路径或者环的长度即为其中所包含的边数。 如果两个顶点v和w是互相可达的，则称它们为强连通的。也就是说，既存在一条从v到w的有向路径，也存在一条从w到v的有向路径。如果一幅有向图中的任意两个顶点都是强连通的，则称这幅有向图也是强连通的。 示意 实现12345678910111213141516171819202122232425262728293031323334353637383940414243public class Digraph &#123; private final int V; private int E; private Stack&lt;Integer&gt;[] adj; public Digraph(int V)&#123; this.V = V; this.E = 0; adj = (Stack&lt;Integer&gt;[]) new Stack[V]; for (int v = 0; v &lt; V; v++)&#123; adj[v] = new Stack&lt;Integer&gt;(); &#125; &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; public void addEdge(int v, int w)&#123; adj[v].push(w); E++; &#125; public Iterable&lt;Integer&gt; adj(int v)&#123; return adj[v]; &#125; public Digraph reverse()&#123; Digraph tmp = new Digraph(V); for (int v = 0; v &lt; V; v++)&#123; for (int w : adj[v]) tmp.addEdge(w, v); &#125; return tmp; &#125;&#125; 加权无向图加权图是一种为每条边关联一个权值或是成本的图模型。 示意 实现123456789101112131415161718192021222324252627282930public class Edge implements Comparable&lt;Edge&gt; &#123; private final int v; private final int w; private final double weight; public Edge(int v, int w, double weight)&#123; this.v = v; this.w = w; this.weight = weight; &#125; public double weight()&#123; return weight; &#125; public int either()&#123; return v; &#125; public int other(int vertex)&#123; if (vertex == v) return w; else return v; &#125; public int compareTo(Edge that)&#123; return Double.compare(this.weight, that.weight); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class EdgeWeightedGraph &#123; private final int V; private int E; private Stack&lt;Edge&gt;[] adj; public EdgeWeightedGraph(int V)&#123; this.V = V; this.E = 0; adj = (Stack&lt;Edge&gt;[]) new Stack[V]; for (int v = 0; v &lt; V; v++) adj[v] = new Stack&lt;Edge&gt;(); &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; public void addEdge(Edge e)&#123; int v = e.either(); int w = e.other(v); adj[v].push(e); adj[w].push(e); E++; &#125; public Iterable&lt;Edge&gt; adj(int v)&#123; return adj[v]; &#125; public Iterable&lt;Edge&gt; edges()&#123; Stack&lt;Edge&gt; stack = new Stack&lt;Edge&gt;(); for (int v = 0; v &lt; V; v++)&#123; for(Edge e : adj[v])&#123; if (e.other(v) &gt; v) stack.push(e); &#125; &#125; return stack; &#125;&#125; 最小生成树定义图的生成树是它的一棵含有其所有顶点的无环连通子图。一幅加权无向图的最小生成树（MST）是它的一棵权值（树中所有边的权值之和）最小的生成树。 示意 切分定理把加权图中的所有顶点分为两个集合、检查横跨两个集合的所有边并识别哪条边应属于图的最小生成树。通常，通过指定一个顶点集并隐式地认为它的补集为另一个顶点集来指定一个切分。这样，一条横切边就是连接该集合的一个顶点和不在该集合中的另一个顶点的一条边。 定义图的一种切分是将图的所有顶点分为两个非空且不重复的两个集合。横切边是一条连接两个属于不同集合的顶点的边。 在一幅加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树。 示意 贪心算法使用切分定理找到最小生成树的一条边，不断重复直到找到最小生成树的所有边。 定义将含有V个顶点的任意加权连通图中属于最小生成树的边标记为黑色：初始状态下所有边均为灰色，找到一种切分，它产生的横切边均不为黑色。将它权重最小的横切边标记为黑色。反复，直到标记了V-1条黑色边为止。 示意 加权有向图在加权有向图中，每条有向路径都有一个与之关联的路径权重。 示意 实现1234567891011121314151617181920212223public class DirectedEdge &#123; private final int v; private final int w; private final double weight; public DirectedEdge(int v, int w, double weight)&#123; this.v = v; this.w = w; this.weight = weight; &#125; public double weight()&#123; return weight; &#125; public int from()&#123; return v; &#125; public int to()&#123; return w; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142public class EdgeWeightedDigraph &#123; private final int V; private int E; private Stack&lt;DirectedEdge&gt;[] adj; public EdgeWeightedDigraph(int V)&#123; this.V = V; this.E = 0; adj = (Stack&lt;DirectedEdge&gt;[]) new Stack[V]; for (int v = 0; v &lt; V; v++) adj[v] = new Stack&lt;DirectedEdge&gt;(); &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; public void addEdge(DirectedEdge e)&#123; adj[e.from()].push(e); E++; &#125; public Iterable&lt;DirectedEdge&gt; adj(int v)&#123; return adj[v]; &#125; public Iterable&lt;DirectedEdge&gt; edges()&#123; Stack&lt;DirectedEdge&gt; stack = new Stack&lt;DirectedEdge&gt;(); for (int v = 0; v &lt; V; v++)&#123; for(DirectedEdge e : adj[v]) stack.push(e); &#125; return stack; &#125;&#125; 最短路径树最短路径定义在一幅加权有向图中，从顶点s到顶点t的最短路径是所有从s到t的路径中的权重最小者。 示意 定义给定一幅加权有向图和一个顶点s，以s为起点的一棵最短路径树是图的一幅子图，它包含s和从s可达的所有顶点。这棵有向树的根结点为s，树的每条路径都是有向图中的一条最短路径。 示意 边的松弛放松边v-&gt;w意味着检查从s到w的最短路径是否是先从s到v，然后再由v到w。如果是，则根据这个情况更新数据结构的内容。 示意 实现123456789private void relax(DirectedEdge e)&#123; int v = e.from(); int w = e.to(); if (distTo[v] + e.weight() &lt; distTo[w])&#123; distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; &#125;&#125; 顶点的松弛放松从一个给定顶点指出的所有边。 示意 实现12345678910private void relax(EdgeWeightedDigraph g, int v)&#123; for (DirectedEdge e : g.adj(v))&#123; int w = e.to(); if (distTo[v] + e.weight() &lt; distTo[w])&#123; distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; &#125; &#125;&#125; 负权重的环示意 定义加权有向图中的负权重环是一个总权重（环上的所有边的权重之和）为负的有向环。 当且仅当加权有向图中至少存在一条从s到v的有向路径且所有从s到v的有向路径上的任意顶点都不存在于任何负权重环中时，s到v的最短路径才是存在的。]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[hihoCoder] Problem 1288 - Font Size]]></title>
    <url>%2F2017%2F04%2F01%2FhihoCoder-Problem-1288-Font-Size%2F</url>
    <content type="text"><![CDATA[Steven loves reading book on his phone. The book he reads now consists of N paragraphs and the i-th paragraph contains ai characters. Steven wants to make the characters easier to read, so he decides to increase the font size of characters. But the size of Steven’s phone screen is limited. Its width is W and height is H. As a result, if the font size of characters is S then it can only show ⌊W / S⌋ characters in a line and ⌊H / S⌋ lines in a page. (⌊x⌋ is the largest integer no more than x) So here’s the question, if Steven wants to control the number of pages no more than P, what’s the maximum font size he can set? Note that paragraphs must start in a new line and there is no empty line between paragraphs. Time Limit:10000msCase Time Limit:1000msMemory Limit:256MB InputInput may contain multiple test cases. The first line is an integer TASKS, representing the number of test cases. For each test case, the first line contains four integers N, P, W and H, as described above. The second line contains N integers a1, a2, … aN, indicating the number of characters in each paragraph. For all test cases, 1 &lt;= N &lt;= 10^3, 1 &lt;= W, H, ai &lt;= 10^3, 1 &lt;= P &lt;= 10^6, There is always a way to control the number of pages no more than P. OutputFor each testcase, output a line with an integer Ans, indicating the maximum font size Steven can set. Sample Input21 10 4 3102 10 4 310 10 Sample Output32 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int t = sc.nextInt(); for (int i = 0; i &lt; t; i++) &#123; int n = sc.nextInt(); int p = sc.nextInt(); int w = sc.nextInt(); int h = sc.nextInt(); if (n &lt; 1 || n &gt; 1000 || w &lt; 1 || w &gt; 1000 || h &lt; 1 || h &gt; 1000 || p &lt; 1 || p &gt; 1000000) return; int[] a = new int[n]; for (int j = 0; j &lt; n; j++)&#123; int x = sc.nextInt(); if (x &lt; 1 || x &gt; 1000) return; a[j] = x; &#125; int result = binarySearch(w, h, p, a); System.out.println(result); &#125; &#125; private static double validatePages(int mid, int w, int h, int[] a) &#123; double charactersPerLine = w / mid; double linesPerPage = h / mid; int lines = 0; for (int i = 0; i &lt; a.length; i++) lines += Math.ceil(a[i] / charactersPerLine); double pages = Math.ceil(lines / linesPerPage); return pages; &#125; private static int binarySearch(int w, int h, int p, int[] a) &#123; int left = 0; int right = Math.min(w, h); int result = 0; while (left &lt;= right)&#123; int mid = (left + right) / 2; if (validatePages(mid, w, h, a) &lt;= p)&#123; result = mid; left = mid + 1; &#125; else right = mid - 1; &#125; return result; &#125; &#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LightOJ] Problem 1138 - Trailing Zeroes (III)]]></title>
    <url>%2F2017%2F04%2F01%2FLightOJ-Problem-1138-Trailing-Zeroes-III%2F</url>
    <content type="text"><![CDATA[You task is to find minimal natural number N, so that N! contains exactly Q zeroes on the trail in decimal notation. As you know N! = 12…*N. For example, 5! = 120, 120 contains one zero on the trail. Time Limit: 2 second(s)Memory Limit: 32 MB InputInput starts with an integer T (≤ 10000), denoting the number of test cases. Each case contains an integer Q (1 ≤ Q ≤ 10^8) in a line. OutputFor each case, print the case number and N. If no solution is found then print ‘impossible’. Sample Input3125 Output for Sample InputCase 1: 5Case 2: 10Case 3: impossible Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int t = sc.nextInt(); if (t &lt; 1 || t &gt; 10000) return; for (int i = 1; i &lt;= t; i++) &#123; int x = sc.nextInt(); if (x &lt; 1 || x &gt; Math.pow(10, 8)) return; long result = binarySearch(1, Long.MAX_VALUE, x); if (result != -1) System.out.println("Case " + i + ": " + result); else System.out.println("Case " + i + ": impossible"); &#125; &#125; private static long trailingZeroes(long n) &#123; return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5); &#125; private static long binarySearch(long left, long right, long key) &#123; while (left &lt;= right)&#123; long mid = (left + right) / 2; if (trailingZeroes(mid) == key &amp;&amp; trailingZeroes(mid - 1) &lt; key) return mid; else if (trailingZeroes(mid) &lt; key) left = mid + 1; else right = mid - 1; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Torch Demo]]></title>
    <url>%2F2017%2F03%2F18%2FTorch-Demo%2F</url>
    <content type="text"><![CDATA[We have 5 steps to do in training a torch neural network. *(1) Load and normalize data; **(2) Define Neural Network; **(3) Define Loss function; **(4) Train network on training data; **(5) Test network on test data. * Tutorialcvpr2015/Deep Learning with Torch.ipynb Code12345require 'paths'require 'nn'require 'torch'require 'cunn'require 'cutorch' Load and normalize data12345678910111213141516171819if (not paths.filep("cifar10torchsmall.zip")) then os.execute('wget -c https://s3.amazonaws.com/torch7/data/cifar10torchsmall.zip') os.execute('unzip cifar10torchsmall.zip')endtrainset = torch.load('cifar10-train.t7')testset = torch.load('cifar10-test.t7')classes = &#123;'airplane', 'automobile', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck'&#125;setmetatable(trainset, &#123;__index = function(t, i) return &#123;t.data[i], t.label[i]&#125; end&#125;);function trainset:size() return self.data:size(1)end 1234567891011121314151617trainset.data = trainset.data:double()testset.data = testset.data:double()mean = &#123;&#125;stdv = &#123;&#125;for i=1,3 do mean[i] = trainset.data[&#123; &#123;&#125;, &#123;i&#125;, &#123;&#125;, &#123;&#125; &#125;]:mean() --print('Channel ' .. i .. ', Mean: ' .. mean[i]) trainset.data[&#123; &#123;&#125;, &#123;i&#125;, &#123;&#125;, &#123;&#125; &#125;]:add(-mean[i]) stdv[i] = trainset.data[&#123; &#123;&#125;, &#123;i&#125;, &#123;&#125;, &#123;&#125; &#125;]:std() --print('Channel ' .. i .. ', Standard Deviation: ' .. stdv[i]) trainset.data[&#123; &#123;&#125;, &#123;i&#125;, &#123;&#125;, &#123;&#125; &#125;]:div(stdv[i])endfor i=1,3 do testset.data[&#123; &#123;&#125;, &#123;i&#125;, &#123;&#125;, &#123;&#125; &#125;]:add(-mean[i]) testset.data[&#123; &#123;&#125;, &#123;i&#125;, &#123;&#125;, &#123;&#125; &#125;]:div(stdv[i])end Define neural network1234567891011121314net = nn.Sequential()net:add(nn.SpatialConvolution(3, 6, 5, 5)) -- 3 input image channels, 6 output channels, 5x5 convolution kernelnet:add(nn.ReLU()) -- non-linearitynet:add(nn.SpatialMaxPooling(2,2,2,2)) -- A max-pooling operation that looks at 2x2 windows and finds the max.net:add(nn.SpatialConvolution(6, 16, 5, 5))net:add(nn.ReLU()) -- non-linearitynet:add(nn.SpatialMaxPooling(2,2,2,2))net:add(nn.View(16*5*5)) -- reshapes from a 3D tensor of 16x5x5 into 1D tensor of 16*5*5net:add(nn.Linear(16*5*5, 120)) -- fully connected layer (matrix multiplication between input and weights)net:add(nn.ReLU()) -- non-linearitynet:add(nn.Linear(120, 84))net:add(nn.ReLU()) -- non-linearitynet:add(nn.Linear(84, 10)) -- 10 is the number of outputs of the network (in this case, 10 digits)net:add(nn.LogSoftMax()) -- converts the output to a log-probability. Useful for classification problems Define the Loss function1criterion = nn.ClassNLLCriterion() Train the neural network1234trainer = nn.StochasticGradient(net, criterion)trainer.learningRate = 0.001trainer.maxIteration = 5trainer:train(trainset) 1234567-- train on GPUnet = net:cuda()criterion = criterion:cuda()trainset.data = trainset.data:cuda()trainset.label = trainset.label:cuda()testset.data = testset.data:cuda()testset.label = testset.label:cuda() Test the network, print accuracy12345678910111213141516correct = 0class_performance = &#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;for i=1,10000 do local groundtruth = testset.label[i] local prediction = net:forward(testset.data[i]) local confidences, indices = torch.sort(prediction, true) -- true means sort in descending order if groundtruth == indices[1] then correct = correct + 1 class_performance[groundtruth] = class_performance[groundtruth] + 1 endendprint(correct, 100*correct/10000 .. " % ")for i=1,#classes do print(classes[i], 100*class_performance[i]/1000 .. ' %')end ResultIt’ll take around 30 minutes to get the result on CPU. However, it’ll cost less than 10 minutes on GPU. 1th filename.lua On CPU On GPU]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Torch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
