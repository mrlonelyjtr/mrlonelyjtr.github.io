<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Map与JavaBean之间相互转化]]></title>
      <url>%2F2018%2F12%2F17%2FMap%E4%B8%8EJavaBean%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96%2F</url>
      <content type="text"><![CDATA[反射可以操作各种不同的Java类，而内省只是通过反射来操作JavaBean的。 内省12345678910111213141516171819202122232425262728293031323334353637383940public Map&lt;String, Object&gt; beanToMap(Object bean) &#123; Map&lt;String, Object&gt; map = new HashMap(); try &#123; BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass(), Object.class); PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : propertyDescriptors) &#123; String key = propertyDescriptor.getName(); Object value = propertyDescriptor.getReadMethod().invoke(bean); map.put(key, value); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return map;&#125;public &lt;T&gt; T mapToBean(Map&lt;String, Object&gt; map, Class&lt;T&gt; beanType) &#123; T bean = null; try &#123; bean = beanType.newInstance(); BeanInfo beanInfo = Introspector.getBeanInfo(beanType, Object.class); PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : propertyDescriptors) &#123; String key = propertyDescriptor.getName(); Object value = map.get(key); propertyDescriptor.getWriteMethod().invoke(bean, value); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bean;&#125; 反射12345678910111213141516171819202122232425262728293031323334353637383940public Map&lt;String, Object&gt; beanToMap(Object bean) &#123; Map&lt;String, Object&gt; map = new HashMap(); try &#123; Class cls = bean.getClass(); Field[] fields = cls.getDeclaredFields(); for (Field field : fields) &#123; field.setAccessible(true); String key = field.getName(); Object value = field.get(bean); map.put(key, value); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return map;&#125;public &lt;T&gt; T mapToBean(Map&lt;String, Object&gt; map, Class&lt;T&gt; beanType) &#123; T bean = null; try &#123; bean = beanType.newInstance(); for (String key : map.keySet()) &#123; Object value = map.get(key); Field field = beanType.getDeclaredField(key); field.setAccessible(true); field.set(bean, value); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bean;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[InterruptedException异常]]></title>
      <url>%2F2018%2F12%2F14%2FInterruptedException%E5%BC%82%E5%B8%B8%2F</url>
      <content type="text"><![CDATA[如果方法后面加了throws InterruptedException，则表明该方法中（或者该方法进一步调用的方法中）可能会抛出InterruptedException异常。 加了throws InterruptedException的方法在Java的标准类库中，加了throws InterruptedException的典型方法有如下三个： java.lang.Object类的wait方法 java.lang.Thread类的sleep方法 java.lang.Thread类的join方法 花费时间的方法线程执行wait方法后，会进入等待队列，等待被notify/notifyAll。在等待期间，线程是不运行的，但需要花费时间来等待被notify/notifyAll。线程执行sleep方法后，会暂停执行（暂停多长时间由参数指定）。这也是花费时间的方法。线程执行join方法后，会等待指定线程终止。该方法需要花费时间，来等待指定线程终止。 可以取消的方法花费时间的处理会降低程序的响应性，所以如果存在像下面这样可以中途停止执行（取消）的方法，就非常方便了。 取消“wait方法等待notify/notifyAll”的处理 取消“在sleep方法指定的时间内停止执行”的处理 取消“join方法等待其他线程终止”的处理 sleep方法和interrupt方法使用的interrupt方法是Thread类的实例方法。当执行interrupt时，线程并不需要获取Thread实例的锁。无论何时，任何线程都可以调用其他线程的interrupt方法。interrupt方法被调用后，正在sleep的线程会终止暂停状态，抛出InterruptedException异常。这样，线程的控制权就会转移到捕捉该异常的catch语句块中。 wait方法和interrupt方法当使用interrupt方法时，该操作意即告诉正在wait的线程“不用再等待notify/notifyAll了，从等待队列出来吧”。但在wait的情况下，需要注意锁的问题。线程在进入等待队列时，已经释放了锁。当正在wait的线程被调用interrupt方法时（即线程被取消执行时），该线程会在重新获取锁之后，抛出InterruptedException异常。在获取锁之前，线程不会抛出InterruptedException异常。 join方法和interrupt方法由于调用join方法时无需获取锁，所以与使用sleep暂停运行时一样，线程的控制权也会立即跳到catch语句块中。 interrupt方法只是改变中断状态所谓中断状态（interrupted status），是一种用于表示线程是否被中断的状态。interrupt方法只是改变了线程的中断状态而已。当线程A执行了sleep、wait、join而停止运行时，线程B调用了A的interrupt方法。这时，线程A的确会抛出InterruptedException异常。但这其实是因为sleep、wait、join方法内部对线程的中断状态进行了检查，进而抛出了InterruptedException异常。如果没有调用sleep、wait、join等方法，或者没有编写检查线程的中断状态并抛出InterruptedException异常的代码，那么InterruptedException异常就不会被抛出。 isInterrupted方法——检查中断状态isInterrupted是Thread类的实例方法，用于检查指定线程的中断状态。若指定线程处于中断状态，则返回true；若指定线程未处于中断状态（即处于非中断状态），则返回false。isInterrupted并不会改变中断状态。 Thread.interrupted方法——检查并清除中断状态Thread.interrupted是Thread类的静态方法，用于检查并清除当前线程的中断状态。若当前线程处于中断状态，则返回true；若当前线程未处于中断状态，则返回false。调用Thread.interrupted后，中断状态会被清除（线程变为非中断状态）。只有这个方法才可以清除中断状态。Thread.interrupted的操作对象是当前线程（即线程本身），所以该方法并不能用于清除其他线程的中断状态。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【图解Java多线程设计模式】Producer-Consumer模式]]></title>
      <url>%2F2018%2F11%2F29%2F%E3%80%90%E5%9B%BE%E8%A7%A3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Producer-Consumer%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[生产者安全地将数据交给消费者。Producer-Consumer模式在生产者和消费者之间加入了一个“桥梁角色”。该桥梁角色用于消除线程间处理速度的差异。 示例有3位糕点师制作蛋糕并将其放到桌子上，然后有3位客人来吃这些蛋糕。 时序图 Main.java123456789101112public class Main &#123; public static void main(String[] args) &#123; Table table = new Table(3); new MakerThread("MakerThread-1", table, 31415).start(); new MakerThread("MakerThread-2", table, 92653).start(); new MakerThread("MakerThread-3", table, 58979).start(); new EaterThread("EaterThread-1", table, 32384).start(); new EaterThread("EaterThread-2", table, 62643).start(); new EaterThread("EaterThread-3", table, 38327).start(); &#125;&#125; MakerThread.java12345678910111213141516171819202122232425262728import java.util.Random;public class MakerThread extends Thread &#123; private final Table table; private static int id = 0; private final Random random; public MakerThread(String name, Table table, long seed) &#123; super(name); this.table = table; this.random = new Random(seed); &#125; public void run() &#123; try &#123; while (true) &#123; Thread.sleep(random.nextInt(1000)); String cake = "[ Cake No." + nextId() + " by " + getName() + " ]"; table.put(cake); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125; private static synchronized int nextId() &#123; return id++; &#125;&#125; EaterThread.java12345678910111213141516171819202122import java.util.Random;public class EaterThread extends Thread &#123; private final Table table; private final Random random; public EaterThread(String name, Table table, long seed) &#123; super(name); this.table = table; this.random = new Random(seed); &#125; public void run() &#123; try &#123; while (true) &#123; String cake = table.take(); Thread.sleep(random.nextInt(1000)); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125; Table.java1234567891011121314151617181920212223242526272829303132333435363738public class Table &#123; private final String[] buffer; private int head; private int tail; private int count; public Table(int count) &#123; this.buffer = new String[count]; this.head = 0; this.tail = 0; this.count = 0; &#125; public synchronized void put(String cake) throws InterruptedException &#123; while (count &gt;= buffer.length) &#123; wait(); &#125; System.out.println(Thread.currentThread().getName() + " puts " + cake); buffer[tail] = cake; tail = (tail + 1) % buffer.length; count++; notifyAll(); &#125; public synchronized String take() throws InterruptedException &#123; while (count &lt;= 0) &#123; wait(); &#125; String cake = buffer[head]; head = (head + 1) % buffer.length; count--; notifyAll(); System.out.println(Thread.currentThread().getName() + " takes " + cake); return cake; &#125;&#125; 运行结果12345678910111213141516171819202122232425262728293031323334MakerThread-3 puts [ Cake No.20 by MakerThread-3 ]EaterThread-3 takes [ Cake No.20 by MakerThread-3 ]MakerThread-2 puts [ Cake No.21 by MakerThread-2 ]MakerThread-1 puts [ Cake No.22 by MakerThread-1 ]EaterThread-3 takes [ Cake No.21 by MakerThread-2 ]EaterThread-1 takes [ Cake No.22 by MakerThread-1 ]MakerThread-3 puts [ Cake No.23 by MakerThread-3 ]EaterThread-2 takes [ Cake No.23 by MakerThread-3 ]MakerThread-1 puts [ Cake No.24 by MakerThread-1 ]MakerThread-2 puts [ Cake No.25 by MakerThread-2 ]EaterThread-3 takes [ Cake No.24 by MakerThread-1 ]EaterThread-3 takes [ Cake No.25 by MakerThread-2 ]MakerThread-2 puts [ Cake No.26 by MakerThread-2 ]MakerThread-1 puts [ Cake No.27 by MakerThread-1 ]EaterThread-1 takes [ Cake No.26 by MakerThread-2 ]EaterThread-2 takes [ Cake No.27 by MakerThread-1 ]MakerThread-2 puts [ Cake No.28 by MakerThread-2 ]EaterThread-2 takes [ Cake No.28 by MakerThread-2 ]MakerThread-3 puts [ Cake No.29 by MakerThread-3 ]EaterThread-3 takes [ Cake No.29 by MakerThread-3 ]MakerThread-2 puts [ Cake No.30 by MakerThread-2 ]EaterThread-1 takes [ Cake No.30 by MakerThread-2 ]MakerThread-2 puts [ Cake No.31 by MakerThread-2 ]MakerThread-1 puts [ Cake No.32 by MakerThread-1 ]MakerThread-3 puts [ Cake No.33 by MakerThread-3 ]EaterThread-1 takes [ Cake No.31 by MakerThread-2 ]MakerThread-1 puts [ Cake No.34 by MakerThread-1 ]EaterThread-2 takes [ Cake No.32 by MakerThread-1 ]EaterThread-3 takes [ Cake No.33 by MakerThread-3 ]MakerThread-1 puts [ Cake No.35 by MakerThread-1 ]EaterThread-2 takes [ Cake No.34 by MakerThread-1 ]EaterThread-1 takes [ Cake No.35 by MakerThread-1 ]MakerThread-2 puts [ Cake No.36 by MakerThread-2 ]EaterThread-1 takes [ Cake No.36 by MakerThread-2 ] 登场角色DataData角色由Producer角色生成，供Consumer角色使用。在示例程序中，由String类扮演此角色。 Producer（生产者）Producer角色生成Data角色，并将其传递给Channel角色。在示例程序中，由MakerThread扮演此角色。 Consumer（消费者）Consumer角色从Channel角色获取Data角色并使用。在示例程序中，由EaterThread扮演此角色。 Channel（通道）Channel角色保管从Producer角色获取的Data角色，还会响应Consumer角色的请求，传递Data角色。为了确保安全性，Channel角色会对Producer角色和Consumer角色的访问执行互斥处理。当Producer角色将Data角色传递给Channel角色时，如果Channel角色的状态不适合接收Data角色，那么Producer角色将一直等待，直至Channel角色的状态变为可以接收为止。当Consumer角色从Channel角色获取Data角色时，如果Channel角色中没有可以传递的Data角色，那么Consumer角色将一直等待，直至Channel的状态变为可以传递Data角色为止。在示例程序中，由Table类扮演此角色。 类图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[超时]]></title>
      <url>%2F2018%2F11%2F22%2F%E8%B6%85%E6%97%B6%2F</url>
      <content type="text"><![CDATA[介于“直接balk并返回”和“等待到守护条件成立为止”这两种极端的处理方法之间，还有一种处理方法，那就是“在守护条件成立之前等待一段时间”。在守护条件成立之前等待一段时间，如果到时条件还未成立，则直接balk。将这种处理称为guarded timed或timeout。 wait何时终止在调用Java的wait方法时，可以传入参数，以指定超过时间。线程进入obj的等待队列，停止运行，并释放持有的obj锁。当下列情况发生时，线程便会退出等待队列。 notify方法执行时即obj的notify方法被执行后，线程被唤醒了的情况。但当等待队列中有多个等待线程时，只能有一个线程被唤醒。到底唤醒哪一个线程，Java规范中并没有明确规定。 notifyAll方法执行时即obj的notifyAll方法被执行了的情况。notifyAll会唤醒实例的等待队列中的所有线程。不管是notify，还是notifyAll，线程被唤醒后，都必须重新获取obj的锁。 interrupt方法执行时即线程的interrupt方法被执行了的情况。当被interrupt时，等待队列中的线程（与被notify、notifyAll时一样）会重新获取obj的锁，然后抛出InterruptedException异常。notify和notifyAll这两个方法是用于调用实例的，而interrupt方法是用于调用线程的。 超时发生时即wait方法的参数中指定的超时时间到期的情况。与被notify、notifyAll时一样，这时也要重新获取obj的锁。 guarded timed的实现使用wait方法来实现guarded timed。超时异常使用java.util.concurrent.TimeoutException。 Host.java123456789101112131415161718192021222324252627282930313233343536import java.util.concurrent.TimeoutException;public class Host &#123; private final long timeout; private boolean ready = false; public Host(long timeout) &#123; this.timeout = timeout; &#125; public synchronized void setExecutable(boolean on) &#123; ready = on; notifyAll(); &#125; public synchronized void execute() throws InterruptedException, TimeoutException &#123; long start = System.currentTimeMillis(); while (!ready) &#123; long now = System.currentTimeMillis(); long rest = timeout - (now - start); if (rest &lt;= 0) &#123; throw new TimeoutException("now - start = " + (now - start) + ", timeout = " + timeout); &#125; wait(rest); &#125; doExecute(); &#125; private void doExecute() &#123; System.out.println(Thread.currentThread().getName() + " calls doExecute"); &#125;&#125; Main.java1234567891011121314151617import java.util.concurrent.TimeoutException;public class Main &#123; public static void main(String[] args) &#123; Host host = new Host(10000); try &#123; System.out.println("execute BEGIN"); host.execute(); &#125; catch (TimeoutException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果1234execute BEGINjava.util.concurrent.TimeoutException: now - start = 10004, timeout = 10000 at Host.execute(Host.java:24) at Main.main(Main.java:10) java.util.concurrent中的超时java.util.concurrent包中提供了如下两个用于超时处理的方法。 通过异常通知超时当发生超时抛出异常时，返回值并不适合用于表示超时，需要使用java.util.concurrent.TimeoutException异常。 java.util.concurrent.Future接口的get方法 java.util.concurrent.Exchanger类的exchange方法 java.util.concurrent.Cyclicarrier类的await方法 java.util.concurrent.CountDownLatch类的await方法 通过返回值通知超时当执行多次try时，则不使用异常，而是使用返回值来表示超时。 java.util.concurrent.BlockingQueue接口 java.util.concurrent.Semaphore类 java.util.concurrent.locks.lock接口]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【图解Java多线程设计模式】Balking模式]]></title>
      <url>%2F2018%2F11%2F21%2F%E3%80%90%E5%9B%BE%E8%A7%A3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Balking%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[如果现在不适合执行这个操作，或者没必要执行这个操作，就停止处理，直接返回。 示例定期将当前数据内容写入文件中。当数据内容被写入时，会完全覆盖上次写入的内容，只有最新的内容才会被保存。 时序图 Data.java123456789101112131415161718192021222324252627282930313233343536import java.io.FileWriter;import java.io.IOException;import java.io.Writer;public class Data &#123; private final String filename; private String content; private boolean changed; public Data(String filename, String content) &#123; this.filename = filename; this.content = content; this.changed = true; &#125; public synchronized void change(String newContent) &#123; content = newContent; changed = true; &#125; public synchronized void save() throws IOException &#123; if (!changed) &#123; return; &#125; doSave(); changed = false; &#125; private void doSave() throws IOException &#123; System.out.println(Thread.currentThread().getName() + " calls doSave, content = " + content); Writer writer = new FileWriter(filename); writer.write(content); writer.close(); &#125;&#125; SaverThread.java1234567891011121314151617181920212223import java.io.IOException;public class SaverThread extends Thread &#123; private final Data data; public SaverThread(String name, Data data) &#123; super(name); this.data = data; &#125; public void run() &#123; try &#123; while (true) &#123; data.save(); Thread.sleep(1000); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ChangerThread.java1234567891011121314151617181920212223242526import java.io.IOException;import java.util.Random;public class ChangerThread extends Thread &#123; private final Data data; private final Random random = new Random(); public ChangerThread(String name, Data data) &#123; super(name); this.data = data; &#125; public void run() &#123; try &#123; for (int i = 0; ; i++) &#123; data.change("No." + i); Thread.sleep(random.nextInt(1000)); data.save(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Main.java12345678public class Main &#123; public static void main(String[] args) &#123; Data data = new Data("data.txt", "(empty)"); new ChangerThread("ChangerThread", data).start(); new SaverThread("SaverThread", data).start(); &#125;&#125; 运行结果123456789101112SaverThread calls doSave, content = No.0SaverThread calls doSave, content = No.1ChangerThread calls doSave, content = No.2SaverThread calls doSave, content = No.3ChangerThread calls doSave, content = No.4SaverThread calls doSave, content = No.5ChangerThread calls doSave, content = No.6SaverThread calls doSave, content = No.7ChangerThread calls doSave, content = No.8SaverThread calls doSave, content = No.9ChangerThread calls doSave, content = No.10SaverThread calls doSave, content = No.11 登场角色GuardedObject（被防护的对象）GuardedObject角色是一个拥有被防护的方法（guardedMethod）的类。当线程执行guardedMethod方法时，若守护条件成立，则执行实际的处理。而当守护条件不成立时，则不执行实际的处理，直接返回。守护条件的成立与否，会随着GuardedObject角色的状态变化而发生变化。除了guardedMethod之外，GuardedObject角色还有可能有其他来改变状态的方法（stateChangingMethod）。在示例程序中，由Data类扮演此角色。save方法对应的是guardedMethod，change方法对应的则是stateChangingMethod。 类图 Timethreads图 balk结果的表示方式当从guardedMethod方法中balk并返回时，balk结果的表示方式有如下几种。 忽略balk最简单的方式就是不通知调用端“发生了balk”。 通过返回值来表示balk有时会通过boolean类型的值来表示balk。例如，若返回值为true，则表明未发生balk，处理被执行了，而如果为false，则表明发生了balk，处理并未被执行。返回值为引用类型的方法有时也会用null来表示“发生了balk”。 通过异常来表示balk的发生有时也可以通过异常来表示“发生了balk”。即，当balk发生时，程序并不是从方法中return，而是抛出异常。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【图解Java多线程设计模式】Guarded Suspension模式]]></title>
      <url>%2F2018%2F11%2F15%2F%E3%80%90%E5%9B%BE%E8%A7%A3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Guarded-Suspension%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[如果执行现在的处理会造成问题，就让执行处理的线程进行等待。 示例一个线程（ClientThread）会将请求（Request）的实例传递给另一个线程（ServerThread），这是一种最简单的线程间通信。 时序图 Request.java123456789101112131415public class Request &#123; private final String name; public Request(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public String toString() &#123; return "[ Request " + name + " ]"; &#125;&#125; RequestQueue.java12345678910111213141516171819202122import java.util.LinkedList;import java.util.Queue;public class RequestQueue &#123; private final Queue&lt;Request&gt; queue = new LinkedList&lt;&gt;(); public synchronized void putRequest(Request request) &#123; queue.offer(request); notifyAll(); &#125; public synchronized Request getRequest() &#123; while (queue.peek() == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; return queue.remove(); &#125;&#125; ClientThread.java12345678910111213141516171819202122232425import java.util.Random;public class ClientThread extends Thread &#123; private final RequestQueue requestQueue; private final Random random; public ClientThread(RequestQueue requestQueue, String name, long seed) &#123; super(name); this.requestQueue = requestQueue; this.random = new Random(seed); &#125; public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; Request request = new Request("No." + i); System.out.println(Thread.currentThread().getName() + " requests " + request); requestQueue.putRequest(request); try &#123; Thread.sleep(random.nextInt(1000)); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;&#125; ServerThread.java123456789101112131415161718192021222324import java.util.Random;public class ServerThread extends Thread &#123; private final RequestQueue requestQueue; private final Random random; public ServerThread(RequestQueue requestQueue, String name, long seed) &#123; super(name); this.requestQueue = requestQueue; this.random = new Random(seed); &#125; public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; Request request = requestQueue.getRequest(); System.out.println(Thread.currentThread().getName() + " handles " + request); try &#123; Thread.sleep(random.nextInt(1000)); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;&#125; Main.java12345678public class Main &#123; public static void main(String[] args) &#123; RequestQueue requestQueue = new RequestQueue(); new ClientThread(requestQueue, "Alice", 3141592L).start(); new ServerThread(requestQueue, "Bobby", 6535897L).start(); &#125;&#125; 运行结果1234567891011121314Alice requests [ Request No.0 ]Bobby handles [ Request No.0 ]Alice requests [ Request No.1 ]Alice requests [ Request No.2 ]Bobby handles [ Request No.1 ]Bobby handles [ Request No.2 ]Alice requests [ Request No.3 ]Bobby handles [ Request No.3 ]Alice requests [ Request No.4 ]Bobby handles [ Request No.4 ]Alice requests [ Request No.5 ]Alice requests [ Request No.6 ]Bobby handles [ Request No.5 ]Bobby handles [ Request No.6 ] 登场角色GuardedObject（被守护的对象）GuardedObject角色是一个持有被守护的方法（guardedMethod）的类。当线程执行guardedMethod方法时，若守护条件成立，则可以立即执行；当守护条件不成立时，就要进行等待。守护条件的成立与否会随着GuardedObject角色的状态不同而发生变化。除了guardedMethod之外，GuardedObject角色还有可能持有其他改变实例状态（特别是改变守护条件）的方法（stateChangingMethod）。在Java中，guardedMethod通过while语句和wait方法来实现，stateChangingMethod则通过notify/notifyAll方法来实现。在示例程序中，由RequestQueue类扮演此角色。getRequest方法对应guardedMethod，putRequest方法则对应stateChangingMethod。 类图 Timethreads图 使用java.util.concurrent.LinkedBlockingQueueRequestQueue.java123456789101112131415161718192021222324import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;public class RequestQueue &#123; private final BlockingQueue&lt;Request&gt; queue = new LinkedBlockingQueue&lt;&gt;(); public void putRequest(Request request) &#123; try &#123; queue.put(request); &#125; catch (InterruptedException e) &#123; &#125; &#125; public Request getRequest() &#123; Request request = null; try &#123; request = queue.take(); &#125; catch (InterruptedException e) &#123; &#125; return request; &#125;&#125; 类图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[集合类与多线程]]></title>
      <url>%2F2018%2F11%2F13%2F%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[非线程安全的java.util.ArrayList类Main.java1234567891011import java.util.ArrayList;import java.util.List;public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); new WriterThread(list).start(); new ReaderThread(list).start(); &#125;&#125; WriterThread.java1234567891011121314151617import java.util.List;public class WriterThread extends Thread &#123; private final List&lt;Integer&gt; list; public WriterThread(List&lt;Integer&gt; list) &#123; super("WriterThread"); this.list = list; &#125; public void run() &#123; for (int i = 0; ; i++) &#123; list.add(i); list.remove(0); &#125; &#125;&#125; ReaderThread.java123456789101112131415161718import java.util.List;public class ReaderThread extends Thread &#123; private final List&lt;Integer&gt; list; public ReaderThread(List&lt;Integer&gt; list) &#123; super("ReaderThread"); this.list = list; &#125; public void run() &#123; while (true) &#123; for (int n : list) &#123; System.out.println(n); &#125; &#125; &#125;&#125; result1234Exception in thread "ReaderThread" java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851) at ReaderThread.run(ReaderThread.java:13) 利用Collections.synchronizedList方法所进行的同步Main.java123456789101112import java.util.ArrayList;import java.util.Collections;import java.util.List;public class Main &#123; public static void main(String[] args) &#123; final List&lt;Integer&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); new WriterThread(list).start(); new ReaderThread(list).start(); &#125;&#125; ReaderThread.java1234567891011121314151617181920import java.util.List;public class ReaderThread extends Thread &#123; private final List&lt;Integer&gt; list; public ReaderThread(List&lt;Integer&gt; list) &#123; super("ReaderThread"); this.list = list; &#125; public void run() &#123; while (true) &#123; synchronized(list) &#123; for (int n : list) &#123; System.out.println(n); &#125; &#125; &#125; &#125;&#125; 使用copy-on-write的java.util.concurrent.CopyOnWriteArrayList类Main.java1234567891011import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;public class Main &#123; public static void main(String[] args) &#123; final List&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;(); new WriterThread(list).start(); new ReaderThread(list).start(); &#125;&#125; 比较使用copy-on-write时，每次执行“写”操作都会执行复制。因此，程序频繁执行“写”操作时，如果使用CopyOnWriteArrayList，会比较花费时间。但如果写操作比较少，而读操作频率非常高时，使用CopyOnWriteArrayList是非常棒的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【图解Java多线程设计模式】Immutable模式]]></title>
      <url>%2F2018%2F11%2F12%2F%E3%80%90%E5%9B%BE%E8%A7%A3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Immutable%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[Immutable模式中存在着确保实例状态不发生改变的类（immutable类）。在访问这些实例时并不需要执行耗时的互斥处理，能提高程序性能。 示例Person.java123456789101112131415161718192021public class Person &#123; private final String name; private final String address; public Person(String name, String address) &#123; this.name = name; this.address = address; &#125; public String getName() &#123; return name; &#125; public String getAddress() &#123; return address; &#125; public String toString() &#123; return "[ Person: name = " + name + ", address = " + address + " ]"; &#125; &#125; Main.java123456789public class Main &#123; public static void main(String[] args) &#123; Person alice = new Person("Alice", "Alaska"); new PrintPersonThread(alice).start(); new PrintPersonThread(alice).start(); new PrintPersonThread(alice).start(); &#125;&#125; PrintPersonThread.java12345678910111213public class PrintPersonThread extends Thread &#123; private Person person; public PrintPersonThread(Person person) &#123; this.person = person; &#125; public void run() &#123; while (true) &#123; System.out.println(Thread.currentThread().getName() + " prints " + person); &#125; &#125;&#125; 登场角色Immutable（不可变的）Immutable角色是一个类，在这个角色中，字段的值不可以修改，也不存在修改字段内容的方法。Immutable角色的实例被创建后，状态将不再发生变化。这时，无需对Immutable角色应用Single Threaded Execution模式。也就是说，无需将Immutable角色的方法声明为synchronized。在示例程序中，由Person类扮演此角色。 类图 Timethreads图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[计数信号量]]></title>
      <url>%2F2018%2F11%2F06%2F%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F%2F</url>
      <content type="text"><![CDATA[Semaphore的acquire方法用于确保存在可用资源。当存在可用资源时，线程会立即从acquire方法返回，同时信号量内部的资源个数会减1.如无可用资源，线程则阻塞在acquire方法内，直至出现可用资源。Semaphore的release方法用于释放资源。释放资源后，信号量内部的资源个数会增加1。另外，如果acquire中存在等待的线程， 示例多个线程使用数量有限的资源。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.Random;import java.util.concurrent.Semaphore;public class Main &#123; public static void main(String[] args) &#123; BoundedResource resource = new BoundedResource(3); for (int i = 0; i &lt; 10; i++) &#123; new UserThread(resource).start(); &#125; &#125;&#125;class UserThread extends Thread &#123; private final BoundedResource resource; private final static Random random = new Random(26535); public UserThread(BoundedResource resource) &#123; this.resource = resource; &#125; public void run() &#123; try &#123; while (true) &#123; resource.use(); Thread.sleep(random.nextInt(3000)); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125;class BoundedResource &#123; private final int permits; private final Semaphore semaphore; private final static Random random = new Random(314159); public BoundedResource(int permits) &#123; this.semaphore = new Semaphore(permits); this.permits = permits; &#125; public void use() throws InterruptedException &#123; semaphore.acquire(); try &#123; doUse(); &#125; finally &#123; semaphore.release(); &#125; &#125; protected void doUse() throws InterruptedException &#123; Log.println("BEGIN: used = " + (permits - semaphore.availablePermits())); Thread.sleep(random.nextInt(500)); Log.println("END: used = " + (permits - semaphore.availablePermits())); &#125;&#125;class Log &#123; public static void println(String s) &#123; System.out.println(Thread.currentThread().getName() + ": " + s); &#125;&#125; 运行结果1234567891011121314151617181920Thread-0: BEGIN: used = 1Thread-1: BEGIN: used = 2Thread-2: BEGIN: used = 3Thread-1: END: used = 3Thread-3: BEGIN: used = 3Thread-3: END: used = 3Thread-4: BEGIN: used = 3Thread-2: END: used = 3Thread-5: BEGIN: used = 3Thread-4: END: used = 3Thread-6: BEGIN: used = 3Thread-6: END: used = 3Thread-7: BEGIN: used = 3Thread-0: END: used = 3Thread-8: BEGIN: used = 3Thread-5: END: used = 3Thread-9: BEGIN: used = 3Thread-8: END: used = 3Thread-9: END: used = 2Thread-1: BEGIN: used = 2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【图解Java多线程设计模式】Single Threaded Execution模式]]></title>
      <url>%2F2018%2F11%2F01%2F%E3%80%90%E5%9B%BE%E8%A7%A3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Single-Threaded-Execution%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[所谓Single Threaded Execution模式，意即“以一个线程执行”。该模式用于设置限制，以确保同一时间内只能让一个线程执行处理。 示例模拟三个人频繁地通过一个只允许一个人经过的门的情形。当人们通过门的时候，统计人数便会递增。另外，还会记录通行者的“姓名与出生地”。 Main.java1234567891011public class Main &#123; public static void main(String[] args) &#123; System.out.println("Testing Gate, hit CTRL+C to exit."); Gate gate = new Gate(); new UserThread(gate, "Alice", "Alaska").start(); new UserThread(gate, "Bobby", "Brazil").start(); new UserThread(gate, "Chris", "Canada").start(); &#125;&#125; UserThread.java12345678910111213141516171819public class UserThread extends Thread &#123; private final Gate gate; private final String myname; private final String myaddress; public UserThread(Gate gate, String name, String address) &#123; this.gate = gate; this.myname = name; this.myaddress = address; &#125; public void run() &#123; System.out.println(myname + " BEGIN"); while (true) &#123; gate.pass(myname, myaddress); &#125; &#125;&#125; Gate.java12345678910111213141516171819202122public class Gate &#123; private int counter = 0; private String name = "Nobody"; private String address = "Nowhere"; public synchronized void pass(String name, String address) &#123; this.counter++; this.name = name; this.address = address; check(); &#125; private void check() &#123; if (name.charAt(0) != address.charAt(0)) &#123; System.out.println("***** BROKEN ***** " + toString()); &#125; &#125; public synchronized String toString() &#123; return "No." + counter + ": " + name + ", " + address; &#125;&#125; 登场角色SharedResource（共享资源）Single Threaded Execution模式中出现了一个发挥SharedResource（共享资源）作用的类。在示例中，由Gate类扮演SharedResource角色。 SharedResource角色是可被多个线程访问的类，包含很多方法，但这些方法主要分为如下两类。 safeMethod：多个线程同时调用也不会发生问题的方法。 unsafeMethod：多个线程同时调用会发生问题，因此必须加以保护的方法。 Single Threaded Execution模式会保护unsafeMethod，使其同时只能由一个线程访问。Java则是通过将unsafeMethod声明为synchronized方法来进行保护。 类图 Timethreads图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线程的协作]]></title>
      <url>%2F2018%2F10%2F30%2F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8D%8F%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[等待队列所有实例都拥有一个等待队列，它是在实例的wait方法执行后停止操作的线程的队列。当下列任意一种情况发生时，线程便会退出等待队列。 有其他线程的notify方法来唤醒线程 有其他线程的notifyAll方法来唤醒线程 有其他线程的interrupt方法来唤醒线程 wait方法超时 wait方法——将线程放入等待队列获取了锁的线程A执行wait方法。 线程A进入等待队列，释放锁。 线程B能够获取锁。 notify方法——从等待队列中取出线程获取了锁的线程B执行notify方法。 线程A退出等待队列，想要进入wait的下一个操作，但刚才执行notify的线程B仍持有着锁。 刚才执行notify的线程B释放了锁。 退出等待队列的线程A获取锁，执行wait的下一个操作。 notifyAll方法——从等待队列中取出所有线程notifyAll方法唤醒所有线程，并让所有线程都退出等待队列。 由于notify唤醒的线程较少，所以处理速度要比使用notifyAll时快。但使用notify时，如果处理不好，程序便可能会停止。一般来说，使用notifyAll时的代码要比使用notify时的更为健壮。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线程的互斥]]></title>
      <url>%2F2018%2F10%2F30%2F%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5%2F</url>
      <content type="text"><![CDATA[Java使用关键字synchronized来执行线程的互斥处理。 synchronized方法如果声明一个方法时，在前面加上关键字synchronized，那么这个方法就只能由一个线程运行。这种方法称为synchronized方法，有时也成为同步方法。 Bank.java123456789101112131415161718192021222324252627public class Bank &#123; private int money; private String name; public Bank(String name, int money) &#123; this.name = name; this.money = money; &#125; public synchronized void deposit(int m) &#123; money += m; &#125; public synchronized boolean withdraw(int m) &#123; if (money &gt;= m) &#123; money -= m; return true; &#125; else &#123; return false; &#125; &#125; public String getName() &#123; return name; &#125;&#125; synchronized方法每次只能由一个线程运行。 线程运行完synchronized方法deposit后，释放锁。 获取锁的另一个线程开始运行synchronized方法。 synchronized实例方法和synchronized代码块1234567891011//synchronized实例方法synchronized void method() &#123; ...&#125;//synchronized代码块void method() &#123; synchronized(this) &#123; ... &#125;&#125; synchronized实例方法是使用this的锁来执行线程的互斥处理的。 synchronized静态方法和synchronized代码块123456789101112131415//synchronized静态方法class Something &#123; static synchronized void method() &#123; ... &#125;&#125;//synchronized代码块class Something &#123; static void method() &#123; synchronized(Something.class) &#123; ... &#125; &#125;&#125; synchronized静态方法是使用该类的类对象的锁来执行线程的互斥处理的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线程的启动]]></title>
      <url>%2F2018%2F10%2F29%2F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[利用Thread类的子类创建Thread类的子类，创建子类的实例，调用start方法。 PrintThread.java12345678910111213public class PrintThread extends Thread &#123; private String message; public PrintThread(String message) &#123; this.message = message; &#125; public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; System.out.print(message); &#125; &#125;&#125; Main.java123456public class Main &#123; public static void main(String[] args) &#123; new PrintThread("Good!").start(); new PrintThread("Nice!").start(); &#125;&#125; 利用Runnable接口创建Runnable接口的实现类，将实现类的实例作为参数传给Thread的构造函数，调用start方法。 Printer.java12345678910111213public class Printer implements Runnable &#123; private String message; public Printer(String message) &#123; this.message = message; &#125; public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; System.out.print(message); &#125; &#125;&#125; Main.java123456public class Main &#123; public static void main(String[] args) &#123; new Thread(new Printer("Good!")).start(); new Thread(new Printer("Nice!")).start(); &#125;&#125; 补充java.util.concurrent包中包含一个将线程创建抽象化的ThreadFactory接口。利用该接口，可以将以Runnable作为传入参数并通过new创建Thread实例的处理隐藏在ThreadFactory内部。 Main.java12345678910import java.util.concurrent.Executors;import java.util.concurrent.ThreadFactory;public class Main &#123; public static void main(String[] args) &#123; ThreadFactory factory = Executors.defaultThreadFactory(); factory.newThread(new Printer("Good!")).start(); factory.newThread(new Printer("Nice!")).start(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Downloader Middleware Demo]]></title>
      <url>%2F2018%2F10%2F12%2FDownloader-Middleware-Demo%2F</url>
      <content type="text"><![CDATA[核心方法每个Downloader Middleware都定义了一个或多个方法的类，核心的方法有如下三个。 process_request(request, spider) process_response(request, response, spider) process_exception(request, exception, spider) process_requestRequest被Scrapy引擎调度给Downloader之前，process_request()方法就会被调用，也就是在Request从队列里调度出来到Downloader下载执行之前，我们都可以用process_request()方法对Request进行处理。方法的返回值必须为None、Response对象、Request对象之一，或者抛出IgnoreRequest异常。 process_request()方法的参数有如下两个。 request，是Request对象，即被处理的Request。 spider，是Spider对象，即此Request对应的Spider。 process_responseDownloader执行Request下载之后，会得到对应的Response。Scrapy引擎便会将Response发送给Spider进行解析。在发送之前，我们都可以用process_response()方法来对Response进行处理。方法的返回值必须为Request对象、Response对象之一，或者抛出IgnoreRequest异常。 process_response()方法的参数有如下三个。 request，是Request对象，即此Response对应的Request。 response，是Response对象，即此被处理的Response。 spider，是Spider对象，即此Response对应的Spider。 process_exception当Downloader或process_request()方法抛出异常时，例如抛出IgnoreRequest异常，process_exception()方法就会被调用。方法的返回值必须为None、Response对象、Request对象之一。 process_exception()方法的参数有如下三个。 request，是Request对象，即产生异常的Request。 exception，是Exception对象，即抛出的异常。 spider，是Spider对象，即Request对应的Spider。 基本用法利用process_request()方法设置随机的User-Agent，使用process_response()方法修改Response的状态码。 Httpbin.py12345678910import scrapyclass HttpbinSpider(scrapy.Spider): name = 'Httpbin' allowed_domains = ['httpbin.org'] start_urls = ['http://httpbin.org/get'] def parse(self, response): self.logger.debug(response.text) self.logger.debug('Status Code: ' + str(response.status)) middlewares.py123456789101112131415import randomclass RandomUserAgentMiddleware(object): def __init__(self): self.user_agents = [ "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/11.1.1 Safari/605.1.15", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36" ] def process_request(self, request, spider): request.headers['User-Agent'] = random.choice(self.user_agents) def process_response(self, request, response, spider): response.status = 201 return response settings.py123DOWNLOADER_MIDDLEWARES = &#123; 'httpbin.middlewares.RandomUserAgentMiddleware': 543,&#125; result12345678910111213141516&#123; "args": &#123;&#125;, "headers": &#123; "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "Accept-Encoding": "gzip,deflate", "Accept-Language": "en", "Connection": "close", "Host": "httpbin.org", # "User-Agent": "Scrapy/1.5.0 (+https://scrapy.org)" "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36" &#125;, "origin": "218.82.103.201", "url": "http://httpbin.org/get"&#125;Status Code: 201]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Scrapy]]></title>
      <url>%2F2018%2F10%2F09%2FScrapy%2F</url>
      <content type="text"><![CDATA[架构 Engine: 引擎，处理整个系统的数据流处理、触发事务，是整个框架的核心。 Item: 项目，它定义了爬取结果的数据结构，爬取的数据会被赋值成该Item对象。 Scheduler: 调度器，接受引擎发过来的请求并将其加入队列中，在引擎再次请求的时候将请求提供给引擎。 Downloader: 下载器，下载网页内容，并将网页内容返回给蜘蛛。 Spiders: 蜘蛛，其内定义了爬取的逻辑和网页的解析规则，它主要负责解析响应并生成提取结果和新的请求。 Item Pipeline: 项目管道，负责处理由蜘蛛从网页中抽取的项目，它的主要任务是清洗、验证和存储数据。 Downloader Middlewares: 下载器中间件，位于引擎和下载器之间的钩子框架，主要处理引擎与下载器之间的请求及响应。 Spider Middlewares: 蜘蛛中间件，位于引擎和蜘蛛之间的钩子框架，主要处理蜘蛛输入的响应和输出的结果及新的请求。 数据流Scrapy中的数据流由引擎控制，数据流的过程如下: Engine首先打开一个网站，找到处理该网站的Spider，并向该Spider请求第一个要爬取的URL。 Engine从Spider中获取到第一个要爬取的URL，并通过Scheduler以Request的形式调度。 Engine向Scheduler请求下一个要爬取的URL。 Scheduler返回下一个要爬取的URL给Engine，Engine将URL通过Downloader Middlewares转发给Downloader下载。 一旦页面下载完毕，Downloader生成该页面的Response，并将其通过Downloader Middlewares发送给Engine。 Engine从下载器中接收到Response，并将其通过Spider Middlewares发送给Spider处理。 Spider处理Response，并返回爬取到的Item及新的Request给Engine。 Engine将Spider返回的Item给Item Pipeline，将新的Request给Scheduler。 重复第2步到第8步，直到Scheduler中没有更多的Request，Engine关闭该网站，爬取结束。通过多个组件的相互协作、不同组件完成工作的不同、组件对异步处理的支持，Scrapy最大限度地利用了网络带宽，大大提高了数据爬取和处理的效率。 文件 scrapy.cfg: 它是Scrapy项目的配置文件，其内定义了项目的配置文件路径、部署相关信息等内容。 items.py: 它定义Item数据结构，所有的Item的定义都可以放这里。 pipelines.py: 它定义Item Pipeline的实现，所有的Item Pipeline的实现都可以放这里。 settings.py: 它定义项目的全局配置。 middlewares.py: 它定义Spider Middlewares和Downloader Middlewares的实现。 spiders: 其内包含一个个Spider的实现，每个Spider都有一个文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pyspider]]></title>
      <url>%2F2018%2F09%2F30%2FPyspider%2F</url>
      <content type="text"><![CDATA[pyspider的架构主要分为Scheduler(调度器)、Fetcher(抓取器)、Processer(处理器)三个部分，整个爬取过程受到Monitor(监控器)的监控，抓取的结果被Result Worker(结果处理器)处理. Scheduler发起任务调度，Fetcher负责抓取网页内容，Processer负责解析网页内容，然后将新生成的Request发给Scheduler进行调度，将生成的提取结果输出保存。 pyspider的任务执行流程的逻辑很清晰，具体过程如下所示。 每个pyspider的项目对应一个Python脚本，该脚本中定义了一个Handler类，它有一个on_start()方法。爬取首先调用on_start()方法生成最初的抓取任务，然后发送给 Scheduler进行调度。 Scheduler将抓取任务分发给Fetcher进行抓取，Fetcher执行并得到响应，随后将响应发送给Processer。 Processer处理响应并提取出新的URL生成新的抓取任务，然后通过消息队列的方式通知Scheduler当前抓取任务执行情况，并将新生成的抓取任务发送给Scheduler。如果生成了新的提取结果，则将其发送到结果队列等待Result Worker处理。 Scheduler接收到新的抓取任务，然后查询数据库，判断其如果是新的抓取任务或者是需要重试的任务就继续进行调度，然后将其发送回Fetcher进行抓取。 不断重复以上工作，直到所有的任务都执行完毕，抓取结束。 抓取结束后，程序会回调on_finished()方法，这里可以定义后处理过程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Proxy]]></title>
      <url>%2F2018%2F09%2F15%2FProxy%2F</url>
      <content type="text"><![CDATA[设置代理后测试的网址是：httpbin.org/get，访问该网址可以得到请求的相关信息，其中origin宇段就是客户端的IP，可以根据它来判断代理是否设置成功，即是否成功伪装了IP。 urllibHTTP代理123456789101112131415161718192021222324252627from urllib.request import ProxyHandler, build_openerfrom urllib.error import URLErrorproxy = "127.0.0.1:1087"proxy_handler = ProxyHandler(&#123; 'http': "http://" + proxy, 'https': "https://" + proxy&#125;)opener = build_opener(proxy_handler)try: response = opener.open("http://httpbin.org/get") print(response.read().decode('utf-8'))except URLError as e: print(e.reason)# &#123;# "args": &#123;&#125;, # "headers": &#123;# "Accept-Encoding": "identity", # "Connection": "close", # "Host": "httpbin.org", # "User-Agent": "Python-urllib/3.7"# &#125;, # "origin": "38.141.44.98", # "url": "http://httpbin.org/get"# &#125; SOCKS5代理12345678910111213141516171819202122232425from urllib import requestfrom urllib.error import URLErrorimport socketimport sockssocks.set_default_proxy(socks.SOCKS5, "127.0.0.1", 1086)socket.socket = socks.socksockettry: response = request.urlopen("http://httpbin.org/get") print(response.read().decode('utf-8'))except URLError as e: print(e.reason)# &#123;# "args": &#123;&#125;, # "headers": &#123;# "Accept-Encoding": "identity", # "Connection": "close", # "Host": "httpbin.org", # "User-Agent": "Python-urllib/3.7"# &#125;, # "origin": "38.141.44.98", # "url": "http://httpbin.org/get"# &#125; requestsHTTP代理1234567891011121314151617181920212223242526import requestsproxy = "127.0.0.1:1087"proxies = &#123; 'http': "http://" + proxy, 'https': "https://" + proxy&#125;try: response = requests.get("http://httpbin.org/get", proxies=proxies) print(response.text)except requests.ConnectionError as e: print("Error", e.args)# &#123;# "args": &#123;&#125;, # "headers": &#123;# "Accept": "*/*", # "Accept-Encoding": "gzip, deflate", # "Connection": "close", # "Host": "httpbin.org", # "User-Agent": "python-requests/2.19.1"# &#125;, # "origin": "38.141.44.98", # "url": "http://httpbin.org/get"# &#125; SOCKS5代理1234567891011121314151617181920212223242526import requestsproxy = "127.0.0.1:1086"proxies = &#123; 'http': "socks5://" + proxy, 'https': "socks5://" + proxy&#125;try: response = requests.get("http://httpbin.org/get", proxies=proxies) print(response.text)except requests.ConnectionError as e: print("Error", e.args)# &#123;# "args": &#123;&#125;, # "headers": &#123;# "Accept": "*/*", # "Accept-Encoding": "gzip, deflate", # "Connection": "close", # "Host": "httpbin.org", # "User-Agent": "python-requests/2.19.1"# &#125;, # "origin": "38.141.44.98", # "url": "http://httpbin.org/get"# &#125; Selenium123456789101112131415161718192021222324from selenium import webdriverproxy = "127.0.0.1:1087"chrome_options = webdriver.ChromeOptions()chrome_options.add_argument("--proxy-server=http://" + proxy)browser = webdriver.Chrome(chrome_options=chrome_options)browser.get("http://httpbin.org/get")# &#123;# "args": &#123;&#125;, # "headers": &#123;# "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", # "Accept-Encoding": "gzip, deflate", # "Accept-Language": "en-us", # "Connection": "close", # "Cookie": "aaa=111; undefined=undefined; _gauges_unique=1; _gauges_unique_month=1; _gauges_unique_year=1", # "Dnt": "1", # "Host": "httpbin.org", # "Upgrade-Insecure-Requests": "1", # "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/11.1.1 Safari/605.1.15"# &#125;, # "origin": "218.82.103.201", # "url": "http://httpbin.org/get"# &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cookiejar Demo]]></title>
      <url>%2F2018%2F08%2F15%2FCookiejar-Demo%2F</url>
      <content type="text"><![CDATA[如果希望登录状态一直保持，则需要进行Cookie处理。进行Cookie处理的一种常用思路如下： 导入Cookie处理模块http.cookiejar 使用http.cookiejar.CookieJar()创建CookieJar对象 使用HTTPCookieProcessor创建cookie处理器，并以其为参数构建opener对象 创建全局默认的opener对象 123456789101112131415161718192021222324252627282930import urllib.requestimport urllib.parseimport http.cookiejarurl1 = "http://bbs.chinaunix.net/member.php?mod=logging&amp;action=login&amp;loginsubmit=yes&amp;loginhash=LhGEr"postdata = urllib.parse.urlencode(&#123; "username": "", "password": ""&#125;).encode("utf-8")req = urllib.request.Request(url1, postdata)req.add_header("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/604.4.7 (KHTML, like Gecko) Version/11.0.2 Safari/604.4.7")# 使用http.cookiejar.CookieJar()创建CookieJar对象cjar = http.cookiejar.CookieJar()# 使用HTTPCookieProcessor创建cookie处理器，并以其为参数构建opener对象cookie = urllib.request.HTTPCookieProcessor(cjar)opener = urllib.request.build_opener(cookie)# 将opener安装为全局urllib.request.install_opener(opener)data1 = opener.open(req).read()file1 = open("/Users/matianyao/Desktop/login.html", "wb")file1.write(data1)file1.close()url2 = "http://bbs.chinaunix.net"data2 = urllib.request.urlopen(url2).read()file2 = open("/Users/matianyao/Desktop/crawler.html", "wb")file2.write(data2)file2.close()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Regular Expression]]></title>
      <url>%2F2018%2F08%2F14%2FRegular-Expression%2F</url>
      <content type="text"><![CDATA[正则表达式就是描述字符串排列的一套规则。 基础知识原子原子是正则表达式中最基本的组成单位，每个正则表达式中至少要包含一个原子，常见的原子有以下几类： 普通字符 非打印字符 通用字符 原子表 普通字符可以使用一些普通的字符，比如数字、大小写字母、下划线等都可以作为原子使用。 1234567import repattern = "yue"string = "http://yum.iqianyue.com"result = re.search(pattern, string)print(result)# &lt;re.Match object; span=(16, 19), match='yue'&gt; 非打印字符所谓的非打印字符，指的是一些在字符串中用于格式控制的符号，比如换行符等。 12345678910111213import repattern = "\n"string1 = '''http://yum.iqianyue.comhttp://baidu.com'''result1 = re.search(pattern, string1)print(result1)# &lt;re.Match object; span=(23, 24), match='\n'&gt;string2 = "http://yum.iqianyue.comhttp://baidu.com"result2 = re.search(pattern, string2)print(result2)# None 通用字符所谓的通用字符，即一个原子可以匹配一类字符。 1234567import repattern = "\w\dpython\w"string = "abcdfphp345pythony_py"result = re.search(pattern, string)print(result)# &lt;re.Match object; span=(9, 18), match='45pythony'&gt; 原子表使用原子表，可以定义一组地位平等的原子，然后匹配的时候会取该原子表中的任意一个原子进行匹配，在Python中，原子表由[]表示。类似的，[^]代表的是除了中括号里面的原子均可以匹配。 1234567891011121314151617import restring = "abcdfphp345pythony_py"pattern1 = "\w\dpython[xyz]\w"result1 = re.search(pattern1, string)print(result1)# &lt;re.Match object; span=(9, 19), match='45pythony_'&gt;pattern2 = "\w\dpython[^xyz]\w"result2 = re.search(pattern2, string)print(result2)# Nonepattern3 = "\w\dpython[xyz]\W"result3 = re.search(pattern3, string)print(result3)# None 元字符所谓的元字符，就是正则表达式中具有一些特殊含义的字符。具体来说，元字符可以分为：任意匹配元字符、边界限制元字符、限定符、模式选择符、模式单元等。 任意匹配元字符可以使用”.”匹配一个除换行符以外的任意字符。 1234567import repattern = ".python..."string = "abcdfphp345pythony_py"result = re.search(pattern, string)print(result)# &lt;re.Match object; span=(10, 20), match='5pythony_p'&gt; 边界限制元字符可以使用”^”匹配字符串的开始，使用”$”匹配字符串的结束。 12345678910111213141516171819202122import restring = "abcdfphp345pythony_py"pattern1 = "^abd"result1 = re.search(pattern1, string)print(result1)# Nonepattern2 = "^abc"result2 = re.search(pattern2, string)print(result2)# &lt;re.Match object; span=(0, 3), match='abc'&gt;pattern3 = "py$"result3 = re.search(pattern3, string)print(result3)# &lt;re.Match object; span=(19, 21), match='py'&gt;pattern4 = "ay$"result4 = re.search(pattern4, string)print(result4)# None 限定符常见的限定符包括*、?、+、{n}、{n,}、{n, m}。 12345678910111213141516171819202122import restring = "abcdddfphp345pythony_py"pattern1 = "py.*n"result1 = re.search(pattern1, string)print(result1)# &lt;re.Match object; span=(13, 19), match='python'&gt;pattern2 = "cd&#123;2&#125;"result2 = re.search(pattern2, string)print(result2)# &lt;re.Match object; span=(2, 5), match='cdd'&gt;pattern3 = "cd&#123;3&#125;"result3 = re.search(pattern3, string)print(result3)# &lt;re.Match object; span=(2, 6), match='cddd'&gt;pattern4 = "cd&#123;2,&#125;"result4 = re.search(pattern4, string)print(result4)# &lt;re.Match object; span=(2, 6), match='cddd'&gt; 模式选择符使用模式选择符，可以设置多个模式，匹配时，可以从中选择任意一个模式匹配。 1234567import repattern = "python|php"string = "abcdfphp345pythony_py"result = re.search(pattern, string)print(result)# &lt;re.Match object; span=(5, 8), match='php'&gt; 模式单元可以使用”()”将一些原子组合成一个大原子使用，小括号括起来的部分会被当做一个整体去使用。 123456789101112import restring = "abcdcdcdcdfphp345pythony_py"pattern1 = "(cd)&#123;1,&#125;"result1 = re.search(pattern1, string)print(result1)# &lt;re.Match object; span=(2, 10), match='cdcdcdcd'&gt;pattern2 = "cd&#123;1,&#125;"result2 = re.search(pattern2, string)print(result2)# &lt;re.Match object; span=(2, 4), match='cd'&gt; 模式修正所谓模式修正符，即可以在不改变正则表达式的情况下，通过模式修正符改变正则表达式的含义，从而实现一些匹配结果的调整等功能。 1234567891011import restring = "abcdfphp345Pythony_py"pattern = "python"result1 = re.search(pattern, string)print(result1)# Noneresult2 = re.search(pattern, string, re.I)print(result2)# &lt;re.Match object; span=(11, 17), match='Python'&gt; 贪婪模式与懒惰模式在某些字符间匹配任意字符，贪婪模式的核心点就是尽可能多地匹配，而懒惰模式的核心点就是尽可能少地匹配。 123456789101112import restring = "abcdfphp345pythony_py"pattern1 = "p.*y" #贪婪模式result1 = re.search(pattern1, string)print(result1)# &lt;re.Match object; span=(5, 21), match='php345pythony_py'&gt;pattern2 = "p.*?y" #懒惰模式result2 = re.search(pattern2, string)print(result2)# &lt;re.Match object; span=(5, 13), match='php345py'&gt; 常见函数re.match()函数如果想要从源字符串的起始位置匹配一个模式，可以使用re.match()函数，使用格式是：re.match(pattern, string, flag)第一个参数代表对应的正确表达式，第二个参数代表对应的源字符，第三个参数是可选参数，代表对应的标志位，可以放模式修正符等信息。 1234567891011import restring = "apythonhellomypythonhispythonourpythonend"pattern = ".python."result1 = re.match(pattern, string)print(result1)# &lt;re.Match object; span=(0, 8), match='apythonh'&gt;result2 = re.match(pattern, string).span()print(result2)# (0, 8) re.search()函数使用该函数进行匹配，会扫描整个字符串并进行对应的匹配。 1234567891011import restring = "hellomypythonhispythonourpythonend"pattern = ".python."result1 = re.match(pattern, string)print(result1)# Noneresult2 = re.search(pattern, string)print(result2)# &lt;re.Match object; span=(6, 14), match='ypythonh'&gt; 全局匹配函数将符合模式的内容全部都匹配出来。思路如下： 使用re.compile()对正则表达式进行预编译。 编译后，使用findall()根据正则表达式从源字符串中将匹配的结果全部找出。 1234567import restring = "hellomypythonhispythonourpythonend"pattern = re.compile(".python.") #预编译result = pattern.findall(string) #找出符合模式的所有结果print(result)# ['ypythonh', 'spythono', 'rpythone'] re.sub()函数如果想根据正则表达式来实现替换某些字符串的功能，可以使用re.sub()韩式实现。re.sub(pattern, rep, string, max)其中，第一个参数为对应的正则表达式，第二个参数为要替换成的字符串，第三个参数为源字符串，第四个参数为可选项，代表最多替换的次数，如果忽略不写，则会将符合模式的结果全部替换。 1234567891011import restring = "hellomypythonhispythonourpythonend"pattern = re.compile(".python") result1 = re.sub(pattern, "php", string) #全部替换print(result1)# hellomphphiphpouphpendresult2 = re.sub(pattern, "php", string, 2) #最多替换两次print(result2)# hellomphphiphpourpythonend 常见实例解析匹配.com或.cn后缀的URL网址将一串字符串里面以.com或.cn为域名后缀的URL网址匹配出来，过滤掉其他的无关信息。 1234567import repattern = "[a-zA-Z]+://[^\s]*[.com|.cn]"string = "&lt;a href='http://www.baidu.com'&gt;百度首页&lt;/a&gt;"result = re.search(pattern, string)print(result)# &lt;re.Match object; span=(9, 29), match='http://www.baidu.com'&gt; 匹配电话号码将一串字符串里面出现的电话号码信息提取出来，过滤掉其他无关信息。 1234567import repattern = "\d&#123;4&#125;-\d&#123;7&#125;|\d&#123;3&#125;-\d&#123;8&#125;"string = "021-6728263653682382265236"result = re.search(pattern, string)print(result)# &lt;re.Match object; span=(0, 12), match='021-67282636'&gt; 匹配电子邮件地址将一串字符串里面出现的电子邮件信息提取出来，过滤掉其他无关信息。 1234567import repattern = "\w+([.+-]\w+)*@\w+([.-]\w+)*\.\w+([.-]\w+)*"string = "&lt;a href='http://www.baidu.com'&gt;百度首页&lt;/a&gt;&lt;br&gt;&lt;a href='mailto:c-e+o@iqi-anyue.com.cn'&gt;电子邮件地址&lt;/a&gt;"result = re.search(pattern, string)print(result)# &lt;re.Match object; span=(59, 81), match='c-e+o@iqi-anyue.com.cn'&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【图解设计模式】Singleton模式]]></title>
      <url>%2F2018%2F05%2F31%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Singleton%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[确保只能生成一个实例。 示例类图 Singleton类1234567891011public class Singleton &#123; private static Singleton singleton = new Singleton(); private Singleton()&#123; System.out.println("生成了一个实例"); &#125; public static Singleton getInstance() &#123; return singleton; &#125;&#125; Main类12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; System.out.println("Start."); Singleton obj1 = Singleton.getInstance(); Singleton obj2 = Singleton.getInstance(); if (obj1 == obj2) System.out.println("obj1与obj2是相同的实例。"); else System.out.println("obj1与obj2是不同的实例。"); System.out.println("End."); &#125;&#125; 运行结果Start.生成了一个实例obj1与obj2是相同的实例。End. 登场角色Singleton在Singleton模式中，只有Singleton这一个角色。Singleton角色中有一个返回唯一实例的static方法。该方法总是会返回同一个实例。 类图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【图解设计模式】Factory Method模式]]></title>
      <url>%2F2018%2F05%2F30%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Factory-Method%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[使用Template Method模式生成实例。 示例制作身份证（ID卡）。 类图 Product类12345package framework;public abstract class Product &#123; public abstract void use();&#125; Factory类123456789101112package framework;public abstract class Factory &#123; public final Product create(String owner) &#123; Product p = createProduct(owner); registerProduct(p); return p; &#125; protected abstract Product createProduct(String owner); protected abstract void registerProduct(Product product);&#125; IDCard类123456789101112131415161718192021package idcard;import framework.Product;public class IDCard extends Product &#123; private String owner; IDCard(String owner) &#123; this.owner = owner; System.out.println("制作" + owner + "的ID卡。"); &#125; @Override public void use() &#123; System.out.println("使用" + owner + "的ID卡。"); &#125; public String getOwner() &#123; return owner; &#125;&#125; IDCardFactory类12345678910111213141516171819202122232425package idcard;import framework.Factory;import framework.Product;import java.util.ArrayList;import java.util.List;public class IDCardFactory extends Factory &#123; private List owners = new ArrayList(); @Override protected Product createProduct(String owner) &#123; return new IDCard(owner); &#125; @Override protected void registerProduct(Product product) &#123; owners.add(((IDCard)product).getOwner()); &#125; public List getOwners() &#123; return owners; &#125;&#125; Main类1234567891011121314151617import framework.Factory;import framework.Product;import idcard.IDCardFactory;public class Main &#123; public static void main(String[] args) &#123; Factory factory = new IDCardFactory(); Product card1 = factory.create("小明"); Product card2 = factory.create("小红"); Product card3 = factory.create("小刚"); card1.use(); card2.use(); card3.use(); &#125;&#125; 运行结果制作小明的ID卡。制作小红的ID卡。制作小刚的ID卡。使用小明的ID卡。使用小红的ID卡。使用小刚的ID卡。 登场角色Product（产品）Product角色属于框架这一方，是一个抽象类。它定义了在Factory Method模式中生成的那些实例所持有的接口（API），但具体的处理由子类ConcreteProduct角色决定，在示例程序中，由Product类扮演此角色。 Creator（创建者）Creator角色属于框架这一方，它是负责生成Product角色的抽象类，但具体的处理则由子类ConcreteCreator角色决定。在示例程序中，由Factory类扮演此角色。Creator角色对于实际负责生成实例的ConcreteCreator角色一无所知，它唯一知道的就是，只要调用Product角色和生成实例的方法，就可以生成Product的实例。在示例程序中，createProduct方法是用于生成实例的方法。 ConcreteProduct（具体的产品）ConcreteProduct角色属于具体加工这一方，它决定了具体的产品。在示例程序中，由IDCard类扮演此角色。 ConcreteCreator（具体的创建者）ConcreteCreator角色属于具体加工这一方，它负责生成具体的产品。在示例程序中，由IDCardFactory类扮演此角色。 类图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【图解设计模式】Template Method模式]]></title>
      <url>%2F2018%2F05%2F30%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Template-Method%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[在父类中定义处理的流程，在子类中实现具体处理内容。 示例将字符和字符串循环显示5次。 类图 AbstractDisplay类1234567891011121314public abstract class AbstractDisplay &#123; abstract void open(); abstract void print(); abstract void close(); final void display() &#123; open(); for (int i = 0; i &lt; 5; i++) print(); close(); &#125;&#125; CharDisplay类12345678910111213141516171819202122public class CharDisplay extends AbstractDisplay &#123; private char ch; public CharDisplay(char ch) &#123; this.ch = ch; &#125; @Override void open() &#123; System.out.print("&lt;&lt;"); &#125; @Override void print() &#123; System.out.print(ch); &#125; @Override void close() &#123; System.out.println("&gt;&gt;"); &#125;&#125; StringDisplay类123456789101112131415161718192021222324252627282930313233public class StringDisplay extends AbstractDisplay &#123; private String string; private int width; public StringDisplay(String string) &#123; this.string = string; this.width = string.getBytes().length; &#125; @Override void open() &#123; printLine(); &#125; @Override void print() &#123; System.out.println("|" + string + "|"); &#125; @Override void close() &#123; printLine(); &#125; private void printLine() &#123; System.out.print("+"); for (int i = 0; i &lt; width; i++) System.out.print("-"); System.out.println("+"); &#125;&#125; Main类123456789101112public class Main &#123; public static void main(String[] args) &#123; AbstractDisplay d1 = new CharDisplay('H'); AbstractDisplay d2 = new StringDisplay("Hello, world."); AbstractDisplay d3 = new StringDisplay("你好，世界。"); d1.display(); d2.display(); d3.display(); &#125;&#125; 运行结果&lt;&lt;HHHHH&gt;&gt;+————-+|Hello, world.||Hello, world.||Hello, world.||Hello, world.||Hello, world.|+————-++——————+|你好，世界。||你好，世界。||你好，世界。||你好，世界。||你好，世界。|+——————+ 登场角色AbstractClass（抽象类）AbstractClass角色不仅负责实现模版方法，还负责声明在模版方法中所使用到的抽象方法。这些抽象方法由子类ConcreteClass角色负责实现。在示例程序中，由AbstractDisplay类扮演此角色。 ConcreteClass（具体类）该角色负责具体实现AbstractClass角色中定义的抽象方法。这里实现的方法将会在AbstractClass角色的模版方法中被调用。在示例程序中，由CharDisplay类和StringDisplay类扮演此角色。 类图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【图解设计模式】Adapter模式]]></title>
      <url>%2F2018%2F05%2F29%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Adapter%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[用于填补具有不同接口（API）的两个类之间的缝隙。 Adapter模式有以下两种： 类适配器模式（使用继承的适配器） 对象适配器模式（使用委托的适配器） 示例将输入的字符串显示为（Hello）或是*Hello*。 类适配器模式（使用继承）类图 Banner类123456789101112131415public class Banner &#123; private String string; public Banner(String string)&#123; this.string = string; &#125; public void showWithParen()&#123; System.out.println("(" + string + ")"); &#125; public void showWithAster()&#123; System.out.println("*" + string + "*"); &#125;&#125; Print接口1234public interface Print &#123; void printWeak(); void printStrong();&#125; PrintBanner类123456789101112131415public class PrintBanner extends Banner implements Print &#123; public PrintBanner(String string) &#123; super(string); &#125; @Override public void printWeak() &#123; showWithParen(); &#125; @Override public void printStrong() &#123; showWithAster(); &#125;&#125; Main类12345678public class Main &#123; public static void main(String[] args) &#123; Print p = new PrintBanner("Hello"); p.printWeak(); p.printStrong(); &#125;&#125; 运行结果(Hello)*Hello* 对象适配器模式（使用委托）类图 Print类1234public abstract class Print &#123; abstract void printWeak(); abstract void printStrong();&#125; PrintBanner类1234567891011121314151617public class PrintBanner extends Print &#123; private Banner banner; public PrintBanner(String string) &#123; this.banner = new Banner(string); &#125; @Override void printWeak() &#123; banner.showWithParen(); &#125; @Override void printStrong() &#123; banner.showWithAster(); &#125;&#125; 登场角色在类适配器模式中，Adapter角色通过继承来使用Adaptee角色，而在对象适配器模式中，Adapter角色通过委托来使用Adaptee角色。 Targer（对象）该角色负责定义所需的方法。在示例程序中，由Print接口（使用继承时）和Print类（使用委托时）扮演此角色。 Client（请求者）该角色负责使用Target角色所定义的方法进行具体处理。在示例程序中，由Main类扮演此角色。 Adaptee（被适配）Adaptee是一个持有既定方法的角色。在示例程序中，由Banner类扮演此角色。 Adapter(适配)Adapter模式的主人公。使用Adaptee角色的方法来满足Target角色的需求，这是Adapter模式的目的，也是Adapter角色的作用。在示例程序中，由PrintBanner类扮演这个角色。 类适配器模式的类图（使用继承） 对象适配器模式的类图（使用委托）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【图解设计模式】Iterator模式]]></title>
      <url>%2F2018%2F03%2F30%2F%E3%80%90%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91Iterator%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[按照统一的方法遍历集合中的元素。 示例将书（Book）放置到书架（BookShelf）中，并将书的名字按顺序显示出来。 类图 Aggregate接口123public interface Aggregate &#123; Iterator iterator();&#125; Iterator接口1234public interface Iterator &#123; boolean hasNext(); Object next();&#125; Book类1234567891011public class Book &#123; private String name; public Book(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; BookShelf类1234567891011121314151617181920212223242526public class BookShelf implements Aggregate &#123; private Book[] books; private int last; public BookShelf(int maxsize) &#123; this.books = new Book[maxsize]; this.last = 0; &#125; public Book getBookAt(int index) &#123; return books[index]; &#125; public void appendBook(Book book) &#123; books[last++] = book; &#125; public int getLength() &#123; return last; &#125; @Override public Iterator iterator() &#123; return new BookShelfIterator(this); &#125;&#125; BookShelfIterator类12345678910111213141516171819public class BookShelfIterator implements Iterator &#123; private BookShelf bookShelf; private int index; public BookShelfIterator(BookShelf bookShelf) &#123; this.bookShelf = bookShelf; this.index = 0; &#125; @Override public boolean hasNext() &#123; return index &lt; bookShelf.getLength() ? true : false; &#125; @Override public Object next() &#123; return bookShelf.getBookAt(index++); &#125;&#125; Main类12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; BookShelf bookShelf = new BookShelf(4); bookShelf.appendBook(new Book("Around the World in 80 Days")); bookShelf.appendBook(new Book("Bible")); bookShelf.appendBook(new Book("Cinderella")); bookShelf.appendBook(new Book("Daddy-Long-Legs")); Iterator it = new BookShelfIterator(bookShelf); while (it.hasNext()) &#123; Book book = (Book) it.next(); System.out.println(book.getName()); &#125; &#125;&#125; 运行结果Around the World in 80 DaysBibleCinderellaDaddy-Long-Legs 登场角色Iterator（迭代器）该角色负责定义按顺序逐个遍历元素的接口（API）。在示例程序中，由Iterator接口扮演这个角色，它定义了hasNext和next两个方法。其中，hasNext方法用于判断是否存在下一个元素，next方法则用于获取该元素。 ConcreteIterator（具体的迭代器）该角色负责实现Iterator角色所定义的接口（API）。在示例程序中，由BookShelfIterator类扮演这个角色。该角色中包含了遍历集合所必需的信息。在示例程序中，BookShelf类的实例保存在bookShelf字段中，被指向的书的下标保存在index字段中。 Aggregate（集合）该角色负责定义创建Iterator角色的接口（API）。这个接口（API）是一个方法，会创建出“按顺序访问保存在我内部元素的人”。在示例程序中，由Aggregate接口扮演这个角色，它里面定义了iterator方法。 ConcreteAggregate（具体的集合）该角色负责实现Aggregate角色所定义的接口（API）。它会创建出具体的Iterator角色，即ConcreteIterator角色。在示例程序中，由BookShelf类扮演这个角色，它实现了iterator方法。 类图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Slang]]></title>
      <url>%2F2018%2F03%2F06%2FSlang%2F</url>
      <content type="text"><![CDATA[ring a bellto arouse an often indistinct memory，唤起模糊的记忆多以否定形式出现：It/That/Sth does not ring a bell.记不得，想不起来了。尤其强调完全没有印象。 tell me about it告诉我吧，跟我说说，引申为（1）I have had the same experience.我也有相同经历。（2）a way of saying you agree with someone我同意你的观点。有时并不是出于不了解，想让对方再说些什么，而是表示深有同感，你懂的！ on the house（1）given away free免费赠送（2）without asking for money不用钱It’s on the house.常用于酒店、饭馆和酒吧免费招待的酒水、食物或服务。现在也更多地用于其他表达“请客”的语境中。 cold feetfearfulness or timidity preventing the completion of a course of action，因害怕胆怯临阵退缩突然缺乏自信或勇气，临阵退缩。常与动词get连用，即：get cold feet。 silver lininga hopeful or comforting prospect in the midst of difficulty，困境中的希望或安慰，出自一则西方谚语：Every cloud has a silver lining.每一朵乌云都镶着银色的边。用于在一切糟糕不幸的境遇中，看到的希望与生机，不幸中的万幸。 second thoughtsa reconsideration of a decision or opinion previously made，重新考虑已经做出的决定或意见惯用复数形式。通常表示后悔了，有了与之前不同的想法，做出了与之前不同的决定。 off the wagonno longer abstaining from alcoholic beverages，不再戒酒on the wagon戒酒中；(fall) off the wagon酒瘾复发。 break a legused to wish someone, such as an actor, success in a performance，预祝演出成功预祝表演成功。与good luck意思相近，但语境仅限于演出、表演等场合使用。 I’m all ears.acutely attentive，全神贯注全神贯注，集中注意力倾听。愿闻其详，洗耳恭听。 look over one’s shoulder往回看，回头看，引申为：keep watching for danger or threats to oneself，对危险或威胁时刻警惕可表示动作上的往后看，向后瞧；其引申义为时刻小心警惕。 put down roots播种扎根，引申为：to settle down somewhere; to make a place one’s permanent home，安顿下来，定居表示愿意在某地长久居住，定居，购置房产，在当地结交朋友等。 call the shotsto decide on the course of action; to be in charge，做重大决定、负责做得了主，说了算，也可以表示发号施令。 up one’s sleeve在袖子里，引申为：hidden but ready to be used，隐藏备用具有双重含义，直译为在袖子里，也可引申为备有锦囊妙招。 pull yourself togetherto regain one’s composure，重新镇定从字面解释，就是把“四分五裂”的自己拼凑在一起。重整精神，振作起来。 kiss the ringto show respect, often used in the imperative tense，不可免地表示尊重起源于传统宗教仪式中，亲吻罗马教皇手上戴的戒指，以表敬意和忠诚，引申为奉承讨好之意。 hang by a threadto be in danger of having something unlucky or bad happen，即将遭遇不幸或厄运形容千钧一发，朝不保夕，岌岌可危。 pull some stringsto use influence (with someone to get something done)，利用某人的影响力把事情搞定起源于木偶戏，演员在背后操作木偶身上的线。引申为通过非常规渠道，调动可利用的关系，达到目的，走后门。 tight shipto run a ship or an organization in an orderly and disciplined manner，有秩序，有纪律地管理组织原指不漏水的船，形容一艘船上纪律严明，管理井然有序。广泛地用来形容其他组织或团体。惯用动词run来搭配，run a tight ship。 turn over a new leafto start behaving in a better way，重新开始好好表现16世纪时，人们把书本的页面称为“leaf”。翻到新的一页，也就是俗话说的“翻篇”，引申为改过自新，洗心革面。 get off on the wrong footto begin doing something in a way that is likely to fail，失败的开局也作start off on the wrong foot，刚开始就进展不顺，开局不好。反义词get off on the right foot，开局良好，开了个好头。 beat a dead horseto persist in persuing or trying to revive interest in a project or subject that has lost its usefulness or relevance，在已无意义的事情上白费功夫做无用功，再怎么做也是徒劳，无济于事。搭配的动词有flog a dead horse。 jaw drops下巴掉下来，引申为：to show great surprise，惊叹不已one’s jaw drops/drop one’s jaw吃惊不已，目瞪口呆。 get one’s head aroundto be able to understand something (usually negative)，能够理解某事（通常以否定形式出现）绞尽脑汁努力想明白。常与动词wrap搭配，wrap one’s head around。 water under the bridgea past occurrence, especially something unfortunate, that cannot be undone or rectified，无法改变的过去的不幸桥下匆匆过去的流水，有覆水难收之意。尤其指不好的事，已经发生了，已经过去了。 my hands are tied绑住的双手，引申为：someone is not able to help or intervene，帮不上忙或无法介入（婉拒他人请求）无能为力，束手无策。常用于必须按照规矩办事，不能通融。 open booka person or thing without secrecy or concealment that can be easily known or interpreted，没有秘密或容易被看穿的人或事一本开启的书。指一个人坦率直言，没有秘密，没有城府。 walk on eggshells走在蛋壳上，引申为：to walk carefully, to take steps gingerly, to be very diplomatic and in offensive，步步小心谨慎，礼数周全，不冒犯“走在鸡蛋壳上”般小心翼翼，与“如履薄冰”如出一辙，形容对待某人或某事谨小慎微。 not see the forest for the treescannot perceive the overview or important things because of concentrating too much on details，太关注细节而无法领悟整体或重点常以否定形式出现，cannot/not able to see the forest for the trees。眼光不能放长远，看不到大局，也就是“一叶障目，不见泰山”。 speak of the deviltalk about a certain person, and that person appears，说到某个人，那个人就出现了Speak of the devil, and in he walks.是一句古老的西方谚语，提醒大家不要再在聊天中提起魔鬼的名字，否则魔鬼就会立刻现身。现在专指某人不经念叨，说曹操曹操到。 cats and dogsvery heavily or steadily，非常强烈，严重最早只用于形容倾盆大雨，暴风骤雨。据说早年伦敦一遇到暴雨，街上的下水道堵塞，第二天街头就会漂浮很多被淹死的猫猫狗狗。现在也用于争吵中，形容吵得不可开交。 dodge a bullet躲过一颗子弹，引申为：having successfully avoided a sticky situation，成功避免了棘手的情况省去了麻烦，躲过一劫。 clear the air净化空气，引申为：to get rid of doubts or hard feelings，摆脱怀疑或不满直译为净化空气，引申义为讲清楚，澄清事实，消除误会。 get ducks in a rowto organize things well，打理有序把一切打理妥当，有条不紊。常见的搭配还有have one’s ducks in a row。 elephant in the rooma question, problem, or controversial issue which is obvious to everyone who knows about the situation, but which is deliberately ignored，人人心知肚明却故意不提的问题或话题形容无法忽视的，明摆着的事实。 take the high roadto do the right thing even if it’s not popular or easy，即使不易或不受欢迎，也要做正确的事采取高风亮节的做法，通常用于自己站上道德制高点，把别人比下去。 red tape红色的布带，引申为：obstructive official routine or procedure; time-consuming bureaucracy，碍事的官方规定或程序、费时的官僚机构起源于17世纪官方用于捆绑文案文书的红色布条，形容繁复的手续或冗杂的程序，有繁文缛节之意。 twist one’s arm拧折胳膊，引申为：to persuade someone to do something that they do not want to do，说服某人做不想做的事向对方施压，强迫对方做某事。也常用于“并不是真的不愿意，只是表示客气”，出于客套，说话人并不是真的不愿意，盛情难却。 on a silver platter于银盘之上，引申为：provide with something valuable for nothing，无条件提供有价值的东西双手奉上，拱手相送。说话人常常有点并不心甘情愿，或者有点后悔。可搭配的动词有hand/deliver to someone on a silver platter。 blow off steam释放蒸汽，引申为：to do or say something that helps you get rid of strong feeling or energy，做或说一些能摆脱负面情绪的事用法出自老式蒸汽锅。喷出蒸汽有助于释放蒸汽锅内的压力，从而避免爆炸的危险。运用到人身上，释放压力，发泄，减压。 go southto lose value or quality, to stop working，失去价值，失效起源于地图中上北下南的方位。往南从图上看，就是往下走，走下坡路。引申为往不好的局面发展，事情败露，计划泡汤，关系闹僵。同义的搭配还有head south。 steal one’s thunderto use, appropriate, or preempt the use of another’s idea, especially to one’s own advantage and without consent by the originator，在未经允许的情况下，为了自己的利益，窃取占用别人的主意抢风头。该典故起源于17世纪，英国一位剧作家John Dennis发明了在舞台剧演出中制造雷声音效的方法。后来当他创作的舞台剧被叫停后，他发现其他正在上演的舞台剧盗用了他制造雷声的办法。John愤怒不已，抱怨道：“They will not let me play run, but they steal my thunder!“。 once in a blue moonvery rarely, almost never，极其罕见，几乎从不形容比sometimes还要罕见，绝无仅有。 nail in the coffin棺材上的钉子，引申为：an action that will cause something to end，指示终结的举动棺材上的钉子，颇有板上钉钉，死定了的意味。指最后致命的一击，最强补刀。搭配的用法有the final/another nail in the coffin (of…)。 flash in the pan锅里的一道光，引申为：someone or something that draws a lot of attention for a very brief time，短暂地吸引过关注的人或事出处说法不一，最普及的说法是来自于美国淘金热的年代。当时淘金使用的工具类似平底锅，把挖来的泥沙放在锅里浸上水，如果有金子的话，能在阳光下看到金光。flash in the pan说的是徒有一道光线，并没有真金，指空欢喜一场，昙花一现。 peas in a pod在同一颗豆荚中的豆子，引申为：very similar; two of a kind，非常相近，同一类同一颗豆荚里的豆子。既可以用来形容两人关系亲密到难舍难分，也可以用来形容两人当下的境遇相同，或志同道合。亲如兄弟（姐妹）。 ball and chain拴犯人用的枷锁，引申为：a heavy restraint, a wife，强烈的束缚，妻子枷锁，引申为牵绊，束缚，也常常用来代指妻子。 get under one’s skin深入皮肤底层，引申为：to bother or irritate someone，打扰或激怒某人用于被惹恼，被激怒，被强烈地影响了情绪。 poker face扑克脸，引申为：a face that show no emotion or intention，没有任何情感或意图的表情起源于职业扑克牌手在竞技中，为了不让对方看穿自己的牌面，要始终保持面无表情，也就是“扑克脸”。引申为板着脸，一本正经。可搭配的动词有give/lose/practise poker face。 smell bloodto recognise an opportunity to be more successful, especially by taking advantage or someone who is in a difficult situation，发掘能更成功的机会，通常要通过趁人之危原指鲨鱼在海中嗅到血腥味，就会发动攻击。现在多用来形容找准机会，随时准备行动，发动攻势，伺机而动。 push one’s luck把运气“推一推”，引申为：to try too hard to get a particular result and risk losing what you have achieved，为达到目的努力过头，冒着失去已有成就的风险过于希望好运延续，而很有可能得不偿失，即得寸进尺。经常用于否定句中，善意地提醒对方——Don’t push your luck。 cold shoulderdeliberate coldness or disregard, a slight or a snub，故意冷淡忽视、怠慢或斥责最早用来形容待客冷淡的房东或寄宿主人。如今指故意漠视冷落某人，不理不睬。 white liean often trivial, diplomatic or well-intended untruth，微不足道，高明或出于好意的假话在英语传统中，white与good，pure近义，象征着好的初衷。意味着善意的谎言，而现在也用于并非出于好意，而只是耍了耍小聪明，自以为高明的小谎言。 penny for your thoughts一便士买你的想法，引申为：what are you thinking about?你在想什么？据说已经流传了四百多年。在四百年前，一便士还是非常值钱的银币。专门针对身边突然心不在焉的人，就是说“你走神了”。现在则用于询问身边人的想法。 high timethe latest possible time, a time that is almost too late，最后可能的时间，几乎太迟的时候最后的紧要关头，再不…就迟了。比It’s time to更紧急，更刻不容缓。 loose ends绳子毛糙脱线的一端，引申为：a detail that is left unsettled, unexplained or incomplete，遗留未解决、未解释或未完成的细节本义是松开的线头。在罪案剧中，常看到杀手在灭口之前对对方说：“You’re a loose end”，指把柄、遗留问题。常搭配的动词短语是tie up。tie up loose ends解决遗留问题，扫尾。 hold your horses骑马的时候，勒紧缰绳，让马儿慢下来，引申为：stop, slow down，停下，慢点原指勒马，现在用于让对方等等，慢点说，是wait, hold on等的另一种形式。 a taste of your own medicine自己药的味道，引申为：a sample of the unpleasantness that one has been giving other people，复制一个人给其他人带来的不快你自己的苦药，自食其果。可搭配动词get/have a taste of your own medicine, give someone a taste of one’s own medicine。 humble pie用猪牛羊的内脏做的馅饼，引申为：to be forced to admit that you are wrong and to say you are sorry，被迫承认错误并道歉原指用动物内脏制作的馅饼，西方人认为动物内脏是低等的肉质，因为只有穷人才吃。吃动物内脏制作的馅饼，就是低人一等。现在则引申为被迫认识到自己的错误，屈辱地认错或自取其辱，“被打脸”。 lion’s share狮子的那份，引申为：the largest portion，最大份额出自《伊索寓言》中的一则故事。一头狮子与另外三头野兽去打猎。它们猎到了一头鹿，把鹿分成了四份，准备平分。谁料狮子拿了自己应得的那份后，说：“我是森林之王，所以还得再分一份。我的勇气与力量无人能及，所以还得再拿一块。至于第四块的归属，如果你们想跟我挑战的话，我们就来比试比试吧。”最后，狮子把整只鹿独吞了。用来形容占据最大份额或绝大多数。 sinking ship一艘将沉没的船，引申为：a company or other organization that is failing，即将衰败的公司或组织tight ship形容纪律严明、管理有序的组织。sinking ship指大势已去，每况愈下的组织。西方人很喜欢用ship来代指一个团队或组织。搭配的动词有desert/leave/jump a sinking ship。 make ends meet将两端接上，引申为：to earn and spend equal amounts of money，收入与支出持平最早起源于航海船上，系在桅杆上的绳子如果断了，船长为了节省开销，就会让人把断掉的两端重新系在一起。现在则引申为量入为出，精打细算。 a pretty pennyto be expensive; to cost a lot of money，昂贵的，花一大笔钱一大笔钱。这里pretty不是指“漂亮好看”，而是取“数额可观”之意。 hold a candleto be equal to someone; to measure up to someone，与某人平等，比得上某人当年，持烛人这份工作，因为没有任何技术含量，几乎只要长了眼睛的人都能干，所以被视为没有技术含量的低等工作。于是，人们用can’t hold a candle to来形容一个人没本事，连持烛人都不配，也就相当于“连提鞋都不配”。词条沿用到今天，便常常用于什么比不上什么，或配不上什么。 elbow greasehard work or effort, human energy，辛苦的劳作或努力，人的精力直译为在胳膊肘抹油，用于俚语中，指的是要花功夫，费力气，尤其是指体力活。 take a beatstop for a moment to relax; pause and think about what you are doing，停下来歇会儿；停下来想想自己打算怎么做表意是“休息一个节拍的时间”，实则引申为暂缓，从长计议，适用于各种想“等等再说”的语境中。 take off glovesto stop being calm or civil and show an intention of winning a dispute by any means，不再保持冷静或礼貌，表达出为赢得争执不惜一切的意图表义是摘掉手套，现多引申为为达目的，采取强硬手段，不惜一切，放手一搏。 face the musicto receive punishment; to accept the unpleasant results of one’s actions，接受惩罚，接受自身行为造成的不良后果Let’s face the music,起源于军队驱逐劣迹士兵的仪式。现用于日常对话中，包含两层含义：一是面对不好的结果；二是接受随之而来的惩罚。 late bloomera person who finally develops a useful or superior skill or talents later than expected or desired，某人比预期中晚得开发出有用或优异的技能原指晚于花季盛开的花朵，直译即迟开的花。后来便广泛地引申为较晚掌握技能或展现杰出的才能，“大器晚成”。 glass ceilingan unacknowledged discriminatory barrier that prevents women and minorities from rising to positions of power or responsibility, as within a corporation，阻止女性和少数民族在一个集团内，拥有更高权利或责任的不可言说的歧视性障碍glass ceiling就是一层看似无物，却又真实存在着的“玻璃天花板”，成为很多女性和少数民族或种族的上升瓶颈、升职障碍。 in one’s shoesto allow oneself to see or experience something from someone else’s point of view，从其他人的角度看待或经历西方人借“穿别人的鞋”来比喻设身处地，站在他人的立场上考虑问题。常用的有If I was in your shoes，如果我是你。 dust settlesWhen the dust falls out of the air; When things have calmed down，当灰尘从空气中落下；当事情缓和下来尘埃落定。常见的搭配有：When dust settles/Let the dust settle first。 icing on the cakesomething good that is added to another good thing，好事相继发生蛋糕上的装饰，指锦上添花。也用于反讽，指雪上加霜。 nest egg仿制的假蛋，留在鸡窝里，不拿走的蛋，引申为：money saved and held as a reserve for emergencies, retirement, etc，存下来的钱，用于应急或退休等等的储蓄始终留在鸡窝里的一颗蛋，如今已引申为私房钱，养老金。常用的搭配有sit on a nest egg拥有一份储蓄金。 arm’s lengtha distance, avoiding intimacy or familiarity，一段避免亲密或熟悉的距离指的不只是一只胳膊的距离。相隔一只胳膊，说的是保持一段不可逾越的距离。可搭配的词组有keep at arm’s length/stay with arm’s length。 old chestnutsomething that has been repeated so many times that it has lost its impact，重复太多，以致失去效力戏剧已被遗忘，而“老栗子”的说法沿用至今，用来指代一切过时的、老套的、陈旧的人与事。起源：19世纪英国作家William Dimond写过一出情景剧（The Broken Sword），剧中有一位爱聊天的西维尔船长，总爱反复再三地跟大家讲重复的段子。讲着讲着，后来的版本也不免与最初的版本有了出入。一天，他又讲到一个反复多遍的笑话，里面提到一棵树，这次他说是皮栎树。话音刚落，立刻被朋友博布罗打脸：“这个故事我听你讲了27遍了，我肯定你之前说的是栗子树！” no good deed goes unpunishedlife is unfair and people can do or try to do good things and still end up in a lot of trouble，抱怨生活不公，试图做好事却惹来麻烦好心没好报，说话人往往有一点挖苦或自嘲的小无奈。也常用于“初衷是好的，结果却适得其反”的对话中。 keep nose cleanto keep out of trouble, especially trouble with the law，不惹麻烦，尤其是触犯法律曾经是妈妈提醒宝贝要讲究卫生的一句叮嘱，现在用于成人世界，是警告闯祸精们，要洁身自好，不要惹麻烦。尤其在罪案剧中，是训诫有前科的犯人，不要干坏事。 safety in numberssafety achieved by being concealed in or united with large numbers of people or other creatures，通过联合或隐藏在很多人或物中达到安全的目的人越多，越能减少可能的风险，保证安全，也可以理解为常说的“人多势众”，“人多力量大”。常用的句型是There’s safety in numbers。 pins and needles图钉与针，引申为：a tingling feeling in some part of one’s body, especially the arms and legs，身体某部位发麻形容身体发麻。也可以用来表达焦虑不安的情绪，只需与介词on连用，on pins and needles，坐如针毡。 peanut gallerythe hind most or uppermost position section of seating in a theatre balcony; a group of people whose opinions are considered unimportant，剧场观众席最后或最高的位子；最无关紧要的人原指剧场演出的观众席中，最便宜的座位。从台上遥望这些座位，会有一颗颗花生的既视感，因此得名。如今，这个词组广泛地用来形容各色路人甲及围观群众。 fishing expeditiona search for information without knowledge of whether such information exists，在不知道信息是否存在的前提下搜查信息现如今这则词条已经不光用来指代捕鱼。更多地用于司法行业，指在没有嫌疑或情报指向的情况下，盘查对方的各项信息，以期找到有利的线索。而在美国，也会出现为了打击对手，蓄意组织对对方的调查，一旦找到蛛丝马迹就能抹黑对方的情况，这从法律意义上说就是非法调查。因此，既可以指撒网式盘查，也可以直接指代“非法调查”。 take the fifthrefuse to testify by invoking the fifth Amendment, which states that nobody may be forced to testify as a witness against himself ot herself，通过援引《第五修正案》中，证人不可被强迫作出对他人不利的证词，来拒绝作证来源于美国《第五修正案》的条例。条例中明确规定了证人有权保持沉默。这则原本仅用于法庭上使用的词条，被广泛地运用，来表达不想说，或不想回答的意思。 salt of the eartha person or group considered as the best or noblest part of society，被认为是社会中最好或最崇高的人或团体直译为地球之盐，可见这群人对社会的重要性。不光是a good person或者a nice guy，而是最高级：人见人爱的社会顶梁柱。 turn the tablesto change a situation so that someone’s position is opposite of what it was，使某人的处境发生了与之前相反的变化直译好似“掀桌”，实则有“翻盘”之意。就像双陆棋中有太多运气的因素，指风水轮流转，尤其是由坏转好，反败为胜，或者扭转局面之意。 save one’s skinto save someone from injury, embarrassment or punishment，拯救某人免于受伤、尴尬或惩罚意指自保，为自己开脱。不止“拯救皮肤”可以表达这个意思，save one’s neck/save one’s bacon，也都是可以互换使用的近义词条。 sitting duck可以不费吹灰之力逮到的呆坐着的野鸭，引申为：an easy target or victim，容易被攻击的目标或受害者原指容易被猎到的呆坐不动的鸭子，现在引申为容易被攻击的目标，面对攻击束手无策，坐以待毙。 cold turkeyimmediate, complete withdrawal from something on which one has become dependent, such as an addictive drug，迅速彻底地戒掉某种依赖性的习惯，比如药物上瘾指的是最早不加以任何装饰的火鸡的做法——完完全全就是一整只朴实无华的鸡！后来，人们就用来形容直截了当，不拐弯抹角。go cold turkey用来形容干脆利落地戒掉上瘾。 under your beltachieved; counted or scored; learned; mastered，取得成绩，得分；学会掌握原指把食物进入肠胃里，也就是消化掉了。现在它不仅指代消化食物，也更多地用来形容掌握了一项新技能或经过了一段经历，而这些技能或经历对往后的人生能起到积极的影响。 scratch the surfaceto just begin to find out about something; to examine only the superficial aspects of something，刚开始有所发现；对事物的观察停留在表面阶段原指工匠取材时，为了做标记，只用刀在树木或石头的表面留下浅浅的划痕，而不伤害到材料的内里。现在这则词条被广泛应用来表示略知皮毛，对事情的认知停留在表面。 cook the booksbooks账本to record false information in the accounts of an organization, especially in order to steal money，在组织的账目上记录错误信息，尤其是为了窃取钱财做假账，对账目做手脚。最早出现在18世纪的一篇新闻报道中，该记者使用了动词cook生动地描绘出对账本数字任意发挥，“添油加醋”的画面感。 bad bloodfeelings of hate between people because of arguments in the past，由于过去的争执导致彼此间仇恨最早出现在19世纪，专门用于形容家庭成员之间的关系不和，指的就是血亲。现在这则词条广泛地用于形容人与人之间各种不睦的关系，可搭配的介词是between，如(there’s) bad blood between A and B。 at one’s fingertipsimmediately and easily available，迅速而轻易地获得直译为“在指尖”，实际指近在咫尺，触手可得，完全掌握在自己手中，予取予求。 bite one’s tongueto stop yourself from saying something because it would better not to, even if you would like to say it，阻止自己说出来，因为即使很想说，也还是不说为好表意是要到舌头，现在引申为出于礼貌或其他方面考虑，不多嘴，少说话，保守秘密。 until cows come homefor a very long time，很长一段时间直到奶牛回家。因为牛儿要在山头逛上一整天，直到天黑才会回到牛圈，因此被沿用来形容要很长很长的时间，甚至是无限期。 full of beansenergetic; frisky; badly mistaken，有活力，活泼；严重弄错了表意是“满满的豆子”，而从豆子引申出了多重含义。根据语境的不同，既可以表示充满活力，精神饱满，也用来形容一个人说话不着调，胡说八道。 in the doghousein a situation in which someone is annoyed with you because of something you did，因为自己的所作所为，惹恼某人直译是在狗屋里，实际可以把“打入狗屋”理解为“打入冷宫”之意，即失宠，受冷落。而相反地，out of doghouse就是复宠，重获喜爱或青睐。起源：出自1911年发行的著名小说《彼得潘》中的情节。在书中第16章，讲到达林先生因为一时大意，把保姆赶出家门，导致自己的孩子们被绑架了。事后他非常悔恨，便惩罚自己住进了狗屋里，甚至上班的时候，也让人把狗屋一起运送过去。 beat around the bushto avoid answering a question; to stall; to waste time，避免回答问题，拖延，浪费时间表意上理解好似在树丛中放空拳，实则引申为拐弯抹角，回避重点，不直截了当。 fly on the wallsomeone who can secretly see and hear what happens，能隐秘地看见和听见事情发展经过的人直译为墙上的苍蝇，形容以及其不显眼的存在，出现在事发现场，目睹事情经过，而不引起任何人的注意。也形容窥探着的隐蔽技巧高超，无孔不入。 eat crowto be forced to accept a humiliating defeat，被迫接受羞辱的挫败起源于1812年美英战争期间。一位英国军士与一位美国猎人在尼亚加拉河畔狭路相逢。英国军士缴了猎人的步枪，并强迫他吃掉刚捕获的一只乌鸦。美国人只能从命。而等到美国人拿回自己的步枪，就立刻以其人之道还治其人之身，让英国人也受到同样的羞辱。由此引申为被迫认错，丢脸。 die-hardstubbornly resisting change or clinging to a seemingly hopeless or outdated cause，固执地拒绝变化，或坚守着希望渺茫或过时的事情由军队中一句誓死守卫的口号，演变为形容顽固不化，坚守不移的词条。可以用来形容死忠、脑残粉等等。在使用上，既可以作为名词，也可以作为形容词。起源：在1811年的阿尔布厄拉战役（Albuhera）中，西米德塞克斯（West Middlesex）的57团经过了惨烈的交火之后，他们的指挥官英格里斯（Inglis）上校被榴弹击中了脖子和胸口。英格里斯拒绝立即治疗，而是躺在士兵们面前，让他们坚守阵地，他高声喊着：“Die Hard 57th, Die Hard!”（57团不死）最后57团的570名将士中，有422名英勇就义。 out on a limbin a dangerous position to do something; at risk，做某事面临危险的局面；冒险表意为去往树枝外沿，引申义为处于危险的境地，孤立无援。常与动词go搭配，即go out on a limb去冒险。 all bets are offthe outcome of a situation is unpredictable，某种情况的结果不可预知原指在博彩中，之前下好的赌注都不算数了，后来渐渐被引申为，之前的条件、规则、逻辑等等都不作数了，推倒重来，一切皆有可能之意。 kid gloveto deal with someone very gently or carefully，温柔谨慎地对待某人treat someone with kid gloves/handle someone with kid gloves，字面理解是要戴上羊羔皮手套才能碰，意指小心翼翼，谨慎地对待。与take off gloves（不惜一切，放手一搏）正好是一对反义词。 bite the bulletto accept something difficult and try to live with it，接受并忍受困难的事情战时缺乏麻醉剂做手术，就只好咬紧子弹的做法，演变为今天指代“咬紧牙关挺住”的词条，也可以指勉为其难，为难自己做某事。 deep pocketsif an organization or a person has deep pockets, they have a lot of money，拥有大量钱财的组织或个人从字面上理解是深深的口袋，意指掌握了巨大的财富。要注意的是，既可以指代巨大的财富或资源，也可以指代拥有这些财富或资源的人。 apples and orangestwo items or groups of items are compared that cannot be practically compared，把两件或两组不具可比性的事物作比较外国人用苹果比橙子，形容把性质完全不同的事物放在一起做比较，风马牛不相及。在西方，能表达相同意思的说法还有chalk and cheese。 two left feetto be very awkward with one’s feet，出脚非常笨拙两只左脚。说的不是残疾或异形，而是用来形容脚步笨拙，不够灵巧。在各种社交场合中，尤其用来形容不会跳舞。 hard and fastdefined, fixed and invariable，已确定、固定和不可变的指严格固定下来，不容改变的。fast在这里指的是稳固，牢固。在乘机时常听到广播里说的“fasten your belt”（系紧安全带）取的也是这层意思。常用句型有：It’s not a hard and fast rule, but…（这不是硬性规定，但是…） raise the roofto be extremely noisy and boisterous; to become extremely angry。异常嘈杂喧闹；极度生气是一则多义词条。它既可以指愤怒，怒气冲天；也可以指狂欢，嗨翻全场。这两种能制造出刺耳噪音，表达的意思却截然不同的情况，都可以用这同一则词条来表达。 all thumbslacking physical coordination, skill or grace; clumsy，缺乏肢体协调性，技能或者优雅；笨拙原意是讽刺一个人十根手指都是拇指，意指不灵活，笨手笨脚。 stick in the mudone who lacks initiative, imagination or enthusiasm，被动，缺乏想象力或热情直译是插在泥里的木棍，搅也搅不动。常用来形容一个人墨守陈规，顽固不化，或者是不思进取。 go down the drainto fail; to be thrown away or wasted，失败，被丢弃或是浪费表意是冲进下水道，现在引申为白白浪费，付诸东流的意思。除了drain指下水道之外，go down the chute/tubes，都是相同的意思。 a field dayto be able to do something you enjoy a great deal, esp. criticizing someone，做某件让你非常享受的事，尤其是批评别人从19世纪的军营中诞生，到了20世纪普遍地用于日常对话中。have a field day既可以形容度过了愉快、尽兴的时光，也可以指抓住了难得的机会，尽情地批评或讽刺他人。 put finger onto indicate exactly; remember to; to discover; locate，具体地指出，记得，发现，定位直译是伸出手指指出来，引申义是明确具体地指出，说得清楚明白。同义词条还有lay one’s finger on。 up one’s alleysuited to your abilities or interests，适合你的能力或兴趣直译为在谁家狭窄的小街巷上，如今引申为适合某人的才能或特长，或特别擅长的事情。常用的句式是doing something is right up my alley。 a good sportsomeone who can accept a loss in a competition or can accept being the butt of a joke，能接受比赛失利或是不在乎成为笑柄的人从竞赛精神出发，指不看重结果，输得起，有度量，或是有参与精神的人。 brownie pointsa notional mark to one’s credit earned for being seen to do the right thing，因为被看见做了正确的事，而得到抽象的表扬现如今已经不光指代女童子军中的“做好事分数”，而是用于各种日常场合，指好评，认可和赞扬。常用搭配有earn/score (some) brownie points。 hit the jackpotto win a large amount of money gambling or in a lottery; to be exactly right; to find exactly what was sought，在赌博或彩票中赢得一大笔钱；绝对正确；找到了确切的答案指中头彩，中大奖，获得了与金钱相关的巨大胜利，它可以来自赌博或投资等等。除此之外，它还可以表示说对了，一语中的，或是发现了真谛。jackpot是起源于美国1870年代的一种赌牌游戏。参与者先把下的注都放进牌桌中心的pot（奖池）里，游戏规则是每人发5张牌，谁的手里有大于10的一对牌，方可进行下一轮，没有直接淘汰。也就是说，手里至少有一对Jack，才有赢得pot里筹码的机会。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Oral English 2]]></title>
      <url>%2F2018%2F02%2F14%2FOral-English-2%2F</url>
      <content type="text"><![CDATA[Phil’s a snore.这个人太没劲儿。 讲解关键词snore，作动词表示‘打呼’。例句1. Stop snoring.别打呼了；例句2. You snore like a pig.你打鼾打的跟猪一样；作名词表示‘无聊的事情或人’。原句也可以改为：Phil’s a snore and he always makes us snore.Phil这个人很没劲，总是让我们打鼾（无聊后睡着） 补充1.口语里表示‘无聊’的表达bore：He’s a bore.他这个人很没劲；boring指令人感到无聊的：He’s so boring.他让大家感到无聊；bored指自己感到无聊：He’s so bored.他感到很无聊；2.发音技巧：口语里经常把is与主语连读：Bingo is here=Bingo’s here；My dad is a teacher=My dad’s a teacher.养成连读习惯，因为美国人很少说is，直接是‘s. I’ll go see if the idiot has checked in yet.我去看看那个白痴来了没。 讲解关键词check in，表示‘登记’；因为登记需要本人到场，所以原句中直接翻译成‘来’，口语里的check in比较多的是酒店登记入住与机场办登记手续.例句：1. What time should I check in?我几点来登记入住比较好？2. go to the check-in counter去登记台办理登机手续 补充check在口语里作动词可表示1. 检查：go check the second floor去看下二楼；2. double-check再次检查；3. 寄存：I’m gonna go check my coat.我去把外套寄存一下；4. 下象棋时表示：将你的军！；5. 作名词表示‘账单’，在国外吃完喝完就和服务员说：Check, please.表示‘买单’。 Or perhaps you’re turning your back on a man wrongfully accused.又或者是你要离开的人是被冤枉的。 讲解关键短语1. turn one’s back on…表示‘忽略，抛弃…‘。别人对你不理睬转身离去你就可以说Don’t turn your back on me!；别人放弃一个好的职业你可以劝他说You can’t just turn your back on your career；关键短语2. wrongfully accused.Wrong表示‘错误的’；wrongful表示‘不公平的，不合法的’；违法抓人就是arrest someone wrongfully；accuse表示‘指责，控告’；常见搭配：accuse sb of sth因为某事指责或控告某人，例句：Now you’re accusing me of this?你现在觉得事情怪我？（被冤枉时可以说） 补充back作名词表示‘背部’，必须知道的还有：I got your back.我帮你，我顶你；You’d better watch your back.你最好小心点；My back hurts.我背部疼。 It’s time to take the kissing up a notch.是时候让接吻上升一个高度了。 讲解关键词notch表示‘等级’，take sth up to a notch即表示‘将某事带到一个新的高度‘，take sth down n notch则表示‘将某事降一个高度’，动词可以换，比如tone作动词表示‘用某种语调说话’，tone it down a notch表示说话音调稍微小一点。 补充类似的表达还有take sth to the next level表示将某事带到一个新的阶段，例句：It’s time to take our relationship to the next level.是时候将我们的恋情发展到一个新的高度了；a notch below表示‘稍微差一点’，例句：This movie is a notch below that one.这部电影比那部稍微差一点；a notch above则表示‘稍微好一点’，例句：Tom is a notch above her.Tom比她稍微强一点；top-notch字面意思表示最高等级的；作形容词表示最好的。We need to find some top-notch players.我们得引入一些最顶尖的球员。 I gotta break in my new bag.我得赶紧背上我的新包。 讲解关键短语break sth in表示‘穿戴’，一般是新买的，赶紧穿戴来适应；例句：When are you gonna break in the shoes you bought last week?你什么时候穿上周新买的鞋？ 补充break in最常见的意思表示1. ‘强行入室’。例句：We can’t just break in.我们不能就这样强行进去；2. break in on表示‘打扰，影响到’。例句：The noise from outside broke in on my thoughts.外面的噪音打扰到了我的思路；关于break必须要知道的短语还有：break up with someone与某人分手；break sth off断绝某种关系；Break a leg!祝你好运（上台表演时才用）；break down机器的瘫痪或人的崩溃；take a break休息一下；break the ice打破沉默 That’s some drama.真是场好戏啊。 讲解关键词drama表示’戏剧‘，在口语中经常用来表示带有戏剧性的好戏；固定短语drama queen则用来表示一个很喜欢戏剧化小题大作的人，例句：Don’t be such a drama queen.不要如此小题大作；与它相似的短语是make a scene，表示‘引起众人围观’，例句：Keep it down. You will make a scene.小声点，不然会引来大家围观的。 补充drama的形容词dramatic表示戏剧化的，当一个人小题大作时，你可以对他说：You’re being so dramatic.你也太喜欢戏剧化了；相思词是emotional表示情绪化的：Don’t be so emotional.别太情绪化；相关表达还有：Keep it low.低调点；You gotta lay low.你得保持低调；Don’t make a big deal about it.别小题大作。 Since I’m the new girl, I figured there’d be some hazing.由于我是新人，我也想到我会被欺负了。 讲解关键词1. figure，除了熟悉的表示‘数字’，‘人物’等意思之外，口语中经常表示动词‘以为，想到’，一般用过去时形式较多，例句1：You’re the boss. So I figured maybe you could help me.你是老大，所以我觉得或许你能帮我；例句2：A: She’s not coming.她不来了；B: Yeah, I figured.嗯，我想到了；关键词2. hazing表示‘被欺负’，例句：There’s lots of hazing in the military.部队里有很多人被欺负的现象。 补充hazing的原形haze作名词表示‘雾霾’，形容词hazy表示‘雾霾很多的’.例句：It’s very hazy in Shanghai today.今天上海雾霾很严重；hazy还可表示模糊的。例句：My memories of his are very hazy.我对他的记忆很模糊了；雾很大也可说it’s very foggy. For starters, she’s always harsh on my body.首先，她一直对我的身材要求很苛刻。 讲解关键短语1. for starters表示‘首先’，在举例陈述第一条时经常用，同义短语还有firstly；first of all；to start with；to begin with，在做presentation时可表达多元化；关键短语2. Harsh on表示对…要求苛刻，例句：You’re being too harsh on your kid.你对你小孩太过于严格；同义短语是be hard on，例句：Don’t be so hard on him.别对他太严格了；因为hard口语里经常表示严格痛苦.Don’t give me a hard time.的意思就是‘别跟我过不去，别故意让我难受’。中文里的敬酒不吃吃罚酒在英语里就可以用You want to do this the hard way?来表达。 补充starter在英式英语里表示‘开胃菜’；美国人则用appetizer. They started to pick on me after I just arrived.我刚到他们就开始欺负我。 讲解关键短语pick on sb表示‘欺负某人’，例句：John’s always picking on me.John总是欺负我；美国校园里也有恶霸，叫bully.也可作动词，例句：I hate bullies. Theys always bully people for no reason.我讨厌恶霸们，他们总是毫无理由欺负别人。 补充流氓可以叫hooligan或thug；关于pick必须掌握的用法还有：1. just pick one.随便选一个吧；2. Take your pick.开始选吧；3. pick sb up去接某人；4. be picky挑剔的：Don’t be so picky about food.别这么挑食；5. pick one’s nose挖鼻孔；6. toothpick牙签；7. cherry-pick择优挑选；8. pick holes in找茬儿，例句：Why do you always pick holes in what I do?为什么不管我做什么你都找茬儿？ She’s at a new extension. I’ll transfer you.她有了新的分机号。我帮你转接。 讲解关键词1. extension在这里表示‘电话分机’。本意是‘延伸’；办公室分机号就是extension number.例句：I’m looking for Bingo. Do you know his extension number?我找Bingo.你知道他的分机号吗？关键词2. transfer表示‘转移转让’，此处表示‘转机’，例句：Could you transfer me to him?能把我转接到他吗？My boss is transferring me to Hong Kong.我老板要把我调到香港去。 补充和老外打电话比面对面聊天难度大。学会这些表达：1. Hello?喂？；2. You still there? 还在吗？；3. I’m losing you.听不到你说话了；4. Sorry I have bad reception.不好意思我信号不好；5. The connection is bad. I’ll call you back.信号不好。等会打给你。 We’re just gonna drop Hilary off and come right back home.我们把Hilary送到那之后立马就会回家。 讲解关键短语drop sb off，表示‘开车将某人放下’；比如你的朋友开车送你回家，到家门口你可以说：Just drop me off here.我在这下车就好；Drop him off at my sister’s place.把他送到我姐姐家吧；come right back home表示马上回家。英语里经常在back前面加right强调很快马上。比如和朋友聊天你要出去一下，你可以说I’ll be right back.表示我马上回来。 补充关于开车送人还需要知道的表达有：1. Give sb a ride载某人一程：Could you give me a ride home?能载我回家吗？；2. Take sb for a ride带某人兜风：Let me take you for a ride.我带你出去兜一圈；3. hitch-hike免费搭顺风车旅游（老外特别喜欢这样） She was potty-trained at eight months.她八个月大就教她如何上厕所了。 讲解关键词potty表示‘马桶（小孩用语）’；trained表示‘被培训’。美国人会在小孩小的时候教他们如何如厕，文化差异是美国的小孩儿是不穿开裆裤的，中国小孩基本都穿过，英语里会经常用一些迭声词跟小孩沟通，比如：wee-wee/pee-pee小便；poo-poo大便；choo-choo火车；还有些词成人也用，如nighty-night晚安；okeydokey好的. 补充toilet在英式英语表示厕所；去洗手间就是go to the toilet；英国人还喜欢用loo；toilet在美语里表示马桶；美国人喜欢用bathroom/washroom/restroom表示厕所：I’m gonna go to the bathroom.我去下洗手间。Bathroom原本指家里的卫生间，朋友之间在公共场所也会用。女生也可以说go to the ladies’ room；男生则用go to the men’s room. Obese knees are the hardest.肥胖的膝盖是最难弄的。 讲解关键词obese表示‘超级胖的’，名词为obesity.Obesity is a very serious problem in the US.在美国，肥胖是很严重的问题。因为美国人吃junk food（垃圾食品）很多，开车也比较多。Fat作形容词表示胖的；胖子叫fatty；胖猪叫fat-ass；fat作名词表示脂肪；fatty表示脂肪多的：You gotta go easy on fatty foods.你一定要少吃脂肪多的食物。 补充文化差异：中国人对身边胖的朋友喜欢昵称叫‘胖子’，但是fat在英语里是贬义词，如果一个人胖，你可以描述说：He’s a big guy.不要说He’s a fat guy.身材好可以说She’s slim或者She has a good body或She’s in good shape.Thin表示‘瘦’，在英语里也是贬义词。 You’re on your own, buddy.哥们，你得靠你自己了。 讲解关键短语on one’s own靠自己，例句：She did that all on her own.她是靠自己完成的；From now on, you’re financially on your own.从现在开始，你经济独立了！ 补充1.拒绝帮别人时可以说：1. There’s nothing I can do (about it).我也无能为力；2. I would if I could.（完整为：I would help you if I could help you）爱莫能助；3. I’ll see what I can do.我尽力而为吧。2.buddy表示朋友间的哥们；美国的父亲也喜欢叫儿子buddy，或简短的bud.美国人叫哥们还喜欢用man，dude，bro；英国人澳大利亚人喜欢用man，mate.在伦敦经常听到英国人说：Cheers, mate.Cheers在这表示‘谢谢’。美国人则会说：Thanks, buddy. I know. Tell me about it.我知道。可不是嘛！ 讲解I know看似简单，有两个注意点，1. 翻译成中文应是‘我知道’，而在别人告知或讲解后你该说‘我知道了’，对应英文则是：I see；Got it；Got you（Gotcha）；2. 对于别人说的你感同身受时，美国人喜欢说：I know, right?表示赞同。例句：A: It’s too hot in here.这儿太热了；B: I know, right?就是啊！Tell me about it字面意思是‘跟我说说这个’，在两种语境可用：1. 有人说We kissed last night（我们昨晚接吻了）；你可以说Tell me about it.这时对方是需要跟你描述昨晚的事的；2. 当对方说一件很明显或让你感同身受的事情时，比如It’s too hot in Shanghai.上海太热了，你说Tell me about it.意思是‘可不是嘛’，这时是不需要继续描述的。 Since you volunteered, no take-backs.你既然主动报名了，不准反悔哦。 讲解关键短语take sth back，表示拿回某物；口语里在说了自己后悔的话之后，可以说：I take it back.我收回我说的话；原句里的take-back是名词形式，动词短语连起来可表示名词，类似的还有：take sth away拿走某物；takeaway外卖，例句：Let’s order some Chinese takeaway.我们打电话叫中餐外卖吧。Volunteer可作名词表示志愿者；也可作动词表示‘主动做某事’。 补充口语里说的‘话’经常用word这个词来表示，eat one’s words可以表示‘收回说的话’，跟吃没有关系；I give you my word或者You have my word都表示‘我向你保证’；Keep your word不准食言；have a word with you跟你说句话 Chop-Chop.快点！ 讲解chop本身意思为‘剁碎’；可以想象烧菜时迅速切菜的动作，表示非常迅速；例句：We’re running late. Chop-chop.我们要迟到了，快点。 补充1.口语里经常用的表示快点的短语有：1. Hurry up；2. Come on/C’mon；3. Move it快点走；4. Get a move on!；5. Be quick（用的很少）；2.美国人还喜欢在句子后面加already这个词表示快做某事；有人有事不告诉你，你就可以说Tell me already.快点告诉我；你敲门很久没人开门你可以说Open the door already.快点开门；3.chopper则是俚语，表示‘直升机（helicopter）’；4.在句尾加real quick，表示很快回来：I’m gonna go to the bathroom real quick.我去趟洗手间，很快的。 She’s really slammed. Let’s not bother her.她手里太多工作了。我们不要去麻烦她了。 讲解slam作动词表示‘砰地关上’，如slam the door用力关门；在美国俚语中可表示给某人安排很多工作。例句：My boss slammed me before I was about to leave.我刚准备走，老板给我加了很多工作。所以原句中slammed作形容词表示工作很多很忙；bother作动词表示‘麻烦或骚扰’：1. Don’t bother to call me.别打电话给我了（打了我也不会接）；2. Is this guy bothering you?这人是不是在骚扰你？ 补充口语里表示忙碌可用：I’m really busy；I’m really swamped；My hands are full；I have a lot on my plate；正在忙可以说：I’m in the middle of something.；the slam是俚语表示监狱；Slam dunk表示‘灌篮’。 High school for me was no picnic.高中对于我来说蛮艰难的。 讲解picnic除了表示野餐外，还可表示简单的事情。‘no picnic‘是固定表达表示艰难的事情。例句：Memorizing 500 new words a day is no picnic.一天背诵500个生词很难。 补充1.口语中表示事情或任务很简单轻松的表达有名词breeze/cinch/child’s play/a piece of cake/duck soup；有形容词easy/easy-breezy/easy as pie；2.表示轻松成功做成某事可以说nail sth或kill sth.比如有人问你how was the interview?面试进展怎么样？你就可以回答：Nailed it.成功搞定了；你朋友上台之前紧张，你可鼓励说：You will kill it.你会成功搞定的。 Alright. Bring it in!好吧。过来拥抱一下。 讲解关键短语bring it in字面意思是‘把它带进来’，其实是美国人在要和对方拥抱时经常说的话。也可以是人多时，比如教练会说bring it in, guys.就是让大家过来聚在一起打气。所以下次要让对面的人过来拥抱一下除了说give me a hug让我抱一下外也可以说Bring it in. 补充美国人英国人的肢体动作比较多，男生之间握手要用力，别人会夸你good handshake，否则会觉得很weak（弱）；击掌可以说：High five!或Give me five；击拳可以说：Pound it!；女孩之间在亲脸颊（kiss on the cheek）比较普遍，可以亲一边；要是好久不见也可用力亲两边；刚认识的朋友一般不亲。 Cuz my tai chi class is doing a pub crawl.因为我们太极班的同学今天要各种串吧。 讲解这边涉及到文化特色的问题，pub表示小酒馆或小酒吧，也可说tavern或bar；crawl表示‘爬行’。因为西方人喜欢喝酒的文化，pub crawl（也叫bar crawl）表示的是一种喝酒活动，一帮朋友组队，一个下午或一个晚上要去很多酒吧喝酒，在这家喝完去那家喝，感觉是从这家爬到那家似的。Bar crawl因此而得名。 补充关于酒吧，bar指那种一般安静可聊天的酒吧；club或nightclub指夜店；如果在夜店，bar则表示‘吧台’，家里的吧台也叫bar.例句：let’s go to the bar.我们去吧台吧；Let’s go to a bar.我们去一家酒吧吧。注意区别。西方大部分酒吧也是不可以抽烟的。 We’re screwed.我们完蛋了。 讲解关键词screw，除了熟悉的作名词表示螺丝钉；作动词表示‘拧’之外，口语中经常表示气愤生气，例句：Screw out!去你的！；Screw that!管它呢！；用screw的被动形式screwed表示完蛋了，是screwed up的简写：You’re so screwed (up).你毁了！ 补充关于screw必须要知道的表达有1. screw sth up搞砸了：Sorry I screwed up.对不起我搞砸了；2. screw around乱搞男女关系或闹着玩儿（具体看语境）：You can’t screw around.不要到处瞎搞；We’re just screwing around.我们俩闹着玩的；3. screw sb up使某人精神崩溃：Your divorce is gonna screw you up.离婚会让你崩溃的。 Any other topping suggestions?顶部要放什么配料呢？ 讲解关键词topping，由top变化而来，top作名词表示‘顶部’或女生穿的短袖体恤等，the top ten players最顶尖的十位球员；所以形容词topless表示上身裸体的；top作动词表示‘超越’，例句：She topped her last performance.她这次的表演超过了上次；topping作名词表示食物顶部加的配料；在英式英语中topping作形容词表示特别棒的，等于excellent. 补充关于top必须要知道的还有1. tops表示‘顶多’，放于句尾：I have 5 dollars, tops.我身上最多5块钱；2. off the top of my head我首先想到的是；3. on top of the world特别开心；4. top up my phone给我手机充值 Hey, dig in, guys.大家开吃吧！ 讲解关键词dig in，字面意思是在里面挖，想象吃饭时就不难理解了。在美国家庭中，坐上饭桌时主人家长会说这句话，也会有人说Bon appetit.法语，表示有个好胃口. 补充在国外吃饭点餐要学会说1. take it easy on…, please少放一点：Take it easy on the onions please少放点洋葱；2. hold the…不要放：Hold the onions please不要放洋葱；3. 点餐请用Can I have…句型，不要说I want…；4. Check, please买单；关于dig还要知道：1. do some digging做些调查；2. I dig you我喜欢你（dig在口语中可表示like喜欢）；3. Can you dig it你明白吗；4. This is my digs.我住这.加了s的digs表示住处 Let’s pinky swear.我们拉钩。 讲解pinky和粉色没有关系，这边表示小拇指，也可写成pinkie，swear在这表示发誓，小拇指的发誓就是我们所说的拉钩一百年不许变。美国人在和别人有约定后还喜欢说You promise?你能保证吗？ 补充1.swear to sth表示对…发誓：I swear to God.我对天发誓；swear on sth表示以…发誓：I swear on my life.我以我姓名发誓；swear allegiance to…表示对…宣誓衷心；2.swear还可以作动词表示‘说脏话’：don’t swear不要说脏话；swear words脏话；3.关于pink还要知道in the pink表示健康面色红润：My dad’s in the pink.我爸现在身体不错；tickled pink很开心：I’m tickled pink to see you.看到你我很开心。 I am so hung-over.我现在特别宿醉。 讲解关键词hung-over形容词，表示宿醉，名词是hangover.用法：I’m having a huge hangover right now也表示我现在很宿醉；宿醉的特点就是头疼（have a headache）；身体缺水（dehydrated）；喝多了叫drunk；烂醉叫trashed/wasted/loaded/hammered，还有一个搞笑的说法是three sheets to the wind；微醺叫buzzed或tipsy；很清醒叫sober；酒量很好叫can drink like a fish. 补充关于hang必须要知道的表达还有：1. Hang in there.加油，顶住；2. Hang on (a second)等下；3. leave sb hanging让某人干等着；4. How’s it hanging=How’s it going最近怎么样；5. hang out一起玩，放松（不一定是在外面）hang out at my place在我家玩 Pick up the energy.振作起来！ 讲解pick up最简单的意思是‘捡起来’，原句字面意思表示把能量捡起来，其实就是振作的意思。如果是心情的失落需要振作就说：Pull yourself together. Pick up的意思还有1. 取东西：I’m here to pick up my jacket.我来取我的外套；2. 随便学点：I picked up some French when I was in Paris.我在巴黎的时候学了点法语；3. 接人：I’ll pick you up at 5.我五点钟接你；4. 变好了：My luck has picked up.我转运了；5. 振作精神，提神：He picked me up at my lowest.在我人生最低谷时他帮我重新振作；I need something to pick myself up.我得喝点东西提神。名词pick-me-up表示提神的东西。例句：What’s your morning pick-me-up?你早上喝什么提神？；6. pick-up (truck)客货两用的卡车 Sorry I just blew it.对不起，我搞砸了。 讲解关键词blow，都知道blow表示‘吹’，如blow out the candles吹灭蜡烛；the wind is blowing in my face风吹打着我的脸；blow dry吹干；blow dryer电吹风；但是blow在口语中经常表示‘搞砸’，如：I blew my test yesterday我昨天的测试搞砸了；Don’t blow it this time.这次别搞砸了. 补充搞砸了美语里还有：mess sth up/screw sth up.Don’t mess it up别搞砸了；关于blow必须要知道的用法还有：1. blow money挥霍钱：I blew 5 grand last night昨晚我挥霍了5000美金；2. blow sb off爽约：She blew me off again她又放我鸽子了；3. blow my mind使我震撼。 I think you need to cut her some slack.我觉得你对她应该松懈一点。 讲解关键短语cut sb some slack，本意表示‘允许某人稍微落后，休息’，也就是不要要求太苛刻。比如你已经工作了一天你女朋友还让你打扫家里，你可以说：Cut me some slack.让我休息放我一马的意思；相似的表达是give sb a break，字面意思是让某人休息一下。比如你酒量不好，有人一直盯着你让你喝，你可以说Come on, give me a break.拜托，放我一马吧。注：Give me a break也可以表示对别人说的话不相信，换个语境意思就是：你可以拉倒吧！ 补充slack作形容词表示疏忽的松懈的；slacker表示懒鬼。关于cut的表达还需要知道：Cut it out.赶紧停止吧！；cut in line插队，不要插队：Don’t cut in line.或No cuts, no buts, no coconuts.或直接No cutsies! Hilary hooked up with a boy at a party this weekend.这个周末Hilary在一个派对上跟一个男生好上了。 讲解关键短语hook up，表示‘与某人搞上了’，由于西方的性文化，hook up with sb一般是指两个人发生性关系，但也不绝对；hook sb up with sb还可以单纯表示介绍两人相识：Could you hook me up with your boss?能介绍我跟你老板认识吗？；hook sb up with sth表示帮某人搞到某物：My buddy hooked me up with 2 tickets我哥们帮我搞到了两张票。 补充hook本身的意思是钩子；fishhook表示鱼钩；所以其形容词hooked表示上瘾了；短语是hooked on：My brother is hooked on computer games.我弟弟网游上瘾了；Don’t ever get hooked on drugs.永远不要对毒品上瘾。Hooker则表示妓女，很常用。 Real estate’s great for those that are business savvy.房地产适合这些会做生意的。 讲解关键词1：real estate表示房地产；房地产中介公司就说real estate agency；中介要拿提成，在英文里是commission（佣金）；中介人就是realtor.关键词2：savvy作名词可表示懂行的人，专家。原句中business savvy就是生意专家，也就是会做生意的人；如果你对电器电子设备懂的多，你就是一个tech savvy，科技专家。 补充在某个领域的专家叫expert；医学类的专家是specialist；如果很擅长做某事可以说be adept at，如：He’s so adept at negotiating.他是个谈判专家；如果一窍不通可以说：know nothing about：I know nothing about singing.我不懂唱歌；don’t know the first thing about：You don’t know the first thing about marriage.你对婚姻根本不懂。 We all took a bunch of goofy photos.我们都拍了一些很傻的照片。 讲解a bunch of表示‘一些’，也可用a few，美国人特别喜欢用a couple of，a couple表示一对夫妇或情侣；所以a couple of严格来说表示两天，但是口语里经常表示两三天，一个不确定的数字。并且of是经常省略掉也不发音的，如：a couple days ago两三天前；goofy是形容词表示愚笨的，可爱且傻傻的感觉。和silly表示傻的差不多，没有恶意。Dumb或stupid表示愚蠢就是贬义了；goof作名词可表示小傻蛋，动词短语goof around表示不做正事的度过时间。 补充拍照片叫take a picture/photo；想和别人合照说：Can I take a picture with you?；想请别人帮你拍照说：Could you take a picture for me?；想让别人拍张你的照片说：Could you take a picture of me?自拍叫take a selfie. You need to chill.你得淡定下来。 讲解关键词chill作动词表示‘冷静，放松’，省略了out.有人冲动或不淡定时你就可以说you gotta chill (out).在口语里美国人经常用chill来表示relax（放松），没做什么特别的事情的时候，别人问你在干嘛，你就可以说：Just chilling at home.在家休息放松呢。 补充1.表示淡定还可以说Calm down；Cool it；Take a chill pill；英国人喜欢说Wind down；2.美国人现在还喜欢说Chillax表示淡定，是chill与relax的合成词，类似的词还有fantabulous特别棒的，是fantastic+fabulous的合成版；3.chill作名词可表示寒冷，chilly作形容词表示寒冷的.例句：It’s a bit chilly outside.外面有点冷。 I gave her the chance to come clean and she lied to my face?我给她机会实话实说她却当着我的面撒谎？ 讲解关键短语1：come clean表示实话实说，例句：You gotta come clean about your job.你必须把你的工作老实说一下；关键短语2：to my face表示当着我的面，例句：You’re calling him to my face?你当着我的面给他打电话？ 补充与某人实话实说还可以说：be honest with：You’d better be honest with me.最好跟我说实话；level with sb：I’m just gonna level with you.我就跟你实话实说了；clean除了表示干净还可以表示一个人没有犯罪或吸毒：he’s clean.他没事（警匪片经常听到）；in one’s face表示‘直接，挑衅’：He slammed the door in my face.他直接甩门而走；lose face丢脸；save face挽回颜面。 She’s a mess.她的生活完全乱套了。 讲解关键词mess，作名词表示‘混乱’，形容词messy表示混乱的；可以是东西的乱，如：My room is a mess/My room is messy.我的房间很乱；也可以是人生活的混乱：My life is a mess.我也不知道过的什么日子；作动词经常表示弄脏弄乱搞砸，比如mess up：don’t mess up my couch别把我的沙发弄脏；You messed up again?你又搞砸了？；也经常表示‘惹怒’，比如mess with：Don’t mess with me.别惹我；mess with也表示闹着玩。Easy man. I’m just messing with you.淡定哥们，我跟你闹着玩的；mess around表示两个人胡闹着玩：We’re just messing around.我俩闹着玩呢，别当真。 补充一个人做事很有规划不混乱可以说organized，反义词则是disorganized.Bingo’s pretty disorganized.Bingo这个人做事挺混乱的。 You know that made no sense, right?你知道那根本说不通，对吧？ 讲解sense作动词表示感觉到，如：I’m sensing a little hostility here.我感到一点敌意；作名词表示感觉感官，如sense of humor幽默感；sense还可以作名词表示‘道理，合理性’；原句中make no sense的字面意思是没有任何道理合理性，即‘说不通’。下次别人做了或说了让你很奇怪的事情你可以说It doesn’t make any sense.这根本就说不通啊；别人不讲道理时你可以说Make some sense.讲点道理啊！ 补充关于讲道理的表达还有：1. talk some sense into sb劝别人讲道理：You gotta talk some sense into her. She’s crazy.你赶紧劝她讲点道理，她疯了。；2. Be reasonable.你讲点道理！；3. In a sense从某种意义上来说。 This is a breach of trust.你这是失信啊！ 讲解关键词breach，作动词表示违背，如：breach a contract（合同）违约；也可作名词，结构为a breach of…：Y=This is a breach of promise.你这是违背诺言了；a breach of law违法；原句中a breach of trust表示违背了别人信任。 补充口语里关于失信的表达还有：1. You broke your promise；2. You didn’t keep your word/promise；相关表达：1. I trusted you.我之前都是相信的；2. Trust me on this one.这次相信我；3. You failed me.你辜负了我（fail sb表示辜负某人）；文化补充：美国人喜欢给自己的孩子弄trust fund信托基金，给孩子经济上后援。这样的孩子叫trust fund baby.这个可以对应成中国的富二代。 She was completely in the dark.她根本就不知情啊！ 讲解关键短语in the dark，字面意思表示在黑暗处，引申为‘不知情’。类似表达还有：keep sb in the dark不让某人知情：We must keep him in the dark about what’s going on.不能让他知道在发生什么；keep sth dark不要别人知道：keep his identity dark不要说他的身份；dark本身表示黑暗，天黑了，皮肤黝黑，都用dark，不要说black. 补充1.守住秘密的表达还有：keep sth from sb：Don’t keep anything from me.不要跟我有秘密；It’s just between us.不要让第三个人知道；My lips are sealed/Your secret is safe with me.我不会说出去的；It stays in this room.不要说出去；2.关于dark要知道一个短语take a shot in the dark字面意思是在黑暗中射击，表示瞎猜的，瞎蒙的。 I’m gonna need to recharge my batteries.我得好好休息恢复状态。 讲解这是一个比喻表达。原句中recharge my batteries字面意思是给我的电池充电，其实就是让自己的身体休息从而恢复；关于充电，也可以说charge，如charge my phone给我的手机充电；充电器叫charger；出国会需要电源转接器adaptor；手机要没电可以说My phone’s dying；彻底没电了就说My phone’s dead. 补充一般累了我们可以take a nap，小睡一会儿；如果对方累，你也可以说go get some sleep，去休息会；失眠了就说can’t sleep.虽然insomnia也是失眠，但它表示的是长期的疾病，一般睡不着就说I can’t sleep；如果长期失眠再说：I’m suffering from insomnia；累了要休息也可以说get some rest. You brought this on yourself.这是你自找的。 讲解bring sth on oneself字面意思是‘把…带到自己身上‘，引申为自找的。例句：She brought the divorce on herself.离婚都是她自找的；口语里表示自找的还有：1. You asked for it.你自己要的（用过去时）；2. You deserve it.你活该（这是你应得的，看具体语境）；3. You’re the one to blame./It’s all your fault.都怪你；4. You had it coming.你自找的。 补充关于bring必须要知道的表达还有：1. bring sth up提起：Don’t bring it up.别提那事儿；2. be brought up长大：I was brought up in America.我在美国长大；3. Bring it (on)!放马过来./开始吧（接受挑战时说）；4. bring the home the bacon养家糊口. Lily, let’s get you dressed.我们帮你把衣服穿好。 讲解关键词dress除了表示‘裙子’，口语里经常作动词表示穿衣，穿着，被动形式居多。例句：I need to get dressed first.我得先穿好衣服；Why are you not dressed yet?你怎么还没穿好衣服？be dressed了用来表示穿的衣服，如He’s dressed in jeans today.他今天穿的是牛仔裤；dress up则表示盛装或特地穿上某种服装，如：Why are you all dressed up?干嘛穿的这么正式？dress up as表示打扮成，如：I dressed up as ironman for Halloween last year.去年万圣节我打扮成了钢铁侠。 补充一般的裙子叫dress，短裙叫skirt，连衣裙叫one-piece (dress)；盛装打扮也可以说doll up或deck out。例句：You need you doll up before you go to that fancy party.去那个高档派对之前要盛装打扮好。 I really was in a jam.我当时真的很困难。 讲解jam可以作名词表示果酱；或交通堵塞；或困境窘境。原句中短语in a jam表示处于困境中；交通堵塞完整说法是traffic jam；jam作动词可表示使…堵塞，所以路上很堵可以说：The road is jammed with traffic.超级拥挤可以说：jam-packed.例句：It was jam-packed last night.昨晚真是人挤人啊！ 补充处于困难的处境的表达还有：1. torn纠结的：I’m torn. I don’t know what to do.好纠结，不知怎么办是好；2. put sb on the spot让某人为难：Come on, man. Don’t put me on the spot.拜托哥们，别让我为难；3. 别人问你how are you，如果你过的不是很好，可以说：I’ve been better或I’ve had better days.意思就是最近不是很好。 I did my best to cram for my lectures.我尽力为我的演讲恶补了。 讲解关键短语do one’s best，表示‘尽力而为’。相似表达也可以说give it one’s best shot.例句：Just give it your best shot.尽力而为就好。关键词cram表示恶补，临时抱佛脚的感觉，例句：Everyone is cramming for their finals.大家都在为期末考试恶补。 补充提升学习的强度恶补也可以用bone up on sth，例句：He’s going to the US next week. So he has been boning up on his English.他下周要去美国，所以他最近在恶补英语；shot的字面意思表示射击，口语里经常用它表示努力或机会。如：1. Give it a shot试一试；2. This is your last shot.这是你最后一次机会；3. It’s a long shot.这事难度很大（long shot，字面意思是射击远，所以难度大） That’s the worst call ever.这个决定差到极致了。 讲解关键词1：call可表示打电话，动词名词均可：如call me tomorrow/Give me a call tomorrow都很常用；但是口语里经常把它用作‘决定’的意思，本来make a call表示打一个电话，引申为做一个决定，因为你给谁打电话是你做的决定，所以口语有这样的表达：A or B? Your call!要A还是B，你来决定；It’s your call to make, not mine.是你要做决定，不是我；别人做了你喜欢的决定你可以说Good call；反之就是Bad call.关键词2：ever，在最高级句尾加ever表示强调，加深感情，类似于中文的‘史上最…‘，如：You’re the best teacher.你是最棒的老师！感情要比you’re the best teacher要强很多。度过了很不顺利的一天，回家后就说：I just had the worst day ever! I don’t want you to jump into anything.我不希望你匆忙做决定。 讲解关键短语jump into sth，字面意思表示‘跳进去’，其实就是匆忙做决定。你朋友要闪婚的话，你就对他说：You’re jumping into this.与它相似的表达是jump to conclusions表示匆忙作出结论；口语里也常用rush into表示急匆匆的做决定：Don’t rush into anything也表示不要匆忙做决定；别人很急匆匆的你可以问：What’s the rush?或What’s the hurry?急什么？ 补充匆忙时要记得：1. Think it over.再仔细考虑考虑；2. Think it through.把事情方方面面考虑周全；3. Think twice.三思而后行；jump的形容词jumpy表示人焦虑不安的。 TMI, huh?太多信息了是吧？ 讲解TMI的完整形式是too much information.口语里用得较多；常见的缩写需要知道的有：1. FYI=for your information顺便跟你说一下；2. BTW=by the way顺便说一句或顺便问一下；3. ASAP=as soon as possible尽快（注意口语经常读成A-SAP）；4. LMAO=laugh my ass off笑死了（中国人的意象是笑掉大牙；美国人是笑掉屁股，文化差异）；5. LOL=laugh out loud哈哈；6. TGIF=thank goodness/god it’s Friday终于到星期五了（美国人在星期五喜欢说，晚上要party）；7. JK=just kidding开玩笑而已；8. RIP=rest in peace安息（有人去世时会说）；9. ROTFL=rolling on the floor laughing躺在地上笑；10. TBD=to be decided/determined待定。 And there’s a few people outside.而且外面有些人。 讲解关键结构there’s，这边有个概念，就是书面语法与口语语法的区别，基本相同，只不过口语语法相对更随意，由于后面是a few people一些人是复数，按书面语法应为there’re a few people，但口语里不管是单数还是复数，美国人都经常说there’s；常见的口语语法还有：Let’s go eat/Come say hi。即口语里表示去干嘛来干嘛可直接加动词，而不是书面语法的go and eat；If I was you，虚拟语气，如果我是你的话，书面语法应为If I were you，但口语里经常用was即可；me and Bingo，我和Bingo，按照书面语法应为Bingo and I，但‘我和谁’在口语里经常是me and 谁谁谁…。 How can they just kick us out?他们怎么能就这样赶我们出去？ 讲解关键短语kick sb out表示‘赶某人出去‘。例句：My wife kicked me out.我老婆把我赶出了家门。关于kick还需要知道的用法有：1. kick off开始：My vacation now officially kicks off.我的假期正式开始；2. kick in药起作用：The medicine hasn’t kicked in.药吃了还没感觉；3. kick back休闲放松：I’m gonna kick back at home tonight.我今晚就待在家休息了；4. kick sb’s ass/butt痛扁某人或比赛中的狂虐：He’s gonna kick your ass in the game.比赛中他会很容易打败你的；5. ass-kicking很棒的：This is an ass-kicking party.这个派对太棒了；6. kick the bucket去世；7. get a kick out of sth做某事而感到快乐：You’ll get a kick out of it.你会喜欢的。 There have been rumors.有这样的谣言在散播。 讲解关键词rumor表示‘谣言’，常用固定句型Rumor has it that…+谣言的内容。例句：Rumor has it that he is getting fired.有谣言说他要被解雇了。和rumor相近的词还有gossip八卦：Don’t gossip about my life.别八卦我的生活；talk闲聊八卦：Why did you tell him? You know people talk.你干嘛告诉他？你知道人是会闲聊的。 补充在口语学习过程中，多记句型要比死磕语法效果好的多。比如It’s been…经常用来表示‘已经过了多久’或对即将结束的事情的评价，如It’s been a week.已经过了一周了；It’s been a fun journey.旅途到现在为止很开心。不需要去纠结it’s been的完成时的种种。多积累句型，对应中文的表达。 She would’ve wanted this.如果她还活着，她也会希望你这样的。 讲解继续关注句型，少抠语法。原句中would’ve done结构，经常在描述一个已经去世的人时会用，记住这个就行了，比如：Your mom would’ve said yes.你妈要是活着也会答应的。不用太纠结其中语法。 补充would’ve的发音实际有两种：would of和woulda，不会把would have完整发出来；类似的还有：should have=should of=shoulda；could have=could of=coulda；must have=must of=musta；proud of=prouda；out of=outta；kind of=kinda；sort of=sorta；原因是两个：1. have弱读之后发音与of一样；2. t/d后面的of直接把f的发音省略，这样发音更轻松更地道。 You are so high-maintenance.你可真难伺候。 讲解maintenance是maintain（维修）的名词形式，high-maintenance指need a lot of effort to keep in good condition需要大量精力来运转良好。例：I’m tired of having a relationship with my girlfriend, she is so high-maintenance.我受够了跟我女朋友谈恋爱，她真难伺候啊。此外，‘苛求的，难讨好的‘还可以用’demanding‘和’hard to please‘. 补充其反义词‘特别好搞定的人’叫做pushover：Stop bullying me, I’m not a pushover.别再欺负我了，我可不是软柿子，随便让你捏。 This is a killer apartment!你这房子太酷了！ 讲解killer本意指‘杀手’，但口语中有另外两个意思。其一：something or someone very difficult.例：The exam was a real killer.这次考试好难。其二：something very impressive.例：The new movie is a killer.这部新电影超带劲儿。此外，killer smile迷死人的微笑；killer charm让人眩晕的个人魅力。 补充killer还可以当感叹词单独使用。例：A: Guess what? I got accepted to Harvard Law!你猜怎么着？我被哈佛法学院录取了！B: OMG, killer!天哪！简直棒呆了！ She’s playing hard-to-get.她在吊你胃口呢。 讲解hard-to-get‘很难得到手’。例：A: I’m really upset! She doesn’t find me attractive.郁闷啊！她不喜欢我！B: Relax! She is just playing hard-to-get.放松！她只是在吊你胃口而已。 补充‘吊胃口’还有‘一直让某人猜测，始终不说答案’的意思，对应英文是：‘keep/leave someone in suspense’.Suspend本意‘悬挂、吊起’，名词suspense表示‘紧张感，担心’。例：Don’t keep us in suspense any longer, tell us what happened!别再吊胃口（让我们着急）了，快告诉我们出了什么事了！ I can’t get over you.忘记你我做不到。 讲解‘get over’表示‘忘记；熬过；释怀’。例：I’m over you!我已经把你忘记了！get over还可形容‘反应过来，回过神儿来’，如果你看到以前相貌平平的同学现在很美，就可以说：I can’t get over how great you look!真不敢相信，你现在这么美了！ 补充有个很像的词组：I’m all over you!意思完全不同：我超级喜欢你！all over表示整个人都扑到什么上面，迷恋。 I took it pretty hard!我深受打击。 讲解take it easy‘放轻松，轻松接受…‘；take it hard‘难以承受’。例：A: What did he say when you told him you wanted a divorce?当你说要离婚的时候，他说了什么？B: He took it pretty hard, but he’ll get over it.他很难接受，不过他会度过伤痛的。 补充take还有很多搭配：1. Don’t take it personally.这事不是针对你，别放心上。例子：Don’t take it personally, she’s rude to everyone.别往心里去，她对谁都这么粗鲁。2. Don’t take it the wrong way.别误会。3. Don’t take it seriously.别当真，别较真。4. Don’t take it for granted.别想当然以为（这是你该得的）。 We’re just being honest here.我们这是在实话实说。 讲解关键是being这个词：强调当下的动态，让句子听起来更为活泼。最后的here，并非指‘这里’，而是‘在这件事上，此时此刻’。例：A: Stop telling me I’m wrong!别再说我错了！B: We’re just honest here. It’s for your own good.我们这是在实话实说，这是为了你好。 补充常用类似表达：You’re being unreasonable here.你在这件事上怎么这么不讲理啊。You’re being ridiculous here.你现在怎么莫名其妙啊！ Cheer up!高兴点嘛！ 讲解cheer up的意思是‘提起精神，使…不再丧志‘。例：Cheer up, better times may be ahead.高兴点嘛，好日子没准儿就在前面呢。例：A: Let’s buy her flowers to cheer her up.咱们去买花来逗她开心。B: The only thing that’s going to cheer her up is getting her job back.唯一能逗她开心的事，就是让她重回原来的工作。 补充常用类似表达：cheer sb on鼓励某人：The crowd cheered the runners on as they started the last lap.赛跑进入最后一圈时，观众为运动员加油鼓劲。 This is so made up.一听就知道是瞎编的。 讲解make up有很多用法。其一：‘乱说，瞎编’。例：A: Did you make that story up?那个故事是你乱说的吗？B: No, I’m totally serious. It really happend.不，我百分百是认真的，真有其事。其二：‘化妆’。例：She spent an hour making (herself) up before the party.她在聚会前化妆用了一个小时。例：She’s always very heavily made up.她总是浓妆艳抹的。其三：‘和好，复合’。例：Hey, you guys made it up.嘿，你们和好啦。 补充made-up当名词指化妆品，相当于cosmetics.例：She never wears make-up.她从来不搽化妆品. Lighten up!放松！ 讲解light作形容词是指‘轻的’，动词形式Lighten up字面上的意思是‘变轻巧’，就是要对方‘放松心情，放轻松’。例：A: You really need to lighten up.你真该放轻松一点。B: I know. I’ve been really tense lately.我知道，我最近一直很紧张兮兮的。例：A: I know I did terrible on my test! I’m a horrible student!我知道我考试考得很差！我是个烂学生！B: Lighten up. Maybe you’ll do better next time.放轻松，你下次或许会考得更好。 补充‘放松’还可以说‘loosen up!’.照相的时候很多人觉得很扭捏，放不开，摄影师就会说‘loosen up!‘放开点，别紧张！ I wanna get a head start.我想赢在起跑线上。 讲解head start原本是指在竞赛中拥有起跑的优势，口语中引申为‘赢在起点上’。例：A: Our Bobby goes to the best middle school in New York.我们巴比念的是纽约最好的中学。B: Yes, we want him to have a good head start for college.对，我们要他赢在起跑点上，进入一流的大学。 补充可以泛指‘先一步开始’。例：A: Are you and Greg going to the party at the beach?你跟贵格要去在海边举办的派对吗？B: Yeah. Greg got a head start. I’m leaving in a few minutes.要，他先走一步，我几分钟后就走。 I wasn’t myself.我当时不大对劲。 讲解be not oneself这个短语表达‘不正常’的意思，可以指身体上不舒服，也可以指行动上的。例：A: Why can’t you walk a little faster?你今天为什么不能走快一点呢？B: I’m not quite myself today.我今天不大对劲（身体不大舒服）。例：A: You weren’t yourself at the party the other night.那天晚上派对中你行动怪怪的。B: I know. I had too much whisky.我知道，我喝了太多威士忌。 I was on pins and needles.我当时坐如针毡。 讲解pins和needles都是指针状物，坐在上面这种被扎的感觉，正可用来形容紧张不安的情绪。例：A: I’ve been on pins and needles all week. The boss said he wants to see me this Friday.我这整个星期如坐针毡，老板说他这个星期五要召见我。B: Good luck. I hope it’s good news.祝你好运，我希望是好消息。 补充这个表达法也可以用来形容那种雀跃不已，兴奋的期待心情，例：A: They’re announcing the winner for Best Actress.他们正在宣布最佳女主角的得主。B: I’m on pins and needles. I can barely sit still in my seat.我好兴奋喔，我都快坐不住了。 He’ll survive.他会挺过来的。 讲解survive原意是‘存活，幸免于难’，用在面临生死攸关之后，得以活下来。例：Rob is in the hospital. He survived a shark attack last week.罗伯在医院里，他上周被鲨鱼攻击，死里逃生。口语中可以引申为‘捱过、度过（困境）’的意思。例：A: I’m going to fail this exam! I just know it!我这考试一定会被当掉，我有预感！B: You’ll survive. It’s just a test! You’ve studied for it all week.你会撑过去的，不就是个考试嘛！你已经用功整个星期了。 补充熬过还可以说he’ll get over it.或者He’ll be fine. Way to go.好样的！ 讲解‘Way to go.’是’That’s the way to go.’的缩写，是用来告诉一个人他做得很好，请继续保持。例：A: I passed my driving test.我通过驾驶测验了。B: Way to go! I think we should go out to celebrate.太好了！我觉得我们该出去庆祝一下。 补充这个说法也可以用来讽刺太过离谱的人，例子：Way to go. You lost my cell phone again.真有你的，你又搞丢了我的手机了。 This is just too much.这太让人吃不消了。 讲解这个句子通常形容感觉压力很大，或者事出突然无法接受的时候。例：I have to work on five projects at a time? This is just too much.我要同时做5个项目？这实在是太扯了。这个说法除了可以表示心里压力以外，还可以表示体力上吃不消。例：This is just too much. Now I have to drive to Tainan tonight for business.真让人吃不消，我现在得连夜开车去台南出差。 补充吃不消还可以讲：I can’t take/stand this anymore；I’m pushed over the edge；drive somebody crazy What are you up for tonight?你今晚想去哪儿？ 讲解be up for表示‘有想做某事的心情’。例：A: I’ll pick you up at eight. What are you up for tonight?我今晚八点去接你，你今晚想去哪儿？B: Dinner and dancing!吃饭和跳舞！这个表达特别适用‘邀约’，例：A: Are you up for a game of tennis tonight?你今晚想打网球吗？B: I’m always up for tennis!我永远都想打网球！ 补充相似词组联想记忆：be up to sth忙于某事。例子：What are you up to?你平时都忙些什么？ This is incredible.这简直太好了！ 讲解incredible一词源于credit信用；相信，常见于credit card信用卡，credible是可以相信的，incredible是难以置信的，不可思议的，相当于unbelievable。例：What an incredible actress.她是个了不起的演员。credit当相信时，还可做动词：Would you credit it?你相信吗？ 补充口语中表示好的词还有：amazing；awesome；impressive；fantastic；fabulous等等。 I’m totally into photography.我超爱摄影。 讲解into sth本意是‘进到…里面‘，所以口语中可以表示be enthusiastic about sth in which one takes an active interest对某事物很有兴趣；非常喜欢：be into yoga, science fiction, stamp collecting喜爱瑜伽、科幻小说、集邮。be into sb还有一个意思：to owe someone money.例：He’s into me for $50.他欠我50美元。 补充口语中表达喜欢的小词还有：my thing.例子：我超喜欢做饭：cooking is my thing. Don’t flatter yourself.別臭美了；少自作多情了。 讲解flatter本意是奉承，讨好。例：If you flatter your mother a bit she might invite us all to dinner.你要是奉承你母亲几句，说不定她会把我们全请去吃饭；flatter oneself就是讨好自己，让自己开心。例：Do you really think he likes you? You flatter yourself!你真以为他喜欢你？你那是自作多情！常用被动表示某人感到荣幸的，相当于I’m honored. I was very flattered by your invitation to talk at the conference.承蒙你邀我在会上讲话，深感荣幸。 补充形容词flattering使人显得很美的：That’s a very flattering dress.那条连衣裙显得你更漂亮了。或者figure-flattering表示显身材的，使看上去有体型的。 I‘m all ears.我洗耳恭听。 讲解I’m all ears‘我到处都是耳朵，我随时准备好倾听’。例：A: I’ll give you a few pointers on how to study English.我可以给你一些指点，帮助你学习英语。B: I’m all ears.洗耳恭听。 补充这话特别适合用来表示关心别人，show that your are a good listener.A: My boyfriend just dumped me.我男朋友刚把我甩了。B: Are you OK? If you want to talk about it, I’m all ears.你还好吧？假如你想聊，我很愿意听。 Now we’re getting somewhere.这下有眉目了。 讲解‘get somewhere‘’到达某处‘，引申为’有进展，有成果‘。例：A: I don’t want to fight anymore, I just got angry because you were ignoring me.我不想再吵了，我气你是因为你一直忽略我。B: Now we’re getting somewhere. I’m sorry I hurt your feelings.这下子有眉目了（我知道你生气的原因了），对不起我伤了你的感情。当然如果表示没进展的话，就要说成‘not get anywhere‘或者’get nowhere‘.例：A: What do you say if we stop seeing each other for a while?你觉得我们先暂停交往好不好？B: That would get us nowhere.这对我们无济于事。 补充在疑问句中，要用‘get anywhere’.A: I was working on that building design all night.我整晚都在忙那个建筑设计。B: Did you get anywhere?有进展吗？ You should get out more.你应该多出去见见世面。 讲解‘get out’可以是调侃的语气，要对方出去见见世面，免得落伍了；例：A: Have you been to the new bar ‘MUSE’ by CarinaLau?你去过刘嘉玲新开的那家酒吧吗？B: You need to get out more! That bar has been open for 3 years!你真该出去见见世面了，那酒吧开了3年了！也可以作为关心鼓励，要对方‘出去看看，开开眼界’。例：Mom, you and dad need to get out more. You look so pale and weak.妈，您和爸需要多出去走走，您看起来很苍白虚弱。 Are you seeing anyone special?你是不是谈恋爱啦？ 讲解see有‘约会，交往’的意思，但常用于进行时态。例：we should stop seeing each other.我们应该分手了；例：Michael and Anna are seeing each other.迈克和安开始约会了。其二，see还常见于I see，表达‘原来是这样，现在我明白了’，和I know（我本来就知道）不同；其三，‘让我想想啊’的英文：let’s see.比let me think更地道。 补充约会的其他表达：date，后面通常直接跟人：I only dated her once.我和她只约会过一次；go out with：are you going out with Beth?你是不是开始和Beth约会了？ That’s how the world works!这就是社会！ 讲解‘这就是世界运行的方式’，也就是说‘社会就是这样进化变迁的！’例：I know how the world works.我懂这些人情世故，例：A: Can you believe it? He got a promotion! I bet it’s all political!你敢相信吗？他居然被提拔了！我觉得肯定是靠关系上去的！B: Forget it! It’s how the world works!别想了！现在的社会就这样！ 补充类似表达：That’s the way it is!本来就是这么回事！（stop complaining!） You’ve got a point.你说的有道理。 讲解point表示重点，what’s your point?你到底想说什么（重点）？let’s get to the point.咱们说重点吧；got a point说到了重点。例：A: But she might not agree.可是她有可能不同意呀。B: You’ve got a point there.你这话说得很有道理。 补充‘重点’还可以用message表达；get the message=see your point：She said it was getting late, I got the message and left.她说时间不早了，我心领神会，于是告辞. That doesn’t make sense.这讲不通啊！ 讲解sense本意指‘感觉’，a sixth sense第六感；sense of humor/security/direction/guilt幽默/安全/方向/罪恶感；sense还可以指道理，common sense常识；make sense能讲出道理来，有逻辑。例：None of these makes any sense.这一切都讲不通啊。例：You don’t make sense today.你今天不讲理。 补充make sense后面还可以加上of sth表示understand sth理解或弄懂：Can you make sense of this poem?你看得懂这首诗吗？ My treat!我请客。 讲解treat表示‘宴请，招待’，my treat就是‘我来招待你’，例：It’s my treat, don’t sweat it!我请客，别计较了！更简单的‘我请客’是‘It’s on me!‘，用’on‘就表示这顿饭’记我头上，记我账上‘。例：The movies are on me, don’t worry about it!电影算我的，别计较！ 补充‘我买单’还可以说：I’m paying tonight!/Let me treat you./Let me have the check, please!/Let me get the bill, I insist!/My dollar/My buck! Nice try.想得美，做梦呢你。 讲解字面上理解是‘做得好’，可以用来鼓励别人继续努力；但更常用于讽刺别人，某人想骗你上当的时候，你就可以说。例：A: I am currently a professional tennis player and have 3 supermodel girlfriends.B: Umm…Nice try! Do you take me for a fool?（骗谁啊！你当我傻子啊？） 补充想得美还可以说You wish（你就幻想吧）/wishful thinking（痴心妄想）.I think she likes me. But maybe that’s just wishful thinking. My thoughts exactly!跟我想得一模一样！ 讲解当朋友和你很有心电感应，说出和你一模一样的想法时，你就可以用这句话表示惊叹！例：A: Rose and Jack look cute together. Have you ever thought…露丝和杰克在一起看起来好顺眼哦，你有没有想过…B: …that they’re a match made in heaven?…他们俩是天造地设的一对？A: My thoughts exactly!一点没错，我就是这么觉得！ 补充同exactly一样意思的是precisely，也是表达‘精准得，确切得’：A: Let’s fire Allan and promote Ann.咱们让艾伦走路，给安升官。B: My thoughts precisely!我正有此意！ Don’t freak out.别发飙！ 讲解freak本意是a person with a very strong interest in a particular subject有某种强烈癖好的人：a fitness/clean freak健身狂/洁癖；还可以做定语：a freak accident/storm反常的事故/暴风雨；而freak (sb) (out)则是（使某人）吓到、受惊、发飙、抓狂。例：Don’t freak out, but I kinda lost your earrings.别发飙啊，但我好像把你耳环弄丢了；例：The whole idea freaked me out.这个想法吓到我自己了。 补充同义词flip (out)也是表达特别激动的情绪：生气或者兴奋：He completely flipped when he saw the mess in the kitchen.他看到厨房乱糟糟的景象立马发飙了。 Just the opposite.恰恰相反。 讲解适用于别人不但没有猜中你的意思，反而猜的恰恰相反。例：A: What? You got fired?咋啦？被炒鱿鱼了？B: Just the opposite. I got a promotion!恰恰相反，我升官了！ 补充还有一个类似的说法：Not even close.close是接近，even是用来强调，猜测甚至都不沾边。 I have a weakness for sweets.我最招架不住甜食。 讲解If you have a difficulty in resisting sth/sb, then you have a weakness for it.抵挡不了…的诱惑。例：Girls have a weakness for chocolate.女孩子都招架不住巧克力的诱惑。例：A: If you want to win Tom’s heart, make him a cheesecake.如果你想讨汤姆的欢心，就给他做起司蛋糕准没错。B: Great idea! I know he has a weakness got sweets.好主意！我知道他看见甜食就没辙。 补充当然也可以颠倒过来说：…is my weakness.某事是我的致命弱点。 Don’t blow it out of proportion.别夸大其词了。 讲解proportion是比例；out of proportion是‘大到不成比例’，而blow是‘吹’的意思，在美语中有‘吹牛’的意思。例：A: I can’t believe you ignored me like that!我不敢相信你竟这样躲避我！B: I couldn’t take your call! Don’t blow it out of proportion.我只是没办法接你的电话，别夸大其词了。 补充夸张还有一个基本英文叫exaggerate.例：You are exaggerating the difficulties.你把困难夸大了。 We’ll see.我们走着瞧。 讲解当你不同意别人的看法时，就可以用这句话，表示‘现在跟你吵也没用，我们到时候就知道了’。例：A: A guy that listens to heavy metal could never be charming.听重金属的男生不可能有什么魅力。B: We’ll see, remember, Prince Charming comes disguised as a frog sometimes.我们等着瞧吧，别忘了，有时候王子会扮成青蛙的哦。 补充We’ll see口语中也经常拿来敷衍别人，表示‘再看看吧，再说吧’。A: Can we go camping this summer?我们今年夏天可以去野营吗？B: We’ll see.到时候再说吧。 I got stood up.我被放鸽子了。 讲解约会时某人没有按规定的时间到场就可以说‘他放我鸽子he stood me up!’例：A: Can’t you go out with her another day?你不能改天再跟她出去吗？B: It’s too late to cancel, and I don’t wanna stand her up!现在取消来不及了，而我又不想放她鸽子！ 补充no-show也是表示someone who does not arrive or appear somewhere they were expected to be该出场而没来的：The bad weather meant there were a lot of no-shows at the game.天气不好，肯定会有很多人不到场了。 I didn’t mean anything bad.我没有恶意。 讲解若是不小心伤害了别人赶紧用这个句子解释一下吧。例：A: Do you go to bars often?你经常去酒吧吗？B: Of course not. What kind of a girl do you think I am?当然不是，你当我是什么样的女孩儿啊？A: Sorry, I didn’t mean anything bad.很抱歉，我没恶意嘛。例：A: You look very mature in that dress.你穿那件连衣裙很显成熟。B: Are you saying I’m old?你是不是想说我老？A: I didn’t mean anything bad. It looks nice.我没那意思！很好看的。 补充也可以简单得说：I didn’t mean it.我不是这个意思；那么反义词I mean it.就表示‘我是认真的’，相当于I’m serious. Think outside the box.换种思路想想。 讲解‘box’是指被限制在一个范围之内的意思，固有的守旧的思维模式。‘think out of the box‘就是‘think creatively/unconventionally/or from a new perspective‘思维创新、跳出固有思维模式。例：Let’s think outside the box for a minute and try to find a better solution.我们跳出思维定式来想，看看能不能找出更好的解决方案；例：These guys are incredibly creative - they really know how to think out of the box.这些人很有创造力，知道如何创新思维。 I’ll let you off the hook this time.这次我就放你一马。 讲解hook是钩子，所以on hook就是被勾住，陷入麻烦；off the hook就是脱离危险。例：You’re not getting off the hook.你这次休想逃掉；主语如果是电话the phone rang off the hook all day.则表示‘电话响了一天’，根本没办法挂在听筒上，一直处于off the hook的状态；play hooky是‘翘课、逃学’的意思：You wanna play hooky again? No way!你又想翘课啊？没门！ 补充’放我一马‘还可以说go easy on you.在你这里走缓和路线。或者cut me some slack.slack本身表示‘懒散怠慢的’，所以这个词组是‘允许我放肆一次，通融一次’。 What’ve you been up to?你最近都在忙什么啊？ 讲解up to表示occupied or busy with sth忙于某事，一般时态what are you up to?你在忙什么？而现在完成时what’ve you been up to?你最近在忙什么？是常见问候语。例：A: what’ve you been up to?你最近忙什么啊？B: you won’t believe it, but I’ve been seeing a guy from work.跟你说你都不信，我在跟同事谈恋爱。 补充最基本英文how are you?也常换成完成时态how’ve you been?最近好吗？ We have a lot to catch up on.我们有好多要叙叙旧聊一聊的。 讲解catch up本身是‘赶上’的意思。例：A: I haven’t seen you in class for over a week.我已经一个多星期没看见你来上课了。B: Well, I have been sick. I have a ton of homework to catch up on.我生病了，有一大堆功课要补起来。朋友好久没见，所以要‘赶上’分别后彼此的生活。例：A: It’s been almost a year since we’ve seen each other.我们将近快一年没见了。B: you bet. We have a lot to catch up on.没错，我们可得好好叙叙旧。 I’m not falling for this again.我不会再上当了。 讲解fall for sth：allow oneself to be persuaded by sth相信某事。例：The salesman said the car was in good condition, and I was foolish enough to fall for it.推销员说这辆汽车状况良好，而我那么傻竟然信以为真；例：I’m surprised you fell for that trick.真不敢相信你居然相信这个骗局。 补充fall for sb表示fall in love with sb被某人所吸引；爱上某人；迷恋：They met, fell for each other and got married six weeks later.他们俩一见倾心，六个星期后就结了婚。 I’m not a cheapskate.我可不是小气鬼。 讲解cheap（东西）便宜的；（人）小气的；cheapskate则是指小气鬼，a person who is unwilling to spend money.例：Are you saying I’m cheapskate?你说我是小气鬼？其他表示小气的词：形容词stingy吝啬的：He’s very stingy about lending money.他非常吝啬，不愿借钱给别人；形容词mean小抠的：She’s too mean to make a donation.她很小气，不肯捐款；名词miser‘守财奴’：Why don’t you buy me a drink for a change, you old miser!你就不能也请我喝一杯，你这老财迷！ 补充反义词‘花钱大手大脚的人’叫做spendthrift：someone who spends a lot of money in a wasteful way：My father tells me I’m too much of a spendthrift.我父亲说我是个败家子。 You’re off to a good start.你有一个很好的开始。 讲解off to a good start表示starting out correctly；beginning something carefully and cautiously开了个好头，常搭配be/get，例：Their marriage got off to rather a shaky start.他们的婚姻一开始就有些不稳固。例：A: How’re things going with you and Dan?你和丹之间的关系如何了？B: We got off to a good start, but things are kinda falling apart now.我们开始的时候很好，但事情现在有点失控了。 补充开个好/坏头还可以说：start off on the right/wrong foot：begin sth in the right/wrong way.例：The new student started off on the wrong foot with the teacher by answering back rudely.那个新来的学生粗鲁地跟老师顶嘴，一开始就把关系搞僵了。 I’ve had enough of it!我受够了！ 讲解have had enough已经经历过太多的某事物。例：A: I’ve had enough of your being late.我受不了你老爱迟到了。B: Then buy me an alarm clock.那你给我买个闹钟啊。当你表示受够了这个意思，还可以用I’ve had it up to here (with…).例：A: I hate this weather, it sucks!讨厌这种天气，真糟透了！B: I’ve had it up to here with your complaining!我受够了你的抱怨！ 补充‘受够了’还可以很形象的说：I’m fed up.我被喂饱了。 Can you try to talk him out of it?你能劝他打消这个念头吗？ 讲解除了‘persuade’这个词，‘talk’也有‘说服’的意思，‘talk somebody out of/into (doing) something’，说服某人（不）去做某事。例：A: Don’t you think that dress is just beautiful?你不觉得那件洋装漂亮死了吗？B: Are you trying to talk me into buying it for you?你是想说服我帮你买下来吧？例：A: Sammy said that he has decided to drop out of school!山米说他决定辍学！B: Can you try to talk him out of it?你能说服他别这样做吗？ Let’s hang out sometime.我们有时间出来聚吧。 讲解hang out是指visit a place often常去某处。例：Where does he hang out these days?他这些日子里都在什么地方来着？hang in there是表示‘加油，坚持住了’；hang on表示‘等等’，相当于hold on；hang up (on sb)是指挂（某人）电话，例：Did you just hang up on me?你刚刚是不是挂我电话来着？而被动be hung up (about/on sb)对…神魂颠倒，无法释怀，例：Are you still hung up on him?你还想着他吗？ 补充hangout作名词：a place someone likes to go to often某人常去的地方：The bar is a favorite hangout fpr students.这个酒吧是学生们最喜欢去的地方。 This is ridiculous.这太扯了！ 讲解ridiculous本意是指very silly or unreasonable非常傻帽可笑的，例：You look ridiculous in those tight jeans.你穿上那紧身牛仔裤样子真可笑。例：What a ridiculous idea!多么荒谬的念头！ 补充荒唐可笑的还可以说absurd.例：What an absurd suggestion!多么荒唐的建议！或者out of nowhere表示（莫名的行为）没有任何根源，无厘头。还可以说joke，例：Your job is a joke!你的工作就是一个玩笑。 You got it!听你的，没问题。 讲解You got it!两个用法。其一：‘你说对了’。例：A: You mean we have to write a 20-page report on John F. Kennedy by next week?你是说我们下周前，要交出一份关于肯尼迪的二十页的报告？B: Yep. You got it!没错，你说对了！其二：‘没问题’。例：A: Will you get me some Coke while you’re at the store?你去店里买东西的时候，可以帮我捎些可乐吗？B: You got it! Is that all you want?没问题！就只要可乐吗？ 补充口语还用You’re on.表达‘没问题’.这句话本意是‘（演出）该你上场了’，引申为‘这事情你是主角，听你的’。 Don’t be so petty.不要这么小气嘛。 讲解petty愿意是small or unimportant小的；不重要的：petty details/troubles细节/小麻烦；也可以指having or showing a small mind气量小的；小气的：petty and childish behavior小心眼和孩子气的行为。 补充反义词‘大度’叫做generous：He is really generous with his time, he’s always fixing my computer.他很乐于助人，总是花时间帮我修电脑。 She’s out of my league.我配不上这女生。 讲解league本意‘联盟，同盟’，美国8所名校‘常春藤联盟’叫Ivy League；in league表示‘共谋，联合’。例：He pretended not to know her but in fact they were in league (together).他装着不认识她，其实他们暗中勾结（在一起）；league还可以表示本句的‘（好或坏的）等级、范畴’，所以She’s out of my league.就是她跟你不是一个档次的，她不是你能配得上的。 补充‘我配不上她’还可以说I’m not good enough for her.或者She deserves much better. Now that’s perfect English.这才叫好的英语嘛。 讲解用Now that’s…这个句型做开头，是指‘这才像话，这才配称做…‘的意思，表示说话者所给予的正面评价。例：A: Here’s your 12-ounce steak, sir.这是您点的十二盎司牛排。B: Now that’s what I call a steak.这才叫做牛排嘛。例：A: look at my new car!快看我的新车！B: Now that’s a sportscar.这才叫做跑车嘛！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Oral English 1]]></title>
      <url>%2F2018%2F02%2F03%2FOral-English-1%2F</url>
      <content type="text"><![CDATA[I’m heading out.我准备走了。 讲解关键词head，除了熟悉的‘头’，还可以表示‘出发，前往’，例句：Where are you heading?/Where are you headed?主被动都可以。 补充口语中其他常见的表示‘我要走了’的表达：I’m leaving；I’m gonna go；I’m out of here；’我们走吧’：Let’s get out of here；Let’s blow this place off；Let’s roll! You’ll make it.你会成功的！ 讲解关键短语‘make it’表示成功（succeed）.例句：You must make it this time.你这次一定要成功！He made it to the finals.他成功闯进总决赛了. 补充口语中还经常：1）用‘can‘t make it to…’表示不能去…；例句：I’m sorry. I can’t make it to dinner tonight.不好意思，晚饭我去不了了；2）用‘not make it till’表示‘撑不到…’；例句：He won’t make it till tomorrow.他撑不到明天了. Apology accepted!嗯，接受你的道歉。 讲解这是典型的将动词变被动形式的口语句型。原句应为：I accept your apology，当别人说I apologize. Forgive me please（我道歉，请原谅我）时用。 补充口语中常见的类似表达还有：1. Agreed!（表示‘我同意’）；2. None taken.（表示‘没事儿’），在回答别人说No offense（表示‘没有冒犯之意’）时用；3. Problem solved.（表示‘问题解决了’）. I’m stuffed.我吃的撑死了。 讲解关键词‘stuff’，除了作名词表示‘东西/事情’，还可以作动词表示‘塞满’，stuffed字面意思是肚子被塞满了，也就是撑死了的意思.这也是为什么‘stuffy’表示‘天气闷热的’. 补充我饱了：I’m full；我吃撑了还可以说：My stomach is going to pop（字面意思是我的胃要炸了）；我饿了：I’m hungry；我很饿：I’m starved/starving/famished；我饿死了：I’m starving to death/I could eat a horse now（字面意思是：我现在可以吃下一匹马）. Stay put.待着别动。 讲解关键词‘put’这里不表示熟悉的‘放’，而是形容词‘固定的/静止的’，所以这句话也可以说Stay still.（still这里也表示‘静止的’意思）。 注警察抓人时喜欢说：Freeze!（也是‘别动’的意思） 补充口语中put也经常表示‘说/表达’；例句：I don’t know how to put this.（我不知道该怎么说）；Let me put it this way.（我这么跟你说吧）；Well put!（说得好！） What’s with you?你怎么了？ 讲解难点在于‘wrong’一词在口语中省略了，完整句应为：What’s wrong with you?（是不是出事了？） 补充口语中常见的类似表达还有：What’s up?/What’s the matter?（怎么了？）；Is everything okay?（一切还好吧？）；Is something wrong?（是不是出事了？）；What’s bothering you?（你在烦什么呢？） 注What’s wrong with you?和What’s the matter with you?用气愤的语气读也可以表示：你脑子进水了啊？ How’s it going?最近一切可好？ 讲解关键词‘go’，除了表示熟悉的‘去/走’；口语中经常表示‘进展’，所以how’s it going?字面意思是‘一切进展得怎么样？’；而刚见面时说则表示‘最近好吗？’，也经常说：Hey.How’s everything going?例句补充：I hope the meeting will go well.我希望会议能开得顺利. 补充口语中常见的表示打招呼的还有：How are you?/How (are) you doing?/What’s up!（年轻人喜欢用） You rock!你太牛啦！ 讲解关键词‘rock’，除了表示熟悉的‘岩石/摇滚’，口语中经常作动词表示‘很棒/很牛’；例句：Adele really rocks!（Adele实在太棒了！） 补充（1）口语中经常用来表示‘很棒’的词还有rule（动词）：This movie rules!（这部电影真不错！）；awesome（形容词）：This food is awesome.（这东西很好吃！）（2）‘rock’口语中还经常表示‘喝酒放的冰块儿’.例句：Do you want your whiskey on the rocks?（你的威士忌要加冰块儿吗？） He was so pissed off.他当时气得不得了。 讲解关键短语‘piss off’，表示‘使…生气’；piss me off惹我生气；英国人还喜欢用‘Piss off’表示‘滚开’.被动形式pissed off表示生气的.口语中也经常将off省略。例句：I’m so pissed (off) at him right now.我现在特别生他的气。 补充（1）除了pissed off，口语中常用来表示生气的还有：angry：Don’t be angry with me；mad：Don’t be mad at me.都表示‘别生我气’。（2）piss这个词本身表示动词或名词‘小便’，但是较粗鲁，建议在公共场合或陌生人面前不要用，而在朋友面前可以用.例句：I need to piss./I need to take a piss.我得去小便一下。 You’re so sick.你真变态。 讲解关键词‘sick’，除了表示‘生病的’，还可以表示恶心的/变态的。但是看表示生病的还是表示恶心的，得看具体语境。常见例句：You’re sick!你真变态！You make me sick.你真让我感到恶心！ 补充口语中常见的表示‘恶心的’还有形容词gross和disgusting.例句：You’re gross/disgusting.你真恶心；还有动词gross out.例句：You really gross me out.你真让我感到恶心。 I’m beat.我累死了。 讲解关键词‘beat’，除了熟悉的意思动词‘击打’，也可以作形容词表示‘筋疲力尽的’.例句：I wanna sleep, cuz I’m so beat（我想睡觉，因为我实在太累了）. 补充（1）口语中常见的表示‘很累的’形容词还有：very tried；exhausted；dog-tired；worn out；（2）关于beat在口语中的常见表达还有：beat a dead horse白费口舌；beat sb up/beat the hell out of sb痛扁某人一顿；beat around the bush绕弯子；Beats me.（问倒我了，我也不知道） We’re in a hurry.我们挺赶时间的。 讲解关键词‘hurry’表示‘快点’，in a hurry表示赶时间，口语中也经常用in a rush表示赶时间。 补充口语中其他常见类似表达：What’s the rush?你急匆匆的干嘛呀？；No rush.不用急.；We’re running out of time.我们快没时间了.；Hold your horses!别急，等下.；Take your time.你慢慢来，我不着急.；Don’t rush to conclusions.不要仓促做决定.；rush hour上下班高峰期 Watch your tone, young man.年轻人，注意你的说话语气哦。 讲解关键词‘tone’表示‘说话的语气/声调’。例句：I don’t like your tone.我不喜欢你说话的语气；first tone（第一声）/second tone（第二声）. 补充口语中类似的表达还有Watch your mouth和Watch your language（都表示‘注意你的嘴巴和你说的话’，在别人说脏话时可以用）；You eat with that mouth?（你是用那张嘴吃饭的吗？别人说脏话时用）；Swearing is bad. Don’t swear.（说脏话不好，不要说脏话.swear也表示‘说脏话’） I’m really not in the mood.我真的没那心情。 讲解关键词‘mood’表示‘心情’；常见口语搭配：in the mood（有做…事情的心情），经常用in the mood for sth/to do sth；例句：I’m in the mood for a movie.我想看部电影；Sorry, I’m not in the mood to go out.不好意西，我没心情出去玩；Not in the mood!没心情 补充口语中常见相关的表达：（1）心情不好：in a bad mood：She’s in a bad mood.（她心情不好）（2）情绪多变的：moody：She’s really moody.（她这人真的喜怒无常情绪多变） She dumped me!她把我给甩了。 讲解关键词‘dump’，能查到的词典意思是‘倒垃圾/清理废物’，除此之外还可以表示‘甩/抛弃’.例句：I got dumped.我被甩了. Lily dumped Tom yesterday.昨天Lily把Tom甩了. 补充（1）口语中经常用take a dump表示‘大便’（但是较粗俗，建议公共场合不要用，和朋友之间没关系）.例句：I need to go take a dump!我得去大便一下！（2）关于‘甩’：口语中也经常用break up（表示分手）.例句：Don’t break up with me.別跟我分手啊. We’ve broken up.我们已经分手了. Count me in.算上我一个呗。 讲解count表示‘计算/数数’，短语字面意思是：把我算进去，所以count sb in就表示算上某人.例句：Tom’s coming tonight. So count him in.（Tom今晚要来的，把他也算上。） 补充口语中必须掌握的还有（1）count sb out表示不要算上.例句：He’s not coming. So count him out.（他不来了，所以就不要算上他了）；（2）countdown倒计时：The countdown begins.（倒计时开始）；（3）count：重要；例句：That doesn’t count. One more time.（刚才那局不算，我们再来一次.） I’m gonna throw a party this week.这周我要开个party。 讲解关键词‘throw’，这里不表示‘扔’，而表示的是‘举办’：throw a party（开派对）.口语中常见的还有have a party/hold a party（都表示‘开派对’）.例句：I’m having a party at my place this Friday? You wanna come?（这周五我要在家开个派对，你想来吗？） 补充在美国常见的party有：birthday party生日派对；housewarming party暖房派对（搬入新家后邀请朋友过来的派对）；bachelor party新郎新婚前告别单身的派对；bachelorette party新娘结婚前告别单身的派对；costume party化妆舞会；going-away party离别派对 Can I get a refill?我能续杯吗？ 讲解关键词‘refill’，表示‘重新加满’，在这里就是名词‘再次满杯’的意思。‘re’作前缀经常表示‘再次’.比如consider-reconsider：You should reconsider it.（你应该重新考虑一下）；do-redo：I want to redo the house.（我想把房子重新装修一下） 补充口语中的喝酒常用语还有：Can I get some more?（能给我再倒一点吗？）；I’m having a blast right now.（我现在特别开心）；This is very strong.（这酒真烈！）；Bottoms up!（干杯.全部干完！）；I think I’m drunk.（我好像已经醉了。） Like you know him.说的好像你认识他似的。 讲解关键词‘like’，在这不表示‘喜欢’，而表示‘好像’，典型的‘讽刺句’/‘鄙视句’，翻译成中文是：‘说的好像…’。比如：1.你的一个朋友整天和你说英国怎么怎么的好，你就可以说：Like you’ve been there.（说得好像你去过似的）；2.你朋友笑话你昨晚喝醉了，你就可以说：Like you’ve never gotten drunk before.（说得好像你以前从来没喝醉过似的）。 补充口语中还经常用like表示‘比如’.例句：I saw many people last night, like Lily and Tom.我昨晚看到了很多熟人，比如说Lily和Tom. I didn’t mean to.我不是存心的。 讲解关键词‘mean’，mean to do表示‘打算做某事’，didn’t mean to表示‘没打算做’，即不是故意存心的.在美国，两人分手时A说：You hurt me（你伤害了我），此时B经常回答：Sorry, but I really didn’t mean to.（对不起，但是我真的不是存心的）。所以下次再犯无心之错时就对对方说：Sorry, I didn’t mean to. 补充（1）口语中经常用mean表示人‘尖酸刻薄的’：My boss is really mean to me.（我的老板对我真的很坏）；You’re mean!（你这人太坏了！）（2）固定短句I mean it.表示‘我是认真的（没开玩笑）’。 Yeah, I’ve been there before.对的，我也有过类似经历。 讲解此句为典型‘英语思维’句，字面意思为：我以前去过那儿（身体去过那儿）；语境一变，也经常用来表示：我也有过类似经历（思维想法去过那儿）.这里的思维习惯就是：英文里经常把‘身体’与‘思维/想法’对等。常见的表达有：I’m with Bingo.（可以理解为：我和Bingo在一起呢；也可以理解为：我同意Bingo的）；Are you following me?（身体层面：你是不是在跟踪我？；思维层面：你听懂我说的了吗？）；I’m lost.（身体层面：我迷路了；思维层面：我听不懂了）.所以下次你的朋友再说你英语不好的话你就说：I will get there.（我会到达那个水平的）。 Keep in touch.保持联系哦。 讲解关键词touch，这里不表示‘触摸’，而表示‘联系’.常见搭配表达还有：lose touch with sb与某人失去联系；get in touch with sb与某人取得联系；stay in touch保持联系 补充（1）touch被动形式还可以表示‘感动的’：I’m really touched by that movie.（我真的被那部电影感动到了）；（2）a touch经常用来表示‘一点点’；a touch of your love你的一点点爱 Could you do me a huge favor?你能帮我个大忙吗？ 讲解关键词‘favor’作名词时经常表示‘帮忙’.常用搭配有：do me a favor帮我个忙；ask you for a favor请你帮个忙；I got a huge favor to ask.我有个大忙需要你帮. 补充口语中常见的表示‘帮忙’的表达还有：Can you help me (out)?你能帮我吗？；You need a hand?要帮忙不？；Let me give you a hand.我来帮你.更礼貌的表达：I was wondering if you could do me a favor.不知你可不可以帮我个忙？ When are you gonna pop the question?你打算什么时候求婚呢？ 讲解pop the question：表示‘求婚‘.question指代的就是那句经典的‘Will you marry me?’（你愿意嫁给我吗？）；求婚也经常用一个动词叫propose.例句：I’m going to propose to her tonight.我准备今晚向她求婚.求婚的时候一般是单膝跪地：get down on one knee.准备好戒指ring.如果她答应了，那么戒指就是engagement ring（订婚戒指）.而你就可以说I’m engaged.（我已经订婚了）.那么她就是你的fiancee（未婚妻）.你是她的fiance（未婚夫）. Take it easy, man.兄弟你淡定！ 讲解关键词take，这里表示‘接受’.原句字面意思是‘轻松的接受它’，言外之意就是‘淡定，放轻松’。类似的常见口语表达还有：Don’t take it personal.别往心里去，不是针对你！；Don’t take it too seriously.不要太当回事儿.；I can’t take it anymore.我实在受不了了. 补充口语中经常用来表达淡定的还有：Calm down/Chill/Chill out!/Easy!例句：Chill out, man. It’s no big deal.哥们，淡定。没什么大不了的 Can I crash at your place?我能睡你家吗？ 讲解关键词crash，这里不表示熟悉的‘撞击/坠毁’，而表示‘sleep’睡觉，区别在于crash强调的是‘临时决定睡觉或者强调睡觉环境不好或者借宿’。例句：I’m tired. I’m gonna go crash.我累了。我准备去睡觉了；She crashed on the couch.她睡在沙发上的。 补充口语中和睡觉有关的表达还有：hit the bed/hit the hay/hit the sack，都表示去睡觉；take a nap则表示稍微睡一小会儿. Oh, I don’t know about that.这可说不准。 讲解本句意思为引申义，而字面意思是：我不知道这事儿.口语中经常用don’t know（不知道）来表示not sure（不确定）。比如你在shopping时销售人员（salesperson）说这衣服很适合你（you look good in it），你应该买下来（you should buy it），你就可以说：I don’t know. It’s a bit expensive for me.（我不确定，对我来说有点儿贵了） You look stunning.你看上去美极了。 讲解关键词stunning表示‘惊艳的，令人印象深刻的’，此句经常在某种场合遇到朋友时使用.比如在某个party上遇到朋友时就可以打招呼说：Hey. How are you? You look stunning!类似的表达还有：You look amazing/good/sharp today.（表示：你今天看起来很不错）；如果只对女生还可以说：You look beautiful/gorgeous!对男生可以说：You look dapper, dude! 补充聊天时夸对方，美国人还经常喜欢用：You’re funny!你很有趣；You’re cute.你很可爱！ Out with it.你就说出来吧！ 讲解当你感觉对方想说但是还在思考要不要说的时候就可以用这句.口语中常见的表示‘说’的还有很多.但是语境不同，用法也有差异.举例补充：（1）A: Can I ask you something?（我能问你点事儿吗？）B: Shoot.（说吧！）；（2）I know you know her name. Just spill it, man.（我知道你知道她的名字，你就说吧，哥们）；（3）Do you want me to spell it out for you?（你要我帮你说出来吗？）；（4）Can I run something by you?（我能跟你说点事儿吗？；（5）We need to talk.（我们得好好谈一谈）（语气很重，慎用） I need to throw up.我得吐一下。 讲解关键短语throw up：表示呕吐.口语中经常用来表示‘呕吐’的还有：puke和vomit.也可以作名词表示‘呕吐物’。例句：1. Don’t throw up on me!別吐到我身上；2. There’s your vomit all over the place.地上都是你吐的东西. 补充呕吐的原因可能是怀孕了（you’re pregnant），可能是你喝多了（you’re drunk），也有可能是你胃不舒服（Your stomach is not feeling well）. Have I made myself clear?都听懂我说的意思了吗？ 讲解关键短语make oneself clear：表示‘让别人听懂意思’.原句也可改为：Am I making myself clear?例句：You’ve made yourself clear.懂你的意思了. 补充口语中常见的表示‘你听懂了吗？’还有：You understand?；You got it?；You got me?；You following me?；You see what I’m saying?；You understand what I’m talking about?；Are we clear?（经常伴有命令的口吻） You ran out on me.当初是你抛弃我的。 讲解关键短语run out on sb：表示抛弃某人.等于abandon.口语中也可以用walk out on sb表示抛弃某人.例句：My father ran out on us when I was 5.（我5岁的时候我父亲就丢下我们不管走了）。 补充关于run在口语中的用法，必须掌握的还有：（1）I gotta run.（我得走了）；（2）I ran into Bingo yesterday.（我昨天碰到Bingo了）(run into sb表示偶遇某人)；（3）We’re running out of time（我们快没时间了）（run out of sth表示‘快用完…了’）。 I’ll fix you up with Beth.我把Beth介绍给你做女友。 讲解关键短语fix sb up：给某人安排对象，做媒.口语当中也经常用set sb up来表示。例句：Your friend is so pretty! Can you set me up with her?你朋友长得太漂亮了，你能把我介绍给她认识吗？ 补充关于fix在口语中的用法，必须掌握的还有：（1）It can’t be fixed.修不了了/你补不了了；（2）I’ll fix you up with a bigger room.我再给你提供个大一点的房间. Whatever.随便，无所谓了。 讲解whatever表示‘不管什么/随便什么’.单独的‘whatever’经常伴有不屑无所谓的口吻.口语中经常包含whatever短句有：Whatever you say!你说什么就是什么咯；Whatever you’re having.你吃/喝什么我就要什么.（点菜时经常用）；Whatever you do, I’ll be there for you.不管你做什么，我都会支持你的。 补充whatever还经常在刚碰面的时候用来问候别人.例如：Hey. Whatever happened to your brother? Haven’t seen him for a while.你弟弟最近怎么样了？有段时间没见到他了。 Can you put her on the phone?你能让她接下电话吗？ 讲解关键短语put sb on the phone：表示让某人接电话.常用的同义短语还有put sb through.例句：Is Bingo there? Can you put him through?（请问Bingo在吗？能让他接下电话吗？） 补充口语中常用的和电话有关的表达还有：pick up the phone接电话；hang up the phone挂电话；Don’t hang up on me.不要挂我电话；Who is it?你是谁？；Gimme a call tomorrow.明天给我电话哦；I’ll text you.我会给你短信的. You’re unbelievable!你真是不可理喻！ 讲解关键词unbelievable：字面意思是难以置信的；太棒或太极端到难以置信的；例句：Did you hear him sing? It’s unbelievable.你听到他唱歌了没？唱的太棒了！而原句的You’re unbelievable则表示你太极端，难以接受。 补充口语中常用的表示‘不可理喻’的表达还有：Are you out of your mind?（你是不是疯了？）；Are you serious?（你不是吧！） I really appreciate it.我真的很感激。 讲解关键词appreciate表示‘感激’.当表示对别人的感激和帮助时经常用：Thanks. I really appreciate it.例句：I really appreciate you trying to help me.真的很感激你尝试帮我。 补充当希望别人做某事或者希望别人不做某事时经常用句型：I’d really appreciate it if you…例句：I’d really appreciate it if you left right now.如果你现在就走，我会很感激的. I owe you one.我欠你个人情！ 讲解关键词owe：表示‘欠’.口语中常见表达有：You owe me money.你欠我钱；I owe you bigtime.我欠你太多了（人情/金钱都可以）；I owe you an apology.我得跟你道歉；I owe my life to you.我的命是你的了！ 补充关于owe的表达必须掌握的还有（1）You owe it to yourself.这是你应得的；（2）Owing to the rain, we can’t go.由于下雨，我们不能去了(owe to sth表示‘因为某事’) That goes without saying.那还用说？ 讲解习语。字面意思是：不用说就可以进行，言外之意就是不用说了。口语中常见的包含say的短语短句还有：（1）Need I say more?还需要再说下去吗？；（2）Says who?谁说的！；（3）I’m just saying.我只是说说而已；（4）If you say so.你说是的话那就是咯；（5）I can’t say the same.不敢苟同；（6）Do as I say.听我的，我说什么你就做什么;（7）You don’t say!是嘛！/可不是嘛！ Dinner’s on me.晚饭我请客。 讲解关键词on：此处表示‘算…的‘。Lunch is on me.午饭算我的（言外之意就是午饭我买单）.邀请别人吃饭喝酒时常用此句型.例句：First drink’s on me.第一杯算我的. 补充口语中常用和用餐有关的表达还有：（1）Let me buy your dinner.我请你吃晚饭吧；（2）It’s on the house.店主请客（免费）；（3）It’s my treat.算我的，我买单；（4）Let’s split the bill.我们分开付账吧；（5）I got it this time.这次我来请。 Where does that come from?你怎么想起来说这种话呢？ 讲解字面意思是：那是从哪来的？在别人说了一些让你不可思议的话的时候你可以用这句。例句：A: I think you don’t love me anymore.（我觉得你不爱我了）；B: What? Where does that come from?（什么？你怎么想起来说这种话呢？） 补充口语中和‘说话’有关的句子必须掌握的还有：（1）Where were we?我们刚才说到哪了？；（2）I know where this is going.我知道你想要说什么了。 You deserve it!你活该！/这是你应得的！ 讲解关键词deserve表示：值得。原句字面意思是：你值得这个.语境变意思也变。如果是自作自受就翻译为你活该；如果是通过努力理所应当就翻译为你应得的。口语中常见的deserve还有：You deserve someone better.你值得拥有更好的人（别人失恋时安慰可以用） 补充‘你活该’的口语表达还有：You had it coming；You brought this on yourself；表示‘这是你应得的’还有：You owe this to yourself! How am I supposed to know?你问我我问谁？ 讲解关键短语be supposed to表示：应该.原句字面理解为：我怎么会应该知道？.其他例句：What am I supposed to say?我应该说什么好呢？ 补充口语中表示‘不知道’的表达还可以用God。如God knows where he is.（鬼才知道他现在人在哪）。 I’ve been working out lately.我最近一直在健身。 讲解关键短语work out在原句中表示：健身，锻炼身体.例句：I need to go to the gym to work out.我得去健身房锻炼去。口语中也经常用此句夸别人的身材：You look good. Been working out, huh?你看上去不错，最近在健身是吧？ 补充口语中关于‘健身’常见的表达还有：1. lose some weight/shed some pounds减肥；2. You’ve put on some weight.你最近变胖了；3. I’m on a diet.我最近在控制饮食；4. hit the gym去健身房锻炼 He never cheated on me.他从来没背着我偷过人。 讲解关键短语cheat on表示：偷人.例句：I’ve never cheated on her.我从来没有背着她偷过人。cheat本身表示的是作弊欺骗，在考试中作弊叫cheat in exams. 补充口语中和感情有关的常见表达还有：have an affair有婚外恋；break up分手；get dumped被甩了；get back together和好；a perfect match天生一对；go out with与某人约会；in a relationship恋爱中；fall in love坠入爱河 Are you in or are you out?你到底要不要一起做？ 讲解关键词in和out，字面意思是在里面和在外面，口语中经常用来表示‘加入’和‘退出’.当有活动时别人会问你想不想加入，你想加入时可说：I’m in.如果你想退出活动时可说：I’m out.例句：A: We’re going shopping tomorrow. Wanna come?（我们明天去逛街，想来吗？）B: Yeah, I’m in.（好，我来） 补充如果别人邀请，你不想加入时可用pass这个词。例句：Do you want to have dinner with us?（你想和我们一起吃晚饭吗？）B: I’ll pass/I’ll take a pass.（我就不参加了） I failed you.我辜负了你们的期望。 讲解关键词fail，表示失败。例句：Don’t fail again.别再失败了.口语中经常用fail sb表示：另某人失望。或者fail sth表示：未成功.例句：I failed the test, mom. I’m sorry I failed you again.妈妈，我测试没过，对不起，又让你失望了. 补充口语中表示‘失望’的表达还有：Don’t let me down.别让我失望；I’m disappointed in you.我对你感到失望；I expected more.没达到我的期望；not as good as I’d expected.没我期望中的好。 I have no credit left on my phone.我手机没钱了。 讲解关键词credit表示‘信用’，在这引申为‘费用’的意思。给手机充值叫做：top up my phone/put money on my phone/add money to my phone. 补充手机常见的问题还有：I’m losing you.我快听不清你说话了；You there?你还在听我说话吗？；No reception here.手机在这没信号；My cell phone has some bad reception.我手机信号不好；My phone isn’t working well.我手机出了点问题；Hello?Hello?喂，喂？（听不到对方说话时用） That would be great.那样的话就太好啦！ 讲解关键短语would be，口语中，在对方主动提出要做事情或者提到一个可能性时，经常用‘that would be…’句型。例句：1. A: Do you want me to pick you up tomorrow?（你要我明天接你吗？）；B: That would be nice.（那样的话就太好了）；2. A: I think it’s going to rain tomorrow.（我觉得明天要下雨）；B: That would be too bad.（那样就太不好了）. 补充would在口语中经常变成’d.并且d不发音，that would be经常说成that’d be…，如That’d be awesome.那样的话就太棒了！ Big deal!有什么了不起的！ 讲解deal表示交易买卖.big deal字面意思为大买卖，引申为‘了不起’，例句：It’s a big deal. Don’t mess it up.这事儿很重要，别搞砸了。但是口语中经常用big deal，再配合讽刺不屑的语气表示：有什么大不了的。 补充口语中和deal表示‘买卖’的常见表达还有：Deal!一言为定；Don’t make a big deal about it/Don’t make a big deal out of it.別小题大做；This is a good deal.这买卖真划算；cut a deal达成协议。 You got me wrong.你误会我了。 讲解关键词get，除了熟悉的表示获得得到，也经常表示‘理解’。例句：I don’t get it.我不懂；I don’t get her.我真搞不懂她。原句里的got me wrong就是错误的理解我了（即误会我了）.其他常用句子：别误会我：Don’t get me wrong；你全搞错了：You got it all wrong. 补充口语中用get表示理解的短句还有：You got it/You get it?你懂了吗？；You got me?你懂我意思了吗？；I got you/I gotcha.我懂你意思了。 Hey, you wanna hang out?喂，你要不要一起玩啊？ 讲解关键短语hang out，表示：一起玩儿一起放松.例句：1. I like hanging out with you.我喜欢和你一起玩儿；2. I’ll just hang out at home tonight.我今晚就在家休息放松了。口语中也经常会把out省略，比如：Let’s hang tomorrow night.我们明晚一起玩吧。 补充口语中关于hang常见的短语还有：hang in there加油顶住；hang on等一下；hang up the phone挂电话；hang up on sb挂某人电话；have a hangover宿醉；hung-over宿醉的（形容词）；How’s it hanging?最近怎么样（打招呼用） You poor thing!你真可怜！ 讲解poor在这表示可怜。原句理解为：你这个可怜的东西。也经常说：Poor you.英语中，当听到对方描述自己不好的经历时经常用poor表示同情。也经常用：Sorry to hear that.或者That’s terrible.例句：A: I’m not feeling well today.（今天感觉身体不舒服）；B: Oh, you poor thing/Sorry to hear that/That’s terrible.（都表示对对方的同情）。 补充英语中当听到对方描述自己好的经历时经常用：That’s great/awesome；Good for you；That’s good to hear；I’m happy for you；Congratulations（恭喜）等表达。 How come you’re still single?你怎么还是单身呢？ 讲解关键短语how come表示：怎么会？口语中在感到惊讶时用。例句：1. A: I lost my wallet.（我钱包丢了）；B: How come?（怎么会呢？）；2. How come you’re sick?你怎么会生病呢？ 补充当别人说出一些你认为难以置信的事情时，比如你朋友说：I just got into Harvard.（我被哈佛大学录取了），你就可以说：What!/No way!/Are you kidding?/Are you serious?/Really?/Seriously?都表示很惊讶，不会吧！ This guy is nuts.这哥们绝对是个疯子！ 讲解关键词nut，愿意是坚果，俚语意思是疯子，复数nuts表示‘疯的’.常用短语：go nuts发疯（Don’t go nuts别发疯）；drive sb nuts使某人发疯（You’re driving me nuts你真让我崩溃） 补充除了nuts表示疯的，口语中也常用crazy/insane/bananas/out of one’s mind；例句：Are you crazy?/Are you insane?/Are you bananas?/Are you out of mind?都表示你疯了吗？；lunatic也表示疯子（名词）. Let’s take a short break.我们短暂休息一会儿。 讲解关键词break表示短休息。短语take a break.由于寒假假期较短，所以寒假叫做winter take.在美国，休息多长时间用take，并把分钟省略。如休息五分钟可直接说：Let’s take five.不需要加minutes. 补充表示短暂休息睡眠的也可以用nap.例句：I need to take a nap.我得稍微睡一会儿（强调短睡眠）；较长的假期叫vacation，如暑假：summer vacation；中国的法定假日一般用holiday描述，如：National Day holiday国庆假期。去度假叫go on a vacation. It’s all on him.都怪他！ 讲解关键词是on，和前面dinner’s on me一样，表示：算…的。吃饭算我的，所以是我请客；但是语境一变，责任算他的，就表示：都怪他。例句：If anything goes wrong, it’s on you.如果出什么事儿的话就怪你。 补充其他表示‘承担责任’的表达还有：It’s all your fault.都是你的错；My bad.我的错；I blame you.我责怪你；He is to blame.怪他；I’m responsible for this.这事儿我有责任. She’s seeing someone again.她又开始约会了。 讲解关键词seeing表示约会，而不是熟悉的看见.等于dating.例句：I heard that Lily’s seeing Tom.我听说Lily最近在和Tom约会。 补充口语中表示约会常用的短语还有：go out字面意思是出去（男女之间可特指出去约会）：I’ve been going out with Sarah（我最近在和Sarah出去约会）；go on a date去约会；blind date相亲；bring a date带一个男伴/女伴；in a relationship恋爱中；It’s getting serious.（感情）变的认真了. You stay out of this.你别多管闲事儿。 讲解短语stay out of表示：别插手.例句：You stay out of this fight.你别插手这场斗争。 补充口语中常见的表示‘别多管闲事’的句子还有：It has nothing to do with you.（跟你没关系）；It’s none of/not your business.（不关你事儿）；Keep your nose out of this.（别没事儿找事儿）；Mind your own business.（管好你自己的事儿就行）；Don’t get in the way.（別碍事儿）;短语interfere with…（干涉） Sleep tight.睡个好觉。 讲解关键词tight不表示熟悉的‘紧的’，而是俚语意思：舒服地/稳健地.例句：Sit tight.坐好了.晚上睡前经常用sleep tight表示希望对方睡个好觉。 补充常见的和‘睡觉’有关的表达还有：good night晚安；Sweet dreams好梦。一般会经常说（Good night and sleep tight比较押韵）；can’t fall asleep睡不着；have a nightmare做噩梦；I’ll sleep on it.我睡觉时好好考虑；You’ll sleep it off.你睡一觉就好了；sleeping pills安眠药 She’s gonna be crushed.她会崩溃的。 讲解关键词crush，表示‘压碎’；crushed被压碎的，引申为‘人崩溃了’.例句：Lucy’s crushed by the whole breakup thing.整个分手事件把Lucy搞得崩溃了，打击很大. 补充（1）口语中表示‘心情很差’的词还有：heart-broken极其伤心的；broken-hearted极度悲伤的；desperate绝望的；miserable痛苦的；（2）crush在口语中还可以表示‘迷恋，有好感’，可做动词和名词，例句：I have a crush on Sarah/I’m crushing on Sarah.我对Sarah有好感。 This one is way better.这个好多了。 讲解关键词way，除了熟悉的‘方法，方式，道路’，还可以表示‘非常地/远远地’。Better表示更好，way better则表示好的多，修饰程度.经常还会和too搭配表示‘太/非常’；例句：1. It’s way too hot today.今天实在太热了；2. I’m way taller than you.我比你高多了；3. He’s way gone.他早就走了；4. Way ahead of you.早就在你前面想到了。 补充way的口语用法还有：way to go!干得漂亮！；This way please.这边请；the way you talk你说话的方式；in a different way以不同的方式 I’m in the middle of something.我现在正在忙。 讲解短语in the middle of something：字面意思是在某件事的正中间，言外之意就是脱不了身，所以用此短语表示：说话时正在忙。开会时别人给你打电话你就可以说：Sorry. I’m in the middle of something. I’ll call you back.对不起，我在忙，回头给你回电话.也可以具体说出事情：I’m in the middle of a meeting.我在忙着开会呢 补充表示忙的短语还有：busy忙碌的；busy as hell忙得要死；I will be tied up tomorrow.我明天会超忙. Buckle up!系好安全带！ 讲解开车用语，buckle指的是‘皮带扣’，作动词就是把安全带扣上，也经常说：Fasten your seatbelt. Seatbelt表示‘座位安全带’. 补充常见的汽车用语还有：Hop in/Get in the car.上车；Pull over靠边停；Stop the car停车；run red lights闯红灯；Don’t drive when you’re drunk不要醉驾；Don’t drive under the influence不要酒驾；speed limit限速；drive over the speed limit超速；give you a lift让你搭顺风车 Bring it on.放马过来。 讲解口语中也经常说Bring it.表示：开始吧（很有自信）。当别人挑战你时或者比赛时经常说。例句：A: I think you’re no competition.（我觉得你根本不是我对手）B: Really? Bring it on.（是嘛？放马过来吧！） 补充口语中回应对方挑战的表达还有：We’ll see (about that).我们到时看咯，走着瞧了；I don’t know about that.这可说不准；You’re gonna be sorry for saying this.你会为说这话而后悔的；Ok, it’s on!行，我应战！ I don’t buy any of your crap.我才不信你的鬼话呢。 讲解1.关键词buy，除了熟悉的‘买’，口语中经常用来表示‘相信（believe）’.例句：1. I don’t buy a word you just said.你刚才说的话我一个字也不信；2. She buys your story.她是相信你的故事的；2.关键词crap，除了表示‘大便’，口语中经常用来表示‘鬼话废话’.例句：1. Cut the crap.别说废话；2. He’s full of crap.他这人鬼话连篇。 补充表示‘不相信’还可以说：I doubt that.我可不信；Bullshit!胡说；Nonsense.瞎说！ Let’s just take a cab.我们还是打车吧。 讲解关键词cab表示出租车，也可以用熟悉的‘taxi’.计程车司机叫cab driver/taxi driver.英语里用take表示乘坐交通工具，如：take the bus坐公交；take the subway坐地铁；take the train坐火车等. 补充在国外打车可跟司机说地点加please.如：Central park, please.请把我带到中央公园；最后不要忘了给小费说：Keep the change.（零钱不用找了） I quit my job.我辞职了。 讲解关键词quit表示停止/放弃.常见的有：quit smoking戒烟；quit drinking戒酒等.quit my job就是停止我的工作（辞职）；辞职时也可直接说：I quit!我不干了.正式一点的词表示辞职的有：resign: He resigned from the company yesterday.（他昨天辞职了） 补充和工作有关的常见表达还有：fire/lay off解雇：I’m fired/I’m laid off.我被炒鱿鱼了；hire招聘；employ雇佣；employer雇主；employee雇员；suspended被停职了；between jobs没有工作 Almost slippped my mind.差点儿忘记了。 讲解关键短语slip my mind，字面意思是滑过我的脑子，引申为：忘记了。例句：A: Why didn’t you go to the meeting?（你为什么不去开会）；B: Oh, it slipped my mind.（那事儿我忘记了）；与之意思相反的是cross my mind，字面意思是穿过我的脑子，引申为：想起.例句：You always cross my mind before I go to bed.我睡前总是会想到你！ 补充口语中的‘忘记’还有：Just forget about it.忘了吧（没事儿了）；Forget what I said.当我什么也没说。 Dummy up.别说话。 讲解关键词dummy表示：笨蛋，口语中语气更重的还有stupid-ass和dumb-ass，也表示笨蛋.Dummy up表示’保持安静‘.愿意是嘴笨不要说话。 补充口语中和‘闭嘴’有关的表达还有：Shut up/Shut it/Shut your mouth(shut表示关上，就是把嘴关上)；Zip it/Zip your mouth（zip表示拉链，就是把嘴拉上）；Keep quiet保持安静；Keep your voice down/Keep it down声音小点儿；Shh/shush/hush嘘，别说话；No talking!不准说话. I couldn’t care less.我才不在乎呢。 讲解关键语法点couldn’t+比较级表示最高级：couldn’t care less，字面意思是不能在乎的更少了，言外之意就是在乎地已经少的不能再少了，也就是很不在乎。类似常见表达还有：I couldn’t agree more（不能同意更多，即非常同意）；It couldn’t be better（不能更好了，即非常好） 补充口语中表示‘我不在乎’的表达还有：I don’t care我无所谓；Whatever随便；I don’t give a damn/crap/shit（慎用）/rat’s ass我无所谓 Let me be clear.我跟你说清楚吧。 讲解clear在口语中经常表示‘说话意思的清楚’。比如说话时可以问：Am I making myself clear?我说的你们听懂没？；说完话可以问：Have I made myself clear?/Are we clear?（大家都清楚了吧？） 补充口语中的各种’说‘还有：1. I’m gonna be straight with you./I’m just gonna level with you.我就和你直说了；2. Don’t beat around the bush.别绕弯子；3. cut to the chase直接说重点；4. Get down to business谈正事儿；5. Says who?谁说的？ I’ll be right back.我马上回来。 讲解此句在口语中也可以直接说Be right back，并经常用简写BRB.表示失陪下，马上回来。比如和朋友聊天时电话突然响，你就可以说：Be right back（出去接个电话，马上回来），在线聊天时会经常用缩写BRB。而中文里的‘失陪’就可以用：Excuse me. 补充口语中常见的缩写除了BRB还有：TTYL（talk to you later回聊）；TBD（to be determined待定）；LOL（laugh out loud哈哈）；LMAO（laugh my ass off笑死了）；CU（see you再见）；FYI（for your information顺便告诉你）；ASAP（as soon as possible）等 You’ve crossed a line here.你这事儿做的有点过了。 讲解关键短语cross a line，字面意思是越过一条线，引申为‘过分’。例句：Don’t cross the line.不要太过分；There’s a line you should never cross.凡事有个度。 补充口语中表示‘过分’的表达还有：Enough. This is too much.够了，这个太过分了；This is out of line.这个太过分了！；Know your limits.知道自己的底线；This is terrible/awful.这样太不好了！；Don’t push it.别得寸进尺！；You’ve gone too far.你做的太过分了 Listen up, everyone.大家都给我听好了。 讲解关键词listen表示‘听’，后面加up表示‘认真听好了’，用来吸引大家的注意力，相当于listen carefully. everyone. 补充口语中的各种‘听’还有：1. Please hear me out.请听我说完。2. Are you listening to yourself?你在胡说什么啊？3. Look, it’s over.你听着，一切都结束了。4. Sorry, I was eavesdropping.不好意思，我刚才在偷听。5. Never heard of it.从来没有听说过。6. She’s a great listener.她是个不错的倾听者。 Don’t overthink this.你别想多了。 讲解关键词overthink=over（过度地）+think（想）：过渡地想，即想多了。也可以说：Don’t think too much（别想太多了）.口语中经常用over放在动词前面表示：过度地…；常见单词有：overreact：over+react反应过度；overspend：over+spend花费过多；overestimate：over+estimate高估；与之相反的是：under+…，如：underreact：under+react未作出应有反应；underspend：under+spend花费过少；underestimate：under+estimate低估。 Now we’re even.现在我们扯平了。 讲解关键词even除了表示‘甚至’，口语中还经常表示‘平等的’。例句：1. After this, we’re even.这事情结束后我们就扯平了；2. Ok, let’s call it even.好，我们之间扯平了。 补充口语中的和‘平等，公平’有关的表达还有：1. an even break一个公平的机会；2. This is not fair.这太不公平了（fair强调公平）；3. All men are created equal.人生而平等（equal强调平等）；even表示‘甚至’时在否定句中放否定词后面，和中文顺序不一样，如：I don’t even know you.；I’ve never even met you before. Leave me alone.让我一个人静一静。 讲解关键词是leave，除了表示‘离开’，也经常表示‘让…保持…状态‘，原句字面意思是：让我保持alone（一个人）的状态，即让我一个人待着，换一个语境，也可以翻译为：离我远一点（如果有人骚扰你时）。类似的语法表达还有：Leave the door open.把门开着；Leave the lights on.把灯开着（保持开的状态）；Leave it on the table.放在桌上就行（强调状态） 补充著名生活服务类节目‘非诚勿扰’可翻译为：Leave me alone unless you mean it：除非你是认真的（you mean it），不然就离我远一点（leave me alone）. I’m wasted.我喝醉了。 讲解关键词wasted，除了表示‘浪费的’，口语中还表示‘烂醉如泥的’.例句：Let’s go get wasted tonight.我们今晚去大醉一场吧！ 补充（1）口语中用来表示‘喝酒’的形容词还有：I’m sober.我清醒着呢；I’m tipsy/buzzed我微醉 drunk/hammered/trashed醉了；（2）酒鬼：drunkard/alcoholic/lush/alky/booze hound；（3）西方常见酒的分类：alcohol酒精；liquor/booze烈酒；cocktail鸡尾酒；beer啤酒；white wine白葡萄酒；red wine红葡萄酒；whiskey威士忌；scotch苏格兰威士忌；vodka伏特加；rum朗姆酒等 Something’s up.出事了。 讲解关键词up，除了表示‘向上’，还表示‘发生了’，另外的常见短句是What’s up?（发生了什么）；原句在口语中也经常说Something’s come up.意思一样。类似的表达还有：Something’s wrong.有些不对劲儿；Something happened.发生了点事情；We got a problem.我们遇到问题了. 补充‘up’在口语中还经常表示‘醒着’，如：Who’s still up?谁还醒着；What’are you doing up?你不睡觉在干嘛？；还经常表示‘到时间了’，如：Time’s up!时间到；My shift’s up.我轮班结束了。 You totally had it coming.这完全是你自找的。 讲解关键短语have sth coming表示‘应得的’，可以是好的，也可以是坏的。有人自作自受，你就可以说：You had it coming.你自找的。口语中类似表达还有：You deserve it.你活该（也可以用褒义表示：这是你应得的）；You asked for it/You brought this on yourself.你自找的 补充口语中还经常用see sth coming表示‘预料中的’。例句：A: Tom won the game.（Tom赢了比赛）；B: Yeah, I didn’t see it coming though.（对，但是我根本没想到，出乎意料） Don’t play dirty.别跟我玩阴的哦。 讲解关键词dirty，表示脏的；下流的；阴险的。原句中play dirty也可以用fight dirty，在两人比赛斗争时提醒对方不要玩阴招就说Don’t play dirty；当一个人经常说脏话时可说：What a dirty mouth you got!你嘴巴真脏啊！；有人说话下流可以说：He always talks dirty.他说话总是很下流。 补充口语中当别人说脏话时还可以用：You eat with that mouth?（你是用这张嘴吃饭的吗？）；或直接说：Come on.（切）；或Don’t swear.（不要说脏话） Beats me.我也不知道，问倒我了。 讲解不要误解为‘打我’，口语中类似的表达还有：I don’t know/I don’t have any clue/I have no idea我不知道；You got me/I’m stumped你难住我了. 补充口语中表示‘不理解’的表达有：I don’t understand/Not following you/You lost me/I don’t get it.没听懂你说的；I don’t see your point.我不知道你的重点是什么；表示‘迷惑‘的表达有：I’m confused/I’m baffled/I’m bewildered/I’m perplexed.我迷惑了. What’s in it for me?对我有什么好处呢？ 讲解字面意思是：里面有什么是给我的？引申为：对我有什么好处？类似表达还有do me good对我有好处；do me bad对我有坏处；in your interest对你有好处；for your own good为你自己好 补充（1）与原句同义的还有：Why would I say yes?我为什么要答应你呢？（2）口语句‘what’s there to…‘经常表示‘有什么好…的‘。What’s there to see?那有什么好看的呢？；What’s there to eat?那有什么好吃的呢？ I think I’m in love with you.我觉得我爱上你了。 讲解关键短语in love with爱上某人.类似表达还有：fall in love坠入爱河；love at first sight一见钟情；Love me, love my dog.爱屋及乌。 补充口语中的‘喜欢’还有：I like you/I dig you/I’m into you/I’ve got a crush on you/I have a thing for you/I fancy you（英国人喜欢用）都表示我喜欢你；I’m crazy about you. I think about you all the time.非常喜欢你，喜欢的发狂，每时每刻都在想你。 Could you give us a sec?你能让我们俩单独说会儿话吗？ 讲解关键短语give us a sec表示：让我们单独说话；也可以表示：稍等一下；sec是second的缩写，也可以说give us a second/minute/moment.下次想和某人单独说话你就可以说：Can I see you for a sec?或者Can I talk to you for a sec?，这边的sec都可以换成second/minute/moment；而give me a sec一般表示：稍等一下（给我一小会儿）。 补充单独说话在口语中也可用：Can we talk in private?/Can we talk privately?我们能单独聊会儿吗？ Don’t take this the wrong way.别误会哦。 讲解关键词take，表示‘理解/接受’，(in) the wrong way表示‘以错误的方式’，字面意思是不要以错误的方式理解这个，即不要误会。 补充口语中关于take的短语必须知道的还有：take sb for把某人当作…（1. what do you take me for?你把我当成什么人了？；2. Sorry, I took you for someone else不好意思我认错人了）；take it out on me拿我发火解气；take care of you照顾你；take care of it搞定这事儿；I need to take off.我得走了。 Shame on you!真为你感到羞耻。 讲解关键词‘shame’表示‘耻辱’.Shame on sb表示‘为…感到羞耻丢人’。例句：A: Tom stole his mom’s money yesterday（昨天Tom偷他妈的钱了）；B: Shame on him.（他真丢人！）类似表达还有：You should be ashamed of yourself.你应该为自己感到羞耻。；This is so embarrassing.这太丢人了/难为情了；It’s so awkward.太尴尬了 补充shame还经常表示‘遗憾可惜’，如：What a shame!太可惜了！；It’s a shame that you can’t come with us.你不能和我们一起来太遗憾了 You’re doomed.你死定了。 讲解关键词doomed表示‘注定要倒霉的’。类似表达还有：You’re dead!你死翘翘了；You’re dead meat.你死定了；You’re screwed/You’re done.你完蛋了。 补充口语中‘求饶’的表达：Just give me another chance（再给我一次机会吧）；Give me a break.（先让我休息一下吧）；Cut me some slack（放过我吧）；I promise it’s not ganna happen again（我保证这样的事儿不会再发生了）；I swear to God that I won’t do it again（我对天发誓我以后再也不这样了） Don’t play that game with me.不要跟我玩那套。 讲解关键词play game（玩游戏）引申为‘玩…哪套‘。例句：I know what game you’re playing. It won’t work.我知道你在跟我玩哪一套。没有的！ 补充（1）play the … card表示用…招数：I always play the ‘I can’t drink’ card when I don’t want to drink.我不想喝酒的时候我就骗他们说我不能喝酒；He played the ‘I’m sick’ card again.他又骗我们说他生病了。（2）‘不上当’在口语中可表达为：I won’t fall for that.我不会上当的。 I need some time to figure it out.我需要点时间好好弄清楚。 讲解关键短语figure sth out表示：把…弄清楚。例句：You figure out why he didn’t come today.你给我弄清楚为什么他今天没来；I’ve got it all figured out.我把一切都搞清楚了. 补充口语中必须要掌握的‘out’短语还有：Cut it out.停止，别闹了；Check it out.看一看；Don’t freak out.别惊慌失措；knock sb up使某人怀孕；sell out卖光；knockout美女；takeout外卖；move out搬出去；worn out筋疲力尽的；creep sb out使某人感到不舒服自在。 I’ll catch up.我会跟上的。 讲解关键短语catch up表示‘跟上进度’。例句：A: We’re on our third glass. What’s wrong with you?（我们已经喝第三杯了，你怎么回事？）B: Don’t worry. I’ll catch up with you.（別担心，我会跟上你们的进度的）。 补充catch up在口语中经常也表示‘叙旧’。叙旧的常见表达有：Long time no see. We need to catch up.好久不见，我们得好好叙旧；It’s been a while since I saw you last.从我上次见你到现在得有一阵子了吧；Let’s go grab a couple of drinks.我们去喝两杯！；Where’ve you been?最近跑哪去了？；What’ve you been doing?最近忙什么呢？ Get your ass out of here.滚！ 讲解口语中经常用sb’s ass表示‘人’。如：Thank you for saving my ass.谢谢你救了我（不是救了我的屁股）；I’ll kick your ass.我会揍你的（不是踢你的屁股）；所以原句就等于：You get out of here.你滚出去 补充（1）口语中让别人滚的表达还有：Get out of my face/Get lost.从我眼前消失；Get out of the way.别挡道；Be gone!赶紧消失！；Scram/Eff off/Piss off（英国人喜欢用）滚（语气很重）；（2）美语中out of经常缩读成outta.如：I’m out of here.=I’m outta here.（我走了） You don’t wanna do this.你最好别这样做。 讲解字面意思是：你不会想要这么做的，引申为：我建议不要这么做。口语中‘给建议’的表达有：1. You might wanna…如：You might wanna call your mom first.我建议你先给你妈妈打个电话；2. I think you should…如：I think you should give her a chance.我觉得你应该给她个机会；3. You’d better…如：You’d better leave now.你最好现在就走；4. I would … (if I were you)：I would go to LA (if I were you).我建议你去洛杉矶（口语中经常把If I were you省略） That blew my mind.太让我震撼了。 讲解关键短语blow one’s mind表示：令某人震撼，惊叹不已.例句：I think her song is gonna blow your mind.我觉得她的歌会让你为之惊叹.表示‘惊艳‘的美语表达还有：Your song was really mind-blowing/awesome/amazing.你的歌真的很不错；You killed it.你刚才表现很棒 补充口语中的‘mind’还有：change my mind我改变主意；out of my mind我疯了；keep/bear sth in mind记住某事；cross my mind让我想起；slip my mind我忘记；never mind.没事了；I don’t mind.我不介意；What’s in your mind?你脑子里想的什么？ I’m off on Sunday.我周日不用上班。 讲解关键词off在这边表示’不上班‘.原句也可以改为：I got Sunday off.下班：get off work. 补充（1）请假用take off即可：Sir, can I take this Friday off?先生，这周五我可以请假吗？；I took 3 day off last week.我上周请了3天假；生病不用上班叫做off on sick leave；（2）off还可以表示‘走，离开’：I’m off, guys.（各位，我先走了）；Off to Macao later.（等会儿去澳门）；（3）off也可以表示‘取消了’：The wedding’s off.婚礼取消了！ She got the message.她有数了。 讲解get the message字面意思表示：收到消息，引申为：‘懂你意思了’。例句：I got the message when you said you were not feeling well.你说你身体不舒服的时候我就懂你意思了。类似表达有get the idea。 补充口语中‘我懂你意思了’的表达还有：I see what you’re saying；I gotcha；I totally feel you；I see what you’re getting at. What’s with the sad face?你干嘛一脸伤心的样子？ 讲解what’s with the…表示：干嘛…一般觉得好奇不理解时用。例句：What’s with the car?你干嘛开车过来？；What’s with the red t-shirt?你干嘛穿件红体恤？；What’s with the long face?你干嘛拉着个脸？ 补充口语中表示好奇的常见句子还有：What’s the occasion?有什么重要的场合要参加吗？；What brings you here?什么风把你吹来了？；What’re you doing here?你在这干嘛？；What the hell?什么情况？（搞什么？） I wouldn’t say so.我不是很同意你说的话。 讲解完整句为I wouldn’t say so (if I were you).字面意思就是：如果我是你的话我不会这样说的，引申为：我不赞成你说的话。口语中If I were you（如果我是你）经常省略.I wouldn’t经常用来表示委婉的否认别人。例句：A: It’s a beautiful day today.（今天天气真美）；B: I wouldn’t call it beautiful.（我不认为今天算美） 补充口语中经常不赞同别人说的话的表达还有：I don’t think so.我不这么认为；I’m afraid I have to disagree.恐怕我不能赞成你说的了；I can’t say the same.我有不同观点 I kind of miss you.我有点想你了。 讲解关键短语kind of表示：有点儿。例句：I’m kind of hungry.我有点儿饿了。Kind of在口语中经常缩读成kinda；与kind of意思用法一模一样的是sort of，可缩读成sorta.例句：I sorta wanna go out.我有点想出去玩。 补充（1）口语中表示‘一点点’的短语还有：a little/a bit/a little bit/a tad.例句：I’m a bit tired.我有点累了；（2）kind of与sort of还经常表示委婉的语气，如不敢或者不想告诉对方但又必须说时可以用，例句：I kind of kissed your girlfriend last night.我昨晚亲了你女朋友（不敢告诉你，但又必须得说，不能理解成‘我有点亲了你女朋友’）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 69 - Sqrt(x)]]></title>
      <url>%2F2018%2F01%2F23%2FLeetCode-Problem-69-Sqrt-x%2F</url>
      <content type="text"><![CDATA[Implement int sqrt(int x). Compute and return the square root of x. x is guaranteed to be a non-negative integer. ExampleNo.1Input: 4Output: 2 No.2Input: 8Output: 2Explanation: The square root of 8 is 2.82842…, and since we want to return an integer, the decimal part will be truncated. Code1234567891011121314151617181920public int mySqrt(int x) &#123; if (x == 0) return 0; int start = 1; int end = x; while (true) &#123; int mid = start + (end - start) / 2; if (mid &gt; x / mid) end = mid - 1; else &#123; if ((mid + 1) &gt; x / (mid + 1)) return mid; start = mid + 1; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 88 - Merge Sorted Array]]></title>
      <url>%2F2018%2F01%2F23%2FLeetCode-Problem-88-Merge-Sorted-Array%2F</url>
      <content type="text"><![CDATA[Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. NoteYou may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. Code123456789101112131415public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int pos = m + n - 1; int i = m - 1; int j = n - 1; while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; if (nums1[i] &lt; nums2[j]) nums1[pos--] = nums2[j--]; else nums1[pos--] = nums1[i--]; &#125; while (j &gt;= 0) nums1[pos--] = nums2[j--];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 27 - Remove Element]]></title>
      <url>%2F2018%2F01%2F16%2FLeetCode-Problem-27-Remove-Element%2F</url>
      <content type="text"><![CDATA[Given an array and a value, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. ExampleGiven nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. Code12345678910111213public int removeElement(int[] nums, int val) &#123; if (nums == null || nums.length &lt; 1) return 0; int length = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != val) nums[length++] = nums[i]; &#125; return length;&#125; When elements to remove are rare12345678910111213141516public int removeElement(int[] nums, int val) &#123; if (nums == null || nums.length &lt; 1) return 0; int start = 0; int end = nums.length - 1; while (start &lt;= end) &#123; if (nums[start] == val) nums[start] = nums[end--]; else start++; &#125; return end + 1;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 26 - Remove Duplicates from Sorted Array]]></title>
      <url>%2F2018%2F01%2F16%2FLeetCode-Problem-26-Remove-Duplicates-from-Sorted-Array%2F</url>
      <content type="text"><![CDATA[Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. ExampleGiven nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn’t matter what you leave beyond the new length. Code12345678910111213public int removeDuplicates(int[] nums) &#123; if (nums == null || nums.length &lt; 1) return 0; int length = 0; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] != nums[length]) nums[++length] = nums[i]; &#125; return length + 1;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Urllib Demo]]></title>
      <url>%2F2017%2F12%2F29%2FUrllib-Demo%2F</url>
      <content type="text"><![CDATA[使用Urllib爬取网页将爬取到的网页以网页的形式保存在本地1234567891011121314import urllib.request# 爬取百度首页file = urllib.request.urlopen("http://www.baidu.com")# 将对应的网页内容读取出来data = file.read()#print(data)# 以二进制写入的方式打开文件fhandle = open("/Users/matianyao/Desktop/crawler.html", "wb")# 写入对应的数据fhandle.write(data)# 关闭文件fhandle.close() 直接将对应信息写入本地文件123456import urllib.request# 直接将网页写入本地文件filename = urllib.request.urlretrieve("http://edu.51cto.com", filename="/Users/matianyao/Desktop/crawler.html")# 清除urlretrieve执行所造成的缓存urllib.request.urlcleanup() 其它常见用法12345678910# 返回与当前环境有关的信息file.info()# 获取当前爬取网页的状态码file.getcode()# 获取当前所爬取的url地址file.geturl()# 对网址进行编码urllib.request.quote("http://www.sina.com.cn")# 对编码的网址进行解码urllib.request.unquote("http%3A//www.sina.com.cn") 浏览器的模拟——Headers属性有时候，无法爬取一些网页，会出现403错误，因为这些网页为了防止别人恶意采集其信息所以进行了一些反爬虫的设置。可以设置一些Headers信息，模拟成浏览器去访问这些网站。 使用build_opener()修改报头1234567891011import urllib.requesturl = "http://worldagnetwork.com/"headers = ("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/604.4.7 (KHTML, like Gecko) Version/11.0.2 Safari/604.4.7")# 创建自定义的opener对象opener = urllib.request.build_opener()# 设置对应的头信息opener.addheaders = [headers]# 打开对应的网址，再读取对应数据data = opener.open(url).read() 使用add_header()添加报头12345678910import urllib.requesturl = "http://worldagnetwork.com/"# 创建一个Request对象req = urllib.request.Request(url)# 添加对应的报头信息req.add_header("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/604.4.7 (KHTML, like Gecko) Version/11.0.2 Safari/604.4.7")# 打开对应网址并读取了网页内容data = urllib.request.urlopen(req).read() 超时设置有时候，访问一个网页，如果该网页长时间未响应，那么系统就会判断该网页超时了，即无法打开该网页。 12345678910import urllib.requestfor i in range (1, 30): try: # 在爬取的时候设置超时异常的值 file = urllib.request.urlopen("http://yum.iqianyue.com", timeout=0.1) data = file.read() print(len(data)) except Exception as e: print("ERROR--&gt;" + str(e)) HTTP协议请求实战GET请求实例分析 构建对应的url地址，该url地址包含GET请求的字段名和字段内容等信息，并且url地址满足GET请求的格式，即“http://网址?字段名1=字段内容1&amp;字段名2=字段内容2” 以对应的url为参数，构建Request对象 通过urlopen()打开构建的Request对象 按需求进行后续的处理操作，比如读取网页的内容、将内容写入文件等 123456789101112import urllib.requestkey = "哈哈"url = "http://www.baidu.com/s?wd="key_code = urllib.request.quote(key)url_all = url + key_codereq = urllib.request.Request(url_all)data = urllib.request.urlopen(req).read()fhandle = open("/Users/matianyao/Desktop/crawler.html", "wb")fhandle.write(data)fhandle.close() POST请求实例分析 设置好url网址 构建表单数据，并使用urllib.parse.urlencode对数据进行编码处理 创建Request对象，参数包括url地址和要传递的数据 使用add_header()添加头信息，模拟浏览器进行爬取 使用urllib.request.urlopen()打开对应的Request对象，完成信息的传递 后续处理，比如读取网页内容、将内容写入文件等 123456789101112131415import urllib.requestimport urllib.parseurl = "http://www.iqianyue.com/mypost/"postdata = urllib.parse.urlencode(&#123; "name": "ceo@iqianyue.com", "pass": "aA123456"&#125;).encode("utf-8")req = urllib.request.Request(url, postdata)req.add_header("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/604.4.7 (KHTML, like Gecko) Version/11.0.2 Safari/604.4.7")data = urllib.request.urlopen(req).read()fhandle = open("/Users/matianyao/Desktop/crawler.html", "wb")fhandle.write(data)fhandle.close() 代理服务器的设置有时使用同一个IP去爬取同一个网站上的网页，久了之后会被该网站服务器屏蔽。 1234567891011121314151617import urllib.request# 使用代理服务器来爬取某个url网页def use_proxy(proxy_addr, url): # 设置对应的代理服务器信息 proxy = urllib.request.ProxyHandler(&#123;"http": proxy_addr&#125;) # 创建一个自定义的opener对象 opener = urllib.request.build_opener(proxy, urllib.request.HTTPHandler) # 创建全局默认的opener对象 urllib.request.install_opener(opener) # 打开对应网址爬取网页并读取 data = urllib.request.urlopen(url).read().decode("utf-8") return dataproxy_addr = "61.135.217.7:80"data = use_proxy(proxy_addr, "http://www.baidu.com")print(len(data)) 异常处理神器——URLError实战一般来说，产生URLError的原因有如下几种可能：1） 连接不上服务器2） 远程url不存在3） 无网络4） 触发了HTTPError HTTPError12345678import urllib.requestimport urllib.errortry: urllib.request.urlopen("http://worldagnetwork.com/")except urllib.error.HTTPError as e: print(e.code) print(e.reason) URLError1234567import urllib.requestimport urllib.errortry: urllib.request.urlopen("http://www.baidusss.net/")except urllib.error.URLError as e: print(e.reason) 整合改进12345678910import urllib.requestimport urllib.errortry: urllib.request.urlopen("http://www.baidusss.com/")except urllib.error.URLError as e: if hasattr(e, "code"): print(e.code) if hasattr(e, "reason"): print(e.reason)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 264 - Ugly Number II]]></title>
      <url>%2F2017%2F10%2F31%2FLeetCode-Problem-264-Ugly-Number-II%2F</url>
      <content type="text"><![CDATA[Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note1 is typically treated as an ugly number, and n does not exceed 1690. Code1234567891011121314151617181920212223public int nthUglyNumber(int n) &#123; int[] ugly = new int[n]; int t2 = 0; int t3 = 0; int t5 = 0; ugly[0] = 1; for (int i = 1; i &lt; n; i++) &#123; ugly[i] = Math.min(2 * ugly[t2], Math.min(3 * ugly[t3], 5 * ugly[t5])); if (ugly[i] == 2 * ugly[t2]) t2++; if (ugly[i] == 3 * ugly[t3]) t3++; if (ugly[i] == 5 * ugly[t5]) t5++; &#125; return ugly[n-1];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 263 - Ugly Number]]></title>
      <url>%2F2017%2F10%2F31%2FLeetCode-Problem-263-Ugly-Number%2F</url>
      <content type="text"><![CDATA[Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note1 is typically treated as an ugly number. Code123456789101112131415161718public boolean isUgly(int num) &#123; if (num &lt;= 0) return false; if (num == 1) return true; while (num % 2 == 0) num /= 2; while (num % 3 == 0) num /= 3; while (num % 5 == 0) num /= 5; return num == 1;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 202 - Happy Number]]></title>
      <url>%2F2017%2F10%2F31%2FLeetCode-Problem-202-Happy-Number%2F</url>
      <content type="text"><![CDATA[Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example19 is a happy number 1^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1 Code123456789101112131415161718192021222324public boolean isHappy(int n) &#123; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); while (n != 1) &#123; if (set.contains(n)) return false; set.add(n); n = sum(n); &#125; return true;&#125;private int sum(int n) &#123; int sum = 0; while (n != 0) &#123; sum += Math.pow(n % 10, 2); n /= 10; &#125; return sum;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 82 - Remove Duplicates from Sorted List II]]></title>
      <url>%2F2017%2F10%2F12%2FLeetCode-Problem-82-Remove-Duplicates-from-Sorted-List-II%2F</url>
      <content type="text"><![CDATA[Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. ExampleGiven 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. Code12345public class ListNode &#123; int val; ListNode next = null; ListNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516171819202122public ListNode deleteDuplicates(ListNode head) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode prev = dummy; ListNode current = head; while (current != null &amp;&amp; current.next != null) &#123; if (current.val == current.next.val) &#123; while (current.next != null &amp;&amp; current.next.val == prev.next.val) current = current.next; current = current.next; prev.next = current; &#125; else &#123; prev = current; current = current.next; &#125; &#125; return dummy.next;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 83 - Remove Duplicates from Sorted List]]></title>
      <url>%2F2017%2F10%2F12%2FLeetCode-Problem-83-Remove-Duplicates-from-Sorted-List%2F</url>
      <content type="text"><![CDATA[Given a sorted linked list, delete all duplicates such that each element appear only once. ExampleGiven 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. Code12345public class ListNode &#123; int val; ListNode next = null; ListNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) return null; ListNode current = head; while (current.next != null) &#123; if (current.val == current.next.val) current.next = current.next.next; else current = current.next; &#125; return head;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 61 - Rotate List]]></title>
      <url>%2F2017%2F10%2F12%2FLeetCode-Problem-61-Rotate-List%2F</url>
      <content type="text"><![CDATA[Given a list, rotate the list to the right by k places, where k is non-negative. ExampleGiven 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL. Code12345public class ListNode &#123; int val; ListNode next = null; ListNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637public ListNode rotateRight(ListNode head, int k) &#123; if (head == null) return null; ListNode dummy = new ListNode(0); dummy.next = head; ListNode slow = dummy; ListNode fast = dummy; int length = getLength(head); k %= length; for (int i = 0; i &lt; k; i++) fast = fast.next; while (fast.next != null) &#123; fast = fast.next; slow = slow.next; &#125; fast.next = head; dummy.next = slow.next; slow.next = null; return dummy.next;&#125;private int getLength(ListNode head) &#123; int count = 0; while (head != null) &#123; head = head.next; count++; &#125; return count;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 19 - Remove Nth Node From End of List]]></title>
      <url>%2F2017%2F10%2F12%2FLeetCode-Problem-19-Remove-Nth-Node-From-End-of-List%2F</url>
      <content type="text"><![CDATA[Given a linked list, remove the nth node from the end of list and return its head. ExampleGiven linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. NoteGiven n will always be valid.Try to do this in one pass. Code12345public class ListNode &#123; int val; ListNode next = null; ListNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode slow = dummy; ListNode fast = dummy; for (int i = 0; i &lt; n; i++) fast = fast.next; while (fast.next != null) &#123; fast = fast.next; slow = slow.next; &#125; slow.next = slow.next.next; return dummy.next;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 213 - House Robber II]]></title>
      <url>%2F2017%2F09%2F27%2FLeetCode-Problem-213-House-Robber-II%2F</url>
      <content type="text"><![CDATA[After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. NoteThis is an extension of House Robber. Code123456789101112131415161718192021public int rob(int[] nums) &#123; if (nums == null || nums.length &lt; 1) return 0; else if (nums.length == 1) return nums[0]; else if (nums.length == 2) return Math.max(nums[0], nums[1]); return Math.max(robHelper(nums, 0, nums.length - 2), robHelper(nums, 1, nums.length - 1));&#125;private int robHelper(int[] nums, int start, int end) &#123; int[] dp = new int[2]; dp[start%2] = nums[start]; dp[(start+1)%2] = Math.max(nums[start], nums[start+1]); for (int i = start + 2; i &lt;= end; i++) dp[i%2] = Math.max(dp[(i-1)%2], dp[(i-2)%2] + nums[i]); return dp[end%2];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 198 - House Robber]]></title>
      <url>%2F2017%2F09%2F27%2FLeetCode-Problem-198-House-Robber%2F</url>
      <content type="text"><![CDATA[You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Code123456789101112public int rob(int[] nums) &#123; if (nums == null || nums.length &lt; 1) return 0; int[] dp = new int[nums.length+1]; dp[1] = nums[0]; for (int i = 2; i &lt;= nums.length; i++) dp[i] = Math.max(dp[i-1], nums[i-1] + dp[i-2]); return dp[nums.length];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 154 - Find Minimum in Rotated Sorted Array II]]></title>
      <url>%2F2017%2F09%2F26%2FLeetCode-Problem-154-Find-Minimum-in-Rotated-Sorted-Array-II%2F</url>
      <content type="text"><![CDATA[Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. The array may contain duplicates. Code1234567891011121314151617public int findMin(int[] nums) &#123; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int middle = (left + right) &gt;&gt; 1; if (nums[middle] &gt; nums[right]) left = middle + 1; else if (nums[middle] &lt; nums[left]) right = middle; else right--; &#125; return nums[left];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 153 - Find Minimum in Rotated Sorted Array]]></title>
      <url>%2F2017%2F09%2F26%2FLeetCode-Problem-153-Find-Minimum-in-Rotated-Sorted-Array%2F</url>
      <content type="text"><![CDATA[Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. You may assume no duplicate exists in the array. Code123456789101112131415public int findMin(int[] nums) &#123; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int middle = (left + right) &gt;&gt; 1; if (nums[middle] &gt; nums[right]) left = middle + 1; else right = middle; &#125; return nums[left];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 35 - Search Insert Position]]></title>
      <url>%2F2017%2F09%2F26%2FLeetCode-Problem-35-Search-Insert-Position%2F</url>
      <content type="text"><![CDATA[Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0 Code1234567891011121314151617public int searchInsert(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int middle = (left + right) &gt;&gt; 1; if (nums[middle] &gt; target) right = middle - 1; else if (nums[middle] &lt; target) left = middle + 1; else return middle; &#125; return left;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 152 - Maximum Product Subarray]]></title>
      <url>%2F2017%2F09%2F26%2FLeetCode-Problem-152-Maximum-Product-Subarray%2F</url>
      <content type="text"><![CDATA[Find the contiguous subarray within an array (containing at least one number) which has the largest product. Examplegiven the array [2,3,-2,4],the contiguous subarray [2,3] has the largest product = 6. Code12345678910111213141516public int maxProduct(int[] nums) &#123; int[][] dp = new int[nums.length][2]; int max = nums[0]; dp[0][0] = dp[0][1] = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; int localMin = dp[i-1][1] * nums[i]; int localMax = dp[i-1][0] * nums[i]; dp[i][0] = Math.max(nums[i], Math.max(localMax, localMin)); dp[i][1] = Math.min(nums[i], Math.min(localMax, localMin)); max = Math.max(max, dp[i][0]); &#125; return max;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 53 - Maximum Subarray]]></title>
      <url>%2F2017%2F09%2F25%2FLeetCode-Problem-53-Maximum-Subarray%2F</url>
      <content type="text"><![CDATA[Find the contiguous subarray within an array (containing at least one number) which has the largest sum. Examplegiven the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. O(nlogn) runtime, O(logn) stack space – Divide and Conquer123456789101112131415161718192021222324252627282930313233public int maxSubArray(int[] nums) &#123; return subArrayHelper(nums, 0, nums.length - 1);&#125;private int subArrayHelper(int[] nums, int left, int right)&#123; if (left &gt; right) return Integer.MIN_VALUE; int middle = (left + right) &gt;&gt; 1; int leftSum = subArrayHelper(nums, left, middle - 1); int rightSum = subArrayHelper(nums, middle + 1, right); int sum = 0; int sumFromLeft = 0; for (int i = middle - 1; i &gt;= left; i--)&#123; sum += nums[i]; sumFromLeft = Math.max(sumFromLeft, sum); &#125; sum = 0; int sumFromRight = 0; for (int i = middle + 1; i &lt;= right; i++)&#123; sum += nums[i]; sumFromRight = Math.max(sumFromRight, sum); &#125; int middleSum = sumFromLeft + sumFromRight + nums[middle]; return Math.max(middleSum, Math.max(leftSum, rightSum));&#125; O(n) runtime, O(1) space – Dynamic programming1234567891011public int maxSubArray(int[] nums) &#123; int[] dp = new int[nums.length+1]; int max = Integer.MIN_VALUE; for (int i = 1; i &lt;= nums.length; i++) &#123; dp[i] = Math.max(nums[i-1], dp[i-1] + nums[i-1]); max = Math.max(max, dp[i]); &#125; return max;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 63 - Unique Paths II]]></title>
      <url>%2F2017%2F09%2F25%2FLeetCode-Problem-63-Unique-Paths-II%2F</url>
      <content type="text"><![CDATA[Follow up for “Unique Paths”: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. ExampleThere is one obstacle in the middle of a 3x3 grid as illustrated below. [0,0,0],[0,1,0],[0,0,0] The total number of unique paths is 2. Notem and n will be at most 100. Code123456789101112131415161718192021// O(mn) runtime, O(mn) space – Dynamic programmingpublic int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; dp[0][0] = obstacleGrid[0][0] ^ 1; for (int i = 1; i &lt; n; i++) dp[0][i] = obstacleGrid[0][i] == 1 ? 0 : dp[0][i-1]; for (int i = 1; i &lt; m; i++) dp[i][0] = obstacleGrid[i][0] == 1 ? 0 : dp[i-1][0]; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i-1][j] + dp[i][j-1]; &#125; return dp[m-1][n-1];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 62 - Unique Paths]]></title>
      <url>%2F2017%2F09%2F25%2FLeetCode-Problem-62-Unique-Paths%2F</url>
      <content type="text"><![CDATA[A robot is located at the top-left corner of a m x n grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. How many possible unique paths are there? Notem and n will be at most 100. Code123456789101112131415// O(mn) runtime, O(mn) space – Bottom-up dynamic programmingpublic int uniquePaths(int m, int n) &#123; int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == 0 || j == 0) dp[i][j] = 1; else dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 70 - Climbing Stairs]]></title>
      <url>%2F2017%2F09%2F25%2FLeetCode-Problem-70-Climbing-Stairs%2F</url>
      <content type="text"><![CDATA[You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? NoteGiven n will be a positive integer. Code1234567891011121314// O(n) runtime, O(1) space – Dynamic programmingpublic int climbStairs(int n) &#123; int[] dp = new int[2]; dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;=n; i++) &#123; int current = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = current; &#125; return dp[1];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 150 - Evaluate Reverse Polish Notation]]></title>
      <url>%2F2017%2F09%2F19%2FLeetCode-Problem-150-Evaluate-Reverse-Polish-Notation%2F</url>
      <content type="text"><![CDATA[Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Example[“2”, “1”, “+”, “3”, ““] -&gt; ((2 + 1) 3) -&gt; 9[“4”, “13”, “5”, “/“, “+”] -&gt; (4 + (13 / 5)) -&gt; 6 Code123456789101112131415161718192021222324252627282930313233343536373839public int evalRPN(String[] tokens) &#123; if (tokens == null || tokens.length &lt; 1) return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Set&lt;String&gt; operation = new HashSet&lt;String&gt;()&#123;&#123; add("+"); add("-"); add("*"); add("/"); &#125;&#125;; for (String token : tokens) &#123; if (!operation.contains(token)) &#123; stack.push(Integer.valueOf(token)); continue; &#125; int b = stack.pop(); int a = stack.pop(); switch (token) &#123; case "+" : stack.push(a + b); continue; case "-" : stack.push(a - b); continue; case "*" : stack.push(a * b); continue; case "/" : stack.push(a / b); continue; &#125; &#125; return stack.peek();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 20 - Valid Parentheses]]></title>
      <url>%2F2017%2F09%2F18%2FLeetCode-Problem-20-Valid-Parentheses%2F</url>
      <content type="text"><![CDATA[Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not. Code123456789101112131415161718public boolean isValid(String s) &#123; Map&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;()&#123;&#123; put('(', ')'); put('[', ']'); put('&#123;', '&#125;'); &#125;&#125;; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (Character ch : s.toCharArray()) &#123; if (map.containsKey(ch)) stack.push(ch); else if (stack.isEmpty() || map.get(stack.pop()) != ch) return false; &#125; return stack.isEmpty();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 155 - Min Stack]]></title>
      <url>%2F2017%2F09%2F18%2FLeetCode-Problem-155-Min-Stack%2F</url>
      <content type="text"><![CDATA[Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. ExampleMinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; Returns -3.minStack.pop();minStack.top(); –&gt; Returns 0.minStack.getMin(); –&gt; Returns -2. Code123456789101112131415161718192021222324252627282930313233// O(n) runtime, O(n) space – Minor space optimizationclass MinStack &#123; private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; min; public MinStack() &#123; stack = new Stack&lt;&gt;(); min = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; stack.push(x); if (min.isEmpty() || x &lt;= min.peek()) min.push(x); &#125; public void pop() &#123; int x = stack.pop(); if (x == min.peek()) min.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return min.peek(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 133 - Clone Graph]]></title>
      <url>%2F2017%2F09%2F18%2FLeetCode-Problem-133-Clone-Graph%2F</url>
      <content type="text"><![CDATA[Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors. Undirected graph serializationNodes are labeled uniquely. We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.As an example, consider the serialized graph {0,1,2#1,2#2,2}. The graph has a total of three nodes, and therefore contains three parts as separated by #. First node is labeled as 0. Connect node 0 to both nodes 1 and 2. Second node is labeled as 1. Connect node 1 to node 2. Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle. O(n) runtime, O(n) space – Depth-first traversal12345public class UndirectedGraphNode &#123; int label; List&lt;UndirectedGraphNode&gt; neighbors; UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125;&#125; 123456789101112131415161718192021public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123; if (node == null) return null; Map&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = new HashMap&lt;&gt;(); return dfs(map, node);&#125;private UndirectedGraphNode dfs(Map&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map, UndirectedGraphNode node) &#123; UndirectedGraphNode copy = new UndirectedGraphNode(node.label); map.put(node, copy); for (UndirectedGraphNode neighbor : node.neighbors) &#123; if (!map.containsKey(neighbor)) copy.neighbors.add(dfs(map, neighbor)); else copy.neighbors.add(map.get(neighbor)); &#125; return copy;&#125; O(n) runtime, O(n) space – Breadth-first traversal12345public class UndirectedGraphNode &#123; int label; List&lt;UndirectedGraphNode&gt; neighbors; UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125;&#125; 1234567891011121314151617181920212223242526272829public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123; if (node == null) return null; Map&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = new HashMap&lt;&gt;(); return bfs(map, node);&#125;private UndirectedGraphNode bfs(Map&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map, UndirectedGraphNode node) &#123; Queue&lt;UndirectedGraphNode&gt; queue = new LinkedList&lt;&gt;(); UndirectedGraphNode copy = new UndirectedGraphNode(node.label); map.put(node, copy); queue.offer(node); while (!queue.isEmpty()) &#123; UndirectedGraphNode current = queue.poll(); for (UndirectedGraphNode neighbor : current.neighbors) &#123; if (!map.containsKey(neighbor)) &#123; queue.offer(neighbor); map.put(neighbor, new UndirectedGraphNode(neighbor.label)); &#125; map.get(current).neighbors.add(map.get(neighbor)); &#125; &#125; return copy;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 13 - Roman to Integer]]></title>
      <url>%2F2017%2F09%2F18%2FLeetCode-Problem-13-Roman-to-Integer%2F</url>
      <content type="text"><![CDATA[Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Code12345678910111213141516171819202122public int romanToInt(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;()&#123;&#123; put('I', 1); put('V', 5); put('X', 10); put('L', 50); put('C', 100); put('D', 500); put('M', 1000); &#125;&#125;; int num = 0; int prev = 0; for (Character ch : s.toCharArray()) &#123; int current = map.get(ch); num += current &lt;= prev ? current : current - 2 * prev; prev = current; &#125; return num;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 12 - Integer to Roman]]></title>
      <url>%2F2017%2F09%2F18%2FLeetCode-Problem-12-Integer-to-Roman%2F</url>
      <content type="text"><![CDATA[Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Code1234567891011121314public String intToRoman(int num) &#123; StringBuilder sb = new StringBuilder(); int[] key = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;; String[] val = &#123;"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"&#125;; for (int i = 0; i &lt; key.length; i++) &#123; while (num &gt;= key[i]) &#123; sb.append(val[i]); num -= key[i]; &#125; &#125; return sb.toString();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 54 - Spiral Matrix]]></title>
      <url>%2F2017%2F09%2F17%2FLeetCode-Problem-54-Spiral-Matrix%2F</url>
      <content type="text"><![CDATA[Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. ExampleGiven the following matrix: [ 1, 2, 3 ][ 4, 5, 6 ][ 7, 8, 9 ] You should return [1,2,3,6,9,8,7,4,5]. Code12345678910111213141516171819202122232425262728293031323334353637383940public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (matrix == null || matrix.length == 0) return result; int m = matrix.length; int n = matrix[0].length; int start = 0; while (2 * start &lt; m &amp;&amp; 2 * start &lt; n) &#123; spiralOrderHelper(result, matrix, m, n, start); start++; &#125; return result;&#125;private void spiralOrderHelper(List&lt;Integer&gt; result, int[][] matrix, int m, int n, int start) &#123; int endX = n - 1 - start; int endY = m - 1 - start; for (int i = start; i &lt;= endX; i++) result.add(matrix[start][i]); if (endY &gt; start) &#123; for (int i = start + 1; i &lt;= endY; i++) result.add(matrix[i][endX]); &#125; if (endY &gt; start &amp;&amp; endX &gt; start) &#123; for (int i = endX - 1; i &gt;= start; i--) result.add(matrix[endY][i]); &#125; if (endY &gt; start + 1 &amp;&amp; endX &gt; start) &#123; for (int i = endY - 1; i &gt; start; i--) result.add(matrix[i][start]); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 137 - Single Number II]]></title>
      <url>%2F2017%2F09%2F16%2FLeetCode-Problem-137-Single-Number-II%2F</url>
      <content type="text"><![CDATA[Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one. NoteYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Code12345678910111213141516public int singleNumber(int[] nums) &#123; int num = 0; for (int i = 0; i &lt; 32; i++) &#123; int sum = 0; for (int j = 0; j &lt; nums.length; j++) &#123; if (((nums[j] &gt;&gt; i) &amp; 1) == 1) sum++; &#125; num |= (sum % 3) &lt;&lt; i; &#125; return num;&#125; Improvement A new number appears - It gets XOR’d to the variable “ones”. A number gets repeated(appears twice) - It is removed from “ones” and XOR’d to the variable “twos”. A number appears for the third time - It gets removed from both “ones” and “twos”. 123456789101112131415public int singleNumber(int[] nums) &#123; int once = 0; int twice = 0; int common; for (int i = 0; i &lt; nums.length; i++) &#123; twice |= once &amp; nums[i]; once ^= nums[i]; common = ~(once &amp; twice); once &amp;= common; twice &amp;= common; &#125; return once;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 136 - Single Number]]></title>
      <url>%2F2017%2F09%2F16%2FLeetCode-Problem-136-Single-Number%2F</url>
      <content type="text"><![CDATA[Given an array of integers, every element appears twice except for one. Find that single one. NoteYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Code12345678public int singleNumber(int[] nums) &#123; int num = 0; for (int n : nums) num ^= n; return num;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 124 - Binary Tree Maximum Path Sum]]></title>
      <url>%2F2017%2F09%2F16%2FLeetCode-Problem-124-Binary-Tree-Maximum-Path-Sum%2F</url>
      <content type="text"><![CDATA[Given a binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. ExampleGiven the binary tree [2, 1, 3]Return 6. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617private int max = Integer.MIN_VALUE;public int maxPathSum(TreeNode root) &#123; maxPathSumHelper(root); return max;&#125;private int maxPathSumHelper(TreeNode root) &#123; if (root == null) return 0; int left = Math.max(maxPathSumHelper(root.left), 0); int right = Math.max(maxPathSumHelper(root.right), 0); max = Math.max(max, root.val + left + right); return Math.max(left, right) + root.val;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 109 - Convert Sorted List to Binary Search Tree]]></title>
      <url>%2F2017%2F09%2F15%2FLeetCode-Problem-109-Convert-Sorted-List-to-Binary-Search-Tree%2F</url>
      <content type="text"><![CDATA[Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. Code123456789101112public class ListNode &#123; int val; ListNode next = null; ListNode(int x) &#123; val = x; &#125;&#125;public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324252627282930313233// O(n) runtime, O(logn) stack space – Bottom-up recursionprivate ListNode current;public TreeNode sortedListToBST(ListNode head) &#123; ListNode node = head; current = head; int length = 0; while (node != null) &#123; length++; node = node.next; &#125; return sortedListToBSTHelper(0, length - 1);&#125;private TreeNode sortedListToBSTHelper(int start, int end) &#123; if (start &gt; end) return null; int mid = (start + end) &gt;&gt; 1; TreeNode left = sortedListToBSTHelper(start, mid - 1); TreeNode parent = new TreeNode(current.val); parent.left = left; current = current.next; TreeNode right = sortedListToBSTHelper(mid + 1, end); parent.right = right; return parent;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 108 - Convert Sorted Array to Binary Search Tree]]></title>
      <url>%2F2017%2F09%2F15%2FLeetCode-Problem-108-Convert-Sorted-Array-to-Binary-Search-Tree%2F</url>
      <content type="text"><![CDATA[Given an array where elements are sorted in ascending order, convert it to a height balanced BST. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324// O(n) runtime, O(log n) stack spacepublic TreeNode sortedArrayToBST(int[] nums) &#123; if (nums == null || nums.length &lt; 1) return null; return sortedArrayToBSTHelper(nums, 0, nums.length - 1);&#125;private TreeNode sortedArrayToBSTHelper(int[] nums, int start, int end) &#123; if (start &gt; end) return null; if (start == end) return new TreeNode(nums[start]); int mid = (start + end) &gt;&gt; 1; TreeNode root = new TreeNode(nums[mid]); root.left = sortedArrayToBSTHelper(nums, start, mid - 1); root.right = sortedArrayToBSTHelper(nums, mid + 1, end); return root;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 110 - Balanced Binary Tree]]></title>
      <url>%2F2017%2F09%2F15%2FLeetCode-Problem-110-Balanced-Binary-Tree%2F</url>
      <content type="text"><![CDATA[Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021// O(n) runtime, O(n) stack space – Bottom-up recursionpublic boolean isBalanced(TreeNode root) &#123; return maxDepth(root) == -1 ? false : true;&#125;private int maxDepth(TreeNode root) &#123; if (root == null) return 0; int leftDepth = maxDepth(root.left); if (leftDepth == -1) return -1; int rightDepth = maxDepth(root.right); if (rightDepth == -1) return -1; return (Math.abs(leftDepth - rightDepth) &gt; 1) ? -1 : Math.max(leftDepth, rightDepth) + 1;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 111 - Minimum Depth of Binary Tree]]></title>
      <url>%2F2017%2F09%2F15%2FLeetCode-Problem-111-Minimum-Depth-of-Binary-Tree%2F</url>
      <content type="text"><![CDATA[Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. O(n) runtime, O(log n) space – Depth-first traversal123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112public int minDepth(TreeNode root) &#123; if (root == null) return 0; if (root.left == null) return minDepth(root.right) + 1; if (root.right == null) return minDepth(root.left) + 1; return Math.min(minDepth(root.right), minDepth(root.left)) + 1;&#125; O(n) runtime, O(n) space – Breadth-first traversal123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617181920212223242526272829public int minDepth(TreeNode root) &#123; if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); TreeNode levelEnd = root; int depth = 1; while (!queue.isEmpty()) &#123; TreeNode current = queue.poll(); if (current.left == null &amp;&amp; current.right == null) break; if (current.left != null) queue.offer(current.left); if (current.right != null) queue.offer(current.right); if (current == levelEnd) &#123; levelEnd = current.right == null ? current.left : current.right; depth++; &#125; &#125; return depth;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 104 - Maximum Depth of Binary Tree]]></title>
      <url>%2F2017%2F09%2F15%2FLeetCode-Problem-104-Maximum-Depth-of-Binary-Tree%2F</url>
      <content type="text"><![CDATA[Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Code123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910// O(n) runtime, O(log n) space – Recursionpublic int maxDepth(TreeNode root) &#123; if (root == null) return 0; int leftDepth = maxDepth(root.left); int rightDepth = maxDepth(root.right); return Math.max(leftDepth, rightDepth) + 1;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 98 - Validate Binary Search Tree]]></title>
      <url>%2F2017%2F09%2F14%2FLeetCode-Problem-98-Validate-Binary-Search-Tree%2F</url>
      <content type="text"><![CDATA[Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than the node’s key.Both the left and right subtrees must also be binary search trees. ExampleNo.1Binary tree [2,1,3], return true. No.2Binary tree [1,2,3], return false. O(n) runtime, O(n) stack space – Top-down recursion123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345678910111213public boolean isValidBST(TreeNode root) &#123; return isValidBSTHelper(root, Long.MIN_VALUE, Long.MAX_VALUE);&#125;private boolean isValidBSTHelper(TreeNode root, long low, long high) &#123; if (root == null) return true; if (root.val &lt;= low || root.val &gt;= high) return false; return isValidBSTHelper(root.left, low, root.val) &amp;&amp; isValidBSTHelper(root.right, root.val, high);&#125; O(n) runtime, O(n) stack space – In-order traversal123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415private TreeNode prev = null;public boolean isValidBST(TreeNode root) &#123; if (root == null) return true; if (isValidBST(root.left)) &#123; if (prev == null || root.val &gt; prev.val) &#123; prev = root; return isValidBST(root.right); &#125; &#125; return false;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 138 - Copy List with Random Pointer]]></title>
      <url>%2F2017%2F09%2F14%2FLeetCode-Problem-138-Copy-List-with-Random-Pointer%2F</url>
      <content type="text"><![CDATA[A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. Code12345public class RandomListNode &#123; int label; RandomListNode next, random; RandomListNode(int x) &#123; this.label = x; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738// O(n) runtime, O(1) space – Modify original structurepublic RandomListNode copyRandomList(RandomListNode head) &#123; RandomListNode current = head; RandomListNode copyHead = null, copyCurrent = null; while (current != null) &#123; RandomListNode copy = new RandomListNode(current.label); copy.next = current.next; current.next = copy; current = copy.next; &#125; current = head; while (current != null) &#123; if (current.random != null) current.next.random = current.random.next; current = current.next.next; &#125; current = head; if (current != null) &#123; copyHead = copyCurrent = current.next; current.next = current.next.next; current = copyCurrent.next; &#125; while (current != null) &#123; copyCurrent.next = current.next; current.next = current.next.next; copyCurrent = copyCurrent.next; current = current.next; &#125; return copyHead;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 23 - Merge K Sorted Linked Lists]]></title>
      <url>%2F2017%2F09%2F14%2FLeetCode-Problem-23-Merge-K-Sorted-Linked-Lists%2F</url>
      <content type="text"><![CDATA[Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. O(nklogk) runtime, O(k) space – Heap12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021222324public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length &lt; 1) return null; PriorityQueue&lt;ListNode&gt; minHeap = new PriorityQueue&lt;&gt;(lists.length, (o1, o2) -&gt; o1.val - o2.val); ListNode head = new ListNode(0); ListNode current = head; for (ListNode node : lists) &#123; if (node != null) minHeap.add(node); &#125; while (!minHeap.isEmpty()) &#123; current.next = minHeap.poll();; current = current.next; if (current.next != null) minHeap.offer(current.next); &#125; return head.next;&#125; O(nklogk) runtime, O(1) space – Divide and conquer using two way merge12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length &lt; 1) return null; return partition(lists, 0, lists.length - 1);&#125;private ListNode partition(ListNode[] lists, int start, int end) &#123; if (start == end) return lists[start]; int mid = (start + end) &gt;&gt; 1; ListNode left = partition(lists, start, mid); ListNode right = partition(lists, mid + 1, end); return mergeTwoLists(left, right);&#125;private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 24 - Swap Nodes in Pairs]]></title>
      <url>%2F2017%2F09%2F13%2FLeetCode-Problem-24-Swap-Nodes-in-Pairs%2F</url>
      <content type="text"><![CDATA[Given a linked list, swap every two adjacent nodes and return its head. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. ExampleGiven 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Code12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516public ListNode swapPairs(ListNode head) &#123; ListNode node = new ListNode(0); node.next = head; ListNode prev = node; while (prev.next != null &amp;&amp; prev.next.next != null) &#123; ListNode current = prev.next; ListNode next = prev.next.next; current.next = next.next; next.next = current; prev.next = next; prev = current; &#125; return node.next;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 2 - Add Two Numbers]]></title>
      <url>%2F2017%2F09%2F13%2FLeetCode-Problem-2-Add-Two-Numbers%2F</url>
      <content type="text"><![CDATA[You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. ExampleInput: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Code12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 1234567891011121314151617181920212223242526272829public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0); ListNode current1 = l1; ListNode current2 = l2; ListNode current = head; int carry = 0; while (current1 != null || current2 != null) &#123; int val1 = current1 == null ? 0 : current1.val; int val2 = current2 == null ? 0 : current2.val; int sum = val1 + val2 + carry; current.next = new ListNode(sum % 10); carry = sum / 10; current = current.next; if (current1 != null) current1 = current1.next; if (current2 != null) current2 = current2.next; &#125; if (carry &gt; 0) current.next = new ListNode(carry); return head.next;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 21 - Merge Two Sorted Lists]]></title>
      <url>%2F2017%2F09%2F13%2FLeetCode-Problem-21-Merge-Two-Sorted-Lists%2F</url>
      <content type="text"><![CDATA[Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Code12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 12345678910111213141516public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt;= l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 9 - Palindrome Number]]></title>
      <url>%2F2017%2F09%2F13%2FLeetCode-Problem-9-Palindrome-Number%2F</url>
      <content type="text"><![CDATA[Determine whether an integer is a palindrome. Do this without extra space. Some hintsCould negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. Code12345678910111213public boolean isPalindrome(int x) &#123; if (x &lt; 0 || (x != 0 &amp;&amp; x % 10 == 0)) return false; int reverseX = 0; while (x &gt; reverseX) &#123; reverseX = reverseX * 10 + x % 10; x /= 10; &#125; return x == reverseX || reverseX / 10 == x;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 66 - Plus One]]></title>
      <url>%2F2017%2F09%2F13%2FLeetCode-Problem-66-Plus-One%2F</url>
      <content type="text"><![CDATA[Given a non-negative integer represented as a non-empty array of digits, plus one to the integer. You may assume the integer do not contain any leading zero, except the number 0 itself. The digits are stored such that the most significant digit is at the head of the list. Code123456789101112131415public int[] plusOne(int[] digits) &#123; for (int i = digits.length - 1; i &gt;= 0; i--) &#123; if (digits[i] != 9) &#123; digits[i]++; return digits; &#125; else digits[i] = 0; &#125; int[] newDigit = new int[digits.length+1]; newDigit[0] = 1; return newDigit;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 7 - Reverse Integer]]></title>
      <url>%2F2017%2F09%2F13%2FLeetCode-Problem-7-Reverse-Integer%2F</url>
      <content type="text"><![CDATA[Reverse digits of an integer. ExampleExample1: x = 123, return 321Example2: x = -123, return -321 NoteThe input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. Have you thought about this?Here are some good questions to ask before coding. Bonus points for you if you have already thought through this! If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100. Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases? For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Code12345678910111213public int reverse(int x) &#123; int reverseX = 0; while (x != 0) &#123; if (Math.abs(reverseX) &gt; Integer.MAX_VALUE / 10) return 0; reverseX = reverseX * 10 + x % 10; x /= 10; &#125; return reverseX;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 5 - Longest Palindromic Substring]]></title>
      <url>%2F2017%2F09%2F12%2FLeetCode-Problem-5-Longest-Palindromic-Substring%2F</url>
      <content type="text"><![CDATA[Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. ExampleNo.1Input: “babad” Output: “bab” Note: “aba” is also a valid answer. No.2Input: “cbbd” Output: “bb” O(n^2) runtime, O(n) space – Dynamic programming1234567891011121314151617181920212223public String longestPalindrome(String s) &#123; String str = ""; int n = s.length(); if (n &gt; 1000) return str; boolean[][] dp = new boolean[n][n]; // P[i, i] ← true // P[i, i+1] ← (Si = Si+1) // P[i, j] ← (P[i+1, j-1] and Si = Sj) for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i; j &lt; n; j++) &#123; dp[i][j] = (s.charAt(i) == s.charAt(j)) &amp;&amp; (j - i + 1 &lt; 3 || dp[i+1][j-1]); if (dp[i][j] &amp;&amp; (j - i + 1) &gt; str.length()) str = s.substring(i, j + 1); &#125; &#125; return str;&#125; O(n^2) runtime, O(1) space – Simpler solution123456789101112131415161718192021222324252627public String longestPalindrome(String s) &#123; String str = ""; int n = s.length(); if (n &gt; 1000) return str; for (int i = 0; i &lt; n; i++) &#123; int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int max = Math.max(len1, len2); if (max &gt; str.length()) str = s.substring(i - (max - 1) / 2, i + 1 + max / 2); &#125; return str;&#125;private int expandAroundCenter(String s, int i, int j) &#123; while (i &gt;= 0 &amp;&amp; j &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(j)) &#123; i--; j++; &#125; return j - i - 1;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 3 - Longest Substring Without Repeating Characters]]></title>
      <url>%2F2017%2F09%2F12%2FLeetCode-Problem-3-Longest-Substring-Without-Repeating-Characters%2F</url>
      <content type="text"><![CDATA[Given a string, find the length of the longest substring without repeating characters. ExampleGiven “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. Code123456789101112131415161718// O(n) runtime, O(1) spacepublic int lengthOfLongestSubstring(String s) &#123; int[] ascii = new int[256]; int max = 0; int idx = 0; Arrays.fill(ascii, -1); for (int i = 0; i &lt; s.length(); i++) &#123; if (ascii[s.charAt(i)] &gt;= idx) idx = ascii[s.charAt(i)] + 1; ascii[s.charAt(i)] = i; max = Math.max(max, i - idx + 1); &#125; return max;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 65 - Valid Number]]></title>
      <url>%2F2017%2F09%2F12%2FLeetCode-Problem-65-Valid-Number%2F</url>
      <content type="text"><![CDATA[Validate if a given string is numeric. Example“0” =&gt; true“ 0.1 “ =&gt; true“abc” =&gt; false“1 a” =&gt; false“2e10” =&gt; true NoteIt is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. Code123456789101112131415161718192021222324252627282930313233343536373839404142public boolean isNumber(String s) &#123; boolean isNum = false; int i = 0; while (i &lt; s.length() &amp;&amp; Character.isWhitespace(s.charAt(i))) i++; if (i &lt; s.length() &amp;&amp; (s.charAt(i) == '+' || s.charAt(i) == '-')) i++; while (i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i))) &#123; isNum = true; i++; &#125; if (i &lt; s.length() &amp;&amp; s.charAt(i) == '.') &#123; i++; while (i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i))) &#123; isNum = true; i++; &#125; &#125; if (isNum &amp;&amp; i &lt; s.length() &amp;&amp; s.charAt(i) == 'e') &#123; isNum = false; i++; if (i &lt; s.length() &amp;&amp; (s.charAt(i) == '+' || s.charAt(i) == '-')) i++; while (i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i))) &#123; isNum = true; i++; &#125; &#125; while (i &lt; s.length() &amp;&amp; Character.isWhitespace(s.charAt(i))) i++; return isNum &amp;&amp; i == s.length();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 8 - String to Integer (atoi)]]></title>
      <url>%2F2017%2F09%2F12%2FLeetCode-Problem-8-String-to-Integer-atoi%2F</url>
      <content type="text"><![CDATA[Implement atoi to convert a string to an integer. HintCarefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. NotesIt is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Requirements for atoiThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. Code123456789101112131415161718192021222324252627public int myAtoi(String str) &#123; int flag = 1; int num = 0; int i = 0; while (i &lt; str.length() &amp;&amp; Character.isWhitespace(str.charAt(i))) i++; if (i &lt; str.length() &amp;&amp; str.charAt(i) == '-') &#123; flag = -1; i++; &#125; else if (i &lt; str.length() &amp;&amp; str.charAt(i) == '+') i++; while (i &lt; str.length() &amp;&amp; Character.isDigit(str.charAt(i))) &#123; int digit = Character.getNumericValue(str.charAt(i)); if (num &gt; Integer.MAX_VALUE / 10 || (num == 214748364 &amp;&amp; digit &gt; 7)) return flag == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; num = 10 * num + digit; i++; &#125; return flag * num;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 151 - Reverse Words in a String]]></title>
      <url>%2F2017%2F09%2F12%2FLeetCode-Problem-151-Reverse-Words-in-a-String%2F</url>
      <content type="text"><![CDATA[Given an input string, reverse the string word by word. ExampleGiven s = “the sky is blue”,return “blue is sky the”. Clarification What constitutes a word?A sequence of non-space characters constitutes a word. Could the input string contain leading or trailing spaces?Yes. However, your reversed string should not contain leading or trailing spaces. How about multiple spaces between two words?Reduce them to a single space in the reversed string. Code123456789101112131415161718// O(n) runtime, O(n) spacepublic String reverseWords(String s) &#123; StringBuilder sb = new StringBuilder(); int end = s.length(); for (int start = s.length() - 1; start &gt;= 0; start--) &#123; if (s.charAt(start) == ' ') end = start; else if (start == 0 || s.charAt(start - 1) == ' ') &#123; if (sb.length() != 0) sb.append(" "); sb.append(s.substring(start, end)); &#125; &#125; return sb.toString();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 28 - Implement strStr()]]></title>
      <url>%2F2017%2F09%2F12%2FLeetCode-Problem-28-Implement-strStr%2F</url>
      <content type="text"><![CDATA[Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Code1234567891011121314// O(nm) runtime, O(1) spacepublic int strStr(String haystack, String needle) &#123; for (int i = 0; i &lt;= haystack.length() - needle.length(); i++) &#123; for (int j = 0; ; j++) &#123; if (j == needle.length()) return i; if (needle.charAt(j) != haystack.charAt(i+j)) break; &#125; &#125; return -1;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 125 - Valid Palindrome]]></title>
      <url>%2F2017%2F09%2F12%2FLeetCode-Problem-125-Valid-Palindrome%2F</url>
      <content type="text"><![CDATA[Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Example“A man, a plan, a canal: Panama” is a palindrome.“race a car” is not a palindrome. NoteHave you consider that the string might be empty? This is a good question to ask during an interview. For the purpose of this problem, we define empty string as valid palindrome. Code123456789101112131415161718192021// O(n) runtime, O(1) spacepublic boolean isPalindrome(String s) &#123; int start = 0; int end = s.length() - 1; while (start &lt; end) &#123; while (start &lt; end &amp;&amp; !Character.isLetterOrDigit(s.charAt(start))) start++; while (start &lt; end &amp;&amp; !Character.isLetterOrDigit(s.charAt(end))) end--; if (Character.toLowerCase(s.charAt(start)) != Character.toLowerCase(s.charAt(end))) return false; start++; end--; &#125; return true;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 167 - Two Sum II - Input array is sorted]]></title>
      <url>%2F2017%2F09%2F11%2FLeetCode-Problem-167-Two-Sum-II-Input-array-is-sorted%2F</url>
      <content type="text"><![CDATA[Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. ExampleInput: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2 O(nlogn) runtime, O(1) space1234567891011121314151617181920212223242526public int[] twoSum(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length &amp;&amp; nums[i] &lt;= target; i++) &#123; int num = nums[i]; int j = binarySearch(nums, i + 1, nums.length - 1, target - num); if (j != -1) return i &lt; j ? new int[] &#123;i + 1, j + 1&#125; : new int[] &#123;j + 1, i + 1&#125;; &#125; return null;&#125;private int binarySearch(int[] nums, int start, int end, int target) &#123; while (start &lt;= end) &#123; int mid = (start + end) &gt;&gt; 1; if (nums[mid] &lt; target) start = mid + 1; else if (nums[mid] &gt; target) end = mid - 1; else return mid; &#125; return -1;&#125; O(n) runtime, O(1) space123456789101112131415public int[] twoSum(int[] nums, int target) &#123; int start = 0; int end = nums.length - 1; while (start &lt; end) &#123; if (nums[start] + nums[end] &lt; target) start++; else if (nums[start] + nums[end] &gt; target) end--; else return new int[] &#123;start + 1, end + 1&#125;; &#125; return null;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode] Problem 1 - Two Sum]]></title>
      <url>%2F2017%2F09%2F10%2FLeetCode-Problem-1-Two-Sum%2F</url>
      <content type="text"><![CDATA[Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. ExampleGiven nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Code123456789101112131415// O(n) runtime, O(n) spacepublic int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int num = nums[i]; if (map.containsKey(target - num)) return new int[] &#123;i, map.get(target - num)&#125;; map.put(num, i); &#125; return null;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】机器人的运动范围]]></title>
      <url>%2F2017%2F09%2F10%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%2F</url>
      <content type="text"><![CDATA[题目地上有一个m行n列的方格。一个机器人从坐标(0,0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格(35,37)，因为3+5+3+7=18。但它不能进入方格(35,38)。因为3+5+3+8=19.请问该机器人能够到达多少个格子？ 实现123456789101112131415161718192021222324252627282930public int movingCount(int threshold, int rows, int cols) &#123; boolean[] visited = new boolean[rows*cols]; return movingCountHelper(threshold, rows, cols, 0, 0, visited);&#125;private int movingCountHelper(int threshold, int rows, int cols, int row, int col, boolean[] visited) &#123; if (row &lt; 0 || col &lt; 0 || row &gt;= rows || col &gt;= cols || visited[row*cols+col] || getDigitSum(row) + getDigitSum(col) &gt; threshold) return 0; int count = 1; visited[row*cols+col] = true; count += movingCountHelper(threshold, rows, cols, row - 1, col, visited) + movingCountHelper(threshold, rows, cols, row + 1, col, visited) + movingCountHelper(threshold, rows, cols, row, col - 1, visited) + movingCountHelper(threshold, rows, cols, row, col + 1, visited); return count;&#125;private int getDigitSum(int num) &#123; int sum = 0; while (num != 0) &#123; sum += num % 10; num /= 10; &#125; return sum;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】矩阵中的路径]]></title>
      <url>%2F2017%2F09%2F10%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
      <content type="text"><![CDATA[题目请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如在下面的3x4的矩阵中包含一条字符串“bcced”的路径。但矩阵中不包含字符串“abcb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 a b c es f c sa d e e 实现123456789101112131415161718192021222324252627282930313233343536373839public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; if (matrix == null || rows &lt; 1 || cols &lt; 1 || str == null) return false; boolean[] visited = new boolean[matrix.length]; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) if (hasPathHelper(matrix, rows, cols, i, j, str, 0, visited)) return true; &#125; return false;&#125;private boolean hasPathHelper(char[] matrix, int rows, int cols, int row, int col, char[] str, int strIdx, boolean[] visited) &#123; if (row &lt; 0 || col &lt; 0 || row &gt;= rows || col &gt;= cols) return false; int matrixIdx = row * cols + col; if (visited[matrixIdx] || str[strIdx] != matrix[matrixIdx]) return false; if (strIdx == str.length - 1) return true; visited[matrixIdx] = true; boolean result = hasPathHelper(matrix, rows, cols, row - 1, col, str, strIdx + 1, visited) || hasPathHelper(matrix, rows, cols, row + 1, col, str, strIdx + 1, visited) || hasPathHelper(matrix, rows, cols, row, col - 1, str, strIdx + 1, visited) || hasPathHelper(matrix, rows, cols, row, col + 1, str, strIdx + 1, visited); if (!result) visited[matrixIdx] = false; return result;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】滑动窗口的最大值]]></title>
      <url>%2F2017%2F09%2F09%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
      <content type="text"><![CDATA[题目给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。例如，如果输入数组{2, 3, 4, 2, 6, 2, 5, 1}及滑动窗口的大小3，那么一共存在6个滑动窗口，它们的最大值分别为{4, 4, 6, 6, 6, 5}。 实现1234567891011121314151617181920212223public ArrayList&lt;Integer&gt; maxInWindows(int[] num, int size) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (num == null || num.length &lt; 1 || size &lt; 1) return result; LinkedList&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; num.length; i++) &#123; while (!deque.isEmpty() &amp;&amp; num[i] &gt; num[deque.peekLast()]) deque.pollLast(); deque.offerLast(i); if (i - deque.peekFirst() &gt; size - 1) deque.pollFirst(); if (i &gt;= size - 1) result.add(num[deque.peekFirst()]); &#125; return result;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】数据流中的中位数]]></title>
      <url>%2F2017%2F09%2F08%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
      <content type="text"><![CDATA[题目如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序后中间两个数的平均值。 实现123456789101112131415161718192021222324252627private PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(5, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2.compareTo(o1); &#125;&#125;);private PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();public void Insert(Integer num) &#123; if (maxHeap.size() == minHeap.size()) maxHeap.add(num); else minHeap.add(num); if (!minHeap.isEmpty() &amp;&amp; !maxHeap.isEmpty() &amp;&amp; maxHeap.peek() &gt; minHeap.peek()) &#123; maxHeap.offer(minHeap.poll()); minHeap.offer(maxHeap.poll()); &#125;&#125;public Double GetMedian() &#123; if (maxHeap.size() &gt; minHeap.size()) return (double) maxHeap.peek(); else return (maxHeap.peek() + minHeap.peek()) / 2.0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】二叉搜索树的第k个结点]]></title>
      <url>%2F2017%2F09%2F08%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
      <content type="text"><![CDATA[题目给定一棵二叉搜索树，请找出其中的第k大的结点。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819202122232425262728private int count = 0;public TreeNode KthNode(TreeNode pRoot, int k) &#123; if (pRoot == null || k &lt; 1) return null; return KthNodeHelper(pRoot, k);&#125;private TreeNode KthNodeHelper(TreeNode root, int k) &#123; if (root == null) return null; TreeNode node = KthNodeHelper(root.left, k); if (node != null) return node; if (++count == k) return root; node = KthNodeHelper(root.right, k); if (node != null) return node; return null;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】序列化二叉树]]></title>
      <url>%2F2017%2F09%2F08%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
      <content type="text"><![CDATA[题目请实现两个函数，分别用来序列化和反序列化二叉树。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738private int idx = -1;public String Serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); if (root == null) &#123; sb.append("$,"); return sb.toString(); &#125; sb.append(root.val).append(","); sb.append(Serialize(root.left)); sb.append(Serialize(root.right)); return sb.toString();&#125;public TreeNode Deserialize(String str) &#123; if (str == null || str.length() &lt; 1) return null; String[] strs = str.split(","); return Deserialize(strs);&#125;private TreeNode Deserialize(String[] strs) &#123; idx++; TreeNode root = null; if (idx &lt; strs.length &amp;&amp; !strs[idx].equals("$")) &#123; root = new TreeNode(Integer.valueOf(strs[idx])); root.left = Deserialize(strs); root.right = Deserialize(strs); &#125; return root;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】按之字形顺序打印二叉树]]></title>
      <url>%2F2017%2F09%2F08%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
      <content type="text"><![CDATA[题目请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); if (pRoot != null) &#123; Stack&lt;TreeNode&gt;[] stack = (Stack&lt;TreeNode&gt;[]) new Stack[2]; for (int i = 0; i &lt; 2; i++) stack[i] = new Stack&lt;&gt;(); int idx = 0; stack[idx].push(pRoot); while (!stack[idx].isEmpty()) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int start = 0; int end = stack[idx].size(); while (start++ &lt; end)&#123; TreeNode node = stack[idx].pop(); result.add(node.val); if (idx == 0) &#123; if (node.left != null) stack[1-idx].push(node.left); if (node.right != null) stack[1-idx].push(node.right); &#125; else &#123; if (node.right != null) stack[1-idx].push(node.right); if (node.left != null) stack[1-idx].push(node.left); &#125; &#125; idx = 1 - idx; results.add(result); &#125; &#125; return results;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】把二叉树打印成多行]]></title>
      <url>%2F2017%2F09%2F08%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C%2F</url>
      <content type="text"><![CDATA[题目从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印到一行。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 1234567891011121314151617181920212223242526272829public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); if (pRoot != null) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(pRoot); while (!queue.isEmpty()) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int start = 0; int end = queue.size(); while (start++ &lt; end)&#123; TreeNode node = queue.poll(); result.add(node.val); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); &#125; results.add(result); &#125; &#125; return results;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】对称的二叉树]]></title>
      <url>%2F2017%2F09%2F08%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
      <content type="text"><![CDATA[题目请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 1234567891011121314151617public boolean isSymmetrical(TreeNode pRoot) &#123; if (pRoot == null) return true; return isSymmetricalHelper(pRoot.left, pRoot.right);&#125;private boolean isSymmetricalHelper(TreeNode left, TreeNode right) &#123; if (left == null &amp;&amp; right == null) return true; else if (left == null || right == null) return false; else if (left.val != right.val) return false; return isSymmetricalHelper(left.left, right.right) &amp;&amp; isSymmetricalHelper(left.right, right.left);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】二叉树的下一个结点]]></title>
      <url>%2F2017%2F09%2F08%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
      <content type="text"><![CDATA[题目给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。 实现12345678910public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if (pNode == null) return null; if (pNode.right != null) &#123; pNode = pNode.right; while (pNode.left != null) pNode = pNode.left; &#125; else &#123; while (pNode.next != null &amp;&amp; pNode.next.right == pNode) pNode = pNode.next; pNode = pNode.next; &#125; return pNode;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】删除链表中重复的结点]]></title>
      <url>%2F2017%2F09%2F08%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9%2F</url>
      <content type="text"><![CDATA[题目在一个排序的链表中，如何删除重复的结点？ 实现12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 123456789101112131415161718192021222324252627public ListNode deleteDuplication(ListNode pHead) &#123; if (pHead == null) return null; ListNode current = pHead; ListNode prev = null; while (current != null &amp;&amp; current.next != null) &#123; if (current.next.val &gt; current.val) &#123; prev = current; current = current.next; &#125; else &#123; while (current.next != null &amp;&amp; current.next.val == current.val) current = current.next; current = current.next; if (prev != null) prev.next = current; else pHead = current; &#125; &#125; return pHead;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】链表中环的入口结点]]></title>
      <url>%2F2017%2F09%2F08%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9%2F</url>
      <content type="text"><![CDATA[题目一个链表中包含环，如何找出环的入口结点？ 实现12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public ListNode EntryNodeOfLoop(ListNode pHead) &#123; ListNode node = meetingNode(pHead); if (node == null) return null; int count = countNodes(node); return findEntry(pHead, count);&#125;private ListNode meetingNode(ListNode head) &#123; if (head == null) return null; ListNode slow = head; ListNode fast = head.next; while (fast != null) &#123; if (fast == slow) return slow; if (fast.next == null) return null; slow = slow.next; fast = fast.next.next; &#125; return null;&#125;private int countNodes(ListNode node) &#123; ListNode current = node.next; int count = 1; while (current != node) &#123; count++; current = current.next; &#125; return count;&#125;private ListNode findEntry(ListNode head, int count) &#123; ListNode slow = head; ListNode fast = head; for (int i = 0; i &lt; count; i++) fast = fast.next; while (fast != slow) &#123; fast = fast.next; slow = slow.next; &#125; return slow;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】字符流中第一个不重复的字符]]></title>
      <url>%2F2017%2F09%2F07%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[题目请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符“go”时，第一个只出现一次的字符是‘g’。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是‘l’。 实现1234567891011121314151617181920212223242526272829private int[] occurrence = new int[256];private int index = 0;public void Insert(char ch) &#123; index++; int current = (int) ch; if (occurrence[current] == 0) occurrence[current] = index; else if (occurrence[current] &gt; 0) occurrence[current] = -1;&#125;public char FirstAppearingOnce() &#123; char result = '\0'; int min = Integer.MAX_VALUE; for (int i = 0; i &lt; 256; i++) &#123; if (occurrence[i] &gt; 0 &amp;&amp; occurrence[i] &lt; min) &#123; result = (char) i; min = occurrence[i]; &#125; &#125; if (result == '\0') result = '#'; return result;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】表示数值的字符串]]></title>
      <url>%2F2017%2F09%2F07%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
      <content type="text"><![CDATA[题目请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串“+100”、“5e2”、“-123”、“3.1416”及“-1E-16”都表示数值，但“12e”、“1a3.14”、“1.2.3”、“+-5”及“12e+5.4”都不是。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public boolean isNumeric(char[] str) &#123; if (str == null || str.length &lt; 1) return false; int idx = 0; boolean isNum = true; if (str[idx] == '+' || str[idx] == '-') idx++; idx = scanNumber(str, idx); if (idx &lt; str.length &amp;&amp; str[idx] == '.') &#123; idx++; idx = scanNumber(str, idx); if (idx &lt; str.length &amp;&amp; (str[idx] == 'e' || str[idx] == 'E')) isNum = isExponential(str, idx + 1); else if (idx &lt; str.length &amp;&amp; str[idx] != 'e' &amp;&amp; str[idx] != 'E') return false; &#125; else if (idx &lt; str.length &amp;&amp; (str[idx] == 'e' || str[idx] == 'E')) isNum = isExponential(str, idx + 1); else if (idx &lt; str.length &amp;&amp; str[idx] != '.' &amp;&amp; str[idx] != 'e' &amp;&amp; str[idx] != 'E') isNum = false; return isNum;&#125;private int scanNumber(char[] str, int idx) &#123; for(; idx &lt; str.length; idx++) &#123; if (str[idx] &lt; '0' || str[idx] &gt; '9') return idx; &#125; return idx;&#125;private boolean isExponential(char[] str, int idx) &#123; if (idx == str.length) return false; if (str[idx] == '+' || str[idx] == '-') idx++; if (idx == str.length) return false; idx = scanNumber(str, idx); if (idx &lt; str.length) return false; return true;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】正则表达式匹配]]></title>
      <url>%2F2017%2F09%2F07%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
      <content type="text"><![CDATA[题目请实现一个函数用来匹配包含‘.’和‘’的正则表达式。模式中的字符‘.’表示任意一个字符，而‘’表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串“aaa”与模式“a.a”和“abaca”匹配，但与“aa.a”及“ab*a”均不匹配。 实现12345678910111213141516171819202122232425262728public boolean match(char[] str, char[] pattern) &#123; if (str == null || pattern == null) return false; return matchHelper(str, 0, pattern, 0 );&#125;private boolean matchHelper(char[] str, int strIdx, char[] pattern, int patternIdx) &#123; if (strIdx == str.length &amp;&amp; patternIdx == pattern.length) return true; if (strIdx != str.length &amp;&amp; patternIdx == pattern.length) return false; if (patternIdx + 1 &lt; pattern.length &amp;&amp; pattern[patternIdx+1] == '*') &#123; if (strIdx &lt; str.length &amp;&amp; (str[strIdx] == pattern[patternIdx] || pattern[patternIdx] == '.')) return matchHelper(str, strIdx, pattern, patternIdx + 2) || matchHelper(str , strIdx + 1, pattern, patternIdx) || matchHelper(str, strIdx + 1, pattern, patternIdx + 2); else return matchHelper(str, strIdx, pattern, patternIdx + 2); &#125; if (strIdx &lt; str.length &amp;&amp; (str[strIdx] == pattern[patternIdx] || pattern[patternIdx] == '.')) return matchHelper(str, strIdx + 1, pattern, patternIdx + 1); return false;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】构建乘积数组]]></title>
      <url>%2F2017%2F09%2F07%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%2F</url>
      <content type="text"><![CDATA[题目给定一个数组A[0, 1, … , n-1]，请构建一个数组B[0, 1, … , n-1]，其中B中的元素B[i]=A[0]xA[1]x…xA[i-1]xA[i+1]x…xA[n-1]。不能使用除法。 实现12345678910111213141516171819public int[] multiply(int[] A) &#123; int[] B = new int[A.length]; if (A == null || A.length &lt; 1) return B; B[0] = 1; int temp = 1; for (int i = 1; i &lt;= A.length - 1; i++) B[i] = A[i-1] * B[i-1]; for (int i = A.length - 2; i &gt;= 0; i--) &#123; temp *= A[i+1]; B[i] *= temp; &#125; return B;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】数组中重复的数字]]></title>
      <url>%2F2017%2F09%2F07%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
      <content type="text"><![CDATA[题目在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3. 实现12345678910111213141516171819202122public boolean duplicate(int numbers[], int length, int[] duplication) &#123; if (numbers == null || length &lt; 1) return false; for (int i = 0; i &lt; length; i++) &#123; while (numbers[i] != i) &#123; if (numbers[i] == numbers[numbers[i]]) &#123; duplication[0] = numbers[i]; return true; &#125; swap(numbers, i, numbers[i]); &#125; &#125; return false;&#125;private void swap(int numbers[], int i, int j) &#123; numbers[i] = numbers[i] ^ numbers[j]; numbers[j] = numbers[i] ^ numbers[j]; numbers[i] = numbers[i] ^ numbers[j];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】树中两个结点的最低公共祖先]]></title>
      <url>%2F2017%2F09%2F06%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%2F</url>
      <content type="text"><![CDATA[题目输入两个树结点，求它们的最低公共祖先。这棵树是普通的树，而且树中的结点没有指向父结点的指针。 实现12345678public class TreeNode &#123; int val = 0; List&lt;TreeNode&gt; children = new ArrayList&lt;&gt;(); public TreeNode(int val) &#123; this.val = val; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public TreeNode getLastCommonParent(TreeNode root, TreeNode node1, TreeNode node2) &#123; if (root == null || node1 == null || node2 == null) return null; List&lt;TreeNode&gt; path1 = new ArrayList&lt;&gt;(); getPath(path1, root, node1); List&lt;TreeNode&gt; path2 = new ArrayList&lt;&gt;(); getPath(path2, root, node2); Iterator&lt;TreeNode&gt; iterator1 = path1.iterator(); Iterator&lt;TreeNode&gt; iterator2 = path2.iterator(); TreeNode parent = null; while (iterator1.hasNext() &amp;&amp; iterator2.hasNext()) &#123; TreeNode n1 = iterator1.next(); TreeNode n2 = iterator2.next(); if(n1 != n2) break; parent = n1; &#125; return parent;&#125;private void getPath(List&lt;TreeNode&gt; path, TreeNode root, TreeNode node) &#123; if (root == null) return; path.add(root); if (root == node) return; for (TreeNode child : root.children) &#123; getPath(path, child, node); if (path.contains(node)) break; &#125; if (!path.contains(node)) path.remove(path.size() - 1);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】把字符串转换成整数]]></title>
      <url>%2F2017%2F09%2F06%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0%2F</url>
      <content type="text"><![CDATA[题目写一个函数StrToInt，实现把字符串转换成整数的功能。不能使用atoi或者其他类似的库函数。 实现12345678910111213141516171819202122232425262728293031323334353637private boolean isInvalid = false;public int StrToInt(String str) &#123; if (str == null || str.length() &lt; 1) &#123; isInvalid = true; return 0; &#125; char[] array = str.toCharArray(); long result = 0; boolean minus = false; int index = 0; if (array[index] == '+') index++; else if (array[index] == '-') &#123; minus = true; index++; &#125; for (; index &lt; array.length; index++) &#123; if (array[index] &lt; '0' || array[index] &gt; '9') &#123; isInvalid = true; return 0; &#125; int flag = minus ? -1 : 1; result = result * 10 + flag * (array[index] - '0'); if ((!minus &amp;&amp; result &gt; Integer.MAX_VALUE) || (minus &amp;&amp; result &lt; Integer.MIN_VALUE)) &#123; isInvalid = true; return 0; &#125; &#125; return (int)result;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】不用加减乘除做加法]]></title>
      <url>%2F2017%2F09%2F06%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%2F</url>
      <content type="text"><![CDATA[题目写一个函数，求两个整数之和，要求在函数体内不得使用+、-、x、／四则运算符号。 实现123456789public int Add(int num1, int num2) &#123; while (num2 != 0) &#123; int sum = num1 ^ num2; num2 = (num1 &amp; num2) &lt;&lt; 1; num1 = sum; &#125; return num1;&#125; 相关问题不使用新的变量，交换两个变量的值。比如有两个变量a、b，希望交换它们的值。有两种不同的办法： 基于加减法 基于异或运算 a = a + b a = a ^ b b = a - b b = a ^ b a = a - b a = a ^ b]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】求1+2+...+n]]></title>
      <url>%2F2017%2F09%2F06%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%B1%821-2-n%2F</url>
      <content type="text"><![CDATA[题目求1+2+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 实现12345public int Sum_Solution(int n) &#123; int sum = n; boolean end = n &gt; 0 &amp;&amp; (sum += Sum_Solution(n - 1)) &gt; 0; return sum;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】圆圈中最后剩下的数字]]></title>
      <url>%2F2017%2F09%2F05%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
      <content type="text"><![CDATA[题目0, 1, …, n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。 经典的解法，用环形链表模拟圆圈12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 123456789101112131415161718192021222324252627282930public int LastRemaining_Solution(int n, int m) &#123; if (n &lt; 1 || m &lt; 1) return -1; ListNode head = new ListNode(0); ListNode tail = head; for (int i = 1; i &lt; n; i++) &#123; ListNode node = new ListNode(i); tail.next = node; tail = node; &#125; tail.next = head; ListNode current = head; ListNode prev = null; while (n &gt; 1) &#123; for (int i = 1; i &lt; m; i++) &#123; prev = current; current = current.next; &#125; prev.next = current.next; current = prev.next; n--; &#125; return current.val;&#125; 创新的解法，拿到Offer不在话下12345678910111213public int LastRemaining_Solution(int n, int m) &#123; if (n &lt; 1 || m &lt; 1) return -1; int result = 0; //f(n, m) = f'(n-1,m) = [f(n-1,m) + m] % n for (int i = 2; i &lt;= n; i++) result = (result + m) % i; return result;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】扑克牌的顺子]]></title>
      <url>%2F2017%2F09%2F05%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%89%91%E5%85%8B%E7%89%8C%E7%9A%84%E9%A1%BA%E5%AD%90%2F</url>
      <content type="text"><![CDATA[题目从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王可以看成任意数字。 实现12345678910111213141516171819public boolean isContinuous(int[] numbers) &#123; if (numbers == null || numbers.length &lt; 1) return false; Arrays.sort(numbers); int numOfZero = 0; int numOfGap = 0; for (int i = 0; i &lt; numbers.length - 1; i++) &#123; if (numbers[i] == 0) numOfZero++; else if (numbers[i] == numbers[i+1]) return false; else numOfGap += numbers[i+1] - numbers[i] - 1; &#125; return numOfZero &gt;= numOfGap ? true : false;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】n个骰子的点数]]></title>
      <url>%2F2017%2F09%2F04%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0%2F</url>
      <content type="text"><![CDATA[题目把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 基于递归求骰子点数，时间效率不够高12345678910111213141516171819202122232425262728public void PrintProbability(int number) &#123; if (number &lt; 1) return; int[] prob = new int[6*number-number+1]; for (int i = 1; i &lt;= 6; i++) probability(prob, number, number, i); print(prob, number);&#125;private void probability(int[] prob, int number, int current, int sum) &#123; if (current == 1) &#123; prob[sum-number]++; return; &#125; for (int i = 1; i &lt;= 6; i++) probability(prob, number, current - 1, sum + i);&#125;private void print(int[] prob, int number) &#123; double total = Math.pow(6, number); for (int i = 0; i &lt; prob.length; i++) System.out.println(i+number + ": " + prob[i] / total);&#125; 基于循环求骰子点数，时间性能好123456789101112131415161718192021222324252627282930public void PrintProbability(int number) &#123; if (number &lt; 1) return; int[][] prob = new int[2][6*number+1]; int flag = 0; for (int i = 1; i &lt;= 6; i++) prob[flag][i] = 1; //f(i,n) = f(i-1,n-1) + f(i-1,n-2) + f(i-1,n-3) + f(i-1,n-4) + f(i-1,n-5) + f(i-1,n-6) for (int i = 2; i &lt;= number; i++) &#123; flag = 1 - flag; for (int j = i; j &lt;= 6 * i; j++) &#123; for (int k = 1; k &lt;= 6 &amp;&amp; k &lt;= j; k++) prob[flag][j] += prob[1-flag][j-k]; &#125; &#125; print(prob[flag], number);&#125;private void print(int[] prob, int number) &#123; double total = Math.pow(6, number); for (int i = number; i &lt;= 6 * number; i++) System.out.println(i + ": " + prob[i] / total);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】翻转单词顺序VS左旋转字符串]]></title>
      <url>%2F2017%2F09%2F03%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8FVS%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
      <content type="text"><![CDATA[题目一输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student.”，则输出”student. a am I”。 实现123456789101112131415161718192021222324252627282930313233public String ReverseSentence(String str) &#123; if (str == null || str.length() &lt; 1) return ""; char[] result = str.toCharArray(); int start = 0; int end = 0; reverse(result, 0, result.length - 1); while (end &lt; result.length) &#123; if (result[end] == ' ') &#123; reverse(result, start, end - 1); start = ++end; &#125; else if (end == result.length - 1) reverse(result, start, end++); else end++; &#125; return String.valueOf(result);&#125;private void reverse(char[] result, int start, int end) &#123; while (start &lt; end) &#123; char tmp = result[start]; result[start] = result[end]; result[end] = tmp; start++; end--; &#125;&#125; 题目二字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如输入字符串”abcdefg”和数字2，该函数将返回左旋转2位得到的结果”cdefgab”。 实现123456789101112131415161718192021public String LeftRotateString(String str, int n) &#123; if (str == null || str.length() &lt; n) return ""; char[] result = str.toCharArray(); reverse(result, 0, n - 1); reverse(result, n, result.length - 1); reverse(result, 0, result.length - 1); return String.valueOf(result);&#125;private void reverse(char[] result, int start, int end) &#123; while (start &lt; end) &#123; char tmp = result[start]; result[start] = result[end]; result[end] = tmp; start++; end--; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】和为s的两个数字VS和为s的连续正数序列]]></title>
      <url>%2F2017%2F09%2F02%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97VS%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
      <content type="text"><![CDATA[题目一输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，输出任意一对即可。 实现1234567891011121314151617181920212223public ArrayList&lt;Integer&gt; FindNumbersWithSum(int[] array, int sum) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (array == null || array.length &lt; 2) return list; int start = 0; int end = array.length - 1; while (start &lt; end) &#123; if (array[start] + array[end] &lt; sum) start++; else if (array[start] + array[end] &gt; sum) end--; else &#123; list.add(array[start]); list.add(array[end]); return list; &#125; &#125; return list;&#125; 题目二输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。例如输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以结果打印出3个连续序列1～5、4～6和7～8。 实现1234567891011121314151617181920212223242526272829303132333435363738public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); if (sum &lt; 3) return results; int start = 1; int end = 2; int middle = (sum + 1) / 2; int current = start + end; while (start &lt; middle) &#123; if (current &lt; sum) &#123; end++; current += end; &#125; else if (current &gt; sum) &#123; current -= start; start++; &#125; else &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); findContinuousSequence(result, start, end); results.add(result); current -= start; start++; end++; current += end; &#125; &#125; return results;&#125;private void findContinuousSequence(ArrayList&lt;Integer&gt; result, int start, int end) &#123; for (int i = start; i &lt;= end; i++) result.add(i);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】数组中只出现一次的数字]]></title>
      <url>%2F2017%2F09%2F02%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
      <content type="text"><![CDATA[题目一个整形数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 实现12345678910111213141516171819202122232425262728293031323334public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) &#123; if (array == null || array.length &lt; 2) return; int result = 0; for (int i = 0; i &lt; array.length; i++) result ^= array[i]; int index = findFirstBitIsOne(result); for (int i = 0; i &lt; array.length; i++) &#123; if (isBitOne(array[i], index)) num1[0] ^= array[i]; else num2[0] ^= array[i]; &#125;&#125;private int findFirstBitIsOne(int result) &#123; int index = 0; while (index &lt; 32 &amp;&amp; (result &amp; 1) == 0) &#123; result &gt;&gt;= 1; index++; &#125; return index;&#125;private boolean isBitOne(int num, int index) &#123; num &gt;&gt;= index; return (num &amp; 1) == 1 ;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】二叉树的深度]]></title>
      <url>%2F2017%2F09%2F02%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[题目一输入一棵二叉树的根结点，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 123456789public int TreeDepth(TreeNode root) &#123; if (root == null) return 0; int leftDepth = TreeDepth(root.left); int rightDepth = TreeDepth(root.right); return leftDepth &gt; rightDepth ? leftDepth + 1 : rightDepth + 1;&#125; 题目二输入一棵二叉树的根结点，判断该树是不是平衡二叉树。如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 需要重复遍历结点多次的解法，简单但不足以打动面试官123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819public boolean IsBalanced_Solution(TreeNode root) &#123; if (root == null) return true; int leftDep = TreeDepth(root.left); int rightDep = TreeDepth(root.right); return IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right) &amp;&amp; Math.abs(leftDep - rightDep) &lt; 2;&#125;private int TreeDepth(TreeNode root) &#123; if (root == null) return 0; int leftDepth = TreeDepth(root.left); int rightDepth = TreeDepth(root.right); return leftDepth &gt; rightDepth ? leftDepth + 1 : rightDepth + 1;&#125; 每个结点只遍历一次的解法，正是面试官喜欢的123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819private boolean isBalanced = true;public boolean IsBalanced_Solution(TreeNode root) &#123; getDepth(root); return isBalanced;&#125;private int getDepth(TreeNode root) &#123; if (root == null) return 0; int leftDep = getDepth(root.left); int rightDep = getDepth(root.right); if (Math.abs(leftDep - rightDep) &gt; 1) isBalanced = false; return Math.max(leftDep, rightDep) + 1;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】数字在排序数组中出现的次数]]></title>
      <url>%2F2017%2F09%2F02%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
      <content type="text"><![CDATA[题目统计一个数字在排序数组中出现的次数。例如输入排序数组{1, 2, 3, 3, 3, 3, 4, 5}和数字3，由于3在这个数组中出现了4次，因此输出4. 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public int GetNumberOfK(int[] array , int k) &#123; int count = 0; if (array != null || array.length &lt;1) &#123; int firstIdx = getFirstK(array, k, 0, array.length - 1); int lastIdx = getLastK(array, k, 0, array.length - 1); if (firstIdx != -1 &amp;&amp; lastIdx != -1) count = lastIdx - firstIdx + 1; &#125; return count;&#125;private int getFirstK(int[] array, int k, int start, int end) &#123; if (start &gt; end) return -1; int middle = (start + end) / 2; if (array[middle] &lt; k) return getFirstK(array, k, middle + 1, end); else if (array[middle] &gt; k) return getFirstK(array, k, start, middle - 1); else &#123; if (middle == 0 || (middle &gt; 0 &amp;&amp; array[middle - 1] != k)) return middle; else return getFirstK(array, k, start, middle - 1); &#125;&#125;private int getLastK(int[] array, int k, int start, int end) &#123; if (start &gt; end) return -1; int middle = (start + end) / 2; if (array[middle] &lt; k) return getLastK(array, k, middle + 1, end); else if (array[middle] &gt; k) return getLastK(array, k, start, middle - 1); else &#123; if (middle == array.length - 1 || (middle &lt; array.length - 1 &amp;&amp; array[middle + 1] != k)) return middle; else return getLastK(array, k, middle + 1, end); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】两个链表的第一个公共结点]]></title>
      <url>%2F2017%2F09%2F01%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9%2F</url>
      <content type="text"><![CDATA[题目输入两个链表，找出它们的第一个公共结点。 实现12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; int firstLen = getListLength(pHead1); int secondLen = getListLength(pHead2); int diff = firstLen - secondLen; if (diff &gt; 0) pHead1 = findFirstNodeHelper(pHead1, diff); else if (diff &lt; 0) pHead2 = findFirstNodeHelper(pHead2, -diff); while (pHead1 != null &amp;&amp; pHead2 != null &amp;&amp; pHead1 != pHead2) &#123; pHead1 = pHead1.next; pHead2 = pHead2.next; &#125; return pHead1;&#125;private int getListLength(ListNode head) &#123; int count = 0; while (head != null) &#123; count++; head = head.next; &#125; return count;&#125;private ListNode findFirstNodeHelper(ListNode head, int step) &#123; while (step != 0) &#123; step--; head = head.next; &#125; return head;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】数组中的逆序对]]></title>
      <url>%2F2017%2F09%2F01%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
      <content type="text"><![CDATA[题目在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对，输入一个数组，求出这个数组中的逆序对的总数。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public int InversePairs(int[] array) &#123; if (array == null || array.length &lt; 1) return 0; int[] aux = new int[array.length]; for (int i = 0; i &lt; array.length; i++) aux[i] = array[i]; return sortAndCount(array, aux, 0, array.length - 1);&#125;private int sortAndCount(int[] array, int[] aux, int start, int end)&#123; if (start == end) return 0; int mid = (start + end) / 2; int leftCount = sortAndCount(array, aux, start, mid); int rightCount = sortAndCount(array, aux, mid + 1, end); int splitCount = countSplitInv(array, aux, start, mid, end); return (leftCount + rightCount + splitCount) % 1000000007;&#125;private int countSplitInv(int[] array, int[] aux, int start, int mid, int end) &#123; int count = 0; int j = start; int k = mid + 1; for (int i = start; i &lt;= end; i++) &#123; if (j &gt; mid) array[i] = aux[k++]; else if (k &gt; end) array[i] = aux[j++]; else if (aux[j] &lt; aux[k]) array[i] = aux[j++]; else &#123; count += mid - j + 1; array[i] = aux[k++]; if (count &gt; 1000000007) count %= 1000000007; &#125; &#125; for (int i = start; i &lt;= end; i++) aux[i] = array[i]; return count;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】第一个只出现一次的字符]]></title>
      <url>%2F2017%2F08%2F31%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[题目在字符串中找出第一个只出现一次的字符。如输入“abaccdeff”，则输出’b’。 实现123456789101112131415161718192021222324public int FirstNotRepeatingChar(String str) &#123; if (str == null || str.length() == 0) return -1; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; Character ch = str.charAt(i); if (map.containsKey(ch)) map.put(ch, map.get(ch) + 1); else map.put(ch, 1); &#125; for (int i = 0; i &lt; str.length(); i++) &#123; Character ch = str.charAt(i); if (map.get(ch) == 1) return i; &#125; return -1;&#125; 相关题目 定义一个函数，输入两个字符串，从第一个字符串中删除在第二个字符串中出现过的所有字符。例如从第一个字符串“We are students. ”中删除在第二个字符串“aeiou”中出现过的字符得到的结果是“W r Stdnts. ”。为了解决这个问题，可以创建一个用数组实现的简单哈希表来存储第二个字符串。这样从头到尾扫描第一个字符串的每一个字符时，用O(1)时间就能判断出该字符是不是在第二个字符中。如果第一个字符串的长度是n，那么总的时间复杂度是O(n)。 定义一个函数，删除字符串中所有重复出现的字符。例如输入“google”，删除重复的字符之后的结果是“gole”。可以创建一个用布尔型数组实现的简单的哈希表。数组中的元素的意义是其下标看做ASCII码后对应的字母在字符串中是否已经出现。先把数组中所有的元素都设为false。以“google”为例，当扫描到第一个g时，g的ASCII码是103，那么把数组中下标为103的元素设为true。当扫描到第二个g时，发现数组中下标为103的元素的值是true，就知道g在前面已经出现了。也就是说，用O(1)时间就能判断出每个字符是否在前面已经出现过。如果字符串的长度是n，那么总的时间复杂度是O(n)。 在英语中，如果两个单词中出现的字母相同，并且每个字母出现的次数也相同，那么这两个单词互为变位词（Anagram）。例如silent与listen、evil与live等互为变位词。请完成一个函数，判断输入的两个字符串是不是互为变位词。可以创建一个用数组实现的简单哈希表，用来统计字符串中每个字符出现的次数。当扫描到第一个字符串中的每个字符时，为哈希表对应的项的值增加1.接下来扫描第二个字符串，扫描到每个字符时，为哈希表对应的项的值减去1.如果扫描完第二个字符串后，哈希表中所有的值都是0，那么这两个字符串就互为变位词。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】丑数]]></title>
      <url>%2F2017%2F08%2F31%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%B8%91%E6%95%B0%2F</url>
      <content type="text"><![CDATA[题目把只包含因子2、3和5的数称作丑数（Ugly Number）。求按从小到大的顺序的第1500个丑数。例如6、8都是丑数，但14不是，因为它包含因子7.习惯上把1当做第一个丑数。 逐个判断每个整数是不是丑数的解法，直观但不够高效123456789101112131415161718192021222324252627public int GetUglyNumber_Solution(int index) &#123; if (index &lt; 1) return 0; int number = 1; int currentIdx = 1; while (currentIdx &lt; index) &#123; if (isUglyNumber(number)) currentIdx++; number++; &#125; return number;&#125;private boolean isUglyNumber(int number) &#123; while (number % 2 == 0) number /= 2; while (number % 3 == 0) number /= 3; while (number % 5 == 0) number /= 5; return number == 1 ? true :false;&#125; 创建数组保存已经找到的丑数，用空间换时间的解法1234567891011121314151617181920212223public int GetUglyNumber_Solution(int index) &#123; if (index &lt; 1) return 0; int[] array = new int[index]; int t2 = 0; int t3 = 0; int t5 = 0; array[0] = 1; for (int i = 1; i &lt; index; i++) &#123; array[i] = Math.min(array[t2] * 2, Math.min(array[t3] * 3, array[t5] * 5)); if(array[i] == array[t2] * 2) t2++; if (array[i] == array[t3] * 3) t3++; if (array[i] == array[t5] * 5) t5++; &#125; return array[index - 1];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】把数组排成最小的数]]></title>
      <url>%2F2017%2F08%2F31%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
      <content type="text"><![CDATA[题目输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3, 32, 321}，则打印出这3个数字能排成的最小数字321323。 实现123456789101112131415161718192021public String PrintMinNumber(int[] numbers) &#123; StringBuilder sb = new StringBuilder(); String[] str = new String[numbers.length]; for (int i = 0; i &lt; numbers.length; i++) str[i] = String.valueOf(numbers[i]); Arrays.sort(str, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; String m = o1 + o2; String n = o2 + o1; return m.compareTo(n); &#125; &#125;); for (int i = 0; i &lt; str.length; i++) sb.append(str[i]); return sb.toString();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】从1到n整数中1出现的次数]]></title>
      <url>%2F2017%2F08%2F31%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BB%8E1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
      <content type="text"><![CDATA[题目输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1的数字有1，10，11和12，1一共出现了5次。 不考虑时间效率的解法，靠它想拿Offer有点难123456789101112131415161718192021public int NumberOf1Between1AndN_Solution(int n) &#123; int count = 0; for (int i = 1; i &lt;= n; i++) count += NumberOf1(i); return count;&#125;private int NumberOf1(int n) &#123; int count = 0; while (n != 0) &#123; if (n % 10 == 1) count++; n /= 10; &#125; return count;&#125; 从数字规律着手明显提高时间效率的解法，能让面试官耳目一新1234567891011121314151617181920212223public int NumberOf1Between1AndN_Solution(int n) &#123; int count = 0; int index = 1; int currentN = n; while (currentN &gt; 0)&#123; int current = currentN % 10; int high = currentN / 10; int low = n - currentN * index; count += high * index; if (current &gt; 1) count += index; else if (current == 1) count += low + 1; index *= 10; currentN /= 10; &#125; return count;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】连续子数组的最大和]]></title>
      <url>%2F2017%2F08%2F30%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
      <content type="text"><![CDATA[题目输入一个整形数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。 举例分析数组的规律12345678910111213141516171819public int FindGreatestSumOfSubArray(int[] array) &#123; if (array == null || array.length &lt; 1) return 0; int max = Integer.MIN_VALUE; int sum = -1; for (int i = 0; i &lt; array.length; i++) &#123; if (sum &lt; 0) sum = array[i]; else sum += array[i]; if (sum &gt; max) max = sum; &#125; return max;&#125; 应用动态规划法123456789101112131415public int FindGreatestSumOfSubArray(int[] array) &#123; if (array == null || array.length &lt; 1) return 0; int max = Integer.MIN_VALUE; int[] s = new int[array.length]; s[0] = array[0]; for (int i = 1; i &lt; s.length; i++) &#123; s[i] = Math.max(array[i], s[i - 1] + array[i]); max = Math.max(s[i] , max); &#125; return max;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】最小的K个数]]></title>
      <url>%2F2017%2F08%2F29%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0%2F</url>
      <content type="text"><![CDATA[题目输入n个整数，找出其中最小的k个数。例如输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4. O(n)的算法，只有当我们可以修改输入的数组时可用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] input, int k) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (input == null || input.length &lt;= 0 || k &gt; input.length || k &lt; 1) return result; int left = 0; int right = input.length - 1; int pivot = Partition(input, left, right); while (pivot != k - 1) &#123; if (pivot &lt; k - 1) &#123; left = pivot + 1; pivot = Partition(input, left, right); &#125; else &#123; right = pivot - 1; pivot = Partition(input, left, right); &#125; &#125; for (int i = 0; i &lt; k; i++) result.add(input[i]); return result;&#125;private int Partition(int[] array, int start, int end)&#123; int i = start + 1; for (int j = start + 1; j &lt;= end; j++)&#123; if (array[j] &lt; array[start]) &#123; Swap(array, i, j); i++; &#125; &#125; Swap(array, start, --i); return i;&#125;private void Swap(int[] array, int i, int j)&#123; if (i == j) return; array[i] = array[i] ^ array[j]; array[j] = array[i] ^ array[j]; array[i] = array[j] ^ array[i];&#125; O(nlogk)的算法，特别适合处理海量数据123456789101112131415161718192021222324252627public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] input, int k) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (input == null || input.length &lt;= 0 || k &gt; input.length || k &lt; 1) return result; PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(k, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2.compareTo(o1); &#125; &#125;); for (int i = 0; i &lt; input.length; i++) &#123; if (maxHeap.size() &lt; k) maxHeap.offer(input[i]); else if (input[i] &lt; maxHeap.peek()) &#123; maxHeap.poll(); maxHeap.offer(input[i]); &#125; &#125; for (Integer i : maxHeap) result.add(i); return result;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】数组中出现次数超过一半的数字]]></title>
      <url>%2F2017%2F08%2F28%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
      <content type="text"><![CDATA[题目数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1，2，3，2，2，2，5，4，2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2. 基于Partition函数的O(n)算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public int MoreThanHalfNum_Solution(int[] array) &#123; if (array == null || array.length &lt;= 0) return 0; int left = 0; int right = array.length - 1; int middle = (left + right) / 2; int pivot = Partition(array, left, right); while (pivot != middle) &#123; if (pivot &lt; middle) &#123; left = pivot + 1; pivot = Partition(array, left, right); &#125; else &#123; right = pivot - 1; pivot = Partition(array, left, right); &#125; &#125; int result = array[middle]; if (!CheckMoreThanHalf(array, result)) return 0; return result;&#125;private int Partition(int[] array, int start, int end)&#123; int i = start + 1; for (int j = start + 1; j &lt;= end; j++)&#123; if (array[j] &lt; array[start]) &#123; Swap(array, i, j); i++; &#125; &#125; Swap(array, start, --i); return i;&#125;private void Swap(int[] array, int i, int j)&#123; if (i == j) return; array[i] = array[i] ^ array[j]; array[j] = array[i] ^ array[j]; array[i] = array[j] ^ array[i];&#125;private boolean CheckMoreThanHalf(int[] array, int result) &#123; int count = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (result == array[i]) count++; &#125; if (2 * count &lt;= array.length) return false; return true;&#125; 根据数组特点找出O(n)的算法12345678910111213141516171819202122232425262728293031323334353637public int MoreThanHalfNum_Solution(int[] array) &#123; if (array == null || array.length &lt;= 0) return 0; int result = array[0]; int count = 1; for (int i = 1; i &lt; array.length; i++) &#123; if (count == 0) &#123; count = 1; result = array[i]; &#125; else if (array[i] == result) count++; else count--; &#125; if (!CheckMoreThanHalf(array, result)) return 0; return result;&#125;private boolean CheckMoreThanHalf(int[] array, int result) &#123; int count = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (result == array[i]) count++; &#125; if (2 * count &lt;= array.length) return false; return true;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】字符串的排列]]></title>
      <url>%2F2017%2F08%2F28%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%2F</url>
      <content type="text"><![CDATA[题目输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。 实现1234567891011121314151617181920212223242526272829303132public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;(); HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); if (str != null &amp;&amp; str.length() != 0) &#123; Permutation(str.toCharArray(), 0, set); result.addAll(set); Collections.sort(result); &#125; return result;&#125;private void Permutation(char[] str, int pos, HashSet&lt;String&gt; result) &#123; if (pos == str.length - 1) &#123; result.add(String.valueOf(str)); return; &#125; for (int i = pos; i &lt; str.length; i++)&#123; swap(str, i, pos); Permutation(str, pos + 1, result); swap(str, pos, i); &#125;&#125;private void swap(char[] str, int i, int j) &#123; char temp = str[i]; str[i] = str[j]; str[j] = temp;&#125; 相关题目 输入一个含有8个数字的数组，判断有没有可能把这8个数字分别放到正方体的8个顶点上，使得正方体上三组相对的面上的4个顶点的和都相等。 在8x8的国际象棋上摆放8个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者同一对角线上。请问总共有多少种符合条件的摆法？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】二叉搜索树与双向链表]]></title>
      <url>%2F2017%2F08%2F27%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[题目输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 123456789101112131415161718192021222324private TreeNode last = null;public TreeNode Convert(TreeNode pRootOfTree) &#123; ConvertNode(pRootOfTree); while (last != null &amp;&amp; last.left != null) last = last.left; return last;&#125;private void ConvertNode(TreeNode root) &#123; if (root == null) return; ConvertNode(root.left); root.left = last; if (last != null) last.right = root; last = root; ConvertNode(root.right);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Chat Robot Demo]]></title>
      <url>%2F2017%2F06%2F18%2FChat-Robot-Demo%2F</url>
      <content type="text"><![CDATA[Code12345678910111213141516171819202122232425262728import java.io.*;import java.net.*;import com.google.gson.*;public class ChatRobot&#123; public static void main(String[] args) throws IOException &#123; String APIKEY = "b239e8c2220941988f400352d7efb923"; String[] question = &#123;"你叫什么名字？", "谁是世界上最聪明的人？", "那谁是世界上最帅气的人？"&#125;; for (int i = 0; i &lt; question.length; i++)&#123; String INFO = URLEncoder.encode(question[i], "utf-8"); String getURL = "http://www.tuling123.com/openapi/api?key=" + APIKEY + "&amp;info=" + INFO; URL getUrl = new URL(getURL); HttpURLConnection connection = (HttpURLConnection) getUrl.openConnection(); connection.connect(); BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), "utf-8")); JsonParser parser = new JsonParser(); JsonObject object = (JsonObject) parser.parse(reader); reader.close(); connection.disconnect(); System.out.println("Q: " + question[i]); System.out.println("A: " + object.get("text")); &#125; &#125;&#125; Result]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Demo]]></title>
      <url>%2F2017%2F06%2F15%2FReact-Demo%2F</url>
      <content type="text"><![CDATA[React makes it painless to create interactive UIs. Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes. Declarative views make your code more predictable and easier to debug. Build encapsulated components that manage their own state, then compose them to make complex UIs. Since component logic is written in JavaScript instead of templates, you can easily pass rich data through your app and keep state out of the DOM. build an interactive tic-tac-toe gameWe have three components: Square Board Game The Square component renders a single button, the Board renders 9 squares, and the Game component renders a board with some placeholders. index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;reactDemo&lt;/title&gt; &lt;script src="https://unpkg.com/react@latest/dist/react.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/react-dom@latest/dist/react-dom.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="root"&gt;&lt;/div&gt;&lt;script type="text/babel" src="index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105class Game extends React.Component&#123; render() &#123; return ( &lt;div className="game"&gt; &lt;div className="game-board"&gt; &lt;Board /&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;class Board extends React.Component &#123; constructor()&#123; super(); this.state = &#123; squares: Array(9).fill(null), xIsNext: true, &#125;; &#125; handleClick(i)&#123; const squares = this.state.squares.slice(); if (calculateWinner(squares) || squares[i]) return; squares[i] = this.state.xIsNext ? 'X' : 'O'; this.setState(&#123; squares: squares, xIsNext: !this.state.xIsNext, &#125;); &#125; renderSquare(i) &#123; return ( &lt;Square value=&#123;this.state.squares[i]&#125; onClick=&#123;() =&gt; this.handleClick(i)&#125; /&gt; ); &#125; render() &#123; const winner = calculateWinner(this.state.squares); let status; if (winner) status = 'Winner: ' + winner; else status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O'); return ( &lt;div&gt; &lt;div className="status"&gt;&#123;status&#125;&lt;/div&gt; &lt;div className="board-row"&gt; &#123;this.renderSquare(0)&#125; &#123;this.renderSquare(1)&#125; &#123;this.renderSquare(2)&#125; &lt;/div&gt; &lt;div className="board-row"&gt; &#123;this.renderSquare(3)&#125; &#123;this.renderSquare(4)&#125; &#123;this.renderSquare(5)&#125; &lt;/div&gt; &lt;div className="board-row"&gt; &#123;this.renderSquare(6)&#125; &#123;this.renderSquare(7)&#125; &#123;this.renderSquare(8)&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;function Square(props) &#123; return ( &lt;button className="square" onClick=&#123;props.onClick&#125;&gt; &#123;props.value&#125; &lt;/button&gt; );&#125;function calculateWinner(squares) &#123; const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; for (let i = 0; i &lt; lines.length; i++) &#123; const [a, b, c] = lines[i]; if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) &#123; return squares[a]; &#125; &#125; return null;&#125;ReactDOM.render( &lt;Game /&gt;, document.getElementById('root')); result]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring Boot Demo]]></title>
      <url>%2F2017%2F06%2F07%2FSpring-Boot-Demo%2F</url>
      <content type="text"><![CDATA[Spring Boot offers a fast way to build applications. It looks at your classpath and at beans you have configured, makes reasonable assumptions about what you’re missing, and adds it. With Spring Boot you can focus more on business features and less on infrastructure. Build with Mavendirectory structure pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;springbootDemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; execute1mvn package Create a simple web applicationcreate a web controller1234567891011121314package hello;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.bind.annotation.RequestMapping;@RestControllerpublic class HelloController &#123; @RequestMapping("/") public String index() &#123; return "Greetings from Spring Boot!"; &#125;&#125; create an Application class12345678910111213package hello;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; result Add Testsmock the HTTP request cycle a simple unit test12345678910111213141516171819202122232425262728293031package hello;import static org.hamcrest.Matchers.equalTo;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.http.MediaType;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;@RunWith(SpringRunner.class)@SpringBootTest@AutoConfigureMockMvcpublic class HelloControllerTest &#123; @Autowired private MockMvc mvc; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/").accept(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().string(equalTo("Greetings from Spring Boot!"))); &#125;&#125; a very simple full-stack integration test1234567891011121314151617181920212223242526272829303132333435363738394041package hello;import static org.hamcrest.Matchers.equalTo;import static org.junit.Assert.assertThat;import java.net.URL;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.context.embedded.LocalServerPort;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.boot.test.web.client.TestRestTemplate;import org.springframework.http.ResponseEntity;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class HelloControllerIT &#123; @LocalServerPort private int port; private URL base; @Autowired private TestRestTemplate template; @Before public void setUp() throws Exception &#123; this.base = new URL("http://localhost:" + port + "/"); &#125; @Test public void getHello() throws Exception &#123; ResponseEntity&lt;String&gt; response = template.getForEntity(base.toString(), String.class); assertThat(response.getBody(), equalTo("Greetings from Spring Boot!")); &#125;&#125; result]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】复杂链表的复制]]></title>
      <url>%2F2017%2F05%2F16%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
      <content type="text"><![CDATA[题目请实现函数ComplexListNode Clone(ComplexListNode pHead)，复制一个复杂链表。在复杂链表中，每个结点除了有一个m_pNext指针指向下一个结点外，还有一个m_pSibling指向链表中的任意结点或者NULL。 实现123456789public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public RandomListNode Clone(RandomListNode pHead) &#123; CloneNodes(pHead); ConnectSiblingNodes(pHead); return ReconnectNodes(pHead);&#125;private void CloneNodes(RandomListNode pHead) &#123; RandomListNode node = pHead; while (node != null) &#123; RandomListNode clone = new RandomListNode(node.label); clone.next = node.next; node.next = clone; node = clone.next; &#125;&#125;private void ConnectSiblingNodes(RandomListNode pHead) &#123; RandomListNode node = pHead; while (node != null) &#123; if (node.random != null) node.next.random = node.random.next; node = node.next.next; &#125;&#125;private RandomListNode ReconnectNodes(RandomListNode pHead) &#123; RandomListNode node = pHead; RandomListNode cloneNode = null, cloneHead = null; if (node != null) &#123; cloneHead = cloneNode = node.next; node.next = cloneNode.next; node = node.next; &#125; while (node != null) &#123; cloneNode.next = node.next; cloneNode = cloneNode.next; node.next = cloneNode.next; node = node.next; &#125; return cloneHead;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】二叉树中和为某一值的路径]]></title>
      <url>%2F2017%2F05%2F16%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
      <content type="text"><![CDATA[题目输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 123456789101112131415161718192021222324public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; paths = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; path = new ArrayList&lt;&gt;(); FindPath(root, target, 0, path, paths); return paths;&#125;private void FindPath(TreeNode root, int target, int sum, ArrayList&lt;Integer&gt; path, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; paths) &#123; if (root == null) return; int currentSum = sum + root.val; path.add(root.val); if (currentSum == target &amp;&amp; root.left == null &amp;&amp; root.right == null) paths.add(new ArrayList(path)); FindPath(root.left, target, currentSum, path, paths); FindPath(root.right, target, currentSum, path, paths); path.remove(path.size() - 1);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】二叉搜索树的后序遍历序列]]></title>
      <url>%2F2017%2F05%2F16%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%2F</url>
      <content type="text"><![CDATA[题目输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。 实现12345678910111213141516171819202122232425public boolean VerifySquenceOfBST(int[] sequence) &#123; if (sequence.length == 0) return false; return VerifySquenceOfBST(sequence, 0, sequence.length - 1);&#125;private boolean VerifySquenceOfBST(int[] sequence, int start, int end)&#123; if (start &gt;= end) return true; int idx = start; for (; idx &lt; end; idx++)&#123; if (sequence[idx] &gt; sequence[end]) break; &#125; for (int i = idx + 1; i &lt; end; i++)&#123; if (sequence[i] &lt; sequence[end]) return false; &#125; return VerifySquenceOfBST(sequence, start, idx - 1) &amp;&amp; VerifySquenceOfBST(sequence, idx, end - 1);&#125; 相关题目输入一个整数数组，判断该数组是不是某二叉搜索树的前序遍历的结果。这和前面问题的后序遍历很类似，只是在前序遍历得到的序列中，第一个数字是根结点的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】从上往下打印二叉树]]></title>
      <url>%2F2017%2F05%2F16%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
      <content type="text"><![CDATA[题目从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819202122public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty())&#123; TreeNode node = queue.poll(); result.add(node.val); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); &#125; return result;&#125; 相关题目如何广度优先遍历一个有向图》这同样也可以基于队列实现。树是图的一种特殊退化形式，从上到下按层遍历二叉树，从本质上来说就是广度优先遍历二叉树。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】栈的压入、弹出序列]]></title>
      <url>%2F2017%2F05%2F15%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97%2F</url>
      <content type="text"><![CDATA[题目输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1、2、3、4、5是某栈的压栈序列，序列4、5、3、2、1是该压栈序列对应的一个弹出序列，但4、3、5、1、2就不可能是该压栈序列的弹出序列。 实现12345678910111213141516public boolean IsPopOrder(int[] pushA, int[] popA) &#123; int popPos = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; pushA.length; i++)&#123; if (stack.isEmpty() || stack.peek() != popA[popPos]) stack.push(pushA[i]); while (!stack.isEmpty() &amp;&amp; stack.peek() == popA[popPos])&#123; stack.pop(); popPos++; &#125; &#125; return stack.isEmpty();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】包含min函数的栈]]></title>
      <url>%2F2017%2F05%2F15%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%2F</url>
      <content type="text"><![CDATA[题目定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O(1)。 实现123456789101112131415161718192021222324Stack&lt;Integer&gt; data = new Stack&lt;&gt;();Stack&lt;Integer&gt; min = new Stack&lt;&gt;();public void push(int node) &#123; data.push(node); if (min.size() == 0 || node &lt; min.peek()) min.push(node); else min.push(min.peek());&#125;public void pop() &#123; data.pop(); min.pop();&#125;public int top() &#123; return data.peek();&#125;public int min() &#123; return min.peek();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】顺时针打印矩阵]]></title>
      <url>%2F2017%2F05%2F14%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%2F</url>
      <content type="text"><![CDATA[题目输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 实现1234567891011121314151617181920212223242526272829303132333435363738public ArrayList&lt;Integer&gt; printMatrix(int[][] matrix) &#123; int rows = matrix.length; int columns = matrix[0].length; int start = 0; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); while (2 * start &lt; rows &amp;&amp; 2 * start &lt; columns)&#123; printMatrixInCircle(result, matrix, start); start++; &#125; return result;&#125;private void printMatrixInCircle(ArrayList&lt;Integer&gt; result, int[][] matrix, int start)&#123; int rows = matrix.length; int columns = matrix[0].length; int endX = columns - start - 1; int endY = rows - start - 1; for (int i = start; i &lt;= endX; i++) result.add(matrix[start][i]); if (start &lt; endY)&#123; for (int i = start + 1; i &lt;= endY; i++) result.add(matrix[i][endX]); &#125; if (start &lt; endX &amp;&amp; start &lt; endY)&#123; for (int i = endX - 1; i &gt;= start; i--) result.add(matrix[endY][i]); &#125; if (start &lt; endY - 1 &amp;&amp; start &lt; endX)&#123; for (int i = endY - 1; i &gt; start; i--) result.add(matrix[i][start]); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】二叉树的镜像]]></title>
      <url>%2F2017%2F05%2F14%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%2F</url>
      <content type="text"><![CDATA[题目请完成一个函数，输入一个二叉树，该函数输出它的镜像。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213public void Mirror(TreeNode root) &#123; if (root == null) return; else if (root.left == null &amp;&amp; root.right == null) return; TreeNode tmp = root.left; root.left = root.right; root.right = tmp; Mirror(root.left); Mirror(root.right);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】树的子结构]]></title>
      <url>%2F2017%2F05%2F14%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[题目输入两棵二叉树A和B，判断B是不是A的子结构。 实现123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 123456789101112131415161718192021222324252627public boolean HasSubtree(TreeNode root1, TreeNode root2) &#123; boolean result = false; if (root1 != null &amp;&amp; root2 != null)&#123; if (root1.val == root2.val) result = DoesTree1HasTree2(root1, root2); if (result == false) result = HasSubtree(root1.left, root2); if (result == false) result = HasSubtree(root1.right, root2); &#125; return result;&#125;private boolean DoesTree1HasTree2(TreeNode root1, TreeNode root2)&#123; if (root2 == null) return true; else if (root1 == null) return false; else if (root1.val != root2.val) return false; return DoesTree1HasTree2(root1.left, root2.left) &amp;&amp; DoesTree1HasTree2(root1.right, root2.right);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】合并两个排序的链表]]></title>
      <url>%2F2017%2F05%2F14%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[题目输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。 实现12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819public ListNode Merge(ListNode list1, ListNode list2) &#123; if (list1 == null) return list2; else if (list2 == null) return list1; ListNode head = null; if (list1.val &lt; list2.val)&#123; head = list1; head.next = Merge(list1.next, list2); &#125; else &#123; head = list2; head.next = Merge(list1, list2.next); &#125; return head;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】反转链表]]></title>
      <url>%2F2017%2F05%2F14%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[题目定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。 实现12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 123456789101112131415161718public ListNode ReverseList(ListNode head) &#123; ListNode current = head; ListNode previous = null; ListNode tail = null; while (current != null)&#123; ListNode next = current.next; if (next == null) tail = current; current.next = previous; previous = current; current = next; &#125; return tail;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】链表中倒数第k个结点]]></title>
      <url>%2F2017%2F05%2F14%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
      <content type="text"><![CDATA[题目输入一个链表，输出该链表中倒数第k个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是值为4的结点。 实现12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 123456789101112131415161718192021public ListNode FindKthToTail(ListNode head, int k) &#123; if (k == 0 || head == null) return null; ListNode ahead = head; ListNode behind = head; for (int i = 1; i &lt; k; i++) &#123; if (ahead.next == null) return null; ahead = ahead.next; &#125; while (ahead.next != null)&#123; ahead = ahead.next; behind = behind.next; &#125; return behind;&#125; 相关题目 求链表的中间结点。如果链表中结点总数为奇数，返回中间结点；如果结点总数是偶数，返回中间两个结点的任意一个。我们也可以定义两个指针，同时从链表的头结点出发，一个指针一次走一步，另一个指针一次走两步。当走得快的指针走到链表的末尾时，走得慢的指针正好在链表的中间。 判断一个单向链表是否形成了环形结构。定义两个指针，同时从链表的头结点出发，一个指针一次走一步，另一个指针一次走两步。如果走得快的指针追上了走得慢的指针，那么链表就是环形链表；如果走得快的指针走到了链表的末尾都没有追上第一个指针，那么链表就不是环形链表。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】调整数组顺序使奇数位于偶数前面]]></title>
      <url>%2F2017%2F05%2F13%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%2F</url>
      <content type="text"><![CDATA[题目输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 只完成基本功能的解法，仅适用于初级程序员123456789101112131415161718public void reOrderArray(int[] array) &#123; int begin = 0; int end = array.length - 1; while (begin &lt; end)&#123; while (begin &lt; end &amp;&amp; (array[begin] &amp; 1) == 1) begin++; while (begin &lt; end &amp;&amp; (array[end] &amp; 1) != 1) end--; if (begin &lt; end)&#123; int tmp = array[end]; array[end] = array[begin]; array[begin] = tmp; &#125; &#125;&#125; 考虑可扩展性的解法，能秒杀Offer12345678910111213141516171819202122public void reOrderArray(int[] array) &#123; int begin = 0; int end = array.length - 1; while (begin &lt; end)&#123; while (begin &lt; end &amp;&amp; isOdd(array[begin])) begin++; while (begin &lt; end &amp;&amp; !isOdd(array[end])) end--; if (begin &lt; end)&#123; int tmp = array[end]; array[end] = array[begin]; array[begin] = tmp; &#125; &#125;&#125;private boolean isOdd(int n)&#123; return (n &amp; 1) == 1;&#125; 本题扩展输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 实现12345678910111213141516171819202122232425public void reOrderArray(int[] array) &#123; int[] aux = new int[array.length]; int countOdd = 0; for (int i = 0; i &lt; array.length; i++) &#123; aux[i] = array[i]; if (isOdd(array[i])) countOdd++; &#125; int oddPos = 0; int evenPos = countOdd; for (int i = 0; i &lt; aux.length; i++)&#123; if (isOdd(aux[i])) array[oddPos++] = aux[i]; else array[evenPos++] = aux[i]; &#125;&#125;private boolean isOdd(int n)&#123; return (n &amp; 1) == 1;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】在O(1)时间删除链表结点]]></title>
      <url>%2F2017%2F05%2F13%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%9C%A8O-1-%E6%97%B6%E9%97%B4%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%2F</url>
      <content type="text"><![CDATA[题目给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。 实现12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 1234567891011121314public void deleteNode(ListNode head, ListNode node)&#123; if (node.next != null)&#123; node.val = node.next.val; node.next = node.next.next; &#125; else if (head == node) head = null; else &#123; while (head.next != node) head = head.next; head.next = null; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】打印1到最大的n位数]]></title>
      <url>%2F2017%2F05%2F13%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%89%93%E5%8D%B01%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0%2F</url>
      <content type="text"><![CDATA[题目输入数字n，按顺序打印出从1到最大的n为十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。 跳进面试官的陷阱123456public void Print1ToMaxOfNDigits(int n) &#123; int number = (int) Math.pow(10, n); for (int i = 1; i &lt; number; i++) System.out.println(i);&#125; 在字符串上模拟数字加法的解法，绕过陷阱才能拿到Offer123456789101112131415161718192021222324252627282930313233343536373839404142434445public void Print1ToMaxOfNDigits(int n) &#123; char[] number = new char[n]; Arrays.fill(number, '0'); while (!Increment(number))&#123; PrintNumber(number); System.out.println(); &#125;&#125;private boolean Increment(char[] number)&#123; int carry = 0; for (int i = number.length - 1; i &gt;= 0; i--)&#123; int sum = number[i] - '0' + carry; if (i == number.length - 1) sum++; carry = sum / 10; if (carry == 1)&#123; if (i == 0) return true; number[i] = (char) (sum % 10 + '0'); &#125; else number[i] = (char) (sum + '0'); &#125; return false;&#125;private void PrintNumber(char[] number)&#123; boolean isBeginning0 = true; for (int i = 0; i &lt; number.length; i++)&#123; if (isBeginning0 == true &amp;&amp; number[i] != '0') isBeginning0 = false; if (isBeginning0 == false) System.out.print(number[i]); &#125;&#125; 把问题转换成数字排列的解法，递归让代码更简洁123456789101112131415161718192021222324252627282930313233343536public void Print1ToMaxOfNDigits(int n) &#123; char[] number = new char[n]; Arrays.fill(number, '0'); for (int i = 0; i &lt;= 9; i++)&#123; number[0] = (char) (i + '0'); Print1ToMaxOfNDigits(number, 0); &#125;&#125;private void Print1ToMaxOfNDigits(char[] number, int index)&#123; if (index == number.length - 1)&#123; PrintNumber(number); return; &#125; for (int i = 0; i &lt;= 9; i++) &#123; number[index+1] = (char) (i + '0'); Print1ToMaxOfNDigits(number, index + 1); &#125;&#125;private void PrintNumber(char[] number)&#123; boolean isBeginning0 = true; for (int i = 0; i &lt; number.length; i++)&#123; if (isBeginning0 == true &amp;&amp; number[i] != '0') isBeginning0 = false; if (isBeginning0 == false) System.out.print(number[i]); &#125; if (isBeginning0 == false) System.out.println();&#125; 相关题目定义一个函数，在该函数中可以实现任意两个整数的加法。由于没有限定输入两个数的大小范围，我们也要把它当做大数问题来处理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】数值的整数次方]]></title>
      <url>%2F2017%2F05%2F12%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%2F</url>
      <content type="text"><![CDATA[题目实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 自以为题目简单的解法1234567891011public double Power(double base, int exponent) &#123; double result = 1; for (int i = 1; i &lt;= Math.abs(exponent); i++) result *= base; if (exponent &lt; 0) result = 1 / result; return result;&#125; 全面又高效的解法，确保我们能拿到Offer123456789101112131415161718public double Power(double base, int exponent) &#123; if (exponent == 1) return base; else if (exponent == 0) return 1; double result = Power(base, Math.abs(exponent) &gt;&gt; 1); result *= result; if ((exponent &amp; 1) == 1) result *= base; if (exponent &lt; 0) result = 1 / result; return result;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】二进制中1的个数]]></title>
      <url>%2F2017%2F05%2F12%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
      <content type="text"><![CDATA[题目请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。 可能引起死循环的解法123456789101112public int NumberOf1(int n) &#123; int count = 0; while (n != 0)&#123; if ((n &amp; 1) == 1) count++; n = n &gt;&gt; 1; &#125; return count;&#125; 常规解法12345678910111213public int NumberOf1(int n) &#123; int count = 0; int flag = 1; while (flag != 0)&#123; if ((n &amp; flag) == flag) count++; flag = flag &lt;&lt; 1; &#125; return count;&#125; 能给面试官带来惊喜的解法12345678910public int NumberOf1(int n) &#123; int count = 0; while (n != 0)&#123; count++; n = n &amp; (n - 1); &#125; return count;&#125; 相关题目 用一条语句判断一个整数是不是2的整数次方。一个整数如果是2的整数次方，那么它的二进制表示中有且只有一位是1，而其他所有位都是0.根据前面的分析，把这个整数减去1之后再和它自己做与运算，这个整数中唯一的1就会变成0. 输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n。比如10的二进制表示为1010，13的二进制表示为1101，需要改变1010中的3位才能得到1101.我们可以分为两步解决这个问题：第一步求这两个数的异或，第二步统计异或结果中1的位数。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】斐波那契数列]]></title>
      <url>%2F2017%2F05%2F12%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
      <content type="text"><![CDATA[题目写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。 效率很低的解法，挑剔的面试官不会喜欢123456public int Fibonacci(int n) &#123; if (n == 0 || n == 1) return n; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125; 面试官期待的实用解法123456789101112131415public static int Fibonacci(int n) &#123; if (n == 0 || n == 1) return n; int fib1 = 0; int fib2 = 1; for (int i = 2; i &lt;= n; i++)&#123; int current = fib1 + fib2; fib1 = fib2; fib2 = current; &#125; return fib2;&#125; 时间复杂度O(logn)但不够实用的解法相关题目跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 实现123456public int JumpFloor(int target) &#123; if (target == 1 || target == 2) return target; return JumpFloor(target - 1) + JumpFloor(target - 2);&#125; 变态跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。此时该青蛙跳上一个n级的台阶总共有多少种跳法？ 实现123456public int JumpFloorII(int target) &#123; if (target == 0 || target == 1) return 1; return 2 * JumpFloorII(target - 1);&#125; 矩形覆盖我们可以用2x1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2x1的小矩形无重叠地覆盖一个2xn的大矩形，总共有多少种方法？ 实现123456public int RectCover(int target) &#123; if (target == 0 || target == 1 || target == 2) return target; return RectCover(target - 1) + RectCover(target - 2);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】旋转数组的最小数字]]></title>
      <url>%2F2017%2F05%2F12%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%2F</url>
      <content type="text"><![CDATA[题目把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 实现1234567891011121314151617181920212223242526272829303132public int minNumberInRotateArray(int[] array) &#123; int left = 0; int right = array.length - 1; int mid = left; while (array[left] &gt;= array[right])&#123; if (right - left == 1) &#123; mid = right; break; &#125; mid = (left + right) / 2; if (array[mid] == array[left] &amp;&amp; array[mid] == array[right]) return minInOrder(array, left, right); else if (array[mid] &gt;= array[left]) left = mid; else if (array[mid] &lt;= array[right]) right = mid; &#125; return array[mid];&#125;private int minInOrder(int[] array, int left, int right)&#123; int min = array[left]; for (int i = left + 1; i &lt;= right; i++) min = Math.min(min, array[i]); return min;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】用两个栈实现队列]]></title>
      <url>%2F2017%2F05%2F11%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
      <content type="text"><![CDATA[题目用两个栈实现一个队列。分别完成在队列尾部插入结点和在队列头部删除结点的功能。 实现123456789101112131415Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();public void push(int node) &#123; stack1.push(node);&#125;public int pop() &#123; if (stack2.isEmpty())&#123; while (!stack1.isEmpty()) stack2.push(stack1.pop()); &#125; return stack2.pop();&#125; 相关题目用两个队列实现一个栈。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】重建二叉树]]></title>
      <url>%2F2017%2F05%2F11%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
      <content type="text"><![CDATA[题目输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出二叉树并输出它的头结点。 实现123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415161718192021public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; return reConstructBinaryTree(pre, in, 0, pre.length - 1, 0, in.length - 1);&#125;private TreeNode reConstructBinaryTree(int[] pre, int[] in, int startPreorder, int endPreorder, int startInorder, int endInorder)&#123; if (startPreorder &gt; endPreorder || startInorder &gt; endInorder) return null; TreeNode node = new TreeNode(pre[startPreorder]); for (int i = startInorder; i &lt;= endInorder; i++)&#123; if (in[i] == pre[startPreorder])&#123; int leftLength = i - startInorder; node.left = reConstructBinaryTree(pre, in, startPreorder + 1, startPreorder + leftLength, startInorder, i - 1); node.right = reConstructBinaryTree(pre, in, startPreorder + leftLength + 1, endPreorder, i + 1, endInorder); break; &#125; &#125; return node;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】从尾到头打印链表]]></title>
      <url>%2F2017%2F05%2F11%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[题目输入一个链表的头结点，从尾到头反过来打印出每个结点的值。 实现12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 12345678910ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; if (listNode != null)&#123; printListFromTailToHead(listNode.next); list.add(listNode.val); &#125; return list;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】替换空格]]></title>
      <url>%2F2017%2F05%2F10%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[题目请实现一个函数，把字符串中的每个空格替换成“%20”。例如输入“We are happy.”，则输出“We%20are%20happy.“。 时间复杂度为O(n^2)的解法，不足以拿到Offer时间复杂度为O(n)的解法，搞定Offer就靠它了123456789101112131415161718192021222324252627282930public String replaceSpace(StringBuffer str) &#123; int originalLength = str.length(); int numberOfBlank = 0; for (int i = 0; i &lt; originalLength; i++)&#123; if (str.charAt(i) == ' ') numberOfBlank++; &#125; int newLength = originalLength + 2 * numberOfBlank; str.setLength(newLength); int indexOfOriginal = originalLength - 1; int indexOfNew = newLength - 1; while (indexOfNew &gt; indexOfOriginal)&#123; if (str.charAt(indexOfOriginal) == ' ')&#123; str.setCharAt(indexOfNew, '0'); str.setCharAt(--indexOfNew, '2'); str.setCharAt(--indexOfNew, '%'); &#125; else str.setCharAt(indexOfNew, str.charAt(indexOfOriginal)); indexOfNew--; indexOfOriginal--; &#125; return str.toString();&#125; 相关题目有两个排序的数组A1和A2，内存在A1的末尾有足够多的空余空间容纳A2。请实现一个函数，把A2中的所有数字插入到A1中并且所有的数字是排序的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】二维数组中的查找]]></title>
      <url>%2F2017%2F05%2F10%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
      <content type="text"><![CDATA[题目在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 实现123456789101112131415public boolean Find(int target, int[][] array) &#123; int rows = 0; int columns = array[0].length - 1; while (rows &lt; array.length &amp;&amp; columns &gt;= 0)&#123; if (array[rows][columns] &lt; target) rows++; else if (array[rows][columns] &gt; target) columns--; else return true; &#125; return false;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【剑指Offer】实现Singleton模式]]></title>
      <url>%2F2017%2F05%2F09%2F%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91%E5%AE%9E%E7%8E%B0Singleton%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[题目设计一个类，我们只能生成该类的一个实例。 不好的解法一：只适用于单线程环境1234567891011121314public class Singleton1&#123; private static Singleton1 instance = null; private Singleton1()&#123; &#125; public static Singleton1 getInstance()&#123; if (instance == null) instance = new Singleton1(); return instance; &#125;&#125; 不好的解法二：虽然在多线程环境中能工作但效率不高1234567891011121314public class Singleton2&#123; private static Singleton2 instance = null; private Singleton2()&#123; &#125; public static synchronized Singleton2 getInstance()&#123; if (instance == null) instance = new Singleton2(); return instance; &#125;&#125; 可行的解法：加同步锁前后两次判断实例是否已存在123456789101112131415161718public class Singleton3&#123; private static Singleton3 instance = null; private Singleton3()&#123; &#125; public static Singleton3 getInstance()&#123; if (instance == null)&#123; synchronized (Singleton3.class)&#123; if (instance == null) instance = new Singleton3(); &#125; &#125; return instance; &#125;&#125; 强烈推荐的解法一：利用静态构造函数1234567891011public class Singleton4&#123; private static Singleton4 instance = new Singleton4(); private Singleton4()&#123; &#125; public static Singleton4 getInstance()&#123; return instance; &#125;&#125; 强烈推荐的解法二：实现按需创建实例12345678910111213public class Singleton5&#123; private Singleton5()&#123; &#125; public static Singleton5 getInstance()&#123; return Nested.instance; &#125; private static class Nested&#123; private static Singleton5 instance = new Singleton5(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【算法】图]]></title>
      <url>%2F2017%2F04%2F16%2F%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[union-find算法动态连通性 quick-find算法示意 实现123456789101112131415161718public void union(int p, int q)&#123; int pID = find(p); int qID = find(q); if (pID == qID) return; for (int i = 0; i &lt; id.length; i++)&#123; if (id[i] == pID) id[i] = qID; &#125; count--;&#125;public int find(int p)&#123; return id[p];&#125; 特点在quick-find算法中，每次find调用只需要访问数组一次，而归并两个分量的union操作访问数组的次数在N+3到2N+1之间。 quick-union算法示意 实现123456789101112131415161718public void union(int p, int q)&#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; id[pRoot] = qRoot; count--;&#125;public int find(int p)&#123; while (id[p] != p) p = id[p]; return id[p];&#125; 特点 quick-union算法中的find方法访问数组的次数为1加上给定触点所对应的节点的深度的两倍。union和connected访问数组的次数为两次find操作（如果union中给定的两个触点分别在不同的树中则还需要加1）。 加权quick-union算法记录每一棵树的大小并总是将较小的树连接到较大的树上。 示意 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class UnionFind &#123; private int[] id; private int[] size; private int count; public UnionFind(int n)&#123; count = n; id = new int[n]; size = new int[n]; for (int i = 0; i &lt; n; i++)&#123; id[i] = i; size[i] = 1; &#125; &#125; public int count()&#123; return count; &#125; public boolean connected(int p, int q)&#123; return find(p) == find(q); &#125; public void union(int p, int q)&#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; if (size[pRoot] &lt; size[qRoot])&#123; id[pRoot] = qRoot; size[qRoot] += size[pRoot]; &#125; else&#123; id[qRoot] = pRoot; size[pRoot] += size[qRoot]; &#125; count--; &#125; public int find(int p)&#123; while (id[p] != p) p = id[p]; return id[p]; &#125;&#125; 特点对于N个触点，加权quick-union算法构造的森林中的任意节点的深度最多为lgN。 对于加权quick-union算法和N个触点，在最坏情况下find、connected和union的成本的增长数量级为lgN。 总结 无向图深度优先搜索要搜索一幅图，只需用一个递归方法来遍历所有顶点。在访问其中一个顶点时： 将它标记为已访问 递归地访问它的所有没有被标记过的邻居顶点 如果图是连通的，每个连接链表中的元素都会被检查到。 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142public class DepthFirstPaths &#123; private final int s; private boolean[] marked; private int[] edgeTo; public DepthFirstPaths(Graph g, int s)&#123; this.s = s; marked = new boolean[g.V()]; edgeTo = new int[g.V()]; dfs(g, s); &#125; private void dfs(Graph g, int v)&#123; marked[v] = true; for (int w : g.adj(v))&#123; if (marked[w] == false)&#123; edgeTo[w] = v; dfs(g, w); &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return marked[v]; &#125; public Iterable&lt;Integer&gt; pathTo(int v)&#123; if (!hasPathTo(v)) return null; Stack&lt;Integer&gt; path = new Stack&lt;Integer&gt;(); path.push(v); while (v != s)&#123; path.push(edgeTo[v]); v = edgeTo[v]; &#125; return path; &#125;&#125; 特点深度优先搜索标记与起点连通的所有顶点所需的时间和顶点的度数之和成正比。 使用深度优先搜索得到从给定起点到任意标记顶点的路径所需的时间与路径的长度成正比。 单点路径：给定一幅图和一个起点s，回答“从s到给定目的顶点v是否存在一条路径？如果有，找出这条路径。”等类似问题。 广度优先搜索使用一个队列来保存所有已经被标记过但其邻接表还未被检查过的顶点。先将起点加入队列，然后重复以下步骤直到队列为空： 取队列中的下一个顶点v并标记它 将与v相邻的所有未被标记过的顶点加入队列 示意 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class BreadthFirstPaths &#123; private final int s; private boolean[] marked; private int[] edgeTo; public BreadthFirstPaths(Graph g, int s)&#123; this.s = s; marked = new boolean[g.V()]; edgeTo = new int[g.V()]; bfs(g, s); &#125; private void bfs(Graph g, int s)&#123; Queue&lt;Integer&gt; queue = new Queue&lt;Integer&gt;(); marked[s] = true; queue.enqueue(s); while(!queue.isEmpty())&#123; int v = queue.dequeue(); for (int w : g.adj(v))&#123; if (marked[w] == false)&#123; marked[w] = true; queue.enqueue(w); edgeTo[w] = v; &#125; &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return marked[v]; &#125; public Iterable&lt;Integer&gt; pathTo(int v)&#123; if (!hasPathTo(v)) return null; Stack&lt;Integer&gt; path = new Stack&lt;Integer&gt;(); path.push(v); while (v != s)&#123; path.push(edgeTo[v]); v = edgeTo[v]; &#125; return path; &#125;&#125; 特点对于从s可达的任意顶点v，广度优先搜索都能找到一条从s到v的最短路径（没有其他从s到v的路径所含的边比这条路径更少）。 广度优先搜索所需的时间在最坏情况下和V+E成正比。 单点最短路径：给定一幅图和一个起点s，回答“从s到给定目的顶点v是否存在一条路径？如果有，找出其中最短的那条（所含边数最少）。”等类似问题。 比较在搜索中都会先将起点存入数据结构中，然后重复以下步骤直到数据结构被清空： 取其中的下一个顶点并标记它 将v的所有相邻而又未被标记的顶点加入数据结构 这两个算法的不同之处仅在于从数据结构中获取下一个顶点的规则（对于广度优先搜索来说是最早加入的顶点，对于深度优先搜索来说是最晚加入的顶点）。 连通分量深度优先搜索的直接应用是找出一幅图的所有连通分量。它能够将所有顶点切分为等价类。 示意 实现12345678910111213141516171819202122232425262728293031323334353637383940public class ConnectedComponents &#123; private int count; private boolean[] marked; private int[] id; public ConnectedComponents(Graph g)&#123; count = 0; marked = new boolean[g.V()]; id = new int[g.V()]; for (int s = 0; s &lt; g.V(); s++)&#123; if (marked[s] == false)&#123; dfs(g, s); count++; &#125; &#125; &#125; private void dfs(Graph g, int v)&#123; marked[v] = true; id[v] = count; for (int w : g.adj(v))&#123; if (marked[w] == false) dfs(g, w); &#125; &#125; public boolean connected(int v, int w)&#123; return id[v] == id[w]; &#125; public int id(int v)&#123; return id[v]; &#125; public int count()&#123; return count; &#125;&#125; 特点深度优先搜索的预处理使用的时间和空间与V+E成正比且可以在常数时间内处理关于图的连通性查询。 比较union-find算法其实更快，因为它不需要完整地构造并表示一幅图，是一种动态算法（在任何时候都能用接近常数的时间检查两个顶点是否连通，甚至是在添加一条边的时候），但深度优先搜索则必须要对图进行预处理。因此，在完成只需要判断连通性或是需要完成有大量连通性查询和插入操作混合等类似的任务时，更倾向使用union-find算法，而深度优先搜索则更适合实现图的抽象数据类型，因为它能更有效地利用已有的数据结构。 检测环给定的图是无环图吗？ 实现1234567891011121314151617181920212223242526272829public class Cycle &#123; private boolean[] marked; private boolean hasCycle; public Cycle(Graph g)&#123; marked = new boolean[g.V()]; hasCycle = false; for (int s = 0; s &lt; g.V(); s++)&#123; if (marked[s] == false) dfs(g, s, s); &#125; &#125; private void dfs(Graph g, int v, int p)&#123; marked[v] = true; for (int w : g.adj(v))&#123; if (marked[w] == false) dfs(g, w, v); else if (w != p) hasCycle = true; &#125; &#125; public boolean hasCycle()&#123; return hasCycle; &#125;&#125; 双色问题能够用两种颜色将图的所有顶点着色，使得任意一条边的两个端点的颜色都不相同吗？（这是一幅二分图吗？） 实现123456789101112131415161718192021222324252627282930313233public class TwoColor &#123; private boolean[] marked; private boolean[] color; private boolean isTwoColorable; public TwoColor(Graph g)&#123; marked = new boolean[g.V()]; color = new boolean[g.V()]; isTwoColorable = true; for (int s = 0; s &lt; g.V(); s++)&#123; if (marked[s] == false) dfs(g, s); &#125; &#125; private void dfs(Graph g, int v)&#123; marked[v] = true; for (int w : g.adj(v))&#123; if (marked[w] == false)&#123; color[w] = !color[v]; dfs(g, w); &#125; else if (color[w] == color[v]) isTwoColorable = false; &#125; &#125; public boolean isBipartite()&#123; return isTwoColorable; &#125;&#125; 有向图深度优先搜索实现123456789101112131415161718192021222324252627282930313233343536373839404142public class DepthFirstDirectedPaths &#123; private final int s; private boolean[] marked; private int[] edgeTo; public DepthFirstDirectedPaths(Digraph g, int s)&#123; this.s = s; marked = new boolean[g.V()]; edgeTo = new int[g.V()]; dfs(g, s); &#125; private void dfs(Digraph g, int v)&#123; marked[v] = true; for (int w : g.adj(v))&#123; if (marked[w] == false)&#123; edgeTo[w] = v; dfs(g, w); &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return marked[v]; &#125; public Iterable&lt;Integer&gt; pathTo(int v)&#123; if (!hasPathTo(v)) return null; Stack&lt;Integer&gt; path = new Stack&lt;Integer&gt;(); path.push(v); while (v != s)&#123; path.push(edgeTo[v]); v = edgeTo[v]; &#125; return path; &#125;&#125; 特点在有向图中，深度优先搜索标记由一个集合的顶点可达的所有顶点所需的时间与被标记的所有顶点的出度之和成正比。 单向有向路径给定一幅有向图和一个起点s，回答“从s到给定目的顶点v是否存在一条有向路径？如果有，找出这条路径。”等类似问题。 广度优先搜索实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class BreadthFirstDirectedPaths &#123; private final int s; private boolean[] marked; private int[] edgeTo; public BreadthFirstDirectedPaths(Digraph g, int s)&#123; this.s = s; marked = new boolean[g.V()]; edgeTo = new int[g.V()]; bfs(g, s); &#125; private void bfs(Digraph g, int v)&#123; Queue&lt;Integer&gt; queue = new Queue&lt;Integer&gt;(); marked[v] = true; queue.enqueue(v); while (!queue.isEmpty())&#123; int x = queue.dequeue(); for (int w : g.adj(x))&#123; if (marked[w] == false)&#123; marked[w] = true; edgeTo[w] = x; queue.enqueue(w); &#125; &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return marked[v]; &#125; public Iterable&lt;Integer&gt; pathTo(int v)&#123; if (!hasPathTo(v)) return null; Stack&lt;Integer&gt; path = new Stack&lt;Integer&gt;(); path.push(v); while (v != s)&#123; path.push(edgeTo[v]); v = edgeTo[v]; &#125; return path; &#125;&#125; 特点单点最短有向路径给定一幅有向图和一个起点s，回答“从s到给定目的顶点v是否存在一条有向路径？如果有，找出其中最短的那条（所含边数最少）。”等类似问题。 有向环检测给定的有向图中包含有向环吗？如果有，按照路径的方向从某个顶点并返回自己来找到环上的所有顶点。 定义有向无环图（DAG）就是一幅不含有环的有向图。 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class DirectedCycle &#123; private boolean[] marked; private int[] edgeTo; private boolean[] onStack; private Stack&lt;Integer&gt; cycle; public DirectedCycle(Digraph g)&#123; marked = new boolean[g.V()]; edgeTo = new int[g.V()]; onStack = new boolean[g.V()]; for (int v = 0; v &lt; g.V(); v++)&#123; if (marked[v] == false) dfs(g, v); &#125; &#125; private void dfs(Digraph g, int v)&#123; marked[v] = true; onStack[v] = true; for (int w : g.adj(v))&#123; if (hasCycle()) return; else if (marked[w] == false)&#123; edgeTo[w] = v; dfs(g, w); &#125; else if (onStack[w] == true)&#123; cycle = new Stack&lt;Integer&gt;(); int x = v; cycle.push(x); while (x != w)&#123; cycle.push(edgeTo[x]); x = edgeTo[x]; &#125; cycle.push(v); &#125; &#125; onStack[v] = false; &#125; public boolean hasCycle()&#123; return cycle != null; &#125; public Iterable&lt;Integer&gt; cycle()&#123; return cycle; &#125;&#125; 拓扑排序给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素（或者说明无法做到这一点）。 定义当且仅当一幅有向图是无环图时它才能进行拓扑排序。 一幅有向无环图的拓扑排序即为所有顶点的逆后序排列。 基于深度优先搜索的顶点排序将dfs的参数顶点保存在一个数据结构中，遍历这个数据结构实际上就能访问图中的所有顶点。顶点有以下三种排列顺序： 前序：在递归调用之前将顶点加入队列 后序：在递归调用之后将顶点加入队列 逆后序：在递归调用之后将顶点压入栈 示意 实现12345678910111213141516171819202122232425262728293031323334353637383940414243public class DepthFirstOrder &#123; private boolean[] marked; private Queue&lt;Integer&gt; pre; private Queue&lt;Integer&gt; post; private Stack&lt;Integer&gt; reversePost; public DepthFirstOrder(Digraph g)&#123; marked = new boolean[g.V()]; pre = new Queue&lt;Integer&gt;(); post = new Queue&lt;Integer&gt;(); reversePost = new Stack&lt;Integer&gt;(); for (int v = 0; v &lt; g.V(); v++)&#123; if (marked[v] == false) dfs(g, v); &#125; &#125; private void dfs(Digraph g, int v)&#123; marked[v] = true; pre.enqueue(v); for (int w : g.adj(v))&#123; if (marked[w] == false) dfs(g, w); &#125; post.enqueue(v); reversePost.push(v); &#125; public Iterable&lt;Integer&gt; pre()&#123; return pre; &#125; public Iterable&lt;Integer&gt; post()&#123; return post; &#125; public Iterable&lt;Integer&gt; reversePost()&#123; return reversePost; &#125;&#125; 示意 实现123456789101112131415161718192021public class Topological &#123; private Iterable&lt;Integer&gt; order; public Topological(Digraph g)&#123; DirectedCycle cycle = new DirectedCycle(g); if (!cycle.hasCycle())&#123; DepthFirstOrder dfs = new DepthFirstOrder(g); order = dfs.reversePost(); &#125; &#125; public Iterable&lt;Integer&gt; order()&#123; return order; &#125; public boolean isDAG()&#123; return order != null; &#125;&#125; 特点使用深度优先搜索对有向无环图进行拓扑排序所需的时间和V+E成正比。 强连通性使用深度优先搜索查找给定有向图G的反向图G’，根据由此得到的所有顶点的逆后序再次用深度优先搜索处理有向图G（Kosaraju算法），其构造函数中的每一次递归调用所标记的顶点都在同一个强连通分量之中。 示意 实现1234567891011121314151617181920212223242526272829303132333435363738394041public class KosarajuSCC &#123; private boolean[] marked; private int[] id; private int count; public KosarajuSCC(Digraph g)&#123; marked = new boolean[g.V()]; id = new int[g.V()]; count = 0; DepthFirstOrder order = new DepthFirstOrder(g.reverse()); for (int v : order.reversePost())&#123; if (marked[v] == false)&#123; dfs(g, v); count++; &#125; &#125; &#125; private void dfs(Digraph g, int v)&#123; marked[v] = true; id[v] = count; for (int w : g.adj(v))&#123; if (marked[w] == false) dfs(g, w); &#125; &#125; public boolean stronglyConnected(int v, int w)&#123; return id[v] == id[w]; &#125; public int id(int v)&#123; return id[v]; &#125; public int count()&#123; return count; &#125;&#125; 特点Kosaraju算法的预处理所需的时间和空间与V+E成正比且支持常数时间的有向图强连通性的查询。 给定一幅有向图，回答“给定的两个顶点是强连通的吗？这幅有向图中含有多少个强连通分量？”等类似问题。 最小生成树Prim算法每一步都会为一棵生长中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加V-1条边，每次总是将下一条连接树中的顶点与不在树中的顶点且权重最小的边（黑色表示）加入树中（即由树中的顶点所定义的切分中的一条横向边）。 每当向树中添加了一条边之后，也向树中添加了一个顶点。要维护一个包含所有横切边的集合，就要将连接这个顶点和其他所有不在树中的顶点的边加入优先队列。但，连接新加入树中的顶点与其他已经在树中顶点的所有边都失效了。（这样的边都已经不是横切边了，因为它的两个顶点都在树中。） 示意 定义Prim算法能够得到任意加权无向图的最小生成树。 延时实现将失效的边先留在优先队列中，等到要删除它们的时候再检查边的有效性。 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class LazyPrimMST &#123; private double weight; private boolean[] marked; private Queue&lt;Edge&gt; mst; private MinPQ&lt;Edge&gt; pq; public LazyPrimMST(EdgeWeightedGraph g)&#123; weight = 0; marked = new boolean[g.V()]; mst = new Queue&lt;Edge&gt;(); pq = new MinPQ&lt;Edge&gt;(g.E()); prim(g); &#125; private void prim(EdgeWeightedGraph g)&#123; visit(g, 0); while (!pq.isEmpty())&#123; Edge e = pq.delMin(); int v = e.either(); int w = e.other(v); if (marked[v] == true &amp;&amp; marked[w] == true) continue; weight += e.weight(); mst.enqueue(e); if (marked[v] == false) visit(g, v); else if (marked[w] == false) visit(g, w); &#125; &#125; private void visit(EdgeWeightedGraph g, int v)&#123; marked[v] = true; for (Edge e : g.adj(v))&#123; if (marked[e.other(v)] == false) pq.insert(e); &#125; &#125; public Iterable&lt;Edge&gt; edges()&#123; return mst; &#125; public double weight()&#123; return weight; &#125;&#125; 特点Prim算法的延时实现计算一幅含有V个顶点和E条边的连通加权无向图的最小生成树所需的空间与E成正比，所需的时间与ElogE成正比（最坏情况）。 即时实现只会在优先队列中保存每个非树顶点w的一条边：将它与树中的顶点连接起来的权重最小的那条边。将w和树的顶点连接起来的其他权重较大的边迟早都会失效，所以没必要在优先队列中保存它们。 示意 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class PrimMST &#123; private boolean[] marked; private Edge[] edgeTo; private double[] distTo; private IndexMinPQ&lt;Double&gt; pq; public PrimMST(EdgeWeightedGraph g)&#123; marked = new boolean[g.V()]; edgeTo = new Edge[g.V()]; distTo = new double[g.V()]; pq = new IndexMinPQ&lt;Double&gt;(g.V()); for (int v = 0; v &lt; g.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; prim(g); &#125; private void prim(EdgeWeightedGraph g)&#123; pq.insert(0, 0.0); while (!pq.isEmpty()) visit(g, pq.delMin()); &#125; private void visit(EdgeWeightedGraph g, int v)&#123; marked[v] = true; for (Edge e : g.adj(v))&#123; int w = e.other(v); if (marked[w] == true) continue; if (e.weight() &lt; distTo[w])&#123; distTo[w] = e.weight(); edgeTo[w] = e; if (pq.contains(w)) pq.change(w, distTo[w]); else pq.insert(w, distTo[w]); &#125; &#125; &#125; public Iterable&lt;Edge&gt; edges()&#123; Queue&lt;Edge&gt; mst = new Queue&lt;Edge&gt;(); for (int v = 1; v &lt; edgeTo.length; v++) mst.enqueue(edgeTo[v]); return mst; &#125; public double weight()&#123; double weight = 0.0; for (int v = 1; v &lt; distTo.length; v++) weight += distTo[v]; return weight; &#125;&#125; 特点Prim算法的即时实现计算一幅含有V个顶点和E条边的连通加权无向图的最小生成树所需的空间和V成正比，所需的时间和ElogV成正比（最坏情况）。 Kruskal算法按照边的权重顺序（从小到大）处理它们，将边加入最小生成树中，加入的边不会与已经加入的边构成环，直到树中含有V-1条边为止。这些黑色的边逐渐由一片森林合并为一棵树，也就是图的最小生成树。 定义Kruskal算法能够计算任意加权无向图的最小生成树。 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142public class KruskalMST &#123; private Queue&lt;Edge&gt; mst; private MinPQ&lt;Edge&gt; pq; private UnionFind uf; private double weight; public KruskalMST(EdgeWeightedGraph g)&#123; weight = 0; mst = new Queue&lt;Edge&gt;(); pq = new MinPQ&lt;Edge&gt;(g.E()); uf = new UnionFind(g.V()); for (Edge e : g.edges()) pq.insert(e); kruskal(g); &#125; private void kruskal(EdgeWeightedGraph g)&#123; while (!pq.isEmpty() &amp;&amp; mst.size() &lt; g.V())&#123; Edge e = pq.delMin(); int v = e.either(); int w = e.other(v); if (uf.connected(v, w)) continue; uf.union(v, w); mst.enqueue(e); weight += e.weight(); &#125; &#125; public Iterable&lt;Edge&gt; edges()&#123; return mst; &#125; public double weight()&#123; return weight; &#125;&#125; 特点Kruskal算法计算一幅含有V个顶点和E条边的连通加权无向图的最小生成树所需的空间和E成正比，所需的时间和ElogE成正比（最坏情况）。 比较Prim算法是一条边一条边地来构造最小生成树，每一步都为一棵树添加一条边。 Kruskal算法构造最小生成树的时候也是一条边一条边地构造，但不同的是它寻找的边会连接一片森林中的两棵树。从一片由V棵单顶点的树构成的森林开始并不断将两棵树合并（用可以找到的最短边）直到只剩下一棵树，它就是最小生成树。 总结 最短路径树Dijkstra算法采用了类似Prim算法的方法来计算最短路径树。 定义Dijkstra算法能够解决边权重非负的加权有向图的单起点最短路径问题。 示意 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class DijkstraSPT &#123; private DirectedEdge[] edgeTo; private double[] distTo; private IndexMinPQ&lt;Double&gt; pq; private int s; public DijkstraSPT(EdgeWeightedDigraph g, int s)&#123; edgeTo = new DirectedEdge[g.V()]; distTo = new double[g.V()]; pq = new IndexMinPQ&lt;Double&gt;(g.V()); this.s = s; for (int v = 0; v &lt; g.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; distTo[s] = 0; pq.insert(s, 0.0); while (!pq.isEmpty()) relax(g, pq.delMin()); &#125; private void relax(EdgeWeightedDigraph g, int v)&#123; for (DirectedEdge e : g.adj(v))&#123; int w = e.to(); if (distTo[v] + e.weight() &lt; distTo[w])&#123; distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; if (pq.contains(w)) pq.change(w, distTo[w]); else pq.insert(w, distTo[w]); &#125; &#125; &#125; public double distTo(int v)&#123; return distTo[v]; &#125; public boolean hasPathTo(int v)&#123; return distTo[v] &lt; Double.POSITIVE_INFINITY; &#125; public Iterable&lt;DirectedEdge&gt; pathTo(int v)&#123; if (!hasPathTo(v)) return null; Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;(); DirectedEdge e = edgeTo[v]; while (e.from() != s)&#123; path.push(e); e = edgeTo[e.from()]; &#125; path.push(e); return path; &#125;&#125; 特点在一幅含有V个顶点和E条边的加权有向图中，使用Dijkstra算法计算根结点为给定起点的最短路径树所需的空间与V成正比，时间与ElogV成正比（最坏情况下）。 比较Prim算法每次添加的都是离树最近的非树顶点，Dijkstra算法每次添加的都是离起点最近的非树顶点。 拓扑排序将顶点的放松和拓扑排序结合起来。 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class AcyclicSPT &#123; private DirectedEdge[] edgeTo; private double[] distTo; private int s; public AcyclicSPT(EdgeWeightedDigraph g, int s)&#123; edgeTo = new DirectedEdge[g.V()]; distTo = new double[g.V()]; this.s = s; for (int v = 0; v &lt; g.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; distTo[s] = 0; Topological t = new Topological(g); for (int v : t.order()) relax(g, v); &#125; private void relax(EdgeWeightedDigraph g, int v)&#123; for (DirectedEdge e : g.adj(v))&#123; int w = e.to(); if (distTo[v] + e.weight() &lt; distTo[w])&#123; distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; &#125; &#125; &#125; public double distTo(int v)&#123; return distTo[v]; &#125; public boolean hasPathTo(int v)&#123; return distTo[v] &lt; Double.POSITIVE_INFINITY; &#125; public Iterable&lt;DirectedEdge&gt; pathTo(int v)&#123; if (!hasPathTo(v)) return null; Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;(); DirectedEdge e = edgeTo[v]; while (e.from() != s)&#123; path.push(e); e = edgeTo[e.from()]; &#125; path.push(e); return path; &#125;&#125; 特点按照拓扑排序放松顶点，就能在和E+V成正比的时间内解决无环有向图的单点最短路径问题。 能够在线性时间内解决单点最短路径问题 能够处理负权重的边 能够解决相关的问题，例如找出最长的路径 Bellman-Ford算法解决一般有向图中的以下问题： 负权重环的检测。给定的加权有向图中含有负权重环吗？如果有，找到它。 负权重环不可达时的单点最短路径。给定一幅加权有向图和一个起点s且从s无法到达任何负权重环，回答“是否存在一条从s到给定的顶点v的有向路径？如果有，找出最短（总权重最小）的那条路径。“等类似问题。 定义在任意含有V个顶点的加权有向图中给定起点s，从s无法到达任何负权重环，以下算法能够解决其中的单点最短路径问题：以任意顺序放松有向图的所有边，重复V轮。 示意 负权重环的检测在将所有边放松V轮之后当且仅当队列非空时有向图中才存在从起点可达的负权重环。 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class BellmanFordSPT &#123; private DirectedEdge[] edgeTo; private double[] distTo; private Iterable&lt;DirectedEdge&gt; cycle; private Queue&lt;Integer&gt; queue; private boolean[] onQ; private int s; private int cost; public BellmanFordSPT(EdgeWeightedDigraph g, int s)&#123; this.s = s; cost = 0; edgeTo = new DirectedEdge[g.V()]; distTo = new double[g.V()]; onQ = new boolean[g.V()]; queue = new Queue&lt;Integer&gt;(); for (int v = 0; v &lt; g.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; distTo[s] = 0; onQ[s] = true; queue.enqueue(s); while (!queue.isEmpty() &amp;&amp; !hasNegativeCycle())&#123; int v = queue.dequeue(); onQ[v] = false; relax(g, v); if (++cost % g.V() == 0) findNegativeCycle(); &#125; &#125; private void relax(EdgeWeightedDigraph g, int v)&#123; for (DirectedEdge e : g.adj(v))&#123; int w = e.to(); if (distTo[v] + e.weight() &lt; distTo[w])&#123; distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; if (onQ[w] == false)&#123; onQ[w] = true; queue.enqueue(w); &#125; &#125; &#125; &#125; private void findNegativeCycle()&#123; int V = edgeTo.length; EdgeWeightedDigraph g = new EdgeWeightedDigraph(V); for (int v = 0; v &lt; V; v++)&#123; if (edgeTo[v] != null) g.addEdge(edgeTo[v]); &#125; EdgeWeightedDirectedCycle c = new EdgeWeightedDirectedCycle(g); cycle = c.cycle(); &#125; public boolean hasNegativeCycle()&#123; return cycle != null; &#125; public Iterable&lt;DirectedEdge&gt; negativeCycle()&#123; return cycle; &#125; public double distTo(int v)&#123; return distTo[v]; &#125; public boolean hasPathTo(int v)&#123; return distTo[v] &lt; Double.POSITIVE_INFINITY; &#125; public Iterable&lt;DirectedEdge&gt; pathTo(int v)&#123; if (!hasPathTo(v)) return null; Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;(); DirectedEdge e = edgeTo[v]; while (e.from() != s)&#123; path.push(e); e = edgeTo[e.from()]; &#125; path.push(e); return path; &#125;&#125; 特点对于任意含有V个顶点的加权有向图和给定的起点s，在最坏情况下基于队列的Bellman-Ford算法解决最短路径问题（或者找到从s可达的负权重环）所需的时间和EV成正比，空间和V成正比。 总结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【算法】查找]]></title>
      <url>%2F2017%2F04%2F16%2F%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9F%A5%E6%89%BE%2F</url>
      <content type="text"><![CDATA[顺序查找（无序链表）符号表中使用的数据结构的一个简单选择是链表，每个结点存储一个键值对。 示意 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class SequentialSearch&lt;Key, Value&gt; &#123; private Node first; private int n; private class Node&#123; Key key; Value value; Node next; public Node (Key key, Value value, Node next)&#123; this.key = key; this.value = value; this.next = next; &#125; &#125; public void put(Key key, Value value)&#123; for (Node x = first; x != null; x = x.next)&#123; if (key.equals(x.key))&#123; x.value = value; return; &#125; &#125; first = new Node(key, value, first); n++; &#125; public Value get(Key key)&#123; for (Node x = first; x != null; x = x.next)&#123; if (key.equals(x.key)) return x.value; &#125; return null; &#125; public void delete(Key key)&#123; if (isEmpty()) return; if (key.equals(first.key)) first = first.next; else deleteNode(first, key); n--; &#125; private void deleteNode(Node x, Key key)&#123; if (x.next == null) return; if (key.equals(x.next.key)) x.next = x.next.next; else deleteNode(x.next, key); &#125; public Iterable&lt;Key&gt; keys()&#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); for (Node x = first; x != null; x = x.next) queue.enqueue(x.key); return queue; &#125; public int size()&#123; return n; &#125; public boolean isEmpty()&#123; return size() == 0; &#125; public boolean contains(Key key)&#123; return get(key) != null; &#125;&#125; 特点在含有N对键值的基于（无序）链表的符号表中，未命名的查找和插入操作都需要N次比较。命中的查找在最坏情况下需要N次比较。特别地，向一个空表中插入N个不同的键需要~N^2/2次比较。 二分查找（有序数组）符号表使用的数据结构是一对平行的数组，一个存储键一个存储值。 计算小于给定键的键的数量：首先将key和中间键比较，如果相等则返回其索引；如果小于中间键则在左半部分查找；大于则在右半部分查找。 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152public class BinarySearch&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private int n; private Key[] keys; private Value[] values; public BinarySearch(int capacity)&#123; keys = (Key[]) new Comparable[capacity]; values = (Value[]) new Object[capacity]; &#125; public void put(Key key, Value value)&#123; int i = rank(key); if (i &lt; n &amp;&amp; key.compareTo(keys[i]) == 0)&#123; values[i] = value; return; &#125; for (int j = n; j &gt; i; j--)&#123; keys[j] = keys[j-1]; values[j] = values[j-1]; &#125; keys[i] = key; values[i] = value; n++; &#125; public Value get(Key key)&#123; if (isEmpty()) return null; int i = rank(key); if (i &lt; n &amp;&amp; key.compareTo(keys[i]) == 0) return values[i]; else return null; &#125; public int rank(Key key)&#123; int lo = 0; int hi = n - 1; while (lo &lt;= hi)&#123; int mid = lo + (hi - lo) / 2; int compare = key.compareTo(keys[mid]); if (compare &lt; 0) hi = mid - 1; else if (compare &gt; 0) lo = mid + 1; else return mid; &#125; return lo; &#125; public void delete(Key key)&#123; if (isEmpty()) return; int i = rank(key); if (key.compareTo(keys[i]) != 0) return; for (int j = i + 1; j &lt; n; j++)&#123; keys[j-1] = keys[j]; values[j-1] = values[j]; &#125; keys[n] = null; values[n] = null; n--; &#125; public int size()&#123; return n; &#125; public int size(Key lo, Key hi)&#123; if (hi.compareTo(lo) &lt; 0) return 0; else if (contains(hi)) return rank(hi) - rank(lo) + 1; else return rank(hi) - rank(lo); &#125; public Key floor(Key key)&#123; int i = rank(key); if (i &lt; n &amp;&amp; key.compareTo(keys[i]) == 0) return keys[i]; if (i == 0) return null; else return keys[i-1]; &#125; public Key ceiling(Key key)&#123; int i = rank(key); return keys[i]; &#125; public Iterable&lt;Key&gt; keys()&#123; return keys(min(), max()); &#125; public Iterable&lt;Key&gt; keys(Key lo, Key hi)&#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); for (int i = rank(lo); i &lt; rank(hi); i++) queue.enqueue(keys[i]); if (contains(hi)) queue.enqueue(hi); return queue; &#125; public boolean isEmpty()&#123; return size() == 0; &#125; public boolean contains(Key key)&#123; return get(key) != null; &#125; public Key min()&#123; return keys[0]; &#125; public Key max()&#123; return keys[n-1]; &#125; public Key select(int k)&#123; return keys[k]; &#125; public void deleteMin()&#123; delete(min()); &#125; public void deleteMax()&#123; delete(max()); &#125;&#125; 特点在N个键的有序数组中进行二分查找最多需要（lgN+1）次比较（无论是否成功）。 向大小为N的有序数组中插入一个新的元素在最坏情况下需要访问～2N次数组，因此向一个空符号表中插入N个元素在最坏情况下需要访问~N^2次数组。 比较 二叉查找树定义一个类表示二叉查找树上的一个结点。每个结点都含有一个键、一个值、一条左链接、一条右链接和一个结点计数器。左链接指向一棵由小于该结点的所有键组成的二叉查找树，右链接指向一棵由大于该结点的所有键组成的二叉查找树。变量N给出了以该结点为根的子树的结点总数。 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287public class BinarySearchTree&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private Node root; private class Node&#123; Key key; Value value; Node left; Node right; int n; public Node(Key key, Value value, int n)&#123; this.key = key; this.value = value; this.n = n; &#125; &#125; public void put(Key key, Value value)&#123; root = put(root, key, value); &#125; private Node put(Node x, Key key, Value value)&#123; if (x == null) return new Node(key, value, 1); int compare = key.compareTo(x.key); if (compare &lt; 0) x.left = put(x.left, key, value); else if (compare &gt; 0) x.right = put(x.right, key, value); else x.value = value; x.n = size(x.left) + size(x.right) + 1; return x; &#125; public Value get(Key key)&#123; return get(root, key); &#125; private Value get(Node x, Key key)&#123; if (x == null) return null; int compare = key.compareTo(x.key); if (compare &lt; 0) return get(x.left, key); else if (compare &gt; 0) return get(x.right, key); else return x.value; &#125; public void delete(Key key)&#123; root = delete(root, key); &#125; private Node delete(Node x, Key key)&#123; if (x == null) return null; int compare = key.compareTo(x.key); if (compare &lt; 0) x.left = delete(x.left, key); else if (compare &gt; 0) x.right = delete(x.right, key); else&#123; if (x.left == null) return x.right; else if (x.right == null) return x.left; Node t = x; x = min(t.right); x.right = deleteMin(t.right); x.left = t.left; &#125; x.n = size(x.left) + size(x.right) + 1; return x; &#125; public void deleteMin()&#123; root = deleteMin(root); &#125; private Node deleteMin(Node x)&#123; if (x.left == null) return x.right; x.left = deleteMin(x.left); x.n = size(x.left) + size(x.right) + 1; return x; &#125; public void deleteMax()&#123; root = deleteMax(root); &#125; private Node deleteMax(Node x)&#123; if (x.right == null) return x.left; x.right = deleteMax(x.right); x.n = size(x.left) + size(x.right) + 1; return x; &#125; public Key min()&#123; return min(root).key; &#125; private Node min(Node x)&#123; if (x.left == null) return x; else return min(x.left); &#125; public Key max()&#123; return max(root).key; &#125; private Node max(Node x)&#123; if (x.right == null) return x; else return max(x.right); &#125; public Key floor(Key key)&#123; Node x = floor(root, key); if (x == null) return null; else return x.key; &#125; private Node floor(Node x, Key key)&#123; if (x == null) return null; int compare = key.compareTo(x.key); if (compare == 0) return x; else if (compare &lt; 0) return floor(x.left, key); else &#123; Node y = floor(x.right, key); if (y != null) return y; else return x; &#125; &#125; public int rank(Key key)&#123; return rank(root, key); &#125; private int rank(Node x, Key key)&#123; if (x == null) return 0; int compare = key.compareTo(x.key); if (compare &lt; 0) return rank(x.left, key); else if (compare &gt; 0) return rank(x.right, key) + size(x.left) + 1; else return size(x.left); &#125; public Key select(int k)&#123; return select(root, k).key; &#125; private Node select(Node x, int k)&#123; if (x == null) return null; int t = size(x.left); if (t &gt; k) return select(x.left, k); else if (t &lt; k) return select(x.right, k-t-1); else return x; &#125; public Key ceiling(Key key)&#123; Node x = ceiling(root, key); if (x == null) return null; else return x.key; &#125; private Node ceiling(Node x, Key key)&#123; if (x == null) return null; int compare = key.compareTo(x.key); if (compare == 0) return x; else if (compare &gt; 0) return ceiling(x.right, key); else &#123; Node y = ceiling(x.left, key); if (y != null) return y; else return x; &#125; &#125; public int size()&#123; return size(root); &#125; private int size(Node x)&#123; if (x == null) return 0; else return x.n; &#125; public int size(Key lo, Key hi)&#123; if (hi.compareTo(lo) &lt; 0) return 0; else if (contains(hi)) return rank(hi) - rank(lo) + 1; else return rank(hi) - rank(lo); &#125; public Iterable&lt;Key&gt; keys()&#123; return keys(min(), max()); &#125; public Iterable&lt;Key&gt; keys(Key lo, Key hi)&#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); keys(root, queue, lo, hi); return queue; &#125; private void keys (Node x, Queue&lt;Key&gt; queue, Key lo, Key hi)&#123; if (x == null) return; int compareLo = lo.compareTo(x.key); int compareHi = hi.compareTo(x.key); if (compareLo &lt; 0) keys(x.left, queue, lo, hi); if (compareLo &lt;= 0 &amp;&amp; compareHi &gt;= 0) queue.enqueue(x.key); if (compareHi &gt; 0) keys(x.right, queue, lo, hi); &#125; public boolean isEmpty()&#123; return size() == 0; &#125; public boolean contains(Key key)&#123; return get(key) != null; &#125;&#125; 特点在由N个随机键构造的二叉查找树中，查找命中平均所需的比较次数为~2lnN（约为1.39lgN），插入操作和查找未命中平均所需的比较次数为~2lnN（约为1.39lgN）。 在一棵二叉查找树中，所有操作在最坏情况下所需的时间都和树的高度成正比。 比较 红黑二叉查找树只要谨慎地使用左旋转、右旋转和颜色转换这三种简单的操作，就能够保证插入操作后红黑树和2-3树的一一对应关系： 如果右子结点是红色的而左子结点是黑色的，进行左旋转 如果左子结点是红色的且它的左子结点也是红色的，进行右旋转 如果左右子结点均为红色，进行颜色转换 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403public class RedBlackTree&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private static final boolean RED = true; private static final boolean BLACK = false; private Node root; private class Node&#123; Key key; Value value; Node left; Node right; int n; boolean color; public Node(Key key, Value value, int n, boolean color)&#123; this.key = key; this.value = value; this.n = n; this.color = color; &#125; &#125; private boolean isRed(Node x)&#123; if (x == null) return BLACK; return x.color == RED; &#125; private Node rotateLeft(Node h)&#123; Node x = h.right; h.right = x.left; x.left = h; x.color = h.color; h.color = RED; x.n = h.n; h.n = size(h.left) + size(h.right) + 1; return x; &#125; private Node rotateRight(Node h)&#123; Node x = h.left; h.left = x.right; x.right = h; x.color = h.color; h.color = RED; x.n = h.n; h.n = size(h.left) + size(h.right) + 1; return x; &#125; private void flipColors(Node h)&#123; h.left.color = !h.left.color; h.right.color = !h.right.color; h.color = !h.color; &#125; private Node balance(Node h)&#123; if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h); if (isRed(h.right)) h = rotateLeft(h); if (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h); h.n = size(h.left) + size(h.right) + 1; return h; &#125; private Node moveRedLeft(Node h)&#123; flipColors(h); if (isRed(h.right.left))&#123; h.right = rotateRight(h.right); h = rotateLeft(h); &#125; return h; &#125; private Node moveRedRight(Node h)&#123; flipColors(h); if (isRed(h.left.left)) h = rotateRight(h); return h; &#125; public void put(Key key, Value value)&#123; root = put(root, key, value); root.color = BLACK; &#125; private Node put(Node h, Key key, Value value)&#123; if (h == null) return new Node(key, value, 1, RED); int compare = key.compareTo(h.key); if (compare &lt; 0) h.left = put(h.left, key, value); else if (compare &gt; 0) h.right = put(h.right, key, value); else h.value = value; if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h); if (!isRed(h.left) &amp;&amp; isRed(h.right)) h = rotateLeft(h); if (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h); h.n = size(h.left) + size(h.right) + 1; return h; &#125; public Value get(Key key)&#123; return get(root, key); &#125; private Value get(Node x, Key key)&#123; while (x != null)&#123; int compare = key.compareTo(x.key); if (compare &lt; 0) x = x.left; else if (compare &gt; 0) x = x.right; else return x.value; &#125; return null; &#125; public void delete(Key key)&#123; if (!isRed(root.left) &amp;&amp; !isRed(root.right)) root.color = RED; root = delete(root, key); if (!isEmpty()) root.color = BLACK; &#125; private Node delete(Node h, Key key)&#123; if (key.compareTo(h.key) &lt; 0)&#123; if (!isRed(h.left) &amp;&amp; !isRed(h.left.left)) h = moveRedLeft(h); h.left = delete(h.left, key); &#125; else&#123; if (isRed(h.left)) h = rotateRight(h); //如果被查找的键在树的底部，可以直接删除它 if (h.right == null &amp;&amp; key.compareTo(h.key) == 0) return null; if (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) h = moveRedRight(h); //如果不在，需要将它和它的后继结点交换 if (key.compareTo(h.key) == 0)&#123; h.key = min(h.right).key; h.value = get(h.right, min(h.right).key); h.right = deleteMin(h.right); &#125; else h.right = delete(h.right, key); &#125; return balance(h); &#125; public void deleteMin()&#123; if (!isRed(root.left) &amp;&amp; !isRed(root.right)) root.color = RED; root = deleteMin(root); if (!isEmpty()) root.color = BLACK; &#125; private Node deleteMin(Node h)&#123; if (h.left == null) return null; if (!isRed(h.left) &amp;&amp; !isRed(h.left.left)) h = moveRedLeft(h); h.left = deleteMin(h.left); return balance(h); &#125; public void deleteMax()&#123; if (!isRed(root.left) &amp;&amp; !isRed(root.right)) root.color = RED; root = deleteMax(root); if (!isEmpty()) root.color = BLACK; &#125; private Node deleteMax(Node h)&#123; if (isRed(h.left)) h = rotateRight(h); if (h.right == null) return null; if (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) h = moveRedRight(h); h.right = deleteMax(h.right); return balance(h); &#125; public int size()&#123; return size(root); &#125; private int size(Node x)&#123; if (x == null) return 0; else return x.n; &#125; public int size(Key lo, Key hi)&#123; if (hi.compareTo(lo) &lt; 0) return 0; else if (contains(hi)) return rank(hi) - rank(lo) + 1; else return rank(hi) - rank(lo); &#125; public int rank(Key key)&#123; return rank(root, key); &#125; private int rank(Node x, Key key)&#123; if (x == null) return 0; int compare = key.compareTo(x.key); if (compare &lt; 0) return rank(x.left, key); else if (compare &gt; 0) return rank(x.right, key) + size(x.left) + 1; else return size(x.left); &#125; public Key select(int k)&#123; return select(root, k).key; &#125; private Node select(Node x, int k)&#123; if (x == null) return null; int t = size(x.left); if (t &gt; k) return select(x.left, k); else if (t &lt; k) return select(x.right, k-t-1); else return x; &#125; public Key floor(Key key)&#123; Node x = floor(root, key); if (x == null) return null; else return x.key; &#125; private Node floor(Node x, Key key)&#123; if (x == null) return null; int compare = key.compareTo(x.key); if (compare == 0) return x; else if (compare &lt; 0) return floor(x.left, key); else &#123; Node y = floor(x.right, key); if (y != null) return y; else return x; &#125; &#125; public Key ceiling(Key key)&#123; Node x = ceiling(root, key); if (x == null) return null; else return x.key; &#125; private Node ceiling(Node x, Key key)&#123; if (x == null) return null; int compare = key.compareTo(x.key); if (compare == 0) return x; else if (compare &gt; 0) return ceiling(x.right, key); else &#123; Node y = ceiling(x.left, key); if (y != null) return y; else return x; &#125; &#125; public Key min()&#123; return min(root).key; &#125; private Node min(Node x)&#123; if (x.left == null) return x; else return min(x.left); &#125; public Key max()&#123; return max(root).key; &#125; private Node max(Node x)&#123; if (x.right == null) return x; else return max(x.right); &#125; public Iterable&lt;Key&gt; keys()&#123; return keys(min(), max()); &#125; public Iterable&lt;Key&gt; keys(Key lo, Key hi)&#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); keys(root, queue, lo, hi); return queue; &#125; private void keys (Node x, Queue&lt;Key&gt; queue, Key lo, Key hi)&#123; if (x == null) return; int compareLo = lo.compareTo(x.key); int compareHi = hi.compareTo(x.key); if (compareLo &lt; 0) keys(x.left, queue, lo, hi); if (compareLo &lt;= 0 &amp;&amp; compareHi &gt;= 0) queue.enqueue(x.key); if (compareHi &gt; 0) keys(x.right, queue, lo, hi); &#125; public boolean contains(Key key)&#123; return get(key) != null; &#125; public boolean isEmpty()&#123; return size() == 0; &#125;&#125; 特点一棵大小为N的红黑树的高度不会超过2lgN。 一棵大小为N的红黑树中，根结点到任意结点的平均路径长度为~1.00lgN。 在一棵红黑树中，以下操作在最坏情况下所需的时间是对数级别的：查找（get）、插入（put）、查找最小键、查找最大键、floor、ceiling、rank、select、删除最小键（deleteMin）、删除最大键（deleteMax）、删除（delete）和范围查询。 比较 散列使用散列的查找算法分为两步。第一步是用散列函数将被查找的键转化为数组的一个索引（散列函数）；第二步就是一个处理碰撞冲突的过程（拉链法和线性探测法）。 因为需要的是数组的索引而不是一个32位的整数，在实现中会将默认的hashCode()方法和除留余数法结合起来产生一个0到M-1的整数，方法如下： 123private int hash(Key x)&#123; return (x.hashCode() &amp; 0x7fffffff) % M;&#125; 这段代码会将符号位屏蔽（将一个32位整数变为一个31位非负整数），然后用除留余数法计算它除以M的余数。在使用这样的代码一般会将数组的大小M取为素数以充分利用原散列值的所有位。 基于拉链法的散列表（链表数组）将大小为M的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。 查找分两步：首先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。 示意 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class SeparateChainHash&lt;Key, Value&gt; &#123; private int M; private int N; private SequentialSearch&lt;Key, Value&gt;[] st; public SeparateChainHash(int M)&#123; this.M = M; this.N = 0; st = (SequentialSearch&lt;Key, Value&gt;[]) new SequentialSearch[M]; for (int i = 0; i &lt; M; i++) st[i] = new SequentialSearch(); &#125; private int hash(Key x)&#123; return (x.hashCode() &amp; 0x7fffffff) % M; &#125; public void put(Key key, Value value)&#123; int m = hash(key); if (!contains(key)) N++; st[m].put(key, value); &#125; public Value get(Key key)&#123; int m = hash(key); return st[m].get(key); &#125; public void delete(Key key)&#123; int m = hash(key); if (contains(key)) N--; st[m].delete(key); &#125; public Iterable&lt;Key&gt; keys()&#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); for (int i = 0; i &lt; st.length; i++) &#123; for (Key key : st[i].keys()) queue.enqueue(key); &#125; return queue; &#125; public boolean contains(Key key)&#123; return get(key) != null; &#125; public int size()&#123; return N; &#125; public boolean isEmpty()&#123; return size() == 0; &#125;&#125; 特点在一张含有M条链表和N个键的散列表中，任意一条链表中的键的数量均在N/M的常熟因子范围内的概率无限趋于1，未命中查找和插入操作所需的比较次数为～N/M。 基于线性探测法的散列表（并行数组）用大小为M的数组保存N个键值对，其中M&gt;N，需要依靠数组中的空位解决碰撞冲突。基于这种策略的所有方法被统称为开放地址散列表。 最简单的方法叫做线性探测法：当碰撞发生时（当一个键的散列值已经被另一个不同的键占用），直接检查散列表中的下一个位置（将索引值加1）。这样的线性探测可能会产生三种结果： 命中，该位置的键和被查找的键相同 未命中，键为空（该位置没有键） 继续查找，该位置的键和被查找的键不同 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class LinearProbingHash&lt;Key, Value&gt; &#123; private int M; private int N; private Key[] keys; private Value[] values; public LinearProbingHash(int M)&#123; this.M = M; keys = (Key[]) new Object[M]; values = (Value[]) new Object[M]; &#125; private int hash(Key x)&#123; return (x.hashCode() &amp; 0x7fffffff) % M; &#125; private void resize(int m)&#123; LinearProbingHash&lt;Key, Value&gt; tmp = new LinearProbingHash&lt;Key, Value&gt;(m); for (int i = 0; i &lt; M; i++)&#123; if (keys[i] != null) tmp.put(keys[i], values[i]); &#125; this.M = m; keys = tmp.keys; values = tmp.values; &#125; public void put(Key key, Value value)&#123; if (N &gt;= M / 2) resize(2 * M); int m = hash(key); for (m = hash(key); keys[m] != null; m = (m + 1) % M)&#123; if (keys[m].equals(key))&#123; values[m] = value; return; &#125; &#125; keys[m] = key; values[m] = value; N++; &#125; public Value get(Key key)&#123; for (int m = hash(key); keys[m] != null; m = (m + 1) % M)&#123; if (keys[m].equals(key)) return values[m]; &#125; return null; &#125; public void delete(Key key)&#123; int m; for (m = hash(key); keys[m] != null; m = (m + 1) % M)&#123; if (keys[m].equals(key))&#123; keys[m] = null; values[m] = null; break; &#125; &#125; for (m = (m + 1) % M; keys[m] != null; m = (m + 1) % M)&#123; Key k = keys[m]; Value v = values[m]; keys[m] = null; values[m] = null; put(k, v); N--; &#125; N--; if (N &gt; 0 &amp;&amp; N == M / 8) resize(M / 2); &#125; public Iterable&lt;Key&gt; keys()&#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); for (int i = 0; i &lt; M; i++)&#123; if (keys[i] != null) queue.enqueue(keys[i]); &#125; return queue; &#125; public boolean contains(Key key)&#123; return get(key) != null; &#125; public int size()&#123; return N; &#125; public boolean isEmpty()&#123; return size() == 0; &#125;&#125; 特点在一张大小为M并含有N=aM个键的基于线性探测的散列表中，命中和未命中的查找所需的探测次数分别为： 假设一张散列表能够自己调整数组的大小，初始为空。执行任意数序的t次查找、插入和删除操作所需的时间和t成正比，所使用的内存量总是在表中的键的总数的常数因子范围内。 线性探测的平均成本取决于元素在插入数组后聚集成的一组连续的条目，也叫做键簇。短小的键簇才能保证较高的效率，因此需要动态调整数组的大小来保证使用率在1/8到1/2之间。 比较将a=N/M称为散列表的使用率。对于基于拉链法的散列表，a是每条链表的长度，因此一般大于1；对于基于线性探测的散列表，a是表中已被占用的空间的比例，它是不可能大于1的。 特点 每种类型的键都需要一个优秀的散列函数 性能保证来自于散列函数的质量 散列函数的计算可能复杂而且昂贵 难以支持有序性相关的符号表操作 比较 总结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【算法】排序]]></title>
      <url>%2F2017%2F04%2F13%2F%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[选择排序首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。 示意 实现12345678910111213141516171819202122232425262728293031public class Selection &#123; public void sort(Comparable[] a)&#123; for (int i = 0; i &lt; a.length - 1; i++)&#123; int minIndex = i; for (int j = i + 1; j &lt; a.length; j++)&#123; if (!less(a[minIndex], a[j])) minIndex = j; &#125; exch(a, i, minIndex); &#125; &#125; private boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b) &lt; 0; &#125; private void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; public void show(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); System.out.println(); &#125;&#125; 特点对于长度为N的数组，选择排序需要大约N^2/2次比较和N次交换。 运行时间和输入无关 数据移动是最少的 插入排序将元素插入到其他已经有序的数组中的适当位置。为了要给插入的元素腾出空间，需要将其余所有元素在插入之前都向右移动一位。 示意 实现12345678910111213141516171819202122232425public class Insertion &#123; public void sort(Comparable[] a)&#123; for (int i = 1; i &lt; a.length; i++)&#123; for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j-1]); j--) exch(a, j-1, j); &#125; &#125; private boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b) &lt; 0; &#125; private void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; public void show(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); System.out.println(); &#125;&#125; 特点对于随机排列的长度为N且主键不重复的数组，平均情况下插入排序需要～N^2/2次比较以及~N^2/4次交换。最坏情况下需要～N^2/2次比较和～N^2/2次交换，最好情况下需要N-1次比较和0次交换。 插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。 所需的时间取决于输入中元素的初始顺序，对于部分有序的数组十分高效，也很适合小规模数组 比较对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数。 插入排序不会访问索引右侧的元素，而选择排序不会访问索引左侧的元素 插入排序所需的比较次数平均只有选择排序的一半 希尔排序希尔排序的思想是使数组中任意间隔为h的元素都是有序的。这样的数组被称为h有序数组。在进行排序时，如果h很大，就能将元素移动到很远的地方，为实现更小的h有序创造方便。用这种方式，对于任意以1结尾的h序列，都能够将数组排序。 示意 实现12345678910111213141516171819202122232425262728293031323334public class Shell &#123; public void sort(Comparable[] a)&#123; int h = 1; while (h &lt;= a.length / 3) h = 3 * h + 1; while (h &gt;= 1)&#123; for (int i = h; i &lt; a.length; i++)&#123; for (int j = i; j &gt; h &amp;&amp; less(a[j], a[j-h]); j -= h) exch(a, j-h, j); &#125; h = (h - 1) / 3; &#125; &#125; private boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b) &lt; 0; &#125; private void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; public void show(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); System.out.println(); &#125;&#125; 特点使用递增序列1，4，13，40，121，364…的希尔排序所需的比较次数不会超出N的若干倍数乘以递增序列的长度。 希尔排序更高效的原因是它权衡了子数组的规模和有序性。排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。 希尔排序可以用于大型数组。它对任意排序（不一定是随机的）的数组表现也很好。 希尔排序对于中等大小的数组它的运行时间是可以接受的。它的代码量很小，且不需要使用额外的内存空间。 归并排序要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。 递归实现的归并排序是算法设计中分治思想的典型应用。 示意 特点 能够保证将任意长度为N的数组排序所需时间和NlogN成正比，所需的额外空间和N成正比。 可以用归并排序处理数百万甚至更大规模的数组，这是插入排序或者选择排序做不到的。 自顶向下的归并排序示意 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Merge &#123; private Comparable[] aux; public void sort(Comparable[] a)&#123; aux = new Comparable[a.length]; sort(a, 0, a.length-1); &#125; private void sort(Comparable[] a, int lo, int hi)&#123; if (lo == hi) return; int mid = (hi + lo) / 2; sort(a, lo, mid); sort(a, mid+1, hi); merge(a, lo, mid, hi); &#125; private void merge(Comparable[] a, int lo, int mid, int hi)&#123; int j = lo; int k = mid + 1; for (int i = lo; i &lt;= hi; i++) aux[i] = a[i]; for (int i = lo; i &lt;= hi; i++)&#123; if (j &gt; mid) a[i] = aux[k++]; else if (k &gt; hi) a[i] = aux[j++]; else if (less(aux[j], aux[k])) a[i] = aux[j++]; else a[i] = aux[k++]; &#125; &#125; private boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b) &lt; 0; &#125; public void show(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); System.out.println(); &#125;&#125; 特点对于长度为N的任意数组，自顶向下的归并排序需要1/2*NlgN至NlgN次比较，最多需要访问数组6NlgN次。 自底向上的归并排序示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142public class Merge &#123; private Comparable[] aux; public void sort(Comparable[] a)&#123; aux = new Comparable[a.length]; for (int i = 1; i &lt; a.length; i *= 2)&#123; for (int j = 0; j &lt; a.length; j += 2*i) merge(a, j, j+i-1, Math.min(j+2*i-1, a.length-1)); &#125; &#125; private void merge(Comparable[] a, int lo, int mid, int hi)&#123; int j = lo; int k = mid + 1; for (int i = lo; i &lt;= hi; i++) aux[i] = a[i]; for (int i = lo; i &lt;= hi; i++)&#123; if (j &gt; mid) a[i] = aux[k++]; else if (k &gt; hi) a[i] = aux[j++]; else if (less(aux[j], aux[k])) a[i] = aux[j++]; else a[i] = aux[k++]; &#125; &#125; private boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b) &lt; 0; &#125; public void show(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); System.out.println(); &#125;&#125; 特点对于长度为N的任意数组，自底向上的归并排序需要1/2*NlgN至NlgN次比较，最多访问数组6NlgN次。 比较适合用链表组织的数据。只需要重新组织链表链接就能将链表原地排序（不需要创建任何的链表结点）。 归并排序是一种渐进最优的基于比较排序的算法。 快速排序快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。 示意 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.Random;public class Quick &#123; private static Random random; private static long seed; static &#123; seed = System.currentTimeMillis(); random = new Random(seed); &#125; public void sort(Comparable[] a)&#123; shuffle(a); sort(a, 0, a.length-1); &#125; private void sort(Comparable[] a, int lo, int hi)&#123; if (hi &lt;= lo) return; int i = partition(a, lo, hi); sort(a, lo, i-1); sort(a, i+1, hi); &#125; private int partition(Comparable[] a, int lo, int hi)&#123; int i = lo; int j = hi; while (i &lt; j)&#123; while (i &lt; j &amp;&amp; less(a[i], a[lo])) i++; while (i &lt; j &amp;&amp; less(a[lo], a[j])) j--; exch(a, i, j); &#125; exch(a, lo, i); return i; &#125; private boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b) &lt; 0; &#125; private void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; public void show(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); System.out.println(); &#125; private static void shuffle(Object[] a) &#123; if (a == null) throw new IllegalArgumentException("argument array is null"); int n = a.length; for (int i = 0; i &lt; n; i++) &#123; int r = i + uniform(n-i); Object temp = a[i]; a[i] = a[r]; a[r] = temp; &#125; &#125; private static int uniform(int n) &#123; if (n &lt;= 0) throw new IllegalArgumentException("argument must be positive"); return random.nextInt(n); &#125;&#125; 特点将长度为N的无重复数组排序，快速排序平均需要~2NlnN次比较（以及1/6的交换），最多需要约N^2/2次比较，但随机打乱数组能够预防这种情况。 快速排序实现简单、适用于各种不同的输入数据且在一般应用中比其他排序算法都要快得多。 快速排序是原地排序（只需要一个很小的辅助栈），且将长度为N的数组排序所需的时间和NlgN成正比。 非常脆弱，在实现时要非常小心才能避免低劣的性能。 比较快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。 在第一种情况中，递归调用发生在处理整个数组之前；在第二种情况中，递归调用发生在处理整个数组之后。 在归并排序中，一个数组被等分为两半；在快速排序中，切分的位置取决于数组的内容。 三向切分的快速排序在有大量重复元素的情况下，快速排序的递归性会使元素全部重复的子数组经常出现。一个简单的想法是将数组切分为三部分，分别对应小于、等于和大于切分元素的数组元素。这样的切分能够将和切分元素相等的元素归位，就不会被包含在递归调用处理的子数组之中了。 对于包含大量重复元素的数组，三向切分的快速排序将排序时间从线性对数级降低到了线性级别。 示意 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.Random;public class Quick &#123; private static Random random; private static long seed; static &#123; seed = System.currentTimeMillis(); random = new Random(seed); &#125; public void sort(Comparable[] a)&#123; shuffle(a); sort(a, 0, a.length-1); &#125; private void sort(Comparable[] a, int lo, int hi)&#123; if (hi &lt;= lo) return; int lt = lo; int gt = hi; int i = lo + 1; Comparable v = a[lo]; while (i &lt;= gt)&#123; if (a[i].compareTo(v) &lt; 0)&#123; exch(a, lt, i); lt++; i++; &#125; else if (a[i].compareTo(v) &gt; 0)&#123; exch(a, gt, i); gt--; &#125; else i++; &#125; sort(a, lo, lt-1); sort(a, gt+1, hi); &#125; private void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; public void show(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); System.out.println(); &#125; private static void shuffle(Object[] a) &#123; if (a == null) throw new IllegalArgumentException("argument array is null"); int n = a.length; for (int i = 0; i &lt; n; i++) &#123; int r = i + uniform(n-i); Object temp = a[i]; a[i] = a[r]; a[r] = temp; &#125; &#125; private static int uniform(int n) &#123; if (n &lt;= 0) throw new IllegalArgumentException("argument must be positive"); return random.nextInt(n); &#125;&#125; 特点对于大小为N的数组，三向切分的快速排序需要~(2ln2)NH次比较。其中H为由主键值出现频率定义的香农信息量。 堆排序堆排序可以分为两个阶段。在堆的构造阶段中，将原始数组重新组织安排进一个堆中（从右至左用sink函数构造子堆）；然后在下沉排序阶段，从堆中按递减顺序取出所有元素得到排序结果（将堆中的最大元素删除，然后放入堆缩小后数组空出的位置）。 示意 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Heap &#123; public void sort(Comparable[] a)&#123; int n = a.length; for (int i = n / 2; i &gt;= 1; i--) sink(a, i, n); while (n &gt; 1)&#123; exch(a, 0, n-1); sink(a, 1, --n); &#125; &#125; private boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b) &lt; 0; &#125; private void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; private void sink(Comparable[] a, int k, int n)&#123; while (2 * k &lt;= n)&#123; int j = 2 * k; if (j &lt; n &amp;&amp; less(a[j-1], a[j])) j++; if (!less(a[k-1], a[j-1])) break; exch(a, k-1, j-1); k = j; &#125; &#125; public void show(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); System.out.println(); &#125;&#125; 特点用下沉操作由N个元素构造堆只需少于2N次比较以及少于N次交换。 将N个元素排序，堆排序只需少于（2NlgN+2N）次比较（以及一半次数的交换）。 总结快速排序是最快的通用排序算法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【算法】基础]]></title>
      <url>%2F2017%2F04%2F13%2F%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[链表链表是一种递归的数据结构，它或者为空（null），或者是指向一个结点（node）的引用，该结点含有一个泛型的元素和一个指向另一条链表的引用。 结点记录用一个嵌套类来定义结点的抽象数据类型。一个Node对象含有两个实例变量，类型分别为Item（参数类型）和Node。调用的结果是一个指向Node对象的引用，它的实例变量均被初始化为null。 1234private class Node&#123; Item item; Node next;&#125; 构造链表 在表头插入结点 从表头删除结点 在表尾插入结点 遍历123for (Node x = first; x != null; x = x.next)&#123; //处理x.item&#125; 优点 可以处理任意类型的数据 所需的空间总是和集合的大小成正比 操作所需的时间总是和集合的大小无关 栈栈是一种基于后进先出（LIFO）策略的集合类型。 实现将栈保存为一条链表，栈的顶部即为表头，实例变量first指向栈顶。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.Iterator;public class Stack&lt;E&gt; implements Iterable&lt;E&gt;&#123; private int n; private Node first; private class Node&#123; E e; Node next; &#125; public boolean isEmpty()&#123; return n == 0; &#125; public int size()&#123; return n; &#125; public void push(E e)&#123; Node oldFirst = first; first = new Node(); first.e = e; first.next = oldFirst; n++; &#125; public E pop()&#123; E e = first.e; first = first.next; n--; return e; &#125; public Iterator&lt;E&gt; iterator()&#123; return new ListIterator(); &#125; private class ListIterator implements Iterator&lt;E&gt;&#123; Node current = first; @Override public boolean hasNext() &#123; return current != null; &#125; @Override public E next() &#123; E e = current.e; current = current.next; return e; &#125; &#125;&#125; 队列队列是一种基于先进先出（FIFO）策略的集合类型。 实现将队列表示为一条从最早插入的元素到最近插入的元素的链表，实例变量first指向队列的开头，实例变量last指向队列的结尾。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Iterator;public class Queue&lt;E&gt; implements Iterable&lt;E&gt;&#123; private int n; private Node first; private Node last; private class Node&#123; E e; Node next; &#125; public boolean isEmpty()&#123; return n == 0; &#125; public int size()&#123; return n; &#125; public void enqueue(E e)&#123; Node oldLast = last; last = new Node(); last.e = e; if (isEmpty()) first = last; else oldLast.next = last; n++; &#125; public E dequeue()&#123; E e = first.e; first = first.next; if (isEmpty()) last = first; n--; return e; &#125; public Iterator&lt;E&gt; iterator()&#123; return new ListIterator(); &#125; private class ListIterator implements Iterator&lt;E&gt;&#123; Node current = first; @Override public boolean hasNext() &#123; return current != null; &#125; @Override public E next() &#123; E e = current.e; current = current.next; return e; &#125; &#125;&#125; 二叉堆在二叉堆的数组中，每个元素都要保证大于等于另两个特定位置的元素。相应地，这些位置的元素又至少要大于等于数组中的另两个元素，以此类推。 定义当一棵二叉树的结点都大于等于它的两个子结点时，它被称为堆有序。 二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组的第一个位置）。 根结点是堆有序的二叉树中的最大结点 一棵大小为N的完全二叉树的高度为floor(lgN) 示意 由下至上的堆有序化（上浮）如果堆的有序状态因为某个结点变得比它的父结点更大而被打破，那么就需要通过交换它和它的父结点来修复堆。 示意 实现123456private void swim(int k)&#123; while (k &gt; 1 &amp;&amp; less(k/2, k))&#123; exch(k, k/2); k /= 2; &#125;&#125; 由上至下的堆有序化（下沉）如果堆的有序状态因为某个结点变得比它的两个子结点或是其中之一更小了而被打破了，那么可以通过将它和它的两个子结点中的较大者交换来恢复堆。 示意 实现123456789101112131415private void sink(int k)&#123; while (2 * k &lt;= n)&#123; int j = 2 * k; if (j &lt; n &amp;&amp; less(j, j+1)) j++; if (!less(k, j)) break; exch(k, j); k = j; &#125;&#125; 优先队列优先队列是一种抽象数据类型，它表示了一组值和对这些值的操作。优先队列最重要的操作就是删除最大元素delMax()和插入元素insert()。 示意 插入元素将新元素加到数组末尾，增加堆的大小并让这个新元素上浮到合适的位置。 删除最大元素从数组顶端删去最大的元素并将数组的最后一个元素放到顶端，减小堆的大小并让这个元素下沉到合适的位置。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt; &#123; private Key[] pq; private int n = 0; public MaxPQ(int max)&#123; pq = (Key[]) new Comparable[max+1]; &#125; public boolean isEmpty()&#123; return n == 0; &#125; public int size()&#123; return n; &#125; public void insert(Key k)&#123; pq[++n] = k; swim(n); &#125; public Key delMax()&#123; Key k = pq[1]; exch(1, n); n--; pq[n+1] = null; sink(1); return k; &#125; private boolean less(int i, int j)&#123; return pq[i].compareTo(pq[j]) &lt; 0; &#125; private void exch(int i, int j)&#123; Key t = pq[i]; pq[i] = pq[j]; pq[j] = t; &#125; private void swim(int k)&#123; while (k &gt; 1 &amp;&amp; less(k/2, k))&#123; exch(k, k/2); k /= 2; &#125; &#125; private void sink(int k)&#123; while (2 * k &lt;= n)&#123; int j = 2 * k; if (j &lt; n &amp;&amp; less(j, j+1)) j++; if (!less(k, j)) break; exch(k, j); k = j; &#125; &#125;&#125; 特点对于一个含有N个元素的基于堆的优先队列，插入元素操作只需不超过（lgN+1）次比较，删除最大元素的操作需要不超过2lgN次比较。 二叉树二叉树由结点组成，结点包含的链接可以指向空（null）或者其他结点。在二叉树中，每个结点只能有一个父结点指向自己（只有一个例外，也就是根结点，它没有父结点），而且每个结点都只有左右两个链接，分别指向自己的左子结点和右子结点。 示意 二叉查找树一棵二叉查找树（BST）是一棵二叉树，其中每个结点都含有一个Comparable的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。 示意 查找 插入 向下取整 选择 删除最小键 删除 范围查找需要一个遍历二叉查找树的基本方法，叫做中序遍历。 平衡查找树在一棵含有N个结点的树中，树高为～lgN。 2-3查找树一棵2-3查找树或为一棵空树，或由以下结点组成： 2-结点，含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。 3-结点，含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。 将指向一棵空树的链接称为空链接。 一棵完美平衡的2-3查找树中的所有空链接到根结点的距离都应该是相同的。 示意 查找 插入向2-结点中插入新键 向一棵只含有一个3-结点的树中插入新键 向一个父结点为2-结点的3-结点中插入新键 向一个父结点为3-结点的3-结点中插入新键 分解根结点 特点在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过lgN个。 2-3树插入算法的根本在于这些变换都是局部的：除了相关的结点和链接之外不必修改或者检查树的其他部分。 这些局部变换不会影响树的全局有序性和平衡性：任意空链接到根结点的路径长度都是相等的。 比较和标准的二叉查找树由上向下生长不同，2-3树的生长是由下向上的。 需要维护两种不同类型的结点，将被查找的键和结点中的每个键进行比较，将链接和其他信息从一种结点复制到另一种结点，将结点从一种数据类型转换到另一种数据类型等等。实现这些不仅需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。 红黑二叉查找树红黑二叉查找树背后的基本思想是用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。将树中的链接分为两种类型： 红链接：将两个2-结点连接起来构成一个3-结点 黑链接：2-3树中的普通链接。 确切的说，将3-结点表示为由一条左斜的红色链接（两个2-结点其中之一是另一个的左子结点）相连的两个2-结点。 示意 定义红黑树是含有红黑链接并满足下列条件的二叉查找树： 红链接均为左链接 没有任何一个结点同时和两条红链接相连 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同 颜色表示 颜色转换 旋转 实现12345678910111213141516171819202122232425private Node rotateLeft(Node h)&#123; Node x = h.right; h.right = x.left; x.left = h; x.color = h.color; h.color = RED; x.n = h.n; h.n = size(h.left) + size(h.right) + 1; return x;&#125;private Node rotateRight(Node h)&#123; Node x = h.left; h.left = x.right; x.right = h; x.color = h.color; h.color = RED; x.n = h.n; h.n = size(h.left) + size(h.right) + 1; return x;&#125; 插入向2-结点中插入新键 向树底部的2-结点插入新键 向一棵双键树（即一个3-结点）中插入新键 向树底部的3-结点插入新键 删除不仅要在构造临时4-结点时沿着查找路径向下进行变换，还要在分解遗留的4-结点时沿着查找路径向上进行变换。 删除最小键 特点 对于任意的2-3树，只要对结点进行转换，都可以立即派生出一棵对应的二叉查找树。 红黑树既是二叉查找树，也是2-3树。 散列表示意 散列函数如果有一个能够保存M个键值对的数组，那么就需要一个能够将任意键转化为该数组范围内的索引（[0, M-1]范围内的整数）的散列函数。要找的散列函数应该易于计算并且能够均匀分布所有的键，即对于任意键，0到M-1之间的每个整数都有相等的可能性与之对应（与键无关）。 特点散列表是算法在时间和空间上作出权衡的经典例子。不必重写代码，只需要调整散列算法的参数就可以在空间和时间之间作出取舍。 邻接表将每个顶点的所有相邻顶点都保存在该顶点对应的元素所指向的一张链表中。 示意 特点 使用的空间和V+E成正比 添加一条边所需的时间为常数 遍历顶点v的所有相邻顶点所需的时间和v的度数成正比（处理每个相邻顶点所需的时间为常数） 无向图边仅仅是两个顶点之间的连接。 当两个顶点通过一条边相连时，称这两个顶点是相邻的，并称该连接依附于这两个顶点。某个顶点的度数即为依附于它的边的总数。子图是由一幅图的所有边的一个子集（以及它们所依附的所有顶点）组成的图。 当两个顶点之间存在一条连接双方的路径时，称一个顶点和另一个顶点是连通的。 特殊的图： 自环，即一条连接一个顶点和其自身的边 连接同一对顶点的两条边称为平行边 当且仅当一幅含有V个结点的图G满足下列5个条件之一时，它就是一棵树： G有V-1条边且不含有环 G有V-1条边且是连通的 G是连通的，但删除任意一条边都会使它不再连通 G是无环图，但添加任意一条边都会产生一条环 G中的任意一对顶点之间仅存在一条简单路径 图的密度是指已经连接的顶点对占所有可能被连接的顶点对的比例。在稀疏图中，被连接的顶点对很少；而在稠密图中，只有少部分顶点对之间没有边连接。 二分图是一种能够将所有结点分为两部分的图，其中图的每条边所连接的两个顶点都分别属于不同的部分。 定义图是由一组顶点和一组能够将两个顶点相连的边组成的。 在图中，路径是由边顺序连接的一系列顶点。简单路径是一条没有重复顶点的路径。环是一条至少含有一条边且起点和终点相同的路径，简单环是一条（除了起点和终点必须相同之外）不含有重复顶点和边的环。路径或者环的长度为其中所包含的边数。 如果从任意一个顶点都存在一条路径到达另一个任意顶点，称这幅图是连通图。一幅非连通的图由若干连通的部分组成，它们都是其极大连通子图。 树是一幅无环连通图。互不相连的树组成的集合称为森林。连通图的生成树是它的一幅子图，它含有图中的所有顶点且是一棵树。图的生成树森林是它的所有连通子图的生成树的集合。 示意 实现1234567891011121314151617181920212223242526272829303132public class Graph &#123; private final int V; private int E; private Stack&lt;Integer&gt;[] adj; public Graph(int V)&#123; this.V = V; this.E = 0; adj = (Stack&lt;Integer&gt;[]) new Stack[V]; for (int v = 0; v &lt; V; v++) adj[v] = new Stack&lt;Integer&gt;(); &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; public void addEdge(int v, int w)&#123; adj[v].push(w); adj[w].push(v); E++; &#125; public Iterable&lt;Integer&gt; adj(int v)&#123; return adj[v]; &#125;&#125; 有向图边是单向的：每条边所连接的两个顶点都是一个有序对，它们的邻接性是单向的。 一个顶点的出度为由该顶点指出的边的总数；一个顶点的入度为指向该顶点的边的总数。 一条有向边的第一个顶点称为它的头，第二个顶点则被称为它的尾。 两个顶点是强连通的当且仅当它们都在一个普通的有向环中。 有向图中的强连通性是一种顶点之间平等关系，因为它有着以下性质： 自反性：任意顶点v和自己都是强连通的。 对称性：如果v和w是强连通的，那么w和v也是强连通的。 传递性：如果v和w是强连通的且w和x也是强连通的，那么v和x也是强连通的。 作为一种平等关系，强连通行将所有顶点分为了一些平等的部分，每个部分都是由相互均为强连通的顶点的最大子集组成的，将这些子集称为强连通分量。一个含有V个顶点的有向图含有1～V个强连通分量，一个强连通图只含有一个强连通分量，而一个有向无环图中则含有V个强连通分量。 定义一幅有方向性的图（或有向图）是由一组顶点和一组有方向的边组成的，每条有方向的边都连接着有序的一对顶点。 在一幅有向图中，有向路径由一系列顶点组成，对于其中的每个顶点都存在一条有向边从它指向序列中的下一个顶点。有向环为一条至少含有一条边且起点和终点相同的有向路径。简单有向环是一条（除了起点和终点必须相同之外）不含有重复的顶点和边的环。路径或者环的长度即为其中所包含的边数。 如果两个顶点v和w是互相可达的，则称它们为强连通的。也就是说，既存在一条从v到w的有向路径，也存在一条从w到v的有向路径。如果一幅有向图中的任意两个顶点都是强连通的，则称这幅有向图也是强连通的。 示意 实现12345678910111213141516171819202122232425262728293031323334353637383940414243public class Digraph &#123; private final int V; private int E; private Stack&lt;Integer&gt;[] adj; public Digraph(int V)&#123; this.V = V; this.E = 0; adj = (Stack&lt;Integer&gt;[]) new Stack[V]; for (int v = 0; v &lt; V; v++)&#123; adj[v] = new Stack&lt;Integer&gt;(); &#125; &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; public void addEdge(int v, int w)&#123; adj[v].push(w); E++; &#125; public Iterable&lt;Integer&gt; adj(int v)&#123; return adj[v]; &#125; public Digraph reverse()&#123; Digraph tmp = new Digraph(V); for (int v = 0; v &lt; V; v++)&#123; for (int w : adj[v]) tmp.addEdge(w, v); &#125; return tmp; &#125;&#125; 加权无向图加权图是一种为每条边关联一个权值或是成本的图模型。 示意 实现123456789101112131415161718192021222324252627282930public class Edge implements Comparable&lt;Edge&gt; &#123; private final int v; private final int w; private final double weight; public Edge(int v, int w, double weight)&#123; this.v = v; this.w = w; this.weight = weight; &#125; public double weight()&#123; return weight; &#125; public int either()&#123; return v; &#125; public int other(int vertex)&#123; if (vertex == v) return w; else return v; &#125; public int compareTo(Edge that)&#123; return Double.compare(this.weight, that.weight); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class EdgeWeightedGraph &#123; private final int V; private int E; private Stack&lt;Edge&gt;[] adj; public EdgeWeightedGraph(int V)&#123; this.V = V; this.E = 0; adj = (Stack&lt;Edge&gt;[]) new Stack[V]; for (int v = 0; v &lt; V; v++) adj[v] = new Stack&lt;Edge&gt;(); &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; public void addEdge(Edge e)&#123; int v = e.either(); int w = e.other(v); adj[v].push(e); adj[w].push(e); E++; &#125; public Iterable&lt;Edge&gt; adj(int v)&#123; return adj[v]; &#125; public Iterable&lt;Edge&gt; edges()&#123; Stack&lt;Edge&gt; stack = new Stack&lt;Edge&gt;(); for (int v = 0; v &lt; V; v++)&#123; for(Edge e : adj[v])&#123; if (e.other(v) &gt; v) stack.push(e); &#125; &#125; return stack; &#125;&#125; 最小生成树定义图的生成树是它的一棵含有其所有顶点的无环连通子图。一幅加权无向图的最小生成树（MST）是它的一棵权值（树中所有边的权值之和）最小的生成树。 示意 切分定理把加权图中的所有顶点分为两个集合、检查横跨两个集合的所有边并识别哪条边应属于图的最小生成树。通常，通过指定一个顶点集并隐式地认为它的补集为另一个顶点集来指定一个切分。这样，一条横切边就是连接该集合的一个顶点和不在该集合中的另一个顶点的一条边。 定义图的一种切分是将图的所有顶点分为两个非空且不重复的两个集合。横切边是一条连接两个属于不同集合的顶点的边。 在一幅加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树。 示意 贪心算法使用切分定理找到最小生成树的一条边，不断重复直到找到最小生成树的所有边。 定义将含有V个顶点的任意加权连通图中属于最小生成树的边标记为黑色：初始状态下所有边均为灰色，找到一种切分，它产生的横切边均不为黑色。将它权重最小的横切边标记为黑色。反复，直到标记了V-1条黑色边为止。 示意 加权有向图在加权有向图中，每条有向路径都有一个与之关联的路径权重。 示意 实现1234567891011121314151617181920212223public class DirectedEdge &#123; private final int v; private final int w; private final double weight; public DirectedEdge(int v, int w, double weight)&#123; this.v = v; this.w = w; this.weight = weight; &#125; public double weight()&#123; return weight; &#125; public int from()&#123; return v; &#125; public int to()&#123; return w; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142public class EdgeWeightedDigraph &#123; private final int V; private int E; private Stack&lt;DirectedEdge&gt;[] adj; public EdgeWeightedDigraph(int V)&#123; this.V = V; this.E = 0; adj = (Stack&lt;DirectedEdge&gt;[]) new Stack[V]; for (int v = 0; v &lt; V; v++) adj[v] = new Stack&lt;DirectedEdge&gt;(); &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; public void addEdge(DirectedEdge e)&#123; adj[e.from()].push(e); E++; &#125; public Iterable&lt;DirectedEdge&gt; adj(int v)&#123; return adj[v]; &#125; public Iterable&lt;DirectedEdge&gt; edges()&#123; Stack&lt;DirectedEdge&gt; stack = new Stack&lt;DirectedEdge&gt;(); for (int v = 0; v &lt; V; v++)&#123; for(DirectedEdge e : adj[v]) stack.push(e); &#125; return stack; &#125;&#125; 最短路径树最短路径定义在一幅加权有向图中，从顶点s到顶点t的最短路径是所有从s到t的路径中的权重最小者。 示意 定义给定一幅加权有向图和一个顶点s，以s为起点的一棵最短路径树是图的一幅子图，它包含s和从s可达的所有顶点。这棵有向树的根结点为s，树的每条路径都是有向图中的一条最短路径。 示意 边的松弛放松边v-&gt;w意味着检查从s到w的最短路径是否是先从s到v，然后再由v到w。如果是，则根据这个情况更新数据结构的内容。 示意 实现123456789private void relax(DirectedEdge e)&#123; int v = e.from(); int w = e.to(); if (distTo[v] + e.weight() &lt; distTo[w])&#123; distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; &#125;&#125; 顶点的松弛放松从一个给定顶点指出的所有边。 示意 实现12345678910private void relax(EdgeWeightedDigraph g, int v)&#123; for (DirectedEdge e : g.adj(v))&#123; int w = e.to(); if (distTo[v] + e.weight() &lt; distTo[w])&#123; distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; &#125; &#125;&#125; 负权重的环示意 定义加权有向图中的负权重环是一个总权重（环上的所有边的权重之和）为负的有向环。 当且仅当加权有向图中至少存在一条从s到v的有向路径且所有从s到v的有向路径上的任意顶点都不存在于任何负权重环中时，s到v的最短路径才是存在的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Algorithm from NowCoder (5)]]></title>
      <url>%2F2017%2F04%2F09%2FAlgorithm-from-NowCoder-5%2F</url>
      <content type="text"><![CDATA[No. 1 最长公共连续子串牛牛有两个字符串（可能包含空格）,牛牛想找出其中最长的公共连续子串,希望你能帮助他,并输出其长度。 输入描述输入为两行字符串（可能包含空格），长度均小于等于50. 输出描述输出为一个整数，表示最长公共连续子串的长度。 输入例子abcdeabgde 输出例子2 代码12345678910111213141516171819202122232425262728293031323334import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String s1 = sc.nextLine(); String s2 = sc.nextLine(); if (s1.length() &gt; 50 || s2.length() &gt; 50) return; int[][] dp = new int[s1.length()+1][s2.length()+1]; int max = 0; for (int i = 0; i &lt; s1.length(); i++)&#123; for (int j = 0; j &lt; s2.length(); j++)&#123; if (s1.charAt(i) == s2.charAt(j)) dp[i+1][j+1] = dp[i][j] + 1; &#125; &#125; for (int i = 1; i &lt;= s1.length(); i++)&#123; for (int j = 1; j &lt;= s2.length(); j++)&#123; if (dp[i][j] &gt; max) max = dp[i][j]; &#125; &#125; System.out.println(max); &#125;&#125; No. 2 找整除牛牛想在[a, b]区间内找到一些数满足可以被一个整数c整除,现在你需要帮助牛牛统计区间内一共有多少个这样的数满足条件？ 输入描述首先输入两个整数a,b,（-510^8 ≤ a ≤ b ≤ 510^8)接着是一个正整数c（1 &lt;= c &lt;= 1000） 输出描述输出一个整数表示个数。 输入例子0 14 5 输出例子3 代码12345678910111213141516171819202122import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int a = sc.nextInt(); int b = sc.nextInt(); int c = sc.nextInt(); if (a &lt; -5 * Math.pow(10, 8) || a &gt; 5 * Math.pow(10, 8) || b &lt; -5 * Math.pow(10, 8) || b &gt; 5 * Math.pow(10, 8) || c &lt; 1 || c &gt; 1000) return; while (b % c != 0) b--; System.out.println((b - a) / c + 1); &#125;&#125; No. 3 组装三角形牛牛手里有N根木棒,分别编号为1~N,现在他从N根里想取出三根木棒，使得三根木棒构成一个三角形,你能计算出牛牛有多少种取法吗?(考虑两种取法中使用的木棒编号有一个不一样就认为是不同的取法)。 输入描述首先输入一个正整数N，接下来的一行共有N个正整数表示每个木棒的长度。 N ≤ 50, 木棒的长度 ≤ 10000. 输出描述输出一个整数表示方法数。 输入例子51 2 3 4 5 输出例子3 代码123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Arrays;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); if (n &gt; 50) return; int[] a = new int[n]; for (int i = 0 ; i &lt; n; i++)&#123; int x = sc.nextInt(); if (x &gt; 10000) return; a[i] = x; &#125; Arrays.sort(a); int count = 0; for (int i = n - 1; i &gt;= 2; i--)&#123; for (int j = i - 1; j &gt;= 1 &amp;&amp; 2 * a[j] &gt;= a[i]; j--)&#123; for (int k = j - 1; k &gt;=0; k--)&#123; if (a[j] + a[k] &lt;= a[i]) break; count++; &#125; &#125; &#125; System.out.println(count); &#125;&#125; No. 4 最小的矩形牛牛在二维坐标系中画了N个点，且都是整点。现在牛牛想画出一个矩形，使得这N个点都在矩形内或者在矩形上。矩形的边均平行于坐标轴。牛牛希望矩形的面积最小。请你帮助牛牛计算下最小矩形的面积。 输入描述首先输入一个正整数N表示点的个数（2 &lt;= N &lt;= 50） 接下来N行每行两个整数x, y，表示该点的坐标。绝对值均小于等于100. 输出描述一个整数表示最小矩形的面积。 输入例子20 11 0 输出例子1 代码12345678910111213141516171819202122232425262728293031323334import java.util.Arrays;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); if (n &lt; 2 || n &gt; 50) return; int[] xPos = new int[n]; int[] yPos = new int[n]; for (int i = 0; i &lt; n; i++)&#123; int x = sc.nextInt(); int y = sc.nextInt(); if (Math.abs(x) &gt; 100 || Math.abs(y) &gt; 100) return; xPos[i] = x; yPos[i] = y; &#125; Arrays.sort(xPos); Arrays.sort(yPos); System.out.println((xPos[n-1] - xPos[0]) * (yPos[n-1] - yPos[0])); &#125;&#125; No. 5 平衡数牛牛在研究他自己独创的平衡数，平衡数的定义是：将一个数分成左右两部分，分别成为两个新的数。左右部分必须满足以下两点：1，左边和右边至少存在一位。2，左边的数每一位相乘如果等于右边的数每一位相乘，则这个数称为平衡数。例如：1221这个数，分成12和21的话，12=21，则称1221为平衡数，再例如：1236这个数，可以分成123和123=6，所以1236也是平衡数。而1234无论怎样分也不满足平衡数。 输入描述输入一个正整数（int范围内）。 输出描述如果该数是平衡数，输出 “YES”, 否则输出 “NO”。 输入例子12211234 输出例子YESNO 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNext())&#123; String n = sc.next(); if (n.length() &lt; 2)&#123; System.out.println("NO"); return; &#125; int[] digit = new int[n.length()]; for (int i = 0; i &lt; n.length(); i++) digit[i] = n.charAt(i) - '0'; int head = 0; int tail = n.length() - 1; int left = digit[head]; int right = digit[tail]; while (head &lt; tail - 1)&#123; if ((left &lt;= right &amp;&amp; left != 0) || right == 0)&#123; head++; left *= digit[head]; &#125; else if ((left &gt; right &amp;&amp; right != 0) || left == 0)&#123; tail--; right *= digit[tail]; &#125; &#125; if (left != right) System.out.println("NO"); else System.out.println("YES"); &#125; &#125;&#125; No. 6 字符串分类牛牛有N个字符串，他想将这些字符串分类，他认为两个字符串A和B属于同一类需要满足以下条件：A中交换任意位置的两个字符，最终可以得到B，交换的次数不限。比如：abc与bca就是同一类字符串。现在牛牛想知道这N个字符串可以分成几类。 输入描述首先输入一个正整数N（1 &lt;= N &lt;= 50），接下来输入N个字符串，每个字符串长度不超过50。 输出描述输出一个整数表示分类的个数。 输入例子4abcdabdcdabcbacd 输出例子1 代码12345678910111213141516171819202122232425262728import java.util.Arrays;import java.util.HashSet;import java.util.Scanner;import java.util.Set;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); if (n &lt; 1 || n &gt; 50) return; Set&lt;String&gt; set = new HashSet&lt;String&gt;(); for (int i = 0; i &lt; n; i++)&#123; char[] ch = sc.next().toCharArray(); Arrays.sort(ch); set.add(String.valueOf(ch)); &#125; System.out.println(set.size()); &#125;&#125; No. 7 创造新世界众所周知计算机代码底层计算都是0和1的计算，牛牛知道这点之后就想使用0和1创造一个新世界！牛牛现在手里有n个0和m个1，给出牛牛可以创造的x种物品，每种物品都由一个01串表示。牛牛想知道当前手中的0和1可以最多创造出多少种物品。 输入描述输入数据包括x+1行：第一行包括三个整数x(2 ≤ x ≤ 20)，n(0 ≤ n ≤ 500)，m(0 ≤ m ≤ 500)，以空格分隔接下来的x行，每行一个01串item[i]，表示第i个物品。每个物品的长度length(1 ≤ length ≤ 50) 输出描述输出一个整数，表示牛牛最多能创造多少种物品 输入例子3 3 1100100 输出例子2 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int x = sc.nextInt(); int n = sc.nextInt(); int m = sc.nextInt(); if (x &lt; 2 || x &gt; 20 || n &lt; 0 || n &gt; 500 || m &lt; 0 || m &gt; 500) return; int[] zero = new int[x]; int[] one = new int[x]; for (int i = 0; i &lt; x; i++)&#123; String item = sc.next(); if (item.length() &lt; 1 || item.length() &gt; 50) return; for (int j = 0; j &lt; item.length(); j++)&#123; if (item.charAt(j) == '0') zero[i]++; else one[i]++; &#125; &#125; int[][] dp = new int[n+1][m+1]; for (int i = 0; i &lt; x; i++)&#123; for (int u = n; u &gt;= zero[i]; u--)&#123; for (int v = m; v &gt;= one[i]; v--) dp[u][v] = Math.max(dp[u][v], dp[u-zero[i]][v-one[i]]+1); &#125; &#125; System.out.println(dp[n][m]); &#125;&#125; No. 8 优美的回文串牛牛在书上看到一种字符串叫做回文串,当一个字符串从左到右和从右到左读都是一样的,就称这个字符串为回文串。牛牛又从好朋友羊羊那里了解到一种被称为优美的回文串的字符串,考虑一个长度为N只包含大写字母的字符串,写出它所有长度为M的连续子串(包含所有可能的起始位置的子串,相同的子串也要计入),如果这个字符串至少有K个子串都是回文串,我们就叫这个字符串为优美的回文串。现在给出一个N,牛牛希望你能帮他计算出长度为N的字符串有多少个是优美的回文串(每个位置都可以是’A’~’Z’的一个。) 输入描述输入数据包括三个整数N, M, K(2 ≤ N ≤ 11, 2 ≤ M ≤ N, 0 ≤ K ≤ 11). 输出描述输出一个整数,表示所求的字符串个数. 输入例子2 2 1 输出例子26长度为2的字符串,它长度为2的子串只有它自身。长度为2的回文串有”AA”,”BB”,”CC”…”ZZ”,一共26种。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.Scanner;public class Main &#123; static int n, m, k; static long result = 0; static long[] count = new long[12]; static int[] pattern = new int[12]; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); k = sc.nextInt(); if (n &lt; 2 || n &gt; 11 || m &lt; 2 || m &gt; n || k &lt; 0 || k &gt; 11) return; count[0] = 1; for (int i = 1; i &lt;= n; i++) count[i] = count[i-1] * (26 - i + 1); find(0, 0); System.out.println(result); &#125; private static void find(int pos, int num)&#123; if (pos == n)&#123; if (check()) result += count[num]; return; &#125; for (int i = 0; i &lt; num; i++)&#123; pattern[pos] = i; find(pos + 1, num); &#125; pattern[pos] = num; find(pos + 1, num + 1); &#125; private static boolean check()&#123; int sum = 0; for (int i = 0; i &lt;= n - m; i++)&#123; boolean isPalindrome = true; for (int j = 0; j &lt; m / 2 &amp;&amp; isPalindrome == true; j++)&#123; if (pattern[i+j] != pattern[m+i-1-j]) isPalindrome = false; &#125; if (isPalindrome == true) sum++; &#125; return (sum &gt;= k); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[hihoCoder] Problem 1288 - Font Size]]></title>
      <url>%2F2017%2F04%2F01%2FhihoCoder-Problem-1288-Font-Size%2F</url>
      <content type="text"><![CDATA[Steven loves reading book on his phone. The book he reads now consists of N paragraphs and the i-th paragraph contains ai characters. Steven wants to make the characters easier to read, so he decides to increase the font size of characters. But the size of Steven’s phone screen is limited. Its width is W and height is H. As a result, if the font size of characters is S then it can only show ⌊W / S⌋ characters in a line and ⌊H / S⌋ lines in a page. (⌊x⌋ is the largest integer no more than x) So here’s the question, if Steven wants to control the number of pages no more than P, what’s the maximum font size he can set? Note that paragraphs must start in a new line and there is no empty line between paragraphs. Time Limit:10000msCase Time Limit:1000msMemory Limit:256MB InputInput may contain multiple test cases. The first line is an integer TASKS, representing the number of test cases. For each test case, the first line contains four integers N, P, W and H, as described above. The second line contains N integers a1, a2, … aN, indicating the number of characters in each paragraph. For all test cases, 1 &lt;= N &lt;= 10^3, 1 &lt;= W, H, ai &lt;= 10^3, 1 &lt;= P &lt;= 10^6, There is always a way to control the number of pages no more than P. OutputFor each testcase, output a line with an integer Ans, indicating the maximum font size Steven can set. Sample Input21 10 4 3102 10 4 310 10 Sample Output32 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int t = sc.nextInt(); for (int i = 0; i &lt; t; i++) &#123; int n = sc.nextInt(); int p = sc.nextInt(); int w = sc.nextInt(); int h = sc.nextInt(); if (n &lt; 1 || n &gt; 1000 || w &lt; 1 || w &gt; 1000 || h &lt; 1 || h &gt; 1000 || p &lt; 1 || p &gt; 1000000) return; int[] a = new int[n]; for (int j = 0; j &lt; n; j++)&#123; int x = sc.nextInt(); if (x &lt; 1 || x &gt; 1000) return; a[j] = x; &#125; int result = binarySearch(w, h, p, a); System.out.println(result); &#125; &#125; private static double validatePages(int mid, int w, int h, int[] a) &#123; double charactersPerLine = w / mid; double linesPerPage = h / mid; int lines = 0; for (int i = 0; i &lt; a.length; i++) lines += Math.ceil(a[i] / charactersPerLine); double pages = Math.ceil(lines / linesPerPage); return pages; &#125; private static int binarySearch(int w, int h, int p, int[] a) &#123; int left = 0; int right = Math.min(w, h); int result = 0; while (left &lt;= right)&#123; int mid = (left + right) / 2; if (validatePages(mid, w, h, a) &lt;= p)&#123; result = mid; left = mid + 1; &#125; else right = mid - 1; &#125; return result; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LightOJ] Problem 1138 - Trailing Zeroes (III)]]></title>
      <url>%2F2017%2F04%2F01%2FLightOJ-Problem-1138-Trailing-Zeroes-III%2F</url>
      <content type="text"><![CDATA[You task is to find minimal natural number N, so that N! contains exactly Q zeroes on the trail in decimal notation. As you know N! = 12…*N. For example, 5! = 120, 120 contains one zero on the trail. Time Limit: 2 second(s)Memory Limit: 32 MB InputInput starts with an integer T (≤ 10000), denoting the number of test cases. Each case contains an integer Q (1 ≤ Q ≤ 10^8) in a line. OutputFor each case, print the case number and N. If no solution is found then print ‘impossible’. Sample Input3125 Output for Sample InputCase 1: 5Case 2: 10Case 3: impossible Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int t = sc.nextInt(); if (t &lt; 1 || t &gt; 10000) return; for (int i = 1; i &lt;= t; i++) &#123; int x = sc.nextInt(); if (x &lt; 1 || x &gt; Math.pow(10, 8)) return; long result = binarySearch(1, Long.MAX_VALUE, x); if (result != -1) System.out.println("Case " + i + ": " + result); else System.out.println("Case " + i + ": impossible"); &#125; &#125; private static long trailingZeroes(long n) &#123; return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5); &#125; private static long binarySearch(long left, long right, long key) &#123; while (left &lt;= right)&#123; long mid = (left + right) / 2; if (trailingZeroes(mid) == key &amp;&amp; trailingZeroes(mid - 1) &lt; key) return mid; else if (trailingZeroes(mid) &lt; key) left = mid + 1; else right = mid - 1; &#125; return -1; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Algorithm from NowCoder (4)]]></title>
      <url>%2F2017%2F03%2F27%2FAlgorithm-from-NowCoder-4%2F</url>
      <content type="text"><![CDATA[No. 1 好多鱼！牛牛有一个鱼缸。鱼缸里面已经有n条鱼，每条鱼的大小为fishSize[i] (1 ≤ i ≤ n,均为正整数)，牛牛现在想把新捕捉的鱼放入鱼缸。鱼缸内存在着大鱼吃小鱼的定律。经过观察，牛牛发现一条鱼A的大小为另外一条鱼B大小的2倍到10倍(包括2倍大小和10倍大小)，鱼A会吃掉鱼B。考虑到这个，牛牛要放入的鱼就需要保证：1、放进去的鱼是安全的，不会被其他鱼吃掉2、这条鱼放进去也不能吃掉其他鱼鱼缸里面已经存在的鱼已经相处了很久，不考虑他们互相捕食。现在知道新放入鱼的大小范围[minSize,maxSize](考虑鱼的大小都是整数表示),牛牛想知道有多少种大小的鱼可以放入这个鱼缸。 输入描述输入数据包括3行.第一行为新放入鱼的尺寸范围minSize,maxSize(1 ≤ minSize,maxSize ≤ 1000)，以空格分隔。 第二行为鱼缸里面已经有鱼的数量n(1 ≤ n ≤ 50) 第三行为已经有的鱼的大小fishSize[i](1 ≤ fishSize[i] ≤ 1000)，以空格分隔。 输出描述输出有多少种大小的鱼可以放入这个鱼缸。考虑鱼的大小都是整数表示 输入例子1 1211 输出例子3 代码12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int minSize = sc.nextInt(); int maxSize = sc.nextInt(); int n = sc.nextInt(); if (minSize &lt; 1 || minSize &gt; 1000 || maxSize &lt; 1 || maxSize &gt; 1000 || n &lt; 1 || n &gt; 50) return; int[] fishSize = new int[n]; for (int i = 0; i &lt; n; i++)&#123; int x = sc.nextInt(); if (x &lt; 1 || x &gt; 1000) return; fishSize[i] = x; &#125; int count = 0; for (int i = minSize; i &lt;= maxSize; i++)&#123; boolean isEaten = false; for (int j = 0; j &lt; n &amp;&amp; isEaten == false; j++)&#123; if ((i &lt;= fishSize[j] * 10 &amp;&amp; i &gt;= fishSize[j] * 2) || (10 * i &gt;= fishSize[j] &amp;&amp; 2 * i &lt;= fishSize[j])) isEaten = true; &#125; if (!isEaten) count++; &#125; System.out.println(count); &#125;&#125; No. 2 循环单词如果一个单词通过循环右移获得的单词，我们称这些单词都为一种循环单词。 例如：picture 和 turepic 就是属于同一种循环单词。 现在给出n个单词，需要统计这个n个单词中有多少种循环单词。 输入描述输入包括n+1行： 第一行为单词个数n(1 ≤ n ≤ 50) 接下来的n行，每行一个单词word[i]，长度length(1 ≤ length ≤ 50)。由小写字母构成 输出描述输出循环单词的种数 输入例子5pictureturepicicturepwordordw 输出例子2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.ArrayList;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); if (n &lt; 1 || n &gt; 50) return; String[] word = new String[n]; for (int i = 0; i &lt; n; i++)&#123; String str = sc.next(); if (str.length() &lt; 1 || str.length() &gt; 50) return; word[i] =str; &#125; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); int count = 0; for (int i = 0; i &lt; n; i++)&#123; String str = word[i]; if (!list.contains(str))&#123; list.add(str); count++; for (int j = 1; j &lt; str.length(); j++)&#123; String newString = new String(); // newString = str.substring(j) + str.substring(0, j); newString = str + str; newString = newString.substring(j, j + str.length()); list.add(newString); &#125; &#125; &#125; System.out.println(count); &#125;&#125; No. 3 DNA合成DNA分子是以4种脱氧核苷酸为单位连接而成的长链，这4种脱氧核苷酸分别含有A,T,C,G四种碱基。碱基互补配对原则：A和T是配对的，C和G是配对的。如果两条碱基链长度是相同的并且每个位置的碱基是配对的，那么他们就可以配对合成为DNA的双螺旋结构。现在给出两条碱基链，允许在其中一条上做替换操作：把序列上的某个位置的碱基更换为另外一种碱基。问最少需要多少次让两条碱基链配对成功 输入描述输入包括一行：包括两个字符串,分别表示两条链,两个字符串长度相同且长度均小于等于50。 输出描述输出一个整数，即最少需要多少次让两条碱基链配对成功 输入例子ACGT TGCA 输出例子0 代码12345678910111213141516171819202122232425262728293031323334import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String str1 = sc.next(); String str2 = sc.next(); if (str1.length() != str2.length() || str1.length() &gt; 50 || str2.length() &gt; 50) return; int count = 0; int a = 'A' + 'T'; int b = 'C' + 'G'; for (int i = 0; i &lt; str1.length(); i++)&#123;// if ((str1.charAt(i) == 'A' &amp;&amp; str2.charAt(i) == 'T') || (str1.charAt(i) == 'T' &amp;&amp; str2.charAt(i) == 'A') || // (str1.charAt(i) == 'C' &amp;&amp; str2.charAt(i) == 'G') || (str1.charAt(i) == 'G' &amp;&amp; str2.charAt(i) == 'C'))// count++; int c = str1.charAt(i) + str2.charAt(i); if (a != c &amp;&amp; b != c) count++; &#125; // System.out.println(str1.length() - count); System.out.println(count); &#125;&#125; No. 4 连续整数牛牛的好朋友羊羊在纸上写了n+1个整数，羊羊接着抹除掉了一个整数，给牛牛猜他抹除掉的数字是什么。牛牛知道羊羊写的整数神排序之后是一串连续的正整数，牛牛现在要猜出所有可能是抹除掉的整数。例如：10 7 12 8 11 那么抹除掉的整数只可能是95 6 7 8 那么抹除掉的整数可能是4也可能是9 输入描述输入包括2行： 第一行为整数n(1 &lt;= n &lt;= 50)，即抹除一个数之后剩下的数字个数 第二行为n个整数num[i] (1 &lt;= num[i] &lt;= 1000000000) 输出描述在一行中输出所有可能是抹除掉的数,从小到大输出,用空格分割,行末无空格。如果没有可能的数，则输出mistake 输入例子23 6 输出例子mistake 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.Arrays;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); if (n &lt; 1 || n &gt; 50) return; // int[] num = new int[n]; int min = 1000000001; int max = 0; int res = 0; for (int i = 0; i &lt; n; i++)&#123; int x = sc.nextInt(); if (x &lt; 1 || x &gt; 1000000000) return; // num[i] = x; if (x &lt; min) min = x; if (x &gt; max) max = x; res ^= x; &#125; // Arrays.sort(num);// // for (int i = 0; i &lt; n - 1; i++)&#123;// if (num[i] == num[i+1])&#123;// System.out.println("mistake");// return;// &#125;// &#125;// // if (num[n-1] - num[0] == n)&#123;// for (int i = 0; i &lt; n - 1; i++)&#123;// if (num[i+1] - num[i] != 1)// System.out.println(num[i] + 1);// &#125;// &#125;// else if (num[n-1] - num[0] == n - 1) &#123;// if (num[0] == 1)// System.out.println(num[n-1] + 1);// else // System.out.println((num[0] - 1) + " " + (num[n-1] + 1));// &#125;// else// System.out.println("mistake"); for (int i = min; i &lt;= max; i++) res ^= i; if (res == 0)&#123; if (min != 1) System.out.println((min - 1) + " " + (max + 1)); else System.out.println(max + 1); &#125; else if (res &lt;= min || res &gt;= max) System.out.println("mistake"); else System.out.println(res); &#125;&#125; No. 5 超级素数幂如果一个数字能表示为p^q(^表示幂运算)且p为一个素数,q为大于1的正整数就称这个数叫做超级素数幂。现在给出一个正整数n,如果n是一个超级素数幂需要找出对应的p,q。 输入描述输入一个正整数n(2 ≤ n ≤ 10^18) 输出描述如果n是一个超级素数幂则输出p,q,以空格分隔,行末无空格。如果n不是超级素数幂，则输出No 输入例子27 输出例子3 3 代码12345678910111213141516171819202122232425262728293031import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); long n = sc.nextLong(); if (n &lt; 2 || n &gt; Math.pow(10, 18)) return; for (long q = 2; q &lt;= Math.log(n) / Math.log(2); q++)&#123; double p = Math.pow(n, 1d / q); boolean isPrime = true; for (int i = 2; i &lt;= Math.sqrt(p) &amp;&amp; isPrime == true; i++)&#123; if (p % i == 0) isPrime = false; &#125; if ((long) p == p &amp;&amp; isPrime == true)&#123; System.out.println((long) p + " " + q); return; &#125; &#125; System.out.println("No"); &#125;&#125; No. 6 序列和给出一个正整数N和长度L，找出一段长度大于等于L的连续非负整数，他们的和恰好为N。答案可能有多个，我我们需要找出长度最小的那个。例如 N = 18 L = 2：5 + 6 + 7 = 183 + 4 + 5 + 6 = 18都是满足要求的，但是我们输出更短的 5 6 7 输入描述输入数据包括一行：两个正整数N(1 ≤ N ≤ 1000000000),L(2 ≤ L ≤ 100) 输出描述从小到大输出这段连续非负整数，以空格分隔，行末无空格。如果没有这样的序列或者找出的序列长度大于100，则输出No 输入例子18 2 输出例子5 6 7 代码1234567891011121314151617181920212223242526272829import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int l = sc.nextInt(); if (n &lt; 1 || n &gt; 1000000000 || l &lt; 2 || l &gt; 100) return; for (int i = l; i &lt;= 100; i++)&#123; if ((2 * n - i * i + i) % (2 * i) == 0)&#123; int a = (2 * n - i * i + i) / (2 * i); for (int j = 0; j &lt; i - 1; j++) System.out.print(a + j + " "); System.out.print(a + i - 1); return; &#125; &#125; System.out.println("No"); &#125;&#125; No. 7 页码统计牛牛新买了一本算法书，算法书一共有n页，页码从1到n。牛牛于是想了一个算法题目：在这本算法书页码中0~9每个数字分别出现了多少次？ 输入描述输入包括一个整数n(1 ≤ n ≤ 1,000,000,000) 输出描述输出包括一行10个整数，即0~9这些数字在页码中出现的次数，以空格分隔。行末无空格。 输入例子999 输出例子189 300 300 300 300 300 300 300 300 300 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); if (n &lt; 1 || n &gt; 1000000000) return; int result = 0; for (int i = 0; i &lt; 9; i++)&#123; result = count(n, i); System.out.print(result + " "); &#125; result = count(n, 9); System.out.print(result); &#125; private static int count(int n, int x)&#123; int sum = 0; int index = 1; int currentN = n; while (currentN &gt; 0)&#123; int current = currentN % 10; int high = currentN / 10; int low = n - currentN * index; if (x == 0)&#123; if (high != 0) high--; else break; &#125; sum += high * index; if (current &gt; x) sum += index; else if (current == x) sum += low + 1; index *= 10; currentN /= 10; &#125; return sum; &#125;&#125; No. 8 01翻转牛牛正在挑战一款名为01翻转的游戏。游戏初始有A个0,B个1，牛牛的目标就是把所有的值都变为1，每次操作牛牛可以任意选择恰好K个数字，并将这K个数字的值进行翻转(0变为1，1变为0)。牛牛如果使用最少的操作次数完成这个游戏就可以获得奖品，牛牛想知道最少的操作次数是多少？例如:A = 4 B = 0 K = 30000 -&gt; 1110 -&gt; 1001 -&gt; 0100 -&gt; 1111需要的最少操作次数为4 输入描述输入为一行：一共三个整数A(0 ≤ A ≤ 100,000),B(0 ≤ B ≤ 100,000),K(1 ≤ K ≤100,000).以空格分隔 输出描述输出一个整数，表示最少需要的操作次数。如果不能完成，则输出-1 输入例子4 0 3 输出例子4 代码123456789101112131415161718192021222324252627282930import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int a = sc.nextInt(); int b = sc.nextInt(); int k = sc.nextInt(); if (a &lt; 0 || a &gt; 100000 || b &lt; 0 || b &gt; 100000 || k &lt; 1 || k &gt; 100000) return; for (int n = 0; n &lt; 200000; n++)&#123; int x = n * k - a; if (x &lt; 0 || x % 2 != 0) continue; if (x / 2 &lt;= a * ((n - 1) / 2) + b * (n / 2) || a == 0)&#123; System.out.println(n); return; &#125; &#125; System.out.println(-1); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Algorithm from NowCoder (3)]]></title>
      <url>%2F2017%2F03%2F25%2FAlgorithm-from-NowCoder-3%2F</url>
      <content type="text"><![CDATA[No. 1 构造回文给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回文串最长呢？输出需要删除的字符个数。 输入描述输入数据有多组，每组包含一个字符串s，且保证:1&lt;=s.length&lt;=1000. 输出描述对于每组数据，输出一个整数，代表最少需要删除的字符个数。 输入例子abcdagoogle 输出例子22 代码1234567891011121314151617181920212223242526272829import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) &#123; String str = sc.nextLine(); if (str.length() &lt; 1 || str.length() &gt; 1000) return; int[][] dp = new int[str.length()+1][str.length()+1]; for (int i = 1; i &lt;= str.length(); i++)&#123; for (int j = 1; j &lt;= str.length(); j++)&#123; if (str.charAt(i-1) == str.charAt(str.length()-j)) dp[i][j] = dp[i-1][j-1] + 1; else dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); &#125; &#125; System.out.println(str.length() - dp[str.length()][str.length()]); &#125; &#125;&#125; No. 2 算法基础-字符移位小Q最近遇到了一个难题：把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，且不能申请额外的空间。你能帮帮小Q吗？ 输入描述输入数据有多组，每组包含一个字符串s，且保证:1&lt;=s.length&lt;=1000. 输出描述对于每组数据，输出移位后的字符串。 输入例子AkleBiCeilD 输出例子kleieilABCD 代码1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) &#123; String str = sc.nextLine(); if (str.length() &lt; 1 || str.length() &gt; 1000) return; char[] ch = str.toCharArray(); for (int i = ch.length - 1; i &gt;= 0; i--)&#123; if (ch[i] &gt;= 'A' &amp;&amp; ch[i] &lt;= 'Z')&#123; for (int j = i; j &lt;= ch.length - 2; j++)&#123; if (!Character.isUpperCase(ch[j+1]))&#123; char temp = ch[j+1]; ch[j+1] = ch[j]; ch[j] = temp; &#125; &#125; &#125; &#125; System.out.println(String.valueOf(ch)); &#125; &#125;&#125; No. 3 有趣的数字小Q今天在上厕所时想到了这个问题：有n个数，两两组成二元组，差最小的有多少对呢？差最大呢？ 输入描述输入包含多组测试数据。 对于每组测试数据： N - 本组测试数据有n个数 a1,a2…an - 需要计算的数据 保证: 1&lt;=N&lt;=100000,0&lt;=ai&lt;=INT_MAX. 输出描述对于每组数据，输出两个数，第一个数表示差最小的对数，第二个数表示差最大的对数。 输入例子645 12 45 32 5 6 输出例子1 2 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.Arrays;import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNext()) &#123; int n = sc.nextInt(); if (n &lt; 1 || n &gt; 100000) return; int[] a = new int[n]; for (int i = 0; i &lt; n; i++)&#123; int x = sc.nextInt(); if (x &lt; 0 || x &gt; Integer.MAX_VALUE) return; a[i] = x; &#125; Arrays.sort(a); if (a[0] == a[n-1])&#123; int x = n * (n - 1) / 2; System.out.println(x + " " + x); continue; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; n; i++)&#123; if (map.containsKey(a[i])) map.put(a[i], map.get(a[i]) + 1); else map.put(a[i], 1); &#125; int maxCount = map.get(a[0]) * map.get(a[n-1]); int minCount = 0; if (map.size() == n)&#123; int min = a[1] - a[0]; for (int i = 2; i &lt; n; i++)&#123; int x = a[i] - a[i-1]; if (x &lt; min)&#123; min = x; minCount = 1; &#125; else if (x == min) minCount++; &#125; &#125; else &#123; for (Integer key : map.keySet())&#123; int x = map.get(key); if (x &gt; 1) minCount += x * (x - 1) / 2; &#125; &#125; System.out.println(minCount + " " + maxCount); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Algorithm from NowCoder (2)]]></title>
      <url>%2F2017%2F03%2F24%2FAlgorithm-from-NowCoder-2%2F</url>
      <content type="text"><![CDATA[No. 1 回文序列如果一个数字序列逆置之后跟原序列是一样的就称这样的数字序列为回文序列。例如：{1, 2, 1}, {15, 78, 78, 15} , {112} 是回文序列,{1, 2, 2}, {15, 78, 87, 51} ,{112, 2, 11} 不是回文序列。现在给出一个数字序列，允许使用一种转换操作：选择任意两个相邻的数，然后从序列移除这两个数，并用这两个数字的和插入到这两个数之前的位置(只插入一个和)。现在对于所给序列要求出最少需要多少次操作可以将其变成回文序列。 输入描述输入为两行，第一行为序列长度n (1 ≤ n ≤ 50)第二行为序列中的n个整数item[i] (1 ≤ item[i] ≤ 10000)，以空格分隔。 输出描述输出一个数，表示最少需要的转换次数 输入例子41 1 1 3 输出例子2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); if (n &lt; 1 || n &gt; 50) return; int[] item = new int[n]; for (int i = 0; i &lt; n; i++)&#123; int x = sc.nextInt(); if (x &lt; 1 || x &gt; 10000) return; item[i] = x; &#125; int head = 0; int tail = n - 1; int count = 0; // while (head &lt; tail)&#123;// if (item[head] &lt; item[tail])&#123;// head++;// item[head] = item[head-1] + item[head];// count++;// &#125;// else if (item[head] &gt; item[tail])&#123;// tail--;// item[tail] = item[tail] + item[tail+1];// count++;// &#125;// else &#123;// head++;// tail--;// &#125;// &#125; count = countOperations(head, tail, item); System.out.println(count); &#125; private static int countOperations(int head, int tail, int[] item)&#123; int count = 0; while (head &lt; tail &amp;&amp; item[head] != item[tail])&#123; if (item[head] &lt; item[tail])&#123; head++; item[head] = item[head-1] + item[head]; count++; &#125; else &#123; tail--; item[tail] = item[tail] + item[tail+1]; count++; &#125; &#125; if (head &gt;= tail) return count; else return count += countOperations(head+1, tail-1, item); &#125;&#125; No. 2 优雅的点小易有一个圆心在坐标原点的圆，小易知道圆的半径的平方。小易认为在圆上的点而且横纵坐标都是整数的点是优雅的，小易现在想寻找一个算法计算出优雅的点的个数，请你来帮帮他。例如：半径的平方如果为25优雅的点就有：(+/-3, +/-4), (+/-4, +/-3), (0, +/-5) (+/-5, 0)，一共12个点。 输入描述输入为一个整数，即为圆半径的平方,范围在32位int范围内。 输出描述输出为一个整数，即为优雅的点的个数 输入例子25 输出例子12 代码123456789101112131415161718192021222324252627import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int radius = sc.nextInt(); int count = 0; int a = (int) Math.sqrt(radius); for (int i = -a; i &lt;= a; i++)&#123; double b = Math.sqrt(radius - i * i); if (Math.round(b) == b)&#123; if (b == 0) count++; else count += 2; &#125; &#125; System.out.println(count); &#125;&#125; No. 3 跳石板小易来到了一条石板路前，每块石板上从1挨着编号为：1、2、3…….这条石板路要根据特殊的规则才能前进：对于小易当前所在的编号为K的 石板，小易单次只能往前跳K的一个约数(不含1和K)步，即跳到K+X(X为K的一个非1和本身的约数)的位置。 小易当前处在编号为N的石板，他想跳到编号恰好为M的石板去，小易想知道最少需要跳跃几次可以到达。例如：N = 4，M = 24：4-&gt;6-&gt;8-&gt;12-&gt;18-&gt;24于是小易最少需要跳跃5次，就可以从4号石板跳到24号石板 输入描述输入为一行，有两个整数N，M，以空格隔开。(4 ≤ N ≤ 100000)(N ≤ M ≤ 100000) 输出描述输出小易最少需要跳跃的步数,如果不能到达输出-1 输入例子4 24 输出例子5 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.ArrayList;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); if (n &lt; 4 || n &gt; 100000 || m &lt; n || m &gt; 100000) return; int[] dp = new int[m+1]; for (int i = 0; i &lt;= m; i++)&#123; if (i == n) dp[i] = 0; else dp[i] = Integer.MAX_VALUE; &#125; for (int i = n; i &lt;= m; i++)&#123; if (dp[i] == Integer.MAX_VALUE) continue; ArrayList&lt;Integer&gt; divisor = new ArrayList&lt;Integer&gt;(); getDivisor(divisor, i); for (int j = 0; j &lt; divisor.size(); j++)&#123; if (i + divisor.get(j) &lt;= m) dp[i + divisor.get(j)] = Math.min(dp[i] + 1, dp[i + divisor.get(j)]); &#125; &#125; if (dp[m] == Integer.MAX_VALUE) System.out.println(-1); else System.out.println(dp[m]); &#125; private static void getDivisor(ArrayList&lt;Integer&gt; divisor, int n)&#123; for (int i = 2; i &lt;= Math.sqrt(n); i++)&#123; if (n % i == 0)&#123; divisor.add(i); divisor.add(n / i); &#125; &#125; &#125;&#125; No. 4 暗黑的字符串一个只包含’A’、’B’和’C’的字符串，如果存在某一段长度为3的连续子串中恰好’A’、’B’和’C’各有一个，那么这个字符串就是纯净的，否则这个字符串就是暗黑的。例如：BAACAACCBAAA 连续子串”CBA”中包含了’A’,’B’,’C’各一个，所以是纯净的字符串AABBCCAABB 不存在一个长度为3的连续子串包含’A’,’B’,’C’,所以是暗黑的字符串你的任务就是计算出长度为n的字符串(只包含’A’、’B’和’C’)，有多少个是暗黑的字符串。 输入描述输入一个整数n，表示字符串长度(1 ≤ n ≤ 30) 输出描述输出一个整数表示有多少个暗黑字符串 输入例子23 输出例子921 代码1234567891011121314151617181920212223242526import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNext())&#123; int n = sc.nextInt(); if (n &lt; 1 || n &gt; 30) return; long[] count = new long[n]; count[0] = 3; count[1] = 9; for (int i = 2; i &lt; n; i++) count[i] = 2 * count[i-1] + count[i-2]; System.out.println(count[n-1]); &#125; &#125;&#125; No. 5 数字翻转对于一个整数X，定义操作rev(X)为将X按数位翻转过来，并且去除掉前导0。例如:如果 X = 123，则rev(X) = 321;如果 X = 100，则rev(X) = 1.现在给出整数x和y,要求rev(rev(x) + rev(y))为多少？ 输入描述输入为一行，x、y(1 ≤ x、y ≤ 1000)，以空格隔开。 输出描述输出rev(rev(x) + rev(y))的值 输入例子123 100 输出例子223 代码12345678910111213141516171819202122232425262728import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int x = sc.nextInt(); int y = sc.nextInt(); if (x &lt; 1 || y &lt; 1 || x &gt; 1000 || y &gt; 1000) return; System.out.println(reverse(reverse(x) + reverse(y))); &#125; private static int reverse(int a)&#123; int result = 0; while (a != 0)&#123; result = result * 10 + a % 10; a = a / 10; &#125; return result; &#125;&#125; No. 6 最大的奇约数小易是一个数论爱好者，并且对于一个数的奇数约数十分感兴趣。一天小易遇到这样一个问题： 定义函数f(x)为x最大的奇数约数，x为正整数。 例如:f(44) = 11.现在给出一个N，需要求出 f(1) + f(2) + f(3)…….f(N)例如： N = 7f(1) + f(2) + f(3) + f(4) + f(5) + f(6) + f(7) = 1 + 1 + 3 + 1 + 5 + 3 + 7 = 21小易计算这个问题遇到了困难，需要你来设计一个算法帮助他。 输入描述输入一个整数N (1 ≤ N ≤ 1000000000) 输出描述输出一个整数，即为f(1) + f(2) + f(3)…….f(N) 输入例子7 输出例子21 代码1234567891011121314151617181920212223import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); long n = sc.nextLong(); if (n &lt; 1 || n &gt; 1000000000) return; long sum = 0; for (long i = n; i &gt; 0; i /= 2)&#123; long temp = (i + 1) / 2; sum += temp * temp; &#125; System.out.println(sum); &#125;&#125; No. 7 买苹果小易去附近的商店买苹果，奸诈的商贩使用了捆绑交易，只提供6个每袋和8个每袋的包装(包装不可拆分)。 可是小易现在只想购买恰好n个苹果，小易想购买尽量少的袋数方便携带。如果不能购买恰好n个苹果，小易将不会购买。 输入描述输入一个整数n，表示小易想购买n(1 ≤ n ≤ 100)个苹果 输出描述输出一个整数表示最少需要购买的袋数，如果不能买恰好n个苹果则输出-1 输入例子20 输出例子3 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); if (n &lt; 1 || n &gt; 100) return; // packages(n); int[] dp = new int[n+1]; for (int i = 0; i &lt;= n; i++)&#123; if (i == 8 || i == 6) dp[i] = 1; else dp[i] = Integer.MAX_VALUE; &#125; for (int i = 6; i &lt;= n; i++)&#123; if (dp[i] == Integer.MAX_VALUE) continue; if (i + 6 &lt;= n) dp[i+6] = Math.min(dp[i] + 1, dp[i+6]); if (i + 8 &lt;= n) dp[i+8] = Math.min(dp[i] + 1, dp[i+8]); &#125; if (dp[n] == Integer.MAX_VALUE) System.out.println(-1); else System.out.println(dp[n]); &#125; private static void packages(int n)&#123; if (n % 2 != 0) System.out.println(-1); else if (n % 8 == 0) System.out.println(n / 8); else if (n % 8 != 0)&#123;// System.out.println(n / 8 + 1); int count = n / 8; int remain = n % 8; while (count &gt;= 0)&#123; if (remain % 6 == 0)&#123; System.out.println(count + remain / 6); break; &#125; else &#123; count -= remain % 3; remain += (remain % 3) * 8; &#125; &#125; &#125; &#125;&#125; No. 8 计算糖果A,B,C三个人是好朋友,每个人手里都有一些糖果,我们不知道他们每个人手上具体有多少个糖果,但是我们知道以下的信息：A - B, B - C, A + B, B + C. 这四个数值.每个字母代表每个人所拥有的糖果数.现在需要通过这四个数值计算出每个人手里有多少个糖果,即A,B,C。这里保证最多只有一组整数A,B,C满足所有题设条件。 输入描述输入为一行，一共4个整数，分别为A - B，B - C，A + B，B + C，用空格隔开。范围均在-30到30之间(闭区间)。 输出描述输出为一行，如果存在满足的整数A，B，C则按顺序输出A，B，C，用空格隔开，行末无空格。如果不存在这样的整数A，B，C，则输出No 输入例子1 -2 3 4 输出例子2 1 3 代码12345678910111213141516171819202122232425262728293031import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int i = sc.nextInt(); int j = sc.nextInt(); int m = sc.nextInt(); int n = sc.nextInt(); if (i &lt; -30 || i &gt; 30 || j &lt; -30 || j &gt; 30 || m &lt; -30 || m &gt; 30 || n &lt; -30 || n &gt; 30) return; if ((i + m) % 2 != 0)&#123; System.out.println("No"); return; &#125; int a = (i + m) / 2; int b = m - a; int c = b - j; if (b + c == n) System.out.println(a + " " + b + " " + c); else System.out.println("No"); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Algorithm from NowCoder (1)]]></title>
      <url>%2F2017%2F03%2F23%2FAlgorithm-from-NowCoder-1%2F</url>
      <content type="text"><![CDATA[No. 1 合唱团有 n 个学生站成一排，每个学生有一个能力值，牛牛想从这 n 个学生中按照顺序选取 k 名学生，要求相邻两个学生的位置编号的差不超过 d，使得这 k 个学生的能力值的乘积最大，你能返回最大的乘积吗？ 输入描述每个输入包含 1 个测试用例。每个测试数据的第一行包含一个整数 n (1 &lt;= n &lt;= 50)，表示学生的个数，接下来的一行，包含 n 个整数，按顺序表示每个学生的能力值 ai（-50 &lt;= ai &lt;= 50）。接下来的一行包含两个整数，k 和 d (1 &lt;= k &lt;= 10, 1 &lt;= d &lt;= 50)。 输出描述输出一行表示最大的乘积。 输入例子37 4 72 50 输出例子49 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); if (n &lt; 1 || n &gt; 50) return; int[] a = new int[n]; for (int i = 0; i &lt; n; i++)&#123; int x = sc.nextInt(); if (x &lt; -50 || x &gt; 50) return; a[i] = x; &#125; int k = sc.nextInt(); int d = sc.nextInt(); if (k &lt; 1 || k &gt; 10 || d &lt; 1 || d &gt; 50) return; long dpMax[][] = new long[k+1][n+1]; long dpMin[][] = new long[k+1][n+1]; long result = 0; for (int i = 1; i &lt;= n; i++)&#123; dpMax[1][i] = a[i-1]; dpMin[1][i] = a[i-1]; for (int m = 2; m &lt;= k; m++)&#123; for (int j = i - 1; j &gt;= i - d &amp;&amp; j &gt;0; j--)&#123; dpMax[m][i] = Math.max(dpMax[m][i], Math.max(dpMax[m-1][j] * a[i-1], dpMin[m-1][j] * a[i-1])); dpMin[m][i] = Math.min(dpMin[m][i], Math.min(dpMax[m-1][j] * a[i-1], dpMin[m-1][j] * a[i-1])); &#125; &#125; result = Math.max(result, dpMax[k][i]); &#125; System.out.println(result); &#125;&#125; No. 2 地牢逃脱给定一个 n 行 m 列的地牢，其中 ‘.’ 表示可以通行的位置，’X’ 表示不可通行的障碍，牛牛从 (x0 , y0 ) 位置出发，遍历这个地牢，和一般的游戏所不同的是，他每一步只能按照一些指定的步长遍历地牢，要求每一步都不可以超过地牢的边界，也不能到达障碍上。地牢的出口可能在任意某个可以通行的位置上。牛牛想知道最坏情况下，他需要多少步才可以离开这个地牢。 输入描述每个输入包含 1 个测试用例。每个测试用例的第一行包含两个整数 n 和 m（1 &lt;= n, m &lt;= 50），表示地牢的长和宽。接下来的 n 行，每行 m 个字符，描述地牢，地牢将至少包含两个 ‘.’。接下来的一行，包含两个整数 x0, y0，表示牛牛的出发位置（0 &lt;= x0 &lt; n, 0 &lt;= y0 &lt; m，左上角的坐标为 （0, 0），出发位置一定是 ‘.’）。之后的一行包含一个整数 k（0 &lt; k &lt;= 50）表示牛牛合法的步长数，接下来的 k 行，每行两个整数 dx, dy 表示每次可选择移动的行和列步长（-50 &lt;= dx, dy &lt;= 50） 输出描述输出一行一个数字表示最坏情况下需要多少次移动可以离开地牢，如果永远无法离开，输出 -1。以下测试用例中，牛牛可以上下左右移动，在所有可通行的位置.上，地牢出口如果被设置在右下角，牛牛想离开需要移动的次数最多，为3次。 输入例子3 3………0 141 00 1-1 00 -1 输出例子3 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import java.util.LinkedList;import java.util.List;import java.util.Queue;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); if (n &lt; 1 || n &gt; 50 || m &lt; 1 || m &gt; 50) return; char[][] board = new char[n][m]; int[][] count = new int[n][m]; for (int i = 0; i &lt; n; i++) board[i] = sc.next().toCharArray(); int x0 = sc.nextInt(); int y0 = sc.nextInt(); int k = sc.nextInt(); if (x0 &lt; 0 || x0 &gt;= n || y0 &lt; 0 || y0 &gt;= m || k &lt;= 0 || k &gt; 50) return; List&lt;int[]&gt; steps = new LinkedList&lt;int[]&gt;(); for (int i = 0; i &lt; k; i++)&#123; int x = sc.nextInt(); int y = sc.nextInt(); if (x &lt; -50 || x &gt; 50 || y &lt; -50 || y &gt; 50) return; steps.add(new int[]&#123;x, y&#125;); &#125; int max = 0; BFS(count, board, steps, new int[]&#123;x0, y0&#125;); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (count[i][j] == 0)&#123; System.out.println(-1); return; &#125; else if (count[i][j] != -1) max = Math.max(count[i][j], max); &#125; &#125; System.out.println(max - 1); &#125; private static void BFS(int[][] count, char[][] board, List&lt;int[]&gt; steps, int[] start)&#123; Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;(); count[start[0]][start[1]] = 1; queue.add(start); while (!queue.isEmpty())&#123; int[] current = queue.poll(); for (int i = 0; i &lt; steps.size(); i++)&#123; int nextX = current[0]+steps.get(i)[0]; int nextY = current[1]+steps.get(i)[1]; if (nextX &lt; 0 || nextX &gt;= board.length || nextY &lt; 0 || nextY&gt;= board[0].length) continue; if (count[nextX][nextY] == 0 &amp;&amp; board[nextX][nextY] == '.')&#123; count[nextX][nextY] = count[current[0]][current[1]] + 1; queue.add(new int[]&#123;nextX, nextY&#125;); &#125; else if (board[nextX][nextY] != '.') count[nextX][nextY] = -1; &#125; &#125; &#125; &#125; No. 3 下厨房牛牛想尝试一些新的料理，每个料理需要一些不同的材料，问完成所有的料理需要准备多少种不同的材料。 输入描述每个输入包含 1 个测试用例。每个测试用例的第 i 行，表示完成第 i 件料理需要哪些材料，各个材料用空格隔开，输入只包含大写英文字母和空格，输入文件不超过 50 行，每一行不超过 50 个字符。 输出描述输出一行一个数字表示完成所有料理需要多少种不同的材料。 输入例子BUTTER FLOURHONEY FLOUR EGG 输出例子4 代码12345678910111213141516171819202122import java.util.HashSet;import java.util.Scanner;import java.util.Set;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (int i = 1; sc.hasNextLine() &amp;&amp; i &lt;= 50; i++)&#123; String[] strs = sc.nextLine().split(" "); for (String str : strs) set.add(str); &#125; System.out.println(set.size()); &#125;&#125; No. 4 分田地牛牛和 15 个朋友来玩打土豪分田地的游戏，牛牛决定让你来分田地，地主的田地可以看成是一个矩形，每个位置有一个价值。分割田地的方法是横竖各切三刀，分成 16 份，作为领导干部，牛牛总是会选择其中总价值最小的一份田地， 作为牛牛最好的朋友，你希望牛牛取得的田地的价值和尽可能大，你知道这个值最大可以是多少吗？ 输入描述每个输入包含 1 个测试用例。每个测试用例的第一行包含两个整数 n 和 m（1 &lt;= n, m &lt;= 75），表示田地的大小，接下来的 n 行，每行包含 m 个 0-9 之间的数字，表示每块位置的价值。 输出描述输出一行表示牛牛所能取得的最大的价值。 输入例子4 43332323333322323 输出例子2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.Scanner;public class Main &#123; static int[][] sum; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); if (n &lt; 1 || n &gt; 75 || m &lt; 1 || m &gt; 75) return; sum = new int[n+1][m+1]; for (int i = 1; i &lt;= n; i++)&#123; String str = sc.next(); for (int j = 1; j &lt;= m; j++) sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + (str.charAt(j-1) - '0'); &#125; int left = 0; int right = sum[n][m]; int max = 0; max = binarySearch(left, right); System.out.println(max); &#125; private static int binarySearch(int left, int right)&#123; int max = 0; while (left &lt;= right)&#123; int middle = (left + right) / 2; if (isMin(middle))&#123; left = middle + 1; max = middle; &#125; else right = middle - 1; &#125; return max; &#125; private static boolean isMin(int middle)&#123; int m = sum[0].length - 1; for (int i = 1; i &lt;= m - 3; i++)&#123; for (int j = i + 1; j &lt;= m - 2; j++)&#123; for (int k = j + 1; k &lt;= m - 1; k++)&#123; int prev = 0; int count = 0; for (int l = 1; l &lt;= sum.length - 1; l++)&#123; int value1 = getValue(prev, 0, l, i); int value2 = getValue(prev, i, l, j); int value3 = getValue(prev, j, l, k); int value4 = getValue(prev, k, l, m); if (value1 &gt;= middle &amp;&amp; value2 &gt;= middle &amp;&amp; value3 &gt;= middle &amp;&amp; value4 &gt;= middle)&#123; count++; prev = l; &#125; &#125; if (count &gt;= 4) return true; &#125; &#125; &#125; return false; &#125; private static int getValue(int i, int j, int x, int y)&#123; return sum[x][y] - sum[x][j] - sum[i][y] + sum[i][j]; &#125; &#125; No. 5 分苹果n 只奶牛坐在一排，每个奶牛拥有 ai 个苹果，现在你要在它们之间转移苹果，使得最后所有奶牛拥有的苹果数都相同，每一次，你只能从一只奶牛身上拿走恰好两个苹果到另一个奶牛上，问最少需要移动多少次可以平分苹果，如果方案不存在输出 -1。 输入描述每个输入包含一个测试用例。每个测试用例的第一行包含一个整数 n（1 &lt;= n &lt;= 100），接下来的一行包含 n 个整数 ai（1 &lt;= ai &lt;= 100）。 输出描述输出一行表示最少需要移动多少次可以平分苹果，如果方案不存在则输出 -1。 输入例子47 15 9 5 输出例子3 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); if (n &lt; 0 || n &gt; 100) return; int[] a = new int[n]; int sum = 0; for (int i = 0; i &lt; n; i++)&#123; a[i] = sc.nextInt(); if (a[i] &lt; 1 || a[i] &gt; 100) return; sum += a[i]; &#125; if (sum % a.length != 0)&#123; System.out.println(-1); return; &#125; int avg = sum / a.length; int move = 0; for (int i = 0; i &lt; a.length; i++)&#123; if (Math.abs(a[i] - avg) % 2 != 0)&#123; System.out.println(-1); return; &#125; if (a[i] &gt; avg) move += a[i] - avg; &#125; System.out.println(move / 2); &#125;&#125; No. 6 星际穿越航天飞行器是一项复杂而又精密的仪器，飞行器的损耗主要集中在发射和降落的过程，科学家根据实验数据估计，如果在发射过程中，产生了 x 程度的损耗，那么在降落的过程中就会产生 x2 程度的损耗，如果飞船的总损耗超过了它的耐久度，飞行器就会爆炸坠毁。问一艘耐久度为 h 的飞行器，假设在飞行过程中不产生损耗，那么为了保证其可以安全的到达目的地，只考虑整数解，至多发射过程中可以承受多少程度的损耗？ 输入描述每个输入包含一个测试用例。每个测试用例包含一行一个整数 h （1 &lt;= h &lt;= 10^18）。 输出描述输出一行一个整数表示结果。 输入例子10 输出例子2 代码1234567891011121314151617181920212223import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); long h = sc.nextLong(); if (h &lt; 0 || h &gt; Math.pow(10, 18)) return; long x = (long) Math.sqrt(h); for (; x &gt;= 0; x--)&#123; if (x * x + x &lt;= h)&#123; System.out.println(x); return; &#125; &#125; &#125;&#125; No. 7 藏宝图牛牛拿到了一个藏宝图，顺着藏宝图的指示，牛牛发现了一个藏宝盒，藏宝盒上有一个机关，机关每次会显示两个字符串 s 和 t，根据古老的传说，牛牛需要每次都回答 t 是否是 s 的子序列。注意，子序列不要求在原字符串中是连续的，例如串 abc，它的子序列就有 {空串, a, b, c, ab, ac, bc, abc} 8 种。 输入描述每个输入包含一个测试用例。每个测试用例包含两行长度不超过 10 的不包含空格的可见 ASCII 字符串。 输出描述输出一行 “Yes” 或者 “No” 表示结果。 输入例子x.nowcoder.comooo 输出例子Yes 代码1234567891011121314151617181920212223242526272829import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String s = sc.nextLine(); String t = sc.nextLine(); if (s == null || t == null)&#123; System.out.println("No"); return; &#125; int i = 0, j = 0; for (; i &lt; t.length() &amp;&amp; j &lt; s.length(); j++)&#123; if (t.charAt(i) == s.charAt(j)) i++; &#125; if (i == t.length()) System.out.println("Yes"); else System.out.println("No"); &#125;&#125; No. 8 数列还原牛牛的作业薄上有一个长度为 n 的排列 A，这个排列包含了从1到n的n个数，但是因为一些原因，其中有一些位置（不超过 10 个）看不清了，但是牛牛记得这个数列顺序对的数量是 k，顺序对是指满足 i &lt; j 且 A[i] &lt; A[j] 的对数，请帮助牛牛计算出，符合这个要求的合法排列的数目。 输入描述每个输入包含一个测试用例。每个测试用例的第一行包含两个整数 n 和 k（1 &lt;= n &lt;= 100, 0 &lt;= k &lt;= 1000000000），接下来的 1 行，包含 n 个数字表示排列 A，其中等于0的项表示看不清的位置（不超过 10 个）。 输出描述输出一行表示合法的排列数目。 输入例子5 54 0 0 2 0 输出例子2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int k = sc.nextInt(); if (n &lt; 1 || n &gt; 100 || k &lt; 0 || k &gt; 1000000000) return; ArrayList&lt;Integer&gt; a = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; n; i++) a.add(sc.nextInt()); int count = 0; ArrayList&lt;Integer&gt; number = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; copy = (ArrayList&lt;Integer&gt;) a.clone(); List&lt;ArrayList&lt;Integer&gt;&gt; perms = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for (int i = 1; i &lt;= n; i++)&#123; if (!a.contains(i)) number.add(i); &#125; permutation(perms, number, 0); for (ArrayList&lt;Integer&gt; perm : perms)&#123; int index = 0; for (int i = 0; i &lt; a.size(); i++)&#123; if (a.get(i) == 0)&#123; copy.set(i, perm.get(index)); index++; &#125; &#125; int pairs = calculatePairs(copy); if (pairs == k) count++; &#125; System.out.println(count); &#125; private static void permutation(List&lt;ArrayList&lt;Integer&gt;&gt; perm, ArrayList&lt;Integer&gt; number, int index)&#123; if (index == number.size()) perm.add(new ArrayList&lt;Integer&gt;(number)); else &#123; for (int i = index; i &lt; number.size(); i++)&#123; Collections.swap(number, i, index); permutation(perm, number, index + 1); Collections.swap(number, i, index); &#125; &#125; &#125; private static int calculatePairs(ArrayList&lt;Integer&gt; a)&#123; int pairs = 0; for (int i = 0; i &lt; a.size() - 1; i++)&#123; for (int j = i + 1; j &lt; a.size(); j++)&#123; if (a.get(i) &lt; a.get(j)) pairs++; &#125; &#125; return pairs; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Torch Demo]]></title>
      <url>%2F2017%2F03%2F18%2FTorch-Demo%2F</url>
      <content type="text"><![CDATA[We have 5 steps to do in training a torch neural network. (1) Load and normalize data; (2) Define Neural Network; (3) Define Loss function; (4) Train network on training data; (5) Test network on test data. Tutorialcvpr2015/Deep Learning with Torch.ipynb Code12345require 'paths'require 'nn'require 'torch'require 'cunn'require 'cutorch' Load and normalize data12345678910111213141516171819if (not paths.filep("cifar10torchsmall.zip")) then os.execute('wget -c https://s3.amazonaws.com/torch7/data/cifar10torchsmall.zip') os.execute('unzip cifar10torchsmall.zip')endtrainset = torch.load('cifar10-train.t7')testset = torch.load('cifar10-test.t7')classes = &#123;'airplane', 'automobile', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck'&#125;setmetatable(trainset, &#123;__index = function(t, i) return &#123;t.data[i], t.label[i]&#125; end&#125;);function trainset:size() return self.data:size(1)end 1234567891011121314151617trainset.data = trainset.data:double()testset.data = testset.data:double()mean = &#123;&#125;stdv = &#123;&#125;for i=1,3 do mean[i] = trainset.data[&#123; &#123;&#125;, &#123;i&#125;, &#123;&#125;, &#123;&#125; &#125;]:mean() --print('Channel ' .. i .. ', Mean: ' .. mean[i]) trainset.data[&#123; &#123;&#125;, &#123;i&#125;, &#123;&#125;, &#123;&#125; &#125;]:add(-mean[i]) stdv[i] = trainset.data[&#123; &#123;&#125;, &#123;i&#125;, &#123;&#125;, &#123;&#125; &#125;]:std() --print('Channel ' .. i .. ', Standard Deviation: ' .. stdv[i]) trainset.data[&#123; &#123;&#125;, &#123;i&#125;, &#123;&#125;, &#123;&#125; &#125;]:div(stdv[i])endfor i=1,3 do testset.data[&#123; &#123;&#125;, &#123;i&#125;, &#123;&#125;, &#123;&#125; &#125;]:add(-mean[i]) testset.data[&#123; &#123;&#125;, &#123;i&#125;, &#123;&#125;, &#123;&#125; &#125;]:div(stdv[i])end Define neural network1234567891011121314net = nn.Sequential()net:add(nn.SpatialConvolution(3, 6, 5, 5)) -- 3 input image channels, 6 output channels, 5x5 convolution kernelnet:add(nn.ReLU()) -- non-linearitynet:add(nn.SpatialMaxPooling(2,2,2,2)) -- A max-pooling operation that looks at 2x2 windows and finds the max.net:add(nn.SpatialConvolution(6, 16, 5, 5))net:add(nn.ReLU()) -- non-linearitynet:add(nn.SpatialMaxPooling(2,2,2,2))net:add(nn.View(16*5*5)) -- reshapes from a 3D tensor of 16x5x5 into 1D tensor of 16*5*5net:add(nn.Linear(16*5*5, 120)) -- fully connected layer (matrix multiplication between input and weights)net:add(nn.ReLU()) -- non-linearitynet:add(nn.Linear(120, 84))net:add(nn.ReLU()) -- non-linearitynet:add(nn.Linear(84, 10)) -- 10 is the number of outputs of the network (in this case, 10 digits)net:add(nn.LogSoftMax()) -- converts the output to a log-probability. Useful for classification problems Define the Loss function1criterion = nn.ClassNLLCriterion() Train the neural network1234trainer = nn.StochasticGradient(net, criterion)trainer.learningRate = 0.001trainer.maxIteration = 5trainer:train(trainset) 1234567-- train on GPUnet = net:cuda()criterion = criterion:cuda()trainset.data = trainset.data:cuda()trainset.label = trainset.label:cuda()testset.data = testset.data:cuda()testset.label = testset.label:cuda() Test the network, print accuracy12345678910111213141516correct = 0class_performance = &#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;for i=1,10000 do local groundtruth = testset.label[i] local prediction = net:forward(testset.data[i]) local confidences, indices = torch.sort(prediction, true) -- true means sort in descending order if groundtruth == indices[1] then correct = correct + 1 class_performance[groundtruth] = class_performance[groundtruth] + 1 endendprint(correct, 100*correct/10000 .. " % ")for i=1,#classes do print(classes[i], 100*class_performance[i]/1000 .. ' %')end ResultIt’ll take around 30 minutes to get the result on CPU. However, it’ll cost less than 10 minutes on GPU. 1th filename.lua On CPU On GPU]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F17%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
