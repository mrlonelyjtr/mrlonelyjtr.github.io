<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Algorithm from NowCoder (4)]]></title>
      <url>%2F2017%2F03%2F27%2FAlgorithm-from-NowCoder-4%2F</url>
      <content type="text"><![CDATA[No. 1 好多鱼！牛牛有一个鱼缸。鱼缸里面已经有n条鱼，每条鱼的大小为fishSize[i] (1 ≤ i ≤ n,均为正整数)，牛牛现在想把新捕捉的鱼放入鱼缸。鱼缸内存在着大鱼吃小鱼的定律。经过观察，牛牛发现一条鱼A的大小为另外一条鱼B大小的2倍到10倍(包括2倍大小和10倍大小)，鱼A会吃掉鱼B。考虑到这个，牛牛要放入的鱼就需要保证：1、放进去的鱼是安全的，不会被其他鱼吃掉2、这条鱼放进去也不能吃掉其他鱼鱼缸里面已经存在的鱼已经相处了很久，不考虑他们互相捕食。现在知道新放入鱼的大小范围[minSize,maxSize](考虑鱼的大小都是整数表示),牛牛想知道有多少种大小的鱼可以放入这个鱼缸。 输入描述输入数据包括3行.第一行为新放入鱼的尺寸范围minSize,maxSize(1 ≤ minSize,maxSize ≤ 1000)，以空格分隔。 第二行为鱼缸里面已经有鱼的数量n(1 ≤ n ≤ 50) 第三行为已经有的鱼的大小fishSize[i](1 ≤ fishSize[i] ≤ 1000)，以空格分隔。 输出描述输出有多少种大小的鱼可以放入这个鱼缸。考虑鱼的大小都是整数表示 输入例子1 1211 输出例子3 代码1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Algorithm from NowCoder (3)]]></title>
      <url>%2F2017%2F03%2F25%2FAlgorithm-from-NowCoder-3%2F</url>
      <content type="text"><![CDATA[No. 1 构造回文给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回文串最长呢？输出需要删除的字符个数。 输入描述输入数据有多组，每组包含一个字符串s，且保证:1&lt;=s.length&lt;=1000. 输出描述对于每组数据，输出一个整数，代表最少需要删除的字符个数。 输入例子abcdagoogle 输出例子22 代码1234567891011121314151617181920212223242526272829import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) &#123; String str = sc.nextLine(); if (str.length() &lt; 1 || str.length() &gt; 1000) return; int[][] dp = new int[str.length()+1][str.length()+1]; for (int i = 1; i &lt;= str.length(); i++)&#123; for (int j = 1; j &lt;= str.length(); j++)&#123; if (str.charAt(i-1) == str.charAt(str.length()-j)) dp[i][j] = dp[i-1][j-1] + 1; else dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); &#125; &#125; System.out.println(str.length() - dp[str.length()][str.length()]); &#125; &#125;&#125; No. 2 算法基础-字符移位小Q最近遇到了一个难题：把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，且不能申请额外的空间。你能帮帮小Q吗？ 输入描述输入数据有多组，每组包含一个字符串s，且保证:1&lt;=s.length&lt;=1000. 输出描述对于每组数据，输出移位后的字符串。 输入例子AkleBiCeilD 输出例子kleieilABCD 代码1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) &#123; String str = sc.nextLine(); if (str.length() &lt; 1 || str.length() &gt; 1000) return; char[] ch = str.toCharArray(); for (int i = ch.length - 1; i &gt;= 0; i--)&#123; if (ch[i] &gt;= 'A' &amp;&amp; ch[i] &lt;= 'Z')&#123; for (int j = i; j &lt;= ch.length - 2; j++)&#123; if (!Character.isUpperCase(ch[j+1]))&#123; char temp = ch[j+1]; ch[j+1] = ch[j]; ch[j] = temp; &#125; &#125; &#125; &#125; System.out.println(String.valueOf(ch)); &#125; &#125;&#125; No. 3 有趣的数字小Q今天在上厕所时想到了这个问题：有n个数，两两组成二元组，差最小的有多少对呢？差最大呢？ 输入描述输入包含多组测试数据。 对于每组测试数据： N - 本组测试数据有n个数 a1,a2…an - 需要计算的数据 保证: 1&lt;=N&lt;=100000,0&lt;=ai&lt;=INT_MAX. 输出描述对于每组数据，输出两个数，第一个数表示差最小的对数，第二个数表示差最大的对数。 输入例子645 12 45 32 5 6 输出例子1 2 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.Arrays;import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNext()) &#123; int n = sc.nextInt(); if (n &lt; 1 || n &gt; 100000) return; int[] a = new int[n]; for (int i = 0; i &lt; n; i++)&#123; int x = sc.nextInt(); if (x &lt; 0 || x &gt; Integer.MAX_VALUE) return; a[i] = x; &#125; Arrays.sort(a); if (a[0] == a[n-1])&#123; int x = n * (n - 1) / 2; System.out.println(x + " " + x); continue; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; n; i++)&#123; if (map.containsKey(a[i])) map.put(a[i], map.get(a[i]) + 1); else map.put(a[i], 1); &#125; int maxCount = map.get(a[0]) * map.get(a[n-1]); int minCount = 0; if (map.size() == n)&#123; int min = a[1] - a[0]; for (int i = 2; i &lt; n; i++)&#123; int x = a[i] - a[i-1]; if (x &lt; min)&#123; min = x; minCount = 1; &#125; else if (x == min) minCount++; &#125; &#125; else &#123; for (Integer key : map.keySet())&#123; int x = map.get(key); if (x &gt; 1) minCount += x * (x - 1) / 2; &#125; &#125; System.out.println(minCount + " " + maxCount); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Algorithm from NowCoder (2)]]></title>
      <url>%2F2017%2F03%2F24%2FAlgorithm-from-NowCoder-2%2F</url>
      <content type="text"><![CDATA[No. 1 回文序列如果一个数字序列逆置之后跟原序列是一样的就称这样的数字序列为回文序列。例如：{1, 2, 1}, {15, 78, 78, 15} , {112} 是回文序列,{1, 2, 2}, {15, 78, 87, 51} ,{112, 2, 11} 不是回文序列。现在给出一个数字序列，允许使用一种转换操作：选择任意两个相邻的数，然后从序列移除这两个数，并用这两个数字的和插入到这两个数之前的位置(只插入一个和)。现在对于所给序列要求出最少需要多少次操作可以将其变成回文序列。 输入描述输入为两行，第一行为序列长度n ( 1 ≤ n ≤ 50)第二行为序列中的n个整数item[i] (1 ≤ iteam[i] ≤ 1000)，以空格分隔。 输出描述输出一个数，表示最少需要的转换次数 输入例子41 1 1 3 输出例子2 代码1 No. 2 优雅的点小易有一个圆心在坐标原点的圆，小易知道圆的半径的平方。小易认为在圆上的点而且横纵坐标都是整数的点是优雅的，小易现在想寻找一个算法计算出优雅的点的个数，请你来帮帮他。例如：半径的平方如果为25优雅的点就有：(+/-3, +/-4), (+/-4, +/-3), (0, +/-5) (+/-5, 0)，一共12个点。 输入描述输入为一个整数，即为圆半径的平方,范围在32位int范围内。 输出描述输出为一个整数，即为优雅的点的个数 输入例子25 输出例子12 代码123456789101112131415161718192021222324252627import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int radius = sc.nextInt(); int count = 0; int a = (int) Math.sqrt(radius); for (int i = -a; i &lt;= a; i++)&#123; double b = Math.sqrt(radius - i * i); if (Math.round(b) == b)&#123; if (b == 0) count++; else count += 2; &#125; &#125; System.out.println(count); &#125;&#125; No. 3 跳石板小易来到了一条石板路前，每块石板上从1挨着编号为：1、2、3…….这条石板路要根据特殊的规则才能前进：对于小易当前所在的编号为K的 石板，小易单次只能往前跳K的一个约数(不含1和K)步，即跳到K+X(X为K的一个非1和本身的约数)的位置。 小易当前处在编号为N的石板，他想跳到编号恰好为M的石板去，小易想知道最少需要跳跃几次可以到达。例如：N = 4，M = 24：4-&gt;6-&gt;8-&gt;12-&gt;18-&gt;24于是小易最少需要跳跃5次，就可以从4号石板跳到24号石板 输入描述输入为一行，有两个整数N，M，以空格隔开。(4 ≤ N ≤ 100000)(N ≤ M ≤ 100000) 输出描述输出小易最少需要跳跃的步数,如果不能到达输出-1 输入例子4 24 输出例子5 代码1 No. 4 暗黑的字符串一个只包含’A’、’B’和’C’的字符串，如果存在某一段长度为3的连续子串中恰好’A’、’B’和’C’各有一个，那么这个字符串就是纯净的，否则这个字符串就是暗黑的。例如：BAACAACCBAAA 连续子串”CBA”中包含了’A’,’B’,’C’各一个，所以是纯净的字符串AABBCCAABB 不存在一个长度为3的连续子串包含’A’,’B’,’C’,所以是暗黑的字符串你的任务就是计算出长度为n的字符串(只包含’A’、’B’和’C’)，有多少个是暗黑的字符串。 输入描述输入一个整数n，表示字符串长度(1 ≤ n ≤ 30) 输出描述输出一个整数表示有多少个暗黑字符串 输入例子23 输出例子921 代码1 No. 5 数字翻转对于一个整数X，定义操作rev(X)为将X按数位翻转过来，并且去除掉前导0。例如:如果 X = 123，则rev(X) = 321;如果 X = 100，则rev(X) = 1.现在给出整数x和y,要求rev(rev(x) + rev(y))为多少？ 输入描述输入为一行，x、y(1 ≤ x、y ≤ 1000)，以空格隔开。 输出描述输出rev(rev(x) + rev(y))的值 输入例子123 100 输出例子223 代码12345678910111213141516171819202122232425262728import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int x = sc.nextInt(); int y = sc.nextInt(); if (x &lt; 1 || y &lt; 1 || x &gt; 1000 || y &gt; 1000) return; System.out.println(reverse(reverse(x) + reverse(y))); &#125; private static int reverse(int a)&#123; int result = 0; while (a != 0)&#123; result = result * 10 + a % 10; a = a / 10; &#125; return result; &#125;&#125; No. 6 最大的奇约数小易是一个数论爱好者，并且对于一个数的奇数约数十分感兴趣。一天小易遇到这样一个问题： 定义函数f(x)为x最大的奇数约数，x为正整数。 例如:f(44) = 11.现在给出一个N，需要求出 f(1) + f(2) + f(3)…….f(N)例如： N = 7f(1) + f(2) + f(3) + f(4) + f(5) + f(6) + f(7) = 1 + 1 + 3 + 1 + 5 + 3 + 7 = 21小易计算这个问题遇到了困难，需要你来设计一个算法帮助他。 输入描述输入一个整数N (1 ≤ N ≤ 1000000000) 输出描述输出一个整数，即为f(1) + f(2) + f(3)…….f(N) 输入例子7 输出例子21 代码1234567891011121314151617181920212223import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); long n = sc.nextLong(); if (n &lt; 1 || n &gt; 1000000000) return; long sum = 0; for (long i = n; i &gt; 0; i /= 2)&#123; long temp = (i + 1) / 2; sum += temp * temp; &#125; System.out.println(sum); &#125;&#125; No. 7 买苹果小易去附近的商店买苹果，奸诈的商贩使用了捆绑交易，只提供6个每袋和8个每袋的包装(包装不可拆分)。 可是小易现在只想购买恰好n个苹果，小易想购买尽量少的袋数方便携带。如果不能购买恰好n个苹果，小易将不会购买。 输入描述输入一个整数n，表示小易想购买n(1 ≤ n ≤ 100)个苹果 输出描述输出一个整数表示最少需要购买的袋数，如果不能买恰好n个苹果则输出-1 输入例子20 输出例子3 代码1 No. 8 计算糖果A,B,C三个人是好朋友,每个人手里都有一些糖果,我们不知道他们每个人手上具体有多少个糖果,但是我们知道以下的信息：A - B, B - C, A + B, B + C. 这四个数值.每个字母代表每个人所拥有的糖果数.现在需要通过这四个数值计算出每个人手里有多少个糖果,即A,B,C。这里保证最多只有一组整数A,B,C满足所有题设条件。 输入描述输入为一行，一共4个整数，分别为A - B，B - C，A + B，B + C，用空格隔开。范围均在-30到30之间(闭区间)。 输出描述输出为一行，如果存在满足的整数A，B，C则按顺序输出A，B，C，用空格隔开，行末无空格。如果不存在这样的整数A，B，C，则输出No 输入例子1 -2 3 4 输出例子2 1 3 代码1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Algorithm from NowCoder (1)]]></title>
      <url>%2F2017%2F03%2F23%2FAlgorithm-from-NowCoder-1%2F</url>
      <content type="text"><![CDATA[No. 1 合唱团有 n 个学生站成一排，每个学生有一个能力值，牛牛想从这 n 个学生中按照顺序选取 k 名学生，要求相邻两个学生的位置编号的差不超过 d，使得这 k 个学生的能力值的乘积最大，你能返回最大的乘积吗？ 输入描述每个输入包含 1 个测试用例。每个测试数据的第一行包含一个整数 n (1 &lt;= n &lt;= 50)，表示学生的个数，接下来的一行，包含 n 个整数，按顺序表示每个学生的能力值 ai（-50 &lt;= ai &lt;= 50）。接下来的一行包含两个整数，k 和 d (1 &lt;= k &lt;= 10, 1 &lt;= d &lt;= 50)。 输出描述输出一行表示最大的乘积。 输入例子37 4 72 50 输出例子49 代码1 No. 2 地牢逃脱给定一个 n 行 m 列的地牢，其中 ‘.’ 表示可以通行的位置，’X’ 表示不可通行的障碍，牛牛从 (x0 , y0 ) 位置出发，遍历这个地牢，和一般的游戏所不同的是，他每一步只能按照一些指定的步长遍历地牢，要求每一步都不可以超过地牢的边界，也不能到达障碍上。地牢的出口可能在任意某个可以通行的位置上。牛牛想知道最坏情况下，他需要多少步才可以离开这个地牢。 输入描述每个输入包含 1 个测试用例。每个测试用例的第一行包含两个整数 n 和 m（1 &lt;= n, m &lt;= 50），表示地牢的长和宽。接下来的 n 行，每行 m 个字符，描述地牢，地牢将至少包含两个 ‘.’。接下来的一行，包含两个整数 x0, y0，表示牛牛的出发位置（0 &lt;= x0 &lt; n, 0 &lt;= y0 &lt; m，左上角的坐标为 （0, 0），出发位置一定是 ‘.’）。之后的一行包含一个整数 k（0 &lt; k &lt;= 50）表示牛牛合法的步长数，接下来的 k 行，每行两个整数 dx, dy 表示每次可选择移动的行和列步长（-50 &lt;= dx, dy &lt;= 50） 输出描述输出一行一个数字表示最坏情况下需要多少次移动可以离开地牢，如果永远无法离开，输出 -1。以下测试用例中，牛牛可以上下左右移动，在所有可通行的位置.上，地牢出口如果被设置在右下角，牛牛想离开需要移动的次数最多，为3次。 输入例子3 3………0 141 00 1-1 00 -1 输出例子3 代码1 No. 3 下厨房牛牛想尝试一些新的料理，每个料理需要一些不同的材料，问完成所有的料理需要准备多少种不同的材料。 输入描述每个输入包含 1 个测试用例。每个测试用例的第 i 行，表示完成第 i 件料理需要哪些材料，各个材料用空格隔开，输入只包含大写英文字母和空格，输入文件不超过 50 行，每一行不超过 50 个字符。 输出描述输出一行一个数字表示完成所有料理需要多少种不同的材料。 输入例子BUTTER FLOURHONEY FLOUR EGG 输出例子4 代码12345678910111213141516171819202122import java.util.HashSet;import java.util.Scanner;import java.util.Set;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (int i = 1; sc.hasNextLine() &amp;&amp; i &lt;= 50; i++)&#123; String[] strs = sc.nextLine().split(" "); for (String str : strs) set.add(str); &#125; System.out.println(set.size()); &#125;&#125; No. 4 分田地牛牛和 15 个朋友来玩打土豪分田地的游戏，牛牛决定让你来分田地，地主的田地可以看成是一个矩形，每个位置有一个价值。分割田地的方法是横竖各切三刀，分成 16 份，作为领导干部，牛牛总是会选择其中总价值最小的一份田地， 作为牛牛最好的朋友，你希望牛牛取得的田地的价值和尽可能大，你知道这个值最大可以是多少吗？ 输入描述每个输入包含 1 个测试用例。每个测试用例的第一行包含两个整数 n 和 m（1 &lt;= n, m &lt;= 75），表示田地的大小，接下来的 n 行，每行包含 m 个 0-9 之间的数字，表示每块位置的价值。 输出描述输出一行表示牛牛所能取得的最大的价值。 输入例子4 43332323333322323 输出例子2 代码1 No. 5 分苹果n 只奶牛坐在一排，每个奶牛拥有 ai 个苹果，现在你要在它们之间转移苹果，使得最后所有奶牛拥有的苹果数都相同，每一次，你只能从一只奶牛身上拿走恰好两个苹果到另一个奶牛上，问最少需要移动多少次可以平分苹果，如果方案不存在输出 -1。 输入描述每个输入包含一个测试用例。每个测试用例的第一行包含一个整数 n（1 &lt;= n &lt;= 100），接下来的一行包含 n 个整数 ai（1 &lt;= ai &lt;= 100）。 输出描述输出一行表示最少需要移动多少次可以平分苹果，如果方案不存在则输出 -1。 输入例子47 15 9 5 输出例子3 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); if (n &lt; 0 || n &gt; 100) return; int[] a = new int[n]; int sum = 0; for (int i = 0; i &lt; n; i++)&#123; a[i] = sc.nextInt(); if (a[i] &lt; 1 || a[i] &gt; 100) return; sum += a[i]; &#125; if (sum % a.length != 0)&#123; System.out.println(-1); return; &#125; int avg = sum / a.length; int move = 0; for (int i = 0; i &lt; a.length; i++)&#123; if (Math.abs(a[i] - avg) % 2 != 0)&#123; System.out.println(-1); return; &#125; if (a[i] &gt; avg) move += a[i] - avg; &#125; System.out.println(move / 2); &#125;&#125; No. 6 星际穿越航天飞行器是一项复杂而又精密的仪器，飞行器的损耗主要集中在发射和降落的过程，科学家根据实验数据估计，如果在发射过程中，产生了 x 程度的损耗，那么在降落的过程中就会产生 x2 程度的损耗，如果飞船的总损耗超过了它的耐久度，飞行器就会爆炸坠毁。问一艘耐久度为 h 的飞行器，假设在飞行过程中不产生损耗，那么为了保证其可以安全的到达目的地，只考虑整数解，至多发射过程中可以承受多少程度的损耗？ 输入描述每个输入包含一个测试用例。每个测试用例包含一行一个整数 h （1 &lt;= h &lt;= 10^18）。 输出描述输出一行一个整数表示结果。 输入例子10 输出例子2 代码1234567891011121314151617181920212223import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); long h = sc.nextLong(); if (h &lt; 0 || h &gt; Math.pow(10, 18)) return; long x = (long) Math.sqrt(h); for (; x &gt;= 0; x--)&#123; if (x * x + x &lt;= h)&#123; System.out.println(x); return; &#125; &#125; &#125;&#125; No. 7 藏宝图牛牛拿到了一个藏宝图，顺着藏宝图的指示，牛牛发现了一个藏宝盒，藏宝盒上有一个机关，机关每次会显示两个字符串 s 和 t，根据古老的传说，牛牛需要每次都回答 t 是否是 s 的子序列。注意，子序列不要求在原字符串中是连续的，例如串 abc，它的子序列就有 {空串, a, b, c, ab, ac, bc, abc} 8 种。 输入描述每个输入包含一个测试用例。每个测试用例包含两行长度不超过 10 的不包含空格的可见 ASCII 字符串。 输出描述输出一行 “Yes” 或者 “No” 表示结果。 输入例子x.nowcoder.comooo 输出例子Yes 代码1234567891011121314151617181920212223242526272829import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String s = sc.nextLine(); String t = sc.nextLine(); if (s == null || t == null)&#123; System.out.println("No"); return; &#125; int i = 0, j = 0; for (; i &lt; t.length() &amp;&amp; j &lt; s.length(); j++)&#123; if (t.charAt(i) == s.charAt(j)) i++; &#125; if (i == t.length()) System.out.println("Yes"); else System.out.println("No"); &#125;&#125; No. 8 藏宝图牛牛的作业薄上有一个长度为 n 的排列 A，这个排列包含了从1到n的n个数，但是因为一些原因，其中有一些位置（不超过 10 个）看不清了，但是牛牛记得这个数列顺序对的数量是 k，顺序对是指满足 i &lt; j 且 A[i] &lt; A[j] 的对数，请帮助牛牛计算出，符合这个要求的合法排列的数目。 输入描述每个输入包含一个测试用例。每个测试用例的第一行包含两个整数 n 和 k（1 &lt;= n &lt;= 100, 0 &lt;= k &lt;= 1000000000），接下来的 1 行，包含 n 个数字表示排列 A，其中等于0的项表示看不清的位置（不超过 10 个）。 输出描述输出一行表示合法的排列数目。 输入例子5 54 0 0 2 0 输出例子2 代码1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DL Intro]]></title>
      <url>%2F2017%2F03%2F20%2FDL-Intro%2F</url>
      <content type="text"><![CDATA[A brief introduction about deep learning, which will cover models, libraries and so on. Deep Learning Models Restricted Boltzmann Machine (RBM) Deep Belief Network (DBN) Convolutional Neural Net Recurrent Nets Gating units (LSTM, GRU) Gradient clipping Steeper gates Better optimizers Autoencoders Recursive Neural Tensor Nets Use Cases Machine Vision Image Classification Object Recognition: clarifai Video Recognition Speech Recognition Text Processing Fact Extraction Machine Translation Sentiment Analysis: metamind Character level text processing Medical Cancer detection Drug discovery Radiology Finance Digital advertising Fraud detection Customer intel How to choose a deep net ?UnlabelledFeature ExtractionUnsupervised LearningPattern Recognition RBM Autoencoders Labelled Text Processing: RNTN, Recurrent Net Image Recognition: DBN, Convolutional Net Object Recognition: RNTN, Convolutional Net Speech Recognition: Recurrent Net General Classification: MLP/RELU, Deep Belief Net Time Series Analysis: Recurrent Net Deep Net PlatformDeep Net CapabilityData MungingUI/Model ManagementInfrastructure Pros &amp; Cons Pros: Hyper-parameter configuration through UI, no need to learn to code Cons: Constrained by platform functionality Platforms H2O.ai Dato GraphLab Create Deep Learning LibrariesPros &amp; Cons Pros: Increased flexibility and options Cons: Need to know code Libraries Theano Python Library Libraries: Blocks, Lasagne/Keras, Passage Deeplearning4j Features: Canova Iterative Map-Reduce Torch LuaJIT Library Hyper-parameter Config Extensions: CuTorch, NN, Cephes, DP, NNGraph Caffe C++ Library, Matlab/Python Interface Features: Hyper-parameter Config, Model Zoo Performance: Vectorization through blobs TensorFlow Computational Graph Variables, Sub-expressions, Differentiation Data Parallelism, Model Parallelism OpenCL TensorBoard Configure a Deep Net Layers Input Layer Convolution / Pooling Matrix operations Output Layer Neurons Growing Pruning Activations: Sigmoid, Tanh, ReLU Regularization Gating Learning Rate: Adagrad, RMSprop, Adadelta Initialization Training Time: raise the number of training epochs How good is your fit ? Underfitting Overfitting 3 Way Data Split Regularization Max Norm Constraints Dropout MetricsF1 score Confusion Matrix Predicted True Predicted False Actual True TP FN Actual False FP TN RecallTP / (TP + FN) PrecisionTP / (TP + FP) PerformanceHardware levelParallel processing Shared memory: GPU, FPGA, ASIC Distributed computing: data parallelism, model parallelism, pipeline parallelism Software levelParallel programming Model Algorithm Implementation NLPLemmatizationNamed Entity RecognitionPart of Speech TaggingSyntactic ParsingFact ExtractionSentiment AnalysisMachine Translation Models to solve the problem of One-Hot Vector Continuous Bag of Words Skip grams Tools for converting words to vectors word2vec GloVe Applications Fashion Matching with Indico Transfer Learning Custom Collection API Neural Storyteller with Somatic skip-thought model MSCOCO Dataset, Book Corpus Inceptionism with Somatic Generation Convolutional Nets Reinforcement LearningExplore a tradeoff between exploration and exploitation and choose a path to maximum the expected reward High score Follow rules: + points Break rules: - points Deep Atari Regression No pooling Deep Q Net (DQN)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Torch Demo]]></title>
      <url>%2F2017%2F03%2F18%2FTorch-Demo%2F</url>
      <content type="text"><![CDATA[We have 5 steps to do in training a torch neural network. (1) Load and normalize data; (2) Define Neural Network; (3) Define Loss function; (4) Train network on training data; (5) Test network on test data. Tutorialcvpr2015/Deep Learning with Torch.ipynb Code12345require 'paths'require 'nn'require 'torch'require 'cunn'require 'cutorch' Load and normalize data12345678910111213141516171819if (not paths.filep("cifar10torchsmall.zip")) then os.execute('wget -c https://s3.amazonaws.com/torch7/data/cifar10torchsmall.zip') os.execute('unzip cifar10torchsmall.zip')endtrainset = torch.load('cifar10-train.t7')testset = torch.load('cifar10-test.t7')classes = &#123;'airplane', 'automobile', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck'&#125;setmetatable(trainset, &#123;__index = function(t, i) return &#123;t.data[i], t.label[i]&#125; end&#125;);function trainset:size() return self.data:size(1)end 1234567891011121314151617trainset.data = trainset.data:double()testset.data = testset.data:double()mean = &#123;&#125;stdv = &#123;&#125;for i=1,3 do mean[i] = trainset.data[&#123; &#123;&#125;, &#123;i&#125;, &#123;&#125;, &#123;&#125; &#125;]:mean() --print('Channel ' .. i .. ', Mean: ' .. mean[i]) trainset.data[&#123; &#123;&#125;, &#123;i&#125;, &#123;&#125;, &#123;&#125; &#125;]:add(-mean[i]) stdv[i] = trainset.data[&#123; &#123;&#125;, &#123;i&#125;, &#123;&#125;, &#123;&#125; &#125;]:std() --print('Channel ' .. i .. ', Standard Deviation: ' .. stdv[i]) trainset.data[&#123; &#123;&#125;, &#123;i&#125;, &#123;&#125;, &#123;&#125; &#125;]:div(stdv[i])endfor i=1,3 do testset.data[&#123; &#123;&#125;, &#123;i&#125;, &#123;&#125;, &#123;&#125; &#125;]:add(-mean[i]) testset.data[&#123; &#123;&#125;, &#123;i&#125;, &#123;&#125;, &#123;&#125; &#125;]:div(stdv[i])end Define neural network1234567891011121314net = nn.Sequential()net:add(nn.SpatialConvolution(3, 6, 5, 5)) -- 3 input image channels, 6 output channels, 5x5 convolution kernelnet:add(nn.ReLU()) -- non-linearitynet:add(nn.SpatialMaxPooling(2,2,2,2)) -- A max-pooling operation that looks at 2x2 windows and finds the max.net:add(nn.SpatialConvolution(6, 16, 5, 5))net:add(nn.ReLU()) -- non-linearitynet:add(nn.SpatialMaxPooling(2,2,2,2))net:add(nn.View(16*5*5)) -- reshapes from a 3D tensor of 16x5x5 into 1D tensor of 16*5*5net:add(nn.Linear(16*5*5, 120)) -- fully connected layer (matrix multiplication between input and weights)net:add(nn.ReLU()) -- non-linearitynet:add(nn.Linear(120, 84))net:add(nn.ReLU()) -- non-linearitynet:add(nn.Linear(84, 10)) -- 10 is the number of outputs of the network (in this case, 10 digits)net:add(nn.LogSoftMax()) -- converts the output to a log-probability. Useful for classification problems Define the Loss function1criterion = nn.ClassNLLCriterion() Train the neural network1234trainer = nn.StochasticGradient(net, criterion)trainer.learningRate = 0.001trainer.maxIteration = 5trainer:train(trainset) 1234567-- train on GPUnet = net:cuda()criterion = criterion:cuda()trainset.data = trainset.data:cuda()trainset.label = trainset.label:cuda()testset.data = testset.data:cuda()testset.label = testset.label:cuda() Test the network, print accuracy12345678910111213141516correct = 0class_performance = &#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;for i=1,10000 do local groundtruth = testset.label[i] local prediction = net:forward(testset.data[i]) local confidences, indices = torch.sort(prediction, true) -- true means sort in descending order if groundtruth == indices[1] then correct = correct + 1 class_performance[groundtruth] = class_performance[groundtruth] + 1 endendprint(correct, 100*correct/10000 .. " % ")for i=1,#classes do print(classes[i], 100*class_performance[i]/1000 .. ' %')end ResultIt’ll take around 30 minutes to get the result on CPU. However, it’ll cost less than 10 minutes on GPU. 1th filename.lua On CPU On GPU]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F17%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
